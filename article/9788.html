

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Mysql45讲-实践（二） - Boyolo</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="MySQL有哪些“饮鸩止渴”提高性能的方法？业务高峰期...">
  <meta name="author" content="bobo">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/boyolo-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: true,
        alipay: '/images/theme/alipay.jpg',
        wechat: '/images/theme/wechatpay.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v1.hitokoto.cn/?encode=text&c=i',
          data_contents: ''
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: '/images/theme/wechat',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">Mysql45讲-实践（二）</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/" class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/tags/" class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/" class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/archives/" class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/galleries/" class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a> |  website - <a target="_blank" href="https://boyolo.github.io/">bobo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/coverphoto/Mysql.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Mysql45讲-实践（二）</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>April 14, 2022</span>
      
        <span class="post-info-item">
          <i class="iconfont iconeye"></i><span id="/article/9788.html" class="leancloud-counter" data-flag-title="Mysql45讲-实践（二）"></span>
        </span>
        <span class="post-info-item">
          <i class="iconfont iconheart"></i><span id="/article/9788.html" class="leancloud-like" data-flag-title="Mysql45讲-实践（二）"></span>
        </span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>20463</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
        <h2 id="MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><p>业务高峰期，生产环境的 MySQL 压力太大，没法正常响应，需要短期内、临时性地提升一些性能。</p>
<h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><blockquote>
<p>正常的短连接模式就是连接到数据库后，执行很少的 SQL 语句就断开，下次需要的时候再重连。</p>
<p>如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。</p>
</blockquote>
<p>MySQL 建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。</p>
<p><strong>短连接模型存在一个风险，就是一旦数据库处理得慢一些，连接数就会暴涨。</strong></p>
<p><code>max_connections</code> 参数，用来控制一个 MySQL 实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。对于被拒绝连接的请求来说，从业务角度看就是数据库不可用。</p>
<blockquote>
<p>调高 max_connections 的值:</p>
<p>因为设计 max_connections 这个参数的目的是想保护 MySQL，如果我们把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到 CPU 资源去执行业务的 SQL 请求。</p>
</blockquote>
<ol>
<li><p>第一种方法：先处理掉那些占着连接但是不工作的线程。</p>
<p>对于那些不需要保持的连接，我们可以通过 kill connection 主动踢掉。这个行为跟事先设置 wait_timeout 的效果是一样的。设置 wait_timeout 参数表示的是，一个线程空闲 wait_timeout 这么多秒之后，就会被 MySQL 直接断开连接。</p>
<p><strong>但是需要注意，在 show processlist 的结果里，踢掉显示为 sleep 的线程，可能是有损的。</strong></p>
<p><strong>应该优先断开事务外空闲的连接。</strong></p>
<blockquote>
<p>看事务具体状态的话，你可以查 <code>information_schema</code> 库的 <code>innodb_trx</code> 表。</p>
<p><code>trx_mysql_thread_id=n</code>，表示 id=n 的线程还处在事务中。</p>
</blockquote>
<p>如果是连接数过多，你可以优先断开事务外空闲太久的连接；如果这样还不够，再考虑断开事务内空闲太久的连接。</p>
<blockquote>
<p>从服务端断开连接使用的是 <code>kill connection + id</code> 的命令， 一个客户端处于 sleep 状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p>
</blockquote>
<p>从数据库端主动断开连接可能是<strong>有损的</strong>，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL 一直没恢复”。</p>
</li>
<li><p>第二种方法：减少连接过程的消耗。</p>
<p>有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是<strong>让数据库跳过权限验证阶段</strong>。</p>
<p>跳过权限验证的方法是：重启数据库，并使用<code>–skip-grant-tables</code> 参数启动。这样，整个 MySQL 会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。</p>
<p><strong>风险极高，特别不建议使用</strong></p>
</li>
</ol>
<h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><p>在 MySQL 中，会引发性能问题的慢查询，大体有以下三种可能：</p>
<ol>
<li><p>索引没有设计好；</p>
<p>这种场景一般就是通过紧急创建索引来解决。</p>
<blockquote>
<p>MySQL 5.6 版本以后，创建索引都支持 Online DDL 了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行 alter table 语句。</p>
</blockquote>
<p>比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库 A、备库 B，这个方案的大致流程是这样的：</p>
<ol>
<li>在备库 B 上执行 <code>set sql_log_bin=off</code>，也就是不写 binlog，然后执行 alter table 语句加上索引；</li>
<li>执行主备切换；</li>
<li>这时候主库是 B，备库是 A。在 A 上执行 <code>set sql_log_bin=off</code>，然后执行 alter table 语句加上索引。</li>
</ol>
</li>
<li><p>SQL 语句没写好；</p>
<p>我们可以通过改写 SQL 语句来处理。MySQL 5.7 提供了 <code>query_rewrite</code> 功能，可以把输入的一种语句改写成另外一种模式。</p>
</li>
<li><p>MySQL 选错了索引。</p>
<p>使用查询重写功能，给原来的语句加上 force index</p>
</li>
</ol>
<h3 id="预先发现问题"><a href="#预先发现问题" class="headerlink" title="预先发现问题"></a>预先发现问题</h3><ol>
<li>上线前，在测试环境，把慢查询日志（slow log）打开，并且把 long_query_time 设置成 0，确保每个语句都会被记录入慢查询日志；</li>
<li>在测试表里插入模拟线上的数据，做一遍回归测试；</li>
<li>观察慢查询日志里每类语句的输出，特别留意 Rows_examined 字段是否与预期一致。</li>
</ol>
<h3 id="QPS-突增问题"><a href="#QPS-突增问题" class="headerlink" title="QPS 突增问题"></a>QPS 突增问题</h3><blockquote>
<p>有时候由于业务突然出现高峰，或者应用程序 bug，导致某个语句的 QPS 突然暴涨，也可能导致 MySQL 压力过大，影响服务。</p>
</blockquote>
<p>由一个新功能的 bug 导致的，最理想的情况是让业务把这个功能下掉，服务自然就会恢复。</p>
<ol>
<li><p>一种是由全新业务的 bug 导致的。假设你的 DB 运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</p>
</li>
<li><p>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的 QPS 就会变成 0。</p>
</li>
<li><p>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的 SQL 语句直接重写成 <code>select 1</code> 返回。</p>
<p>副作用:</p>
<ol>
<li>如果别的功能里面也用到了这个 SQL 语句模板，会有误伤；</li>
<li>很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这一个语句以 <code>select 1</code> 的结果返回的话，可能会导致后面的业务逻辑一起失败。</li>
</ol>
<p><strong>风险极高，特别不建议使用</strong></p>
</li>
</ol>
<h2 id="MySQL是怎么保证数据不丢的？"><a href="#MySQL是怎么保证数据不丢的？" class="headerlink" title="MySQL是怎么保证数据不丢的？"></a>MySQL是怎么保证数据不丢的？</h2><p>只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。</p>
<h3 id="binlog-的写入机制"><a href="#binlog-的写入机制" class="headerlink" title="binlog 的写入机制"></a>binlog 的写入机制</h3><p>事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p>
<p><strong>一个事务的 binlog 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入</strong></p>
<p><strong>binlog cache 的保存</strong>：</p>
<p>系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<p>事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。</p>
<p><img   class="lazyload" data-original="/article/binlog 写盘状态.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">binlog 写盘状态</span></p>
<p>每个线程有自己 binlog cache，但是共用同一份 binlog 文件</p>
<ol>
<li>图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。</li>
<li>图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。</li>
</ol>
<blockquote>
<ol>
<li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。(对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。)</li>
</ol>
</blockquote>
<h3 id="redo-log-的写入机制"><a href="#redo-log-的写入机制" class="headerlink" title="redo log 的写入机制"></a>redo log 的写入机制</h3><p>事务在执行过程中，生成的 redo log 是要先写到 redo log buffer 的。</p>
<ol>
<li><p>redo log buffer 里面的内容，是不是每次生成后都要直接持久化到磁盘呢？</p>
<p>不需要</p>
<p>如果事务执行期间 MySQL 发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</p>
</li>
<li><p>事务还没提交的时候，redo log buffer 中的部分日志有没有可能被持久化到磁盘呢？</p>
<p>有可能</p>
<p><img   class="lazyload" data-original="/article/MySQL redo log 存储状态.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">MySQL redo log 存储状态</span></p>
<ol>
<li>存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分；</li>
<li>写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分；</li>
<li>持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。</li>
</ol>
<blockquote>
<p>为了控制 redo log 的写入策略，InnoDB 提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它有三种可能取值：</p>
<ol>
<li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
<li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ol>
</blockquote>
<p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p>
<p><strong>注意</strong>，事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。</p>
</li>
</ol>
<pre><code>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。

1. 一种是，redo log buffer 占用的空间即将达到 `innodb_log_buffer_size `**一半**的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。
2. 另一种是，并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 `innodb_flush_log_at_trx_commit` 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘

&gt; 如果把 `innodb_flush_log_at_trx_commit` 设置成 1，那么 redo log 在 prepare 阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于 prepare 的 redo log，再加上 binlog 来恢复的。
&gt;
&gt; 每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB 就认为 redo log 在 commit 的时候就不需要 fsync 了，只会 write 到文件系统的 page cache 中就够了。
</code></pre><p><strong>MySQL 的“双 1”配置</strong></p>
<p><code>sync_binlog</code> 和 <code>innodb_flush_log_at_trx_commit</code> 都设置成 1</p>
<p>一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p>
<h3 id="组提交（group-commit）机制"><a href="#组提交（group-commit）机制" class="headerlink" title="组提交（group commit）机制"></a>组提交（group commit）机制</h3><p><strong>日志逻辑序列号（log sequence number，LSN）</strong>:LSN 是单调递增的，用来对应 redo log 的一个个写入点。每次写入长度为 length 的 redo log， LSN 的值就会加上 length。</p>
<p>LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log。</p>
<blockquote>
<p><img   class="lazyload" data-original="/article/redo log 组提交.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">redo log 组提交</span></p>
<p>三个并发事务 (trx1, trx2, trx3) 在 prepare 阶段，都写完 redo log buffer，持久化到磁盘的过程，对应的 LSN 分别是 50、120 和 160。</p>
<ol>
<li>trx1 是第一个到达的，会被选为这组的 leader；</li>
<li>等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；</li>
<li>trx1 去写盘的时候，带的就是 LSN=160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；</li>
<li>这时候 trx2 和 trx3 就可以直接返回了。</li>
</ol>
</blockquote>
<p>一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。</p>
<p>但如果只有单线程压测，那就只能一个事务对应一次持久化操作。</p>
<blockquote>
<p>为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间</p>
<img   class="lazyload" data-original="/article/9788/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%BB%86%E5%8C%96.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  class title="两阶段提交细化">
<p>把 redo log 做 fsync 的时间拖到了步骤 1 之后</p>
<p>在执行第 4 步把 binlog fsync 到磁盘时，如果有多个事务的 binlog 已经写完了，也是一起持久化的，这样也可以减少 IOPS 的消耗。</p>
<p>不过通常情况下第 3 步执行得会很快，所以 binlog 的 write 和 fsync 间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如 redo log 的效果那么好。</p>
<p><strong>提升 binlog 组提交的效果:</strong></p>
<p>可以通过设置 <code>binlog_group_commit_sync_delay</code> 和 <code>binlog_group_commit_sync_no_delay_count</code> 来实现。</p>
<ol>
<li><code>binlog_group_commit_sync_delay</code> 参数，表示延迟多少微秒后才调用 fsync;</li>
<li><code>binlog_group_commit_sync_no_delay_count</code> 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>只要有一个满足条件就会调用 fsync</p>
</blockquote>
<p>WAL 机制是减少磁盘写，可是每次提交事务都要写 redo log 和 binlog，磁盘读写次数为什么没变少？</p>
<p>WAL 机制主要得益于两个方面：</p>
<ol>
<li>redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快；</li>
<li>组提交机制，可以大幅度降低磁盘的 IOPS 消耗。</li>
</ol>
<h3 id="IO性能瓶颈，提升性能"><a href="#IO性能瓶颈，提升性能" class="headerlink" title="IO性能瓶颈，提升性能"></a>IO性能瓶颈，提升性能</h3><ol>
<li>设置 <code>binlog_group_commit_sync_delay</code> 和 <code>binlog_group_commit_sync_no_delay_count</code> 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
<li>将 <code>sync_binlog</code> 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</li>
<li>将 <code>innodb_flush_log_at_trx_commit</code> 设置为 2。这样做的风险是，主机掉电的时候会丢数据。(不建议把 <code>innodb_flush_log_at_trx_commit</code> 设置成 0,因为把这个参数设置成 0，表示 redo log 只保存在内存中，这样的话 MySQL 本身异常重启也会丢数据，风险太大。而 redo log 写到文件系统的 page cache 的速度也是很快的，所以将这个参数设置成 2 跟设置成 0 其实性能差不多，但这样做 MySQL 异常重启时就不会丢数据了，相比之下风险会更小。)</li>
</ol>
<hr>
<p><strong>问题：为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</strong></p>
<blockquote>
<p>MySQL 这么设计的主要原因是，binlog 是不能“被打断的”。一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。</p>
<p>而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中。redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p>
</blockquote>
<hr>
<h2 id="MySQL是怎么保证主备一致的？"><a href="#MySQL是怎么保证主备一致的？" class="headerlink" title="MySQL是怎么保证主备一致的？"></a>MySQL是怎么保证主备一致的？</h2><h3 id="MySQL-主备的基本原理"><a href="#MySQL-主备的基本原理" class="headerlink" title="MySQL 主备的基本原理"></a>MySQL 主备的基本原理</h3><p><strong>基本的主备切换流程</strong></p>
<p><img   class="lazyload" data-original="/article/MySQL 主备切换流程.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">MySQL 主备切换流程</span></p>
<p>在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。</p>
<p>当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。</p>
<blockquote>
<p>在状态 1 中，虽然节点 B 没有被直接访问，但是依然建议把节点 B（也就是备库）设置成只读（readonly）模式。这样做，有以下几个考虑：</p>
<ol>
<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li>
<li>防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致；</li>
<li>可以用 readonly 状态，来判断节点的角色。</li>
</ol>
<p><strong>readonly 设置对超级 (super) 权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</strong></p>
</blockquote>
<blockquote>
<p><strong>节点 A 到 B 这条线的内部流程是什么样的?</strong></p>
<p>一个 update 语句在节点 A 执行，然后同步到节点 B 的完整流程图</p>
<img   class="lazyload" data-original="/article/9788/%E4%B8%BB%E5%A4%87%E6%B5%81%E7%A8%8B%E5%9B%BE.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  class title="主备流程图">
<p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写 binlog</p>
<p>备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：</p>
<ol>
<li>在备库 B 上通过 <code>change master</code> 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 <strong>io_thread</strong> 和 <strong>sql_thread</strong>。其中 io_thread 负责与主库建立连接。</li>
<li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li>
<li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
</blockquote>
<h3 id="binlog-的三种格式对比"><a href="#binlog-的三种格式对比" class="headerlink" title="binlog 的三种格式对比"></a>binlog 的三种格式对比</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `a` int(11) DEFAULT NULL,<br>  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,<br>  PRIMARY KEY (`id`),<br>  KEY `a` (`a`),<br>  KEY `t_modified`(`t_modified`)<br>) ENGINE=InnoDB;<br><br>insert into t values(1,1,&#x27;2018-11-13&#x27;);<br>insert into t values(2,2,&#x27;2018-11-12&#x27;);<br>insert into t values(3,3,&#x27;2018-11-11&#x27;);<br>insert into t values(4,4,&#x27;2018-11-10&#x27;);<br>insert into t values(5,5,&#x27;2018-11-09&#x27;);<br></code></pre></td></tr></table></figure>
</blockquote>
<p>在表中删除一行数据的话， delete 语句的 binlog 是怎么记录的?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; delete from t /*comment*/  where a&gt;=4 and t_modified&lt;=&#x27;2018-11-10&#x27; limit 1;<br></code></pre></td></tr></table></figure>
<ol>
<li><p>当 binlog_format=statement 时，binlog 里面记录的就是 SQL 语句的原文</p>
<blockquote>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events in &#x27;master.000001&#x27;;<br></code></pre></td></tr></table></figure>
<p>查看 binlog 中的内容</p>
<p><img   class="lazyload" data-original="/article/statement 格式 binlog 示例.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">statement 格式 binlog 示例</span></p>
<ol>
<li>第一行 SET @@SESSION.GTID_NEXT=’ANONYMOUS’你可以先忽略，后面文章我们会在介绍主备切换的时候再提到；</li>
<li>第二行是一个 BEGIN，跟第四行的 commit 对应，表示中间是一个事务；</li>
<li>第三行就是真实执行的语句了。可以看到，在真实执行的 delete 命令之前，还有一个“use ‘test’”命令。这条命令不是我们主动执行的，而是 MySQL 根据当前要操作的表所在的数据库，自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到 test 库的表 t。</li>
<li>最后一行是一个 COMMIT。（XID是用来联系bin log和redo log的。比如redo log里面有一个事务是prepare状态，但是不知道是不是commit状态，那就可以用XID去bin log里面查询该事务到底有没有提交。有提交则是commit状态，若没有提交则回滚该事务。）</li>
</ol>
</blockquote>
</li>
<li><p>当 binlog_format=row 时，binlog 里面记录的就是 事件</p>
<blockquote>
<p><img   class="lazyload" data-original="/article/row 格式 binlog 示例.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">row 格式 binlog 示例</span></p>
<p>与 statement 格式的 binlog 相比，前后的 BEGIN 和 COMMIT 是一样的。但是，row 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。</p>
<ol>
<li>Table_map event，用于说明接下来要操作的表是 test 库的表 t;</li>
<li>Delete_rows event，用于定义删除的行为。</li>
</ol>
<p>看不到详细信息需要借助 mysqlbinlog 工具，用命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqlbinlog  -vv data/master.000001 --start-position=8900;<br></code></pre></td></tr></table></figure>
<p>解析和查看 binlog 中的内容</p>
<p><img   class="lazyload" data-original="/article/row 格式 binlog 示例的详细信息.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">row 格式 binlog 示例的详细信息</span></p>
<ol>
<li>server id 1，表示这个事务是在 server_id=1 的这个库上执行的</li>
<li>每个 event 都有 CRC32 的值，这是因为我把参数 binlog_checksum 设置成了 CRC32</li>
<li>Table_map event 显示了接下来要打开的表，map 到数字 226。现在我们这条 SQL 语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的 Table_map event、都会 map 到一个单独的数字，用于区分对不同表的操作。</li>
<li>我们在 mysqlbinlog 的命令中，使用了 <code>-vv</code> 参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4、 @2=4 这些值）。binlog_row_image 的默认配置是 FULL，因此 Delete_event 里面，包含了删掉的行的所有字段的值。如果把 binlog_row_image 设置为 MINIMAL，则只会记录必要的信息，在这个例子里，就是只会记录 id=4 这个信息。</li>
<li>最后的 Xid event，用于表示事务被正确地提交了。</li>
</ol>
</blockquote>
</li>
<li><p>为什么会有 mixed 格式的 binlog？</p>
<ol>
<li>因为有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式。</li>
<li>但 row 格式的缺点是，很占空间。比如你用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</li>
<li>所以，MySQL 就取了个折中方案，也就是有了 mixed 格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</li>
</ol>
</li>
</ol>
<h3 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h3><p>实际生产上使用比较多的是双 M 结构</p>
<p><img   class="lazyload" data-original="/article/MySQL 主备切换流程 -- 双 M 结构.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">MySQL 主备切换流程 -- 双 M 结构</span></p>
<p>节点 A 和 B 之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。</p>
<p><strong>循环复制问题:</strong></p>
<blockquote>
<p>业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。</p>
<p>那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是<strong>循环复制</strong>了。</p>
</blockquote>
<p><strong>解决两个节点间的循环复制的问题：</strong></p>
<p>MySQL 在 binlog 中记录了这个命令第一次执行时所在实例的 server id。</p>
<ol>
<li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li>
<li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li>
<li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
<h2 id="MySQL是怎么保证高可用的？"><a href="#MySQL是怎么保证高可用的？" class="headerlink" title="MySQL是怎么保证高可用的？"></a>MySQL是怎么保证高可用的？</h2><p><img   class="lazyload" data-original="/article/MySQL 主备切换流程 -- 双 M 结构.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">MySQL 主备切换流程 -- 双 M 结构</span></p>
<h3 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h3><blockquote>
<p> 与数据同步有关的时间点主要包括以下三个：</p>
<ol>
<li>主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1;</li>
<li>之后传给备库 B，我们把备库 B 接收完这个 binlog 的时刻记为 T2;</li>
<li>备库 B 执行完成这个事务，我们把这个时刻记为 T3。</li>
</ol>
<p><strong>主备延迟</strong>，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是 T3-T1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show slave status<br></code></pre></td></tr></table></figure>
<p>返回结果里面会显示 <code>seconds_behind_master</code>，用于表示当前备库延迟了多少秒</p>
<ol>
<li>每个事务的 binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 seconds_behind_master。</li>
</ol>
</blockquote>
<p>主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产 binlog 的速度要慢。</p>
<h3 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h3><ol>
<li><p>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</p>
</li>
<li><p>备库的压力大</p>
<blockquote>
<p>因为主备可能发生切换，备库随时可能变成主库，所以主备库选用相同规格的机器，并且做对称部署，是现在比较常见的情况。</p>
</blockquote>
<p>备库上的查询耗费了大量的 CPU 资源，影响了同步速度，造成主备延迟。</p>
<p><strong>处理</strong>:</p>
<ol>
<li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li>
<li>通过 binlog 输出到外部系统，比如 Hadoop 这类系统，让外部系统提供统计类查询的能力。</li>
</ol>
</li>
<li><p>大事务</p>
<blockquote>
<p>因为主库上必须等事务执行完成才会写入 binlog，再传给备库。所以，如果一个主库上的语句执行 10 分钟，那这个事务很可能就会导致从库延迟 10 分钟。</p>
</blockquote>
</li>
<li><p>备库的并行复制能力</p>
</li>
</ol>
<h3 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h3><blockquote>
<p>在双 M 结构下，从状态 1 到状态 2 切换的详细过程是这样的：</p>
<ol>
<li>判断备库 B 现在的 <code>seconds_behind_master</code>，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；</li>
<li>把主库 A 改成只读状态，即把 readonly 设置为 true；</li>
<li>判断备库 B 的 <code>seconds_behind_master</code> 的值，直到这个值变成 0 为止；</li>
<li>把备库 B 改成可读写状态，也就是把 readonly 设置为 false；</li>
<li>把业务请求切到备库 B。</li>
</ol>
<p><img   class="lazyload" data-original="/article/MySQL 可靠性优先主备切换流程.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">MySQL 可靠性优先主备切换流程</span></p>
<p>这个切换流程中是有不可用时间的。因为在步骤 2 之后，主库 A 和备库 B 都处于 readonly 状态，也就是说这时系统处于不可写状态，直到步骤 5 完成后才能恢复。</p>
</blockquote>
<h3 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h3><p>把步骤 4、5 调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库 B，并且让备库 B 可以读写，那么系统几乎就没有不可用时间了。</p>
<p>把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。</p>
<ol>
<li>使用 row 格式的 binlog 时，数据不一致的问题更容易被发现。而使用 mixed 或者 statement 格式的 binlog 时，数据很可能悄悄地就不一致了。如果过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。</li>
<li>主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，建议使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。</li>
</ol>
<h2 id="备库为什么会延迟好几个小时？"><a href="#备库为什么会延迟好几个小时？" class="headerlink" title="备库为什么会延迟好几个小时？"></a>备库为什么会延迟好几个小时？</h2><blockquote>
<img   class="lazyload" data-original="/article/9788/%E4%B8%BB%E5%A4%87%E6%B5%81%E7%A8%8B%E5%9B%BE1.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  class title="主备流程图1">
<p>一个箭头代表了客户端写入主库，另一箭头代表的是备库上 sql_thread 执行中转日志（relay log）。</p>
<p>如果用箭头的粗细来代表并行度的话，第一个箭头要明显粗于第二个箭头。</p>
<p>日志在备库上的执行，就是图中备库上 sql_thread 更新数据 (DATA) 的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成<strong>主备延迟</strong>。</p>
</blockquote>
<blockquote>
<p>在官方的 5.6 版本之前，MySQL 只支持单线程复制，由此在主库并发高、TPS 高时就会出现严重的主备延迟问题。</p>
</blockquote>
<p><strong>MySQL 多线程复制</strong></p>
<img   class="lazyload" data-original="/article/9788/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  class title="多线程模型">
<p>把只有一个线程的 sql_thread，拆成多个线程。</p>
<p>coordinator 就是原来的 sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了 worker 线程。而 work 线程的个数，就是由参数 <code>slave_parallel_workers</code> 决定的。</p>
<p>coordinator 在分发的时候，需要满足以下这两个基本要求：</p>
<ol>
<li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中。</li>
<li>同一个事务不能被拆开，必须放到同一个 worker 中。</li>
</ol>
<h3 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h3><img   class="lazyload" data-original="/article/9788/%E6%8C%89%E8%A1%A8%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  class title="按表并行复制程模型">
<p>每个 worker 线程对应一个 hash 表，用于保存当前正在这个 worker 的“执行队列”里的事务所涉及的表。<strong>hash 表的 key 是“库名. 表名”，value 是一个数字，表示队列中有多少个事务修改这个表。</strong></p>
<p>每个事务在分发的时候，跟所有 worker 的冲突关系包括以下三种情况：</p>
<ol>
<li>如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker;</li>
<li>如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；</li>
<li>如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。</li>
</ol>
<p>问题：如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</p>
<h3 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h3><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。</p>
<p><strong>这个模式要求 binlog 格式必须是 row。</strong></p>
<p>基于行的策略，事务 hash 表中还需要考虑唯一键，即 <strong>key 应该是“库名 + 表名 + 索引名 + 该索引的值”。</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t1` (<br>  `id` int(11) NOT NULL,<br>  `a` int(11) DEFAULT NULL,<br>  `b` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  UNIQUE KEY `a` (`a`)<br>) ENGINE=InnoDB;<br><br>insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);<br></code></pre></td></tr></table></figure>
<img   class="lazyload" data-original="/article/9788/%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81%E7%A4%BA%E4%BE%8B.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  class title="唯一键冲突示例">
<ol>
<li>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。</li>
<li>key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表 a=2 的行。</li>
<li>key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表 a=1 的行。</li>
</ol>
</blockquote>
<p><strong>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。</strong></p>
<p>这两个方案其实都有一些约束条件：</p>
<ol>
<li>要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；</li>
<li>表必须有主键；不能有外键。</li>
<li>表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。</li>
</ol>
<h3 id="MySQL-5-6-版本的并行复制策略"><a href="#MySQL-5-6-版本的并行复制策略" class="headerlink" title="MySQL 5.6 版本的并行复制策略"></a>MySQL 5.6 版本的并行复制策略</h3><p><strong>用于决定分发策略的 hash 表里，key 就是数据库名。</strong></p>
<p>相比于按表和按行分发，这个策略有两个优势：</p>
<ol>
<li>构造 hash 值的时候很快，只需要库名；而且一个实例上 DB 数也不会很多，不会出现需要构造 100 万个项这种情况。</li>
<li>不要求 binlog 的格式。因为 statement 格式的 binlog 也可以很容易拿到库名。</li>
</ol>
<h3 id="MariaDB-的并行复制策略"><a href="#MariaDB-的并行复制策略" class="headerlink" title="MariaDB 的并行复制策略"></a>MariaDB 的并行复制策略</h3><ol>
<li>在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；</li>
<li>commit_id 直接写到 binlog 里面；</li>
<li>传到备库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；</li>
<li>这一组全部执行完成后，coordinator 再去取下一批。</li>
</ol>
<p>这个方案很容易被大事务拖后腿</p>
<h3 id="MySQL-5-7-的并行复制策略"><a href="#MySQL-5-7-的并行复制策略" class="headerlink" title="MySQL 5.7 的并行复制策略"></a>MySQL 5.7 的并行复制策略</h3><p>由参数 <code>slave-parallel-type</code> 来控制并行复制策略：</p>
<ol>
<li>配置为 DATABASE，表示使用 MySQL 5.6 版本的按库并行策略；</li>
<li>配置为 LOGICAL_CLOCK，表示的就是类似 MariaDB 的策略</li>
</ol>
<p>MySQL 5.7 并行复制策略的思想是：</p>
<ol>
<li>同时处于 prepare 状态的事务，在备库执行时是可以并行的；</li>
<li>处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的。</li>
</ol>
<h3 id="MySQL-5-7-22-的并行复制策略"><a href="#MySQL-5-7-22-的并行复制策略" class="headerlink" title="MySQL 5.7.22 的并行复制策略"></a>MySQL 5.7.22 的并行复制策略</h3><p>基于 WRITESET 的并行复制</p>
<p>新增了一个参数 <code>binlog-transaction-dependency-tracking</code>，用来控制是否启用这个新策略。参数的可选值有以下三种：</p>
<ol>
<li><code>COMMIT_ORDER</code>，表示的就是前面介绍的，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</li>
<li><code>WRITESET</code>，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。(hash 值是通过“库名 + 表名 + 索引名 + 值”计算)</li>
<li><code>WRITESET_SESSION</code>，是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ol>
<p><strong>优势:</strong></p>
<ol>
<li>writeset 是在主库生成后直接写入到 binlog 里面的，这样在备库执行的时候，不需要解析 binlog 内容（event 里的行数据），节省了很多计算量；</li>
<li>不需要把整个事务的 binlog 都扫一遍才能决定分发到哪个 worker，更省内存；</li>
<li>由于备库的分发策略不依赖于 binlog 内容，所以 binlog 是 statement 格式也是可以的。</li>
</ol>
<p><strong>约束：</strong></p>
<p>对于“表上没主键”和“外键约束”的场景，WRITESET 策略是没法并行的，也会暂时退化为单线程模型。</p>
<h2 id="主库出问题了，从库怎么办？"><a href="#主库出问题了，从库怎么办？" class="headerlink" title="主库出问题了，从库怎么办？"></a>主库出问题了，从库怎么办？</h2><blockquote>
<img   class="lazyload" data-original="/article/9788/%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  class title="一主多从基本结构">
<p>虚线箭头表示的是主备关系，也就是 A 和 A’互为主备， 从库 B、C、D 指向的是主库 A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p>
</blockquote>
<blockquote>
<p>主库发生故障，主备切换后的结果</p>
<p><img   class="lazyload" data-original="/article/一主多从基本结构 -- 主备切换.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">一主多从基本结构 -- 主备切换</span></p>
<p>一主多从结构在切换完成后，A’会成为新的主库，从库 B、C、D 也要改接到 A’。正是由于多了从库 B、C、D 重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>
</blockquote>
<h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><blockquote>
<p>当把节点 B 设置成节点 A’的从库的时候，需要执行一条 change master 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CHANGE MASTER TO <br>MASTER_HOST=$host_name <br>MASTER_PORT=$port <br>MASTER_USER=$user_name <br>MASTER_PASSWORD=$password <br>MASTER_LOG_FILE=$master_log_name <br>MASTER_LOG_POS=$master_log_pos  <br></code></pre></td></tr></table></figure>
<ol>
<li>MASTER_HOST、MASTER_PORT、MASTER_USER 和 MASTER_PASSWORD 四个参数，分别代表了主库 A’的 IP、端口、用户名和密码。</li>
<li>参数 MASTER_LOG_FILE 和 MASTER_LOG_POS 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。</li>
</ol>
</blockquote>
<p><strong>同步位点</strong></p>
<p>节点 B 是 A 的从库，本地记录的也是 A 的位点。但是相同的日志<strong>，A 的位点和 A’的位点是不同的</strong>。因此，从库 B 要切换的时候，就需要先经过“找同步位点”这个逻辑。</p>
<p>考虑到切换过程中不能丢数据，所以总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库 B 上已经执行过的事务。</p>
<p><strong>主动跳过错误</strong></p>
<p>在进行主从切换时，由于同步位点找的并不是很精确，就会出现如 主键冲突，停止同步 的错误</p>
<p>通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法</p>
<ol>
<li><p>主动跳过一个事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set global sql_slave_skip_counter=1;<br>start slave;<br></code></pre></td></tr></table></figure>
<p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库 B 刚开始接到新主库 A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p>
</li>
<li><p>通过设置 <code>slave_skip_errors</code> 参数，直接设置跳过指定的错误</p>
<p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p>
<ol>
<li>1062 错误是插入数据时唯一键冲突；</li>
<li>1032 错误是删除数据时找不到行。</li>
</ol>
<p>可以把 <code>slave_skip_errors</code> 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过</p>
<p>这种直接跳过指定错误的方法，<strong>针对</strong>的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。</p>
</li>
</ol>
<h3 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h3><p>MySQL 5.6 版本引入了 GTID</p>
<p>GTID 的全称是 <em>Global Transaction Identifier</em>，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">GTID=server_uuid:gno<br></code></pre></td></tr></table></figure>
<ul>
<li>server_uuid 是一个实例第一次启动时自动生成的，是一个全局唯一的值；</li>
<li>gno 是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1。</li>
</ul>
<p>GTID 模式的启动也很简单，我们只需要在启动一个 MySQL 实例的时候，加上参数 <code>gtid_mode=on</code> 和 <code>enforce_gtid_consistency=on</code></p>
<p>在 GTID 模式下，每个事务都会跟一个 GTID 一一对应。这个 GTID 有两种生成方式，而使用哪种方式取决于 session 变量 <code>gtid_next</code> 的值。</p>
<ol>
<li><p>如果 <code>gtid_next=automatic</code>，代表使用默认值。这时，MySQL 就会把 <code>server_uuid:gno</code> 分配给这个事务。</p>
<ol>
<li><p>记录 binlog 的时候，先记录一行 SET </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">@@SESSION.GTID_NEXT=‘server_uuid:gno’;<br></code></pre></td></tr></table></figure>
</li>
<li><p>把这个 GTID 加入本实例的 GTID 集合。</p>
</li>
</ol>
</li>
<li><p>如果 gtid_next 是一个指定的 GTID 的值，比如通过 set <code>gtid_next=&#39;current_gtid’</code> 指定为 current_gtid，那么就有两种可能：</p>
<ol>
<li>如果 current_gtid 已经存在于实例的 GTID 集合中，接下来执行的这个事务会直接被系统忽略；</li>
<li>如果 current_gtid 没有存在于实例的 GTID 集合中，就将这个 current_gtid 分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的 GTID，因此 gno 也不用加 1。</li>
</ol>
</li>
</ol>
<p>一个 current_gtid 只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行 set 命令，把 gtid_next 设置成另外一个 gtid 或者 automatic。</p>
<h3 id="基于-GTID-的主备切换"><a href="#基于-GTID-的主备切换" class="headerlink" title="基于 GTID 的主备切换"></a>基于 GTID 的主备切换</h3><p>在 GTID 模式下，备库 B 要设置为新主库 A’的从库的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs MYSQL">CHANGE MASTER TO <br>MASTER_HOST=$host_name <br>MASTER_PORT=$port <br>MASTER_USER=$user_name <br>MASTER_PASSWORD=$password <br>master_auto_position=1 <br></code></pre></td></tr></table></figure>
<p><code>master_auto_position=1</code> 就表示这个主备关系使用的是 GTID 协议。</p>
<blockquote>
<p>实例 A’的 GTID 集合记为 set_a，实例 B 的 GTID 集合记为 set_b。</p>
<p>我们在实例 B 上执行 start slave 命令，取 binlog 的逻辑是这样的：</p>
<ol>
<li>实例 B 指定主库 A’，基于主备协议建立连接。</li>
<li>实例 B 把 set_b 发给主库 A’。</li>
<li>实例 A’算出 set_a 与 set_b 的差集，也就是所有存在于 set_a，但是不存在于 set_b 的 GTID 的集合，判断 A’本地是否包含了这个差集需要的所有 binlog 事务。<ol>
<li>如果不包含，表示 A’已经把实例 B 需要的 binlog 给删掉了，直接返回错误；</li>
<li>如果确认全部包含，A’从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B；</li>
</ol>
</li>
<li>之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。</li>
</ol>
</blockquote>
<p>在基于 GTID 的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。</p>
<h2 id="读写分离有哪些坑？"><a href="#读写分离有哪些坑？" class="headerlink" title="读写分离有哪些坑？"></a>读写分离有哪些坑？</h2><blockquote>
<p><strong>读写分离基本结构</strong></p>
<img   class="lazyload" data-original="/article/9788/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  class title="读写分离基本结构">
<p><strong>带 proxy 的读写分离架构</strong></p>
<p><img   class="lazyload" data-original="/article/带 proxy 的读写分离架构.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" ><span class="image-caption">带 proxy 的读写分离架构</span></p>
</blockquote>
<ol>
<li>客户端直连方案，因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发。</li>
<li>带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。</li>
</ol>
<p><strong>过期读问题：</strong>由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p>
<p><strong>处理过期读的方案：</strong></p>
<ol>
<li>强制走主库方案；</li>
<li>sleep 方案；</li>
<li>判断主备无延迟方案；</li>
<li>配合 semi-sync 方案；</li>
<li>等主库位点方案；</li>
<li>等 GTID 方案。</li>
</ol>
<h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>强制走主库方案其实就是，将查询请求做分类</p>
<ol>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。</li>
<li>对于可以读到旧数据的请求，才将其发到从库上。</li>
</ol>
<h3 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h3><p>主库更新后，读从库之前先 sleep 一下。</p>
<blockquote>
<p>假设是，大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。</p>
</blockquote>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p><code>show slave status</code> 结果里的 <code>seconds_behind_master</code> 参数的值，可以用来衡量主备延迟时间的长短。</p>
<ol>
<li><p>每次从库执行查询请求前，先判断 <code>seconds_behind_master</code> 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。</p>
</li>
<li><p>对比位点确保主备无延迟</p>
<ol>
<li><code>Master_Log_File</code> 和 <code>Read_Master_Log_Pos</code>，表示的是读到的主库的最新位点；</li>
<li><code>Relay_Master_Log_File</code> 和 <code>Exec_Master_Log_Pos</code>，表示的是备库执行的最新位点。</li>
</ol>
<p>如果 <code>Master_Log_File</code> 和 <code>Relay_Master_Log_File</code>、<code>Read_Master_Log_Pos</code> 和 <code>Exec_Master_Log_Pos</code> 这两组值完全相同，就表示接收到的日志已经同步完成。</p>
</li>
<li><p>对比 GTID 集合确保主备无延迟</p>
<ol>
<li>Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。</li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；</li>
<li>Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li>
</ol>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p>
<blockquote>
<p>问题：有时，binlog 在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。</p>
</blockquote>
</li>
</ol>
<h3 id="配合-semi-sync"><a href="#配合-semi-sync" class="headerlink" title="配合 semi-sync"></a>配合 semi-sync</h3><p>semi-sync 引入半同步复制，也就是 <strong>semi-sync replication</strong></p>
<ol>
<li>事务提交的时候，主库把 binlog 发给从库；</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了；</li>
<li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p>
<p><strong>semi-sync+ 位点判断的方案，只对一主一备的场景是成立的</strong>，在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p>
<ol>
<li>如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据；</li>
<li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li>
</ol>
<p>semi-sync 配合判断主备无延迟的方案，存在两个问题：</p>
<ol>
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li>
<li>在持续延迟的情况下，可能出现过度等待的问题。</li>
</ol>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select master_pos_wait(file, pos[, timeout]);<br></code></pre></td></tr></table></figure>
<ol>
<li>它是在从库执行的；</li>
<li>参数 file 和 pos 指的是主库上的文件名和位置；</li>
<li>timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。</li>
</ol>
<p>这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。</p>
<p>除了正常返回一个正整数 M 外，这条命令还会返回一些其他结果，包括：</p>
<ol>
<li>如果执行期间，备库同步线程发生异常，则返回 NULL；</li>
<li>如果等待超过 N 秒，就返回 -1；</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。</li>
</ol>
</blockquote>
<h3 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select wait_for_executed_gtid_set(gtid_set, 1);<br></code></pre></td></tr></table></figure>
<ol>
<li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</li>
<li>超时返回 1。</li>
</ol>
</blockquote>
<p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行 show master status。而 MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。</p>
<p><strong>让 MySQL 在执行事务后，返回包中带上 GTID</strong></p>
<p>需要将参数 <code>session_track_gtids</code> 设置为 OWN_GTID，然后通过 API 接口 <code>mysql_session_track_get_first</code> 从返回包解析出 GTID 的值即可。</p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>bobo</li>
    <li><strong>本文链接：</strong><a href="https://boyolo.github.io/article/9788.html" title="https:&#x2F;&#x2F;boyolo.github.io&#x2F;article&#x2F;9788.html">https:&#x2F;&#x2F;boyolo.github.io&#x2F;article&#x2F;9788.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="/images/theme/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E4%B9%A0-Mysql/" rel="tag">实习,Mysql</a></li></ul> 

        
  <nav class="nav">
    <a href="/article/62985.html"><i class="iconfont iconleft"></i>函数式编程</a>
    <a href="/article/52913.html">SpringSecurity<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<div id="valine"></div>
<script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  window.onload = function () {
    var loadValine = function () {
      new Valine({
        el: '#valine',
        app_id: "4HVCPi93D54US1F0MCMcBQOl-gzGzoHsz",
        app_key: "y5RbGV3BRqejIr3lLyGjMxAU",
        placeholder: "雁过留痕",
        avatar: "robohash",
        pageSize: "10",
        lang: "zh-CN",
      });
    }
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        loadValine();
      });
    } else {
      loadValine();
    }
  };
</script>

</section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E2%80%9C%E9%A5%AE%E9%B8%A9%E6%AD%A2%E6%B8%B4%E2%80%9D%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">MySQL有哪些“饮鸩止渴”提高性能的方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E8%BF%9E%E6%8E%A5%E9%A3%8E%E6%9A%B4"><span class="toc-text">短连接风暴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-text">慢查询性能问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%85%88%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98"><span class="toc-text">预先发现问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QPS-%E7%AA%81%E5%A2%9E%E9%97%AE%E9%A2%98"><span class="toc-text">QPS 突增问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E7%9A%84%EF%BC%9F"><span class="toc-text">MySQL是怎么保证数据不丢的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog-%E7%9A%84%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">binlog 的写入机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log-%E7%9A%84%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">redo log 的写入机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%8F%90%E4%BA%A4%EF%BC%88group-commit%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-text">组提交（group commit）机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%EF%BC%8C%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD"><span class="toc-text">IO性能瓶颈，提升性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4%E7%9A%84%EF%BC%9F"><span class="toc-text">MySQL是怎么保证主备一致的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E4%B8%BB%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">MySQL 主备的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binlog-%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A0%BC%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-text">binlog 的三种格式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%A4%8D%E5%88%B6%E9%97%AE%E9%A2%98"><span class="toc-text">循环复制问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-text">MySQL是怎么保证高可用的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F"><span class="toc-text">主备延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="toc-text">主备延迟的来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5"><span class="toc-text">可靠性优先策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BC%98%E5%85%88%E7%AD%96%E7%95%A5"><span class="toc-text">可用性优先策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E8%BF%9F%E5%A5%BD%E5%87%A0%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%9F"><span class="toc-text">备库为什么会延迟好几个小时？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E8%A1%A8%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5"><span class="toc-text">按表分发策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E8%A1%8C%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5"><span class="toc-text">按行分发策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-5-6-%E7%89%88%E6%9C%AC%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-text">MySQL 5.6 版本的并行复制策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MariaDB-%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-text">MariaDB 的并行复制策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-5-7-%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-text">MySQL 5.7 的并行复制策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-5-7-22-%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-text">MySQL 5.7.22 的并行复制策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%BA%93%E5%87%BA%E9%97%AE%E9%A2%98%E4%BA%86%EF%BC%8C%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-text">主库出问题了，从库怎么办？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%82%B9%E7%9A%84%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2"><span class="toc-text">基于位点的主备切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GTID"><span class="toc-text">GTID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-GTID-%E7%9A%84%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2"><span class="toc-text">基于 GTID 的主备切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91%EF%BC%9F"><span class="toc-text">读写分离有哪些坑？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%B5%B0%E4%B8%BB%E5%BA%93%E6%96%B9%E6%A1%88"><span class="toc-text">强制走主库方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sleep-%E6%96%B9%E6%A1%88"><span class="toc-text">Sleep 方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%BB%E5%A4%87%E6%97%A0%E5%BB%B6%E8%BF%9F%E6%96%B9%E6%A1%88"><span class="toc-text">判断主备无延迟方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E5%90%88-semi-sync"><span class="toc-text">配合 semi-sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%B8%BB%E5%BA%93%E4%BD%8D%E7%82%B9%E6%96%B9%E6%A1%88"><span class="toc-text">等主库位点方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GTID-%E6%96%B9%E6%A1%88"><span class="toc-text">GTID 方案</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=572643120 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="weixin://dl/business/?ticket=bobo_liakeyou#wechat_redirect "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://github.com/boyolo "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="beau_renbo@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a> |  website - <a target="_blank" href="https://boyolo.github.io/">bobo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
    <div class="fab fab-like">
      <i class="iconfont iconheart"></i>
    </div>
  
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>



  <script>
  $.getScript("//cdn.jsdelivr.net/npm/leancloud-storage@4.1.0/dist/av-min.js", () => {

    AV.init({
      appId: 'bUeKkITlp7tjPXHJVF6XYyFC-gzGzoHsz',
      appKey: 'IaOs2Mc0ddmbLUeggtt9K0cT',
      serverURLs: 'https://leancloud.cn/',
    });

    const Counter = AV.Object.extend("Counter");
    const Like = AV.Object.extend("Like");

    const showCount = (Counter) => {
      const asyncLimit = new AsyncLimit(2);
      $(".leancloud-counter").each(async (e) => {
        const url = $(".leancloud-counter").eq(e).attr('id').trim();
        const query = new AV.Query("Counter");
        query.equalTo("words", url);
        let count = await asyncLimit.run(() => query.count());
        $(".leancloud-counter").eq(e).text(count ? count : 0);
      });
    }

    const addCount = (Counter) => {
      const url = $(".leancloud-counter").length === 1 ? $(".leancloud-counter").attr('id').trim() : 'https://boyolo.github.io';
      var query = new Counter;
      query.save({
        words: url
      });
    }

    const showLike = (Like) => {
      const asyncLimit = new AsyncLimit(2);
      $(".leancloud-like").each(async (e) => {
        const url = $(".leancloud-like").eq(e).attr('id').trim();
        const query = new AV.Query("Like");
        query.equalTo("path", url);
        let count = await asyncLimit.run(() => query.count());
        $(".leancloud-like").eq(e).text(count ? count : 0);
      });
    }

    const addLike = (Like) => {
      const url = $(".leancloud-like").length === 1 ? $(".leancloud-like").attr('id').trim() : 'https://boyolo.github.io';
      var query = new Like;
      query.save({
        path: url,
        nickName: 'Anonymous'
      });
      $(".leancloud-like").addClass('islike');
      $(".fab-like").children(".iconfont").removeClass("iconheart").addClass("iconheart-fill").css("color", "#eb3223");
      ZHAOO.zui.message({ text: '爱你哦~', type: 'success' });
      setTimeout(() => showLike(Like), 1000);
    }

    const handleLikeClick = () => {
      const isLike = $(".leancloud-like").length === 1 && $(".leancloud-like").hasClass('islike') ? true : false;
      if (isLike) {
        ZHAOO.zui.message({ text: '小心心不可以收回呢~', type: 'warning' });
      } else {
        addLike(Like);
      }
    }

    $(function () {
      addCount(Counter);
      showCount(Counter);
      showLike(Like);
      $(".fab-like").on("click", function () {
        handleLikeClick();
      });
    });

  });
</script>





  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>







  <script>
    window.ga = window.ga || function () {
      (ga.q = ga.q || []).push(arguments)
    };
    ga.l = +new Date;
    ga('create', 'G-PS6Y34LRW9', 'auto');
    ga('send', 'pageview');
  </script>
  <script defer src='https://www.google-analytics.com/analytics.js'></script>







</html>