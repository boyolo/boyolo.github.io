<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Typora-markdown 操作详解</title>
    <url>/article/44103.html</url>
    <content><![CDATA[<blockquote>
<p> Stray birds of summer come to my window to sing and fly away.</p>
<p>And yellow leaves of autumn, which have no songs, flutter and fallthere with a sign.</p>
</blockquote>
<h1 id="一、markdown-的简介"><a href="#一、markdown-的简介" class="headerlink" title="一、markdown 的简介"></a>一、markdown 的简介</h1><blockquote>
<p>markdown是一种轻量级的标记语言</p>
<p>理念：markdown致力于让创作或者阅读文档变得更加的容易</p>
<p>hyper text markup language（html）超文本标记性语言</p>
</blockquote>
<blockquote>
<blockquote>
<p>（&lt; + 空格 – 引用）</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">导入文章顶部目录<br>代码：[TOC]<br></code></pre></td></tr></table></figure>
<h1 id="二、标题"><a href="#二、标题" class="headerlink" title="二、标题"></a>二、标题</h1><h2 id="markdown的标题"><a href="#markdown的标题" class="headerlink" title="markdown的标题"></a>markdown的标题</h2><blockquote>
<p>语法：</p>
<!--#（一级标题）  ##（二级标题） ###（三级标题（四级标题） #####（五级标题）-->
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">#（一级标题）<br>##（二级标题）<br>###（三级标题）<br>####（四级标题）<br>#####（五级标题）<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3></blockquote>
<blockquote>
<p>快捷键：</p>
<ul>
<li>command + 数字 1-5   可以快速将选中文字转换为对应级别的标题</li>
<li>command + 加号/减号   可以对标题级别进行加减</li>
</ul>
</blockquote>
<h1 id="三、段落"><a href="#三、段落" class="headerlink" title="三、段落"></a>三、段落</h1><h2 id="1、段落"><a href="#1、段落" class="headerlink" title="1、段落"></a>1、段落</h2><blockquote>
<p>语法：直接进行文字的编辑，如需新建下一段落，可以直接换行</p>
<p>或者在段落的末尾加两个空格回车</p>
</blockquote>
<h2 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h2><blockquote>
<p>语法：</p>
<ol>
<li>粗体   用一对 双星号 （**）包裹  </li>
<li>删除线  用一对 波浪线 （~~）包裹</li>
<li>下划线  用一对  u 标签（<u></u>）包裹</li>
<li>斜体  用一对 单星号 （*）包裹</li>
<li>斜粗体 用一对 三星号（***）包裹</li>
</ol>
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">**这是粗体**<br>~~这是删除线~~<br>&lt;u&gt;这是下划线&lt;/u&gt;<br>*这是斜体*<br>***这是斜粗体***<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<p><strong>这是粗体</strong></p>
<p><del>这是删除线</del></p>
<p><u>这是下划线</u></p>
<p><em>这是斜体</em></p>
<p><strong><em>这是斜粗体</em></strong></p>
</blockquote>
<blockquote>
<p>快捷键：</p>
<ul>
<li>command + B   粗体</li>
<li>shift + control + `  删除线</li>
<li>command + U   下划线</li>
<li>command + I   斜体 </li>
</ul>
</blockquote>
<h2 id="3-分隔符"><a href="#3-分隔符" class="headerlink" title="3.分隔符"></a>3.分隔符</h2><blockquote>
<p>语法：</p>
<p>分割线：三个 — 或 三个 ***</p>
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">---<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<hr>
</blockquote>
<h2 id="4-脚注"><a href="#4-脚注" class="headerlink" title="4.脚注"></a>4.脚注</h2><blockquote>
<p>说明：脚注作用是对文本进行补充说明的</p>
<p>为此文本添加脚注[^键入文本]</p>
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[^键入文本]<br>[^键入文本]:<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<p>为此文本添加脚注[^键入文本]</p>
</blockquote>
<h1 id="四、列表"><a href="#四、列表" class="headerlink" title="四、列表"></a>四、列表</h1><h2 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h2><blockquote>
<p>语法：星号 + 空格</p>
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">&gt;* <br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<p>1、只有同一级别</p>
<ul>
<li></li>
<li></li>
</ul>
<p>2、有子分类</p>
<ul>
<li>一级分类</li>
<li>二级分类<ul>
<li>三级分类</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h2><blockquote>
<p>语法：数字 + . + 空格</p>
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">&gt;1. <br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<ol>
<li>这是第一个标题</li>
<li>这是第二个标题</li>
<li>这是第三个标题<ul>
<li>这是嵌套内容</li>
<li>这也是嵌套内容</li>
</ul>
<ol>
<li>这是新的嵌套</li>
<li>欧吼，又来一个嵌套</li>
</ol>
</li>
</ol>
</blockquote>
<h1 id="五、区块显示"><a href="#五、区块显示" class="headerlink" title="五、区块显示"></a>五、区块显示</h1><blockquote>
<p>代码：</p>
</blockquote>
<blockquote>
<p>效果：</p>
<blockquote>
<p>这是最外层的区块</p>
<blockquote>
<p>这是第二层区块</p>
<blockquote>
<p>这是第三层区块</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li><p>spring boot 技术</p>
<blockquote>
<p>spring boot 技术</p>
</blockquote>
</li>
<li><p>spring cloub技术</p>
<blockquote>
<p>spring cloub 技术</p>
</blockquote>
</li>
</ul>
<h1 id="六、代码块"><a href="#六、代码块" class="headerlink" title="六、代码块"></a>六、代码块</h1><blockquote>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;``` js /java/text<br>&gt;``` js<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">这就是代码块<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs c#">public class Text()&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h1 id="七、链接"><a href="#七、链接" class="headerlink" title="七、链接"></a>七、链接</h1><blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">www.baidu.com<br>[百度一下](https://www.baidu.com)<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果；</p>
<p><a href="http://www.baidu.com">www.baidu.com</a></p>
<p><a href="https://www.baidu.com">百度一下</a></p>
</blockquote>
<h1 id="八、图片插入"><a href="#八、图片插入" class="headerlink" title="八、图片插入"></a>八、图片插入</h1><blockquote>
<p>代码；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs tect">![自定义图片名称](图片路径)<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<p><img src="/Users/pro/Downloads/文件名"><span class="image-caption">This is picture!</span></p>
</blockquote>
<h1 id="九、表格"><a href="#九、表格" class="headerlink" title="九、表格"></a>九、表格</h1><blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">|表头|表中|表尾|<br>|----|----:|:----:|<br>|1|2|3|<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>表头</th>
<th style="text-align:right">表中</th>
<th style="text-align:center">表尾</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:right">2</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</blockquote>
<blockquote>
<p>快捷键：</p>
<ul>
<li>插入表格：command + alt + T</li>
</ul>
</blockquote>
<h1 id="十、其他操作"><a href="#十、其他操作" class="headerlink" title="十、其他操作"></a>十、其他操作</h1><blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">&lt;kbd&gt;&lt;/kbd&gt;<br>`内容`<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<p><kbd>Control</kbd></p>
<p><code>control</code></p>
</blockquote>
]]></content>
      <categories>
        <category>技巧</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>技巧，markdown，typora</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/article/52913.html</url>
    <content><![CDATA[<p>学习源于<a href="https://www.bilibili.com/video/BV1mm4y1X7Hc?p=8&amp;spm_id_from=pageDriver">三更草堂</a></p>
<h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。这是保护基于Spring的应用程序的事实上的标准。</p>
<p>Spring Security是一个专注于为Java应用程序提供身份验证和授权的框架。像所有Spring项目一样，Spring Security的真正力量在于它有多容易被扩展以满足自定义要求。</p>
<p><strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p>
<p><strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>基础项目</strong></p>
<p><code>SecurityApplication.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityApplication</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(SecurityApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>HelloController.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloController</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p>访问 <code>http://localhost:8080/hello</code></p>
<p>跳转页面</p>
<img src="/article/52913/SpringSecurity%E5%85%A5%E9%97%A8.png" class title="image-20220404100727005">
<p>默认用户名：user</p>
<p>默认密码：后台运行复制</p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><img src="/article/52913/%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%B5%81%E7%A8%8B.png" class title="登录校验流程">
<h3 id="SpringSecurity完整流程"><a href="#SpringSecurity完整流程" class="headerlink" title="SpringSecurity完整流程"></a>SpringSecurity完整流程</h3><p>SpringSecurity其实就是一个过滤器链，内部包含了各种功能的过滤器。</p>
<p><strong>基础流程图</strong></p>
<img src="/article/52913/%E6%B5%81%E7%A8%8B%E5%9B%BE-9039561.png" class title="流程图">
<p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p>
<p><strong>ExceptionTranslationFilter：</strong> 处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>
<p><strong>FilterSecurityInterceptor：</strong> 负责权限校验的过滤器。</p>
<p>SpringSecurity过滤器链中有哪些过滤器及它们的顺序：</p>
<img src="/article/52913/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.png" class title="SpringSecurity过滤器链">
<h3 id="认证流程详解"><a href="#认证流程详解" class="headerlink" title="认证流程详解"></a>认证流程详解</h3><img src="/article/52913/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-9040230.png" class title="认证流程详解">
<p><strong>Authentication接口</strong>: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>
<p><strong>AuthenticationManager接口</strong>：定义了认证Authentication的方法</p>
<p><strong>UserDetailsService接口</strong>：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>
<p><strong>UserDetails接口</strong>：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>
<ol>
<li><p>自定义登录验证</p>
<img src="/article/52913/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81.png" class title="自定义登录验证">
<ol>
<li><p>自定义登录接口</p>
<p>调用ProviderManager的方法进行认证 如果认证通过生成jwt</p>
<p>使用userId作为Key，用户信息作为Value，把用户信息存入redis中</p>
</li>
<li><p>自定义UserDetailsService</p>
<p>在这个实现类中去查询数据库</p>
</li>
</ol>
</li>
<li><p>校验</p>
<p>定义Jwt认证过滤器，获取token，解析token获取其中的userid，从redis中获取用户信息，存入SecurityContextHolder</p>
</li>
</ol>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><h3 id="授权基本流程"><a href="#授权基本流程" class="headerlink" title="授权基本流程"></a>授权基本流程</h3><p>在 SpringSecurity 中，会使用默认的 FilterSecurityInterceptor 来进行权限校验。在 FilterSecurityInterceptor 中会从 SecurityContextHolder 获取其中的 Authentication ，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>
<p>所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</p>
<p>然后设置我们的资源所需要的权限即可。</p>
<h3 id="授权实现"><a href="#授权实现" class="headerlink" title="授权实现"></a>授权实现</h3><p><strong>限制访问资源所需权限</strong></p>
<p>可以使用注解去指定访问对应的资源所需的权限</p>
<ol>
<li><p>需要先开启相关配置 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在方法中使用注解配置权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize(&quot;hasAuthority(&#x27;权限&#x27;)&quot;)</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>封装权限信息</strong></p>
<h2 id="自定义失败处理"><a href="#自定义失败处理" class="headerlink" title="自定义失败处理"></a>自定义失败处理</h2><p>希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。</p>
<p>在 SpringSecurity 中，如果我们在认证或者授权的过程中出现了异常会被 ExceptionTranslationFilter 捕获到。在 ExceptionTranslationFilter 中会去判断是认证失败还是授权失败出现的异常。</p>
<p>如果是认证过程中出现的异常会被封装成 AuthenticationException 然后调用 <strong>AuthenticationEntryPoint</strong>  对象的方法去进行异常处理。</p>
<p>如果是授权过程中出现的异常会被封装成 AccessDeniedException 然后调用 <strong>AccessDeniedHandler</strong> 对象的方法去进行异常处理。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>浏览器出于安全的考虑，使用 XMLHttpRequest 对象发起 HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。</p>
<ol>
<li><p>先对SpringBoot配置，运行跨域请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>    <span class="hljs-comment">// 设置允许跨域的路径</span><br>    registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>      <span class="hljs-comment">// 设置允许跨域请求的域名</span><br>      .allowedOriginPatterns(<span class="hljs-string">&quot;*&quot;</span>)<br>      <span class="hljs-comment">// 是否允许cookie</span><br>      .allowCredentials(<span class="hljs-keyword">true</span>)<br>      <span class="hljs-comment">// 设置允许的请求方式</span><br>      .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>)<br>      <span class="hljs-comment">// 设置允许的header属性</span><br>      .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)<br>      <span class="hljs-comment">// 跨域允许时间</span><br>      .maxAge(<span class="hljs-number">3600</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>开启 SpringSecurity 的跨域访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>  <span class="hljs-comment">//允许跨域</span><br>  http.cors();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。</p>
<p>SpringSecurit 去防止 CSRF 攻击的方式就是通过 csrf_token 。后端会生成一个 csrf_token ，前端发起请求的时候需要携带这个 csrf_token ,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。</p>
<p>CSRF 攻击依靠的是 cookie 中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是 token ，而 token 并不是存储中 cookie 中，并且需要前端代码去把token 设置到请求头中才可以，所以CSRF攻击也就不用担心了。</p>
<p>3566930579</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringSecurity</category>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>实习,SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql45讲-实践（一）</title>
    <url>/article/46662.html</url>
    <content><![CDATA[<h2 id="普通索引和唯一索引，应该怎么选择？"><a href="#普通索引和唯一索引，应该怎么选择？" class="headerlink" title="普通索引和唯一索引，应该怎么选择？"></a>普通索引和唯一索引，应该怎么选择？</h2><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p><strong>change buffer</strong></p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些<strong>更新操作</strong>缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>需要说明的是，虽然名字叫作 change buffer，实际上它是<strong>可以持久化的数据</strong>。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 <strong>merge</strong>。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p>
<blockquote>
<p>merge 的执行流程是这样的：</p>
<ol>
<li>从磁盘读入数据页到内存（老版本的数据页）；</li>
<li>从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；</li>
<li>写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。</li>
</ol>
<p>这时候，数据页和内存中 change buffer 对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</p>
</blockquote>
<p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够<strong>避免占用内存，提高内存利用率。</strong></p>
<blockquote>
<p><strong>问题：什么条件下可以使用 change buffer 呢？</strong></p>
<p>对于<strong>唯一索引</strong>来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p>
<p><strong>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</strong></p>
</blockquote>
<p>change buffer 用的是 buffer pool 里的内存，因此<strong>不能无限增大</strong>。change buffer 的大小，可以通过参数 <code>innodb_change_buffer_max_size</code> 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p>
<p><strong>在表中插入一个新纪录，InnoDB处理流程：</strong></p>
<ol>
<li>这个记录要更新的目标页在内存中<ol>
<li>对于唯一索引来说，找到位置，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，找到位置，插入这个值，语句执行结束。</li>
</ol>
</li>
<li><strong>这个记录要更新的目标页不在内存中</strong><ol>
<li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li>
</ol>
</li>
</ol>
<p>将数据从磁盘读入内存涉及<strong>随机 IO 的访问，是数据库里面成本最高的操作之一</strong>。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
<blockquote>
<p>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p>
<p>反过来，假设一个业务的更新模式是<strong>写入之后马上会做查询</strong>，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p>
</blockquote>
<h3 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h3><p><strong>建议尽量选择普通索引</strong></p>
<p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p>
<ol>
<li>首先，业务正确性优先。</li>
<li>然后，在一些“归档库”的场景，你是可以考虑使用普通索引的。</li>
</ol>
<h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><p>如果要简单地对比这两个机制在提升更新性能上的收益的话</p>
<p><strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写）</strong>，</p>
<p><strong>change buffer 主要节省的则是随机读磁盘的 IO 消耗</strong></p>
<hr>
<p><strong>问题：change buffer 一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？change buffer 丢失可不是小事儿，再从磁盘读入数据可就没有了 merge 过程，就等于是数据丢失了。会不会出现这种情况呢？</strong></p>
<blockquote>
<p><strong>不会丢失</strong></p>
<p>虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。</p>
</blockquote>
<hr>
<h2 id="MySQL为什么有时候会选错索引？"><a href="#MySQL为什么有时候会选错索引？" class="headerlink" title="MySQL为什么有时候会选错索引？"></a>MySQL为什么有时候会选错索引？</h2><h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p><strong>选择索引是优化器的工作。</strong></p>
<p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p>
<p><strong>扫描行数</strong>并不是唯一的判断标准，优化器还会结合<strong>是否使用临时表、是否排序</strong>等因素进行综合判断。</p>
<h3 id="扫描行数是怎么判断的？"><a href="#扫描行数是怎么判断的？" class="headerlink" title="扫描行数是怎么判断的？"></a>扫描行数是怎么判断的？</h3><p><strong>区分度</strong></p>
<p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据<strong>统计信息</strong>来估算记录数。这个统计信息就是索引的“<strong>区分度</strong>”。</p>
<p><strong>基数</strong></p>
<p>显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“<strong>基数</strong>”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p>
<p><strong>采样统计</strong></p>
<p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p>
<p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数</p>
<p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</p>
<p>在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 <code>innodb_stats_persistent</code> 的值来选择：</p>
<ol>
<li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li>
<li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li>
</ol>
<p>对于由于索引统计信息不准确导致的问题，你可以用 <code>analyze table</code> 来解决。</p>
<h3 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h3><p><strong>原本可以执行得很快的 SQL 语句，执行速度却比你预期的慢很多，你应该怎么办呢？</strong></p>
<ol>
<li><p>采用 <code>force index</code> 强行选择一个索引</p>
<p>MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果 force index 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p>
</li>
<li><p>考虑修改语句，引导 MySQL 使用我们期望的索引</p>
</li>
<li><p>在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引</p>
</li>
</ol>
<h2 id="怎么给字符串字段加索引？"><a href="#怎么给字符串字段加索引？" class="headerlink" title="怎么给字符串字段加索引？"></a>怎么给字符串字段加索引？</h2><p><strong>用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<blockquote>
<p>当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p>
</blockquote>
<p>我们在建立索引时关注的是<strong>区分度</strong>，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p>
<p>使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例。</p>
<h3 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h3><ol>
<li><p>使用前缀索引可能会增加扫描行数</p>
</li>
<li><p>使用前缀索引就用不上覆盖索引对查询性能的优化</p>
<blockquote>
<p>即使查询到的信息已经包含了所有的信息，但是系统并不确定前缀索引的定义是否截断了完整信息，依然需要回到主键索引再查一次</p>
</blockquote>
</li>
</ol>
<h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><ol>
<li>使用倒序存储</li>
<li>使用 hash 字段</li>
</ol>
<blockquote>
<p>使用倒序存储和使用 hash 字段这两种方法的<strong>异同点</strong></p>
<ol>
<li>相同点：都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的。同样地，hash 字段的方式也只能支持等值查询。</li>
<li>区别：<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</li>
<li>在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li>
<li>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="为什么我的MySQL会“抖”一下？"><a href="#为什么我的MySQL会“抖”一下？" class="headerlink" title="为什么我的MySQL会“抖”一下？"></a>为什么我的MySQL会“抖”一下？</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。</p>
<p>内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>
<p><strong>不论是脏页还是干净页，都在内存中。</strong></p>
<p>InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</p>
<p>第一种是，还没有使用的；</p>
<p>第二种是，使用了并且是干净页；</p>
<p>第三种是，使用了并且是脏页。</p>
<p>InnoDB 的策略是<strong>尽量使用内存</strong>，因此对于一个长时间运行的库来说，未被使用的页面很少。</p>
<p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p>
<blockquote>
<p>刷脏页出现以下这两种情况，都是会明显影响性能的：</p>
<ol>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>
<li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</li>
</ol>
</blockquote>
<h3 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h3><p><code>innodb_io_capacity</code> 这个参数，会告诉 InnoDB 你的磁盘能力。建议设置成磁盘的 IOPS。</p>
<p>测试磁盘随机读写的命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest <br></code></pre></td></tr></table></figure>
<p>InnoDB 的刷盘速度就是要参考这两个因素：</p>
<ol>
<li>一个是脏页比例</li>
<li>一个是 redo log 写盘速度</li>
</ol>
<blockquote>
<p>InnoDB 会根据这两个因素先单独算出两个数字</p>
<p>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是 75%。InnoDB 会根据当前的<strong>脏页比例（假设为 M）</strong>，算出一个范围在 0 到 100 之间的数字：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">F1(M)<br>&#123;<br>  if M&gt;=innodb_max_dirty_pages_pct then<br>      return 100;<br>  return 100*M/innodb_max_dirty_pages_pct;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的<strong>差值，我们假设为 N</strong>。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。</p>
<p>根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 <strong>R</strong>，之后引擎就可以按照 <code>innodb_io_capacity</code> 定义的能力<strong>乘以 R%</strong> 来控制刷脏页的速度。</p>
</blockquote>
<p>InnoDB 会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到 MySQL“抖”了一下的原因。</p>
<p><strong>要尽量避免这种情况，你就要合理地设置 innodb_io_capacity 的值，并且平时要多关注脏页比例(Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total)，不要让它经常接近 75%。</strong></p>
<h2 id="为什么表数据删掉一半，表文件大小不变？"><a href="#为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="为什么表数据删掉一半，表文件大小不变？"></a>为什么表数据删掉一半，表文件大小不变？</h2><p>一个 InnoDB 表包含两部分，即：<strong>表结构定义和数据</strong>。在 MySQL 8.0 版本以前，表结构是存在以 <code>.frm</code> 为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。</p>
<p>表结构定义占用的空间很小</p>
<p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 <code>innodb_file_per_table</code> 控制的：</p>
<ol>
<li>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li>
<li>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 <code>.ibd</code> 为后缀的文件中。</li>
</ol>
<p>建议将这个值设置为 ON:因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 <code>drop table</code> 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的</p>
<h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><p>InnoDB 里的数据都是用 B+ 树的结构组织的,如果我们删掉了一个数据页上的记录，InnoDB 引擎只会把删除的记录标记为删除，如果之后要再插入一个记录时，可能会复用这个位置<strong>（记录的复用，只限于符合范围条件的数据）</strong>。</p>
<p>如果删掉了一个数据页上的所有记录，整个数据页就可以被复用了<strong>（当整个页从 B+ 树里面摘掉以后，可以复用到任何位置）</strong>。</p>
<p><strong>delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。</strong></p>
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>不止是删除数据会造成空洞，插入数据也会造成空洞。</p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>
<blockquote>
<p>经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。而<strong>重建表</strong> <code>alter table</code>，就可以达到这样的目的。</p>
</blockquote>
<p>Online DDL 之后，重建表的流程：</p>
<ol>
<li>建立一个临时文件，扫描表 A 主键的所有数据页；</li>
<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li>
<li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中；</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件；</li>
<li>用临时文件替换表 A 的数据文件。</li>
</ol>
<h2 id="count-这么慢，我该怎么办？"><a href="#count-这么慢，我该怎么办？" class="headerlink" title="count(*)这么慢，我该怎么办？"></a>count(*)这么慢，我该怎么办？</h2><p><strong>count(*) 的实现方式</strong></p>
<ol>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li>
<li>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ol>
<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。</p>
<p>对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</strong></p>
<blockquote>
<p><strong>问题：<code>TABLE_ROWS</code> 能代替 count(*) 吗？</strong></p>
<p>索引统计的值是通过采样来估算的。TABLE_ROWS 就是从这个采样估算得来的，因此它也很不准。</p>
<p>官方文档说误差可能达到 40% 到 50%。所以，show table status 命令显示的行数也不能直接使用。</p>
</blockquote>
<h3 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h3><p>对于更新很频繁的库来说,可以用一个 Redis 服务来保存这个表的总行数。</p>
<blockquote>
<p><strong>问题1：缓存系统可能会丢失更新</strong></p>
<p>Redis 异常重启以后，到数据库里面单独执行一次 count(*) 获取真实的行数，再把这个值写回到 Redis 里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p>
<hr>
<p><strong>问题2：将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。</strong></p>
<ol>
<li>一种是，查到的结果里面有最新插入记录，而 Redis 的计数里还没加 1；</li>
<li>另一种是，查到的结果里没有最新插入的记录，而 Redis 的计数里已经加了 1。</li>
</ol>
<p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的。</p>
</blockquote>
<h3 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h3><p>把这个计数直接放到数据库里单独的一张计数表中</p>
<ol>
<li>解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的；</li>
<li>解决计数不精确的问题，利用“事务”这个特性，解决问题。</li>
</ol>
<h3 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h3><p>count() 的语义：</p>
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p>
<p>count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>
<blockquote>
<p>分析性能差别的时候，三个原则：</p>
<ol>
<li>server 层要什么就给什么；</li>
<li>InnoDB 只给必要的值；</li>
<li>现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。</li>
</ol>
</blockquote>
<ol>
<li><p><code>count(主键 id)</code> </p>
<p>InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
</li>
<li><p><code>count(1)</code></p>
<p>InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
</li>
<li><p><code>count(字段)</code></p>
<ol>
<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li>
<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li>
</ol>
</li>
<li><p><code>count(*)</code></p>
<p>不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p>
</li>
</ol>
<p>按照效率排序的话，<strong>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)</strong></p>
<p>所以尽量使用 count(*)。</p>
<h2 id="“order-by”是怎么工作的？"><a href="#“order-by”是怎么工作的？" class="headerlink" title="“order by”是怎么工作的？"></a>“order by”是怎么工作的？</h2><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer</p>
<p>排序时，可能在内存 sort_buffer 中排序 ，也可能需要使用外部排序，<strong>这取决于排序所需的内存和参数 sort_buffer_size。</strong></p>
<p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>
<blockquote>
<p>通过查看 <code>OPTIMIZER_TRACE</code> 的结果来确认</p>
<p><code>number_of_tmp_files</code> 表示是否使用了临时文件：</p>
<ol>
<li>如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。</li>
<li>如果 sort_buffer_size 太小，number_of_tmp_files 就是 n，表示排序过程中使用 n 个临时文件。</li>
</ol>
</blockquote>
<p>sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。</p>
<h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><p>全字段排序<strong>问题</strong>：如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p>
<p><strong>解决：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET max_length_for_sort_data = 16;<br></code></pre></td></tr></table></figure>
<p><code>max_length_for_sort_data</code> ，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p>
<p><strong>新的算法放入 sort_buffer 的字段，只有要排序的列和主键 id。</strong></p>
<p>最后的“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p>
<h3 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h3><ol>
<li>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</li>
<li>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</li>
</ol>
<p><strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p>
<blockquote>
<p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</p>
</blockquote>
<h2 id="如何正确地显示随机消息？"><a href="#如何正确地显示随机消息？" class="headerlink" title="如何正确地显示随机消息？"></a>如何正确地显示随机消息？</h2><h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><p>用 order by rand() 来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select word from words order by rand() limit 3;<br></code></pre></td></tr></table></figure>
<p>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL 这时就会选择 rowid 排序。</p>
<p><strong>rowid:每个引擎用来唯一标识数据行的信息</strong></p>
<ol>
<li><p>对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；</p>
</li>
<li><p>对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的。</p>
</li>
</ol>
<p><strong>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</strong></p>
<h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><p><code>tmp_table_size</code> 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 <code>tmp_table_size</code>，那么内存临时表就会转成磁盘临时表。</p>
<p>磁盘临时表使用的引擎默认是 InnoDB，是由参数 <code>internal_tmp_disk_storage_engine</code> 控制的。</p>
<p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。</p>
<p><strong>优先队列排序算法</strong></p>
<p>（当存在 limit 时，并且 limit 需要的维护的最大堆的大小小于 sort_buffer，就会使用这个算法。）</p>
<ol>
<li>对于这 n 个准备排序的 (R,rowid)，先取前三行，构造成一个堆；</li>
<li>取下一个行 (R’,rowid’)，跟当前堆里面最大的 R 比较，如果 R’小于 R，把这个 (R,rowid) 从堆中去掉，换成 (R’,rowid’)；</li>
<li>重复第 2 步，直到第 n 个 (R’,rowid’) 完成比较。</li>
</ol>
<h2 id="为什么我只查一行的语句，也执行这么慢？"><a href="#为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="为什么我只查一行的语句，也执行这么慢？"></a>为什么我只查一行的语句，也执行这么慢？</h2><h3 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h3><blockquote>
<p>出现情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t where id=1;<br></code></pre></td></tr></table></figure>
<p>一般碰到这种情况的话，大概率是表 t 被锁住了。</p>
</blockquote>
<p>查看当前语句处于什么状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">show processlist;<br></code></pre></td></tr></table></figure>
<ol>
<li><p>等 MDL 锁</p>
<p>使用 show processlist 命令查看 Waiting for table metadata lock</p>
<p>表示的是，现在有一个线程正在请求或者持有 MDL 写锁，把 select 语句堵住了。</p>
<p><strong>处理方法：找到谁持有 MDL 写锁，然后把它 kill 掉</strong></p>
<p>(MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失，建议可以开启mysql的 performance_schema 功能，这个可以定位被锁的线程情况)</p>
<p>通过查询 sys.schema_table_lock_waits 这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。</p>
</li>
<li><p>等 flush</p>
<blockquote>
<p>mysql&gt; select * from information_schema.processlist where id=1;</p>
</blockquote>
<p>查出来这个线程的状态是 <strong>Waiting for table flush</strong></p>
<p>这个状态表示的是，现在有一个线程正要做 flush 操作。MySQL 里面对表做 flush 操作的用法，一般有以下两个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#如果指定表 t 的话，代表的是只关闭表 t；<br>flush tables t with read lock;<br>#如果没有指定具体的表名，则表示关闭 MySQL 里所有打开的表。<br>flush tables with read lock;<br></code></pre></td></tr></table></figure>
<p>但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p>
<p>所以，出现 <strong>Waiting for table flush</strong> 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句。</p>
</li>
<li><p>等行锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t where id=1 lock in share mode; <br>#读锁（S 锁，共享锁） 由于访问 id=1 这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的 select 语句就会被堵住。<br>mysql&gt; select k from t where id=1 for update; <br>#写锁（X 锁，排他锁）<br></code></pre></td></tr></table></figure>
<p>MySQL 5.7，通过 <strong>sys.innodb_lock_waits</strong> 表查到是谁占着这个写锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from sys.innodb_lock_waits where locked_table=&#x27;`test`.`t`&#x27;\G<br></code></pre></td></tr></table></figure>
<p><strong>直接断开这个连接</strong>。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了 id=1 上的行锁。</p>
</li>
</ol>
<h3 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h3><p>一致性读导致回滚日志过大引起的一致性读慢，当前读快</p>
<h2 id="幻读是什么，幻读有什么问题？"><a href="#幻读是什么，幻读有什么问题？" class="headerlink" title="幻读是什么，幻读有什么问题？"></a>幻读是什么，幻读有什么问题？</h2><h3 id="幻读是什么？"><a href="#幻读是什么？" class="headerlink" title="幻读是什么？"></a>幻读是什么？</h3><p>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，<strong>幻读在“当前读”下才会出现。</strong></p>
<h3 id="幻读有什么问题？"><a href="#幻读有什么问题？" class="headerlink" title="幻读有什么问题？"></a>幻读有什么问题？</h3><ol>
<li><p>首先是语义上的。</p>
<blockquote>
<p><img src="/article/假设只在 id=5 这一行加行锁 -- 语义被破坏.png"><span class="image-caption">假设只在 id=5 这一行加行锁 -- 语义被破坏</span></p>
<p>T1: session A 声明，“我要把所有 d=5 的行锁住，不准别的事务进行读写操作”。</p>
<p>T2:session B 的第二条语句 update t set c=5 where id=0，语义是“我把 id=0、d=5 这一行的 c 值，改成了 5”。由于在 T1 时刻，session A 还只是给 id=5 这一行加了行锁， 并没有给 id=0 这行加上锁。因此，session B 在 T2 时刻，是可以执行这两条 update 语句的。</p>
<p><strong>这样，就破坏了 session A 里 Q1 语句要锁住所有 d=5 的行的加锁声明。</strong></p>
</blockquote>
</li>
<li><p>其次，是数据一致性的问题。</p>
<p>锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p>
<blockquote>
<p><img src="/article/假设只在 id=5 这一行加行锁 -- 数据一致性问题.png"><span class="image-caption">假设只在 id=5 这一行加行锁 -- 数据一致性问题</span></p>
<p><strong>update 的加锁语义和 select …for update 是一致的</strong></p>
<ol>
<li><p>正常执行</p>
<p>经过 T1 时刻，id=5 这一行变成 (5,5,100)，当然这个结果最终是在 T6 时刻正式提交的 ;</p>
<p>经过 T2 时刻，id=0 这一行变成 (0,5,5);</p>
<p>经过 T4 时刻，表里面多了一行 (1,5,5);</p>
</li>
<li><p>binlog 记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#T2 时刻，session B 事务提交，写入了两条语句；<br>update t set d=5 where id=0; /*(0,0,5)*/<br>update t set c=5 where id=0; /*(0,5,5)*/<br>#T4 时刻，session C 事务提交，写入了两条语句；<br>insert into t values(1,1,5); /*(1,1,5)*/<br>update t set c=5 where id=1; /*(1,5,5)*/<br>#T6 时刻，session A 事务提交，写入了 update t set d=100 where d=5 这条语句。<br>update t set d=100 where d=5;/*所有d=5的行，d改成100*/<br></code></pre></td></tr></table></figure>
<p>这个语句序列，不论是拿到备库去执行，还是以后用 binlog 来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100) 和 (5,5,100)。</p>
<p>id=0 和 id=1 这两行，发生了数据不一致。</p>
</li>
</ol>
<hr>
<p>为了解决上面数据不一致的问题，假设把扫描过程中碰到的行都加锁，</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>实习,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql45讲</title>
    <url>/article/53105.html</url>
    <content><![CDATA[<p>关于MySQL的发音：</p>
<blockquote>
<p>The official way to pronounce “MySQL” is “My Ess Que Ell” (not “my sequel”), but we do not mind if you pronounce it as “my sequel” or in some other localized way.</p>
</blockquote>
<h2 id="一条SQL查询语句是如何执行的？"><a href="#一条SQL查询语句是如何执行的？" class="headerlink" title="一条SQL查询语句是如何执行的？"></a>一条SQL查询语句是如何执行的？</h2><p><img src="/article/MySQL 的基本架构示意图.png"><span class="image-caption">img</span></p>
<p><strong>MySQL 可以分为 Server 层和存储引擎层两部分。</strong>不同的存储引擎共用一个 Server 层。</p>
<p>Server 层包括<strong>连接器、查询缓存、分析器、优化器、执行器</strong>等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>现在最常用的存储引擎是 <strong>InnoDB</strong>，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql -h<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.558ex" height="2.509ex" style="vertical-align: -0.671ex;" viewbox="0 -791.3 2823.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">ip -P</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-69" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="345" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="1071" y="0"/>
 <use xlink:href="#E1-MJMATHI-50" x="2071" y="0"/>
</g>
</svg>port -u$user -p<br></code></pre></td></tr></table></figure>
<p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份。</p>
<blockquote>
<ol>
<li><p>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p>
</li>
<li><p>如果用户名密码认证通过，连接器会到<strong>权限表</strong>里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</p>
<p>(一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。)</p>
</li>
</ol>
</blockquote>
<p>显示用户正在运行的线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">show processlist<br></code></pre></td></tr></table></figure>
<p>Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是 8 小时。</p>
<p><strong>建议尽量使用长连接</strong></p>
<blockquote>
<p>数据库里面，<strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。<strong>短连接</strong>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
</blockquote>
<p>全部使用长连接后，有些时候 MySQL 占用内存涨得特别快</p>
<p><strong>这是因为</strong> MySQL 在执行过程中临时使用的内存是管理在<strong>连接对象里面的</strong>。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，<strong>被系统强行杀掉（OOM）</strong>，从现象看就是 MySQL 异常重启了。</p>
<blockquote>
<p><strong>解决方法</strong></p>
<ol>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>MySQL 5.7 或更新版本：可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。<strong>这个过程不需要重连和重新做权限验证</strong>，但是会将连接恢复到刚刚创建完时的状态。</li>
</ol>
</blockquote>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>MySQL 拿到一个查询请求后:</p>
<ol>
<li>先到查询缓存：之前是否执行过这条语句，之前执行过的语句及其结果可能会以 <code>key(查询语句)-value（查询结果）</code> 对的形式，被直接缓存在内存中。(<a href="https://dev.mysql.com/blog-archive/mysql-8-0-retiring-support-for-the-query-cache/">MySQL 8.0版本直接将查询缓存的整块功能删掉了</a> （弊大于利）查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空)。</li>
<li>没有找缓存结果：<a href="#分析器">开始真正执行语句</a></li>
</ol>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><ol>
<li><strong>词法分析</strong>：MySQL 需要识别出输入的的字符串（SQL语句）分别是什么，代表什么；</li>
<li><strong>语法分析</strong>：根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。（语法错误提示：“You have an error in your SQL syntax”）。</li>
</ol>
<p>分析器处理语法和解析查询, 生成一课对应的解析树。 预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>在开始执行之前，还要先经过优化器的处理。</p>
<p><strong>优化器</strong>是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><ol>
<li>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限(在工程实现上，如果命中查询缓存，会在<strong>查询缓存返回结果</strong>的时候，做权限验证。查询也会在<strong>优化器之前</strong>调用 precheck 验证权限)；</li>
<li>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的<strong>引擎定义</strong>，去使用这个引擎提供的接口。</li>
</ol>
<p>你会在数据库的慢查询日志中看到一个 <code>rows_examined</code> 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<blockquote>
<p>执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 <code>rows_examined</code> 并不是完全相同的</p>
</blockquote>
<h2 id="一条SQL更新语句是如何执行的？"><a href="#一条SQL更新语句是如何执行的？" class="headerlink" title="一条SQL更新语句是如何执行的？"></a>一条SQL更新语句是如何执行的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">update T set c=c+1 where ID=2;<br></code></pre></td></tr></table></figure>
<p><img src="/article/MySQL 的基本架构示意图.png"><span class="image-caption">img</span></p>
<p><strong>执行流程</strong></p>
<p>执行语句前要先<strong>连接</strong>数据库，这是连接器的工作</p>
<p>在一个表上有<strong>更新</strong>的时候，跟这个表有关的<strong>查询缓存会失效</strong>，所以这条语句就会把表 T 上所有缓存结果都清空。</p>
<p><strong>分析器</strong>会通过词法和语法解析知道这是一条更新语句。<strong>优化器</strong>决定要使用 ID 这个索引。然后，<strong>执行器</strong>负责具体执行，找到这一行，然后更新。</p>
<p>两个重要的日志模块：<strong>redo log（重做日志）和 binlog（归档日志）</strong>（只要我们写的是DML语句（insert,update,delete,create）等等，那么我们在数据库服务端执行的时候就会涉及到 redo log(重做日志) 和 binlog(归档日志) 两个日志文件的变动）</p>
<h3 id="redo-log（重做日志）–InnoDB特有的日志"><a href="#redo-log（重做日志）–InnoDB特有的日志" class="headerlink" title="redo log（重做日志）–InnoDB特有的日志"></a>redo log（重做日志）–InnoDB特有的日志</h3><blockquote>
<p>问题：如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。</p>
</blockquote>
<p>解决：<strong>WAL 技术</strong>，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。</p>
<p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 <strong>redo log</strong>里面，并更新内存，这个时候更新就算完成了。同时，<strong>InnoDB 引擎</strong>会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<blockquote>
<p>问题：InnoDB 的 redo log 是固定大小的，redo log 写满之后，先将日志中的部分记录写到磁盘，腾出redo log的空间继续写入。</p>
</blockquote>
<p><img src="/article/redo log 循环写入.png"><span class="image-caption">img</span></p>
<p><code>write pos</code> 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<code>check point</code> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p><code>write pos</code> 和 <code>checkpoint</code> 之间的是“redo log”上还空着的部分，可以用来记录新的操作。</p>
<p>如果 <code>write pos</code> 追上 <code>checkpoint</code>，表示“redo log”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。</p>
<p>redo log 用于保证 crash-safe 能力。<code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p>
<h3 id="binlog（归档日志）–Server层-日志"><a href="#binlog（归档日志）–Server层-日志" class="headerlink" title="binlog（归档日志）–Server层 日志"></a>binlog（归档日志）–Server层 日志</h3><blockquote>
<p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，<strong>binlog</strong> 日志只能用于<strong>归档</strong>。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p>
</blockquote>
<p><code>sync_binlog</code> 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p>
<table>
<thead>
<tr>
<th style="text-align:left">redo log</th>
<th style="text-align:left">binlog</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">InnoDB 引擎特有的</td>
<td style="text-align:left">MySQL 的 Server 层实现的，所有引擎都可以使用</td>
</tr>
<tr>
<td style="text-align:left">物理日志：记录的是“在某个数据页上做了什么修改”</td>
<td style="text-align:left">逻辑日志：记录的是这个语句的原始逻辑</td>
</tr>
<tr>
<td style="text-align:left">循环写入，空间固定会用完</td>
<td style="text-align:left">追加写入，binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</td>
</tr>
</tbody>
</table>
<p>浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p>
<p><img src="/article/update 语句执行流程.png"><span class="image-caption">img</span></p>
<p><strong>两阶段提交</strong>:为了让两份日志之间的逻辑一致</p>
<h2 id="事务隔离：为什么你改了我还看不见？"><a href="#事务隔离：为什么你改了我还看不见？" class="headerlink" title="事务隔离：为什么你改了我还看不见？"></a>事务隔离：为什么你改了我还看不见？</h2><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的（MySQL 原生的 MyISAM 引擎就不支持事务）。</p>
<p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p>
<h3 id="隔离性与隔离级"><a href="#隔离性与隔离级" class="headerlink" title="隔离性与隔离级"></a>隔离性与隔离级</h3><p><strong>隔离得越严实，效率就会越低</strong></p>
<p>当数据库上有多个事务同时执行的时候，就可能出现<strong>脏读</strong>（dirty read）、<strong>不可重复读</strong>（non-repeatable read）、<strong>幻读</strong>（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<ol>
<li><strong>脏读</strong>：读到其他事务未提交的数据；</li>
<li><strong>不可重复读</strong>：前后读取的记录内容不一致；</li>
<li><strong>幻读</strong>：前后读取的记录数量不一致。</li>
</ol>
<blockquote>
<p>脏读：事务A查询数据后进行了一次修改且未提交，而事务B这个时候去查询，然后使用了这个数据，因为这个数据还没有被事务A 提交到数据库中，所以事务B的得到数据就是脏数据，对脏数据进行操作可能是不正确的。 不可重复读: 事务A访问了两次数据，但是这访问第二次之间事务B进行一次并进行了修改，导致事务A访问第二次的时候得到的数据与第一次不同，导致一个事务访问两次数据得到的数据不相同。因此叫做不可重复读。 幻读： 与不可重复读都点相似，只是这次是事务B在事务A访问第二次的之前做了一个新增，导致事务A第二次读取的时候发现了多的记录，这就是幻读。 丢失修改：事务A访问该数据，事务B也访问该数据，事务A修改了该数据，事务B也修改了该数据，这样导致事务A的修改被丢失，因此称为丢失修改； 不可重复度和幻读区别： 不可重复读主要是修改操作，幻读的主要在于新增或者删除。 幻读主要在于数据的条数变了，而不可重复读主要在于数据内容变了。</p>
</blockquote>
<p>SQL 标准的事务隔离级别包括<strong>：读未提交</strong>（read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（serializable ）。</p>
<ol>
<li><strong>读未提交</strong>，一个事务还没提交时，它做的变更就能被别的事务看到；</li>
<li><strong>读提交</strong>，一个事务提交之后，它做的变更才会被其他事务看到；</li>
<li><strong>可重复读</strong>，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的；(<strong>别人改数据的事务已经提交，我在我的事务中也不去读</strong>。)</li>
<li><strong>串行化</strong>，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ol>
<p><strong>这4种隔离级别，并行性能依次降低，安全性依次提高</strong></p>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p>
<p>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。（事务启动时的视图可以认为是静态的，不受其他事务更新的影响。）</p>
<blockquote>
<p>事务启动方式：</p>
<ol>
<li>一致性视图是在执行第一个快照读语句时创建的；</li>
<li>一致性视图是在执行 <code>start transaction with consistent snapshot</code> 时创建的。</li>
</ol>
</blockquote>
<p>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。</p>
<p>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</p>
<p>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>
<p>Oracle 数据库的默认隔离级别其实就是“读提交”；</p>
<p>MySQL默认的隔离级别是”可重复读”。</p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
<p><strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong></p>
<p>系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。（就是当系统里没有比这个回滚日志更早的视图的时候）</p>
<p><strong>问题：为什么建议你尽量不要使用长事务</strong></p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 <strong>ibdata</strong> 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。</p>
<p>长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><ol>
<li><p>显式启动事务语句， <code>begin</code> 或 <code>start transaction</code>。配套的提交语句是 <code>commit</code>，回滚语句是 <code>rollback</code>。</p>
</li>
<li><p><code>set autocommit=0</code>，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 <code>commit</code> 或<code>rollback</code>语句，或者断开连接。</p>
<p><strong>建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务。</strong></p>
</li>
<li><p>用 <code>commit work and chain</code> 语法</p>
<p>在 <strong>autocommit 为 1</strong> 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>
</li>
</ol>
<p><code>information_schema 库的 innodb_trx 这个表</code>中查询长事务</p>
<hr>
<p><strong>问题：有什么方案来避免出现或者处理长事物？</strong></p>
<blockquote>
<p>首先，从应用开发端来看：</p>
<ol>
<li>确认是否使用了 <code>set autocommit=0</code>。这个确认工作可以在测试环境中开展，把 MySQL 的 <code>general_log</code> 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</li>
<li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 <code>begin/commit</code> 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</li>
<li>业务连接数据库的时候，根据业务本身的预估，通过 <code>SET MAX_EXECUTION_TIME</code> 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li>
</ol>
<p>其次，从数据库端来看：</p>
<ol>
<li><p>监控 <code>information_schema.Innodb_trx 表</code>，设置长事务阈值，超过就报警 / 或者 kill；</p>
</li>
<li><p>Percona 的 pt-kill 这个工具不错，推荐使用；</p>
</li>
<li><p>在业务功能测试阶段要求输出所有的 <code>general_log</code>，分析日志行为提前发现问题；</p>
</li>
<li><p>如果使用的是 MySQL 5.6 或者更新版本，把 <code>innodb_undo_tablespaces</code> 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</p>
<p>(innodb_undo_tablespaces是控制undo是否开启独立的表空间的参数 </p>
<ol>
<li>为0表示：undo使用系统表空间，即ibdata1 </li>
<li>不为0表示：使用独立的表空间，一般名称为 undo001 undo002，存放地址的配置项为：innodb_undo_directory </li>
<li>一般innodb_undo_tablespaces 默认配置为0，innodb_undo_directory默认配置为当前数据目录)</li>
</ol>
</li>
</ol>
</blockquote>
<hr>
<h2 id="深入浅出索引"><a href="#深入浅出索引" class="headerlink" title="深入浅出索引"></a>深入浅出索引</h2><p><strong>索引的出现是为了提高查询效率</strong></p>
<h3 id="哈希表索引模型"><a href="#哈希表索引模型" class="headerlink" title="哈希表索引模型"></a>哈希表索引模型</h3><p>哈希表是一种以 <strong>键 - 值</strong>（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。</p>
<blockquote>
<p>思路：</p>
<p>用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>
</blockquote>
<blockquote>
<p><strong>问题</strong>：多个 key 值经过哈希函数的换算，会出现同一个值的情况</p>
<p><strong>解决方法：</strong>拉出一个链表</p>
<img src="/article/53105/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="根据身份证号查找对应的名字">
<p><strong>缺点：</strong>因为不是有序的（比如四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加），所以<strong>哈希索引做区间查询的速度是很慢的</strong>。</p>
<p>哈希表这种结构适用于只有<strong>等值查询</strong>的场景，比如 Memcached 及其他一些 NoSQL 引擎。</p>
</blockquote>
<h3 id="有序数组索引模型"><a href="#有序数组索引模型" class="headerlink" title="有序数组索引模型"></a>有序数组索引模型</h3><p>适用于<strong>等值查询</strong>和<strong>范围查询</strong>场景</p>
<blockquote>
<p>根据身份证号查找对应的名字<strong>有序数组</strong>示意图</p>
<img src="/article/53105/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="根据身份证号查找对应的名字">
<p>用二分法就可以快速得到，这个<strong>时间复杂度是 O(log(N))</strong></p>
<p><strong>优点：</strong>仅仅看查询效率，有序数组就是最好的数据结构</p>
<p><strong>缺点：</strong>中间插入一个记录就必须得挪动后面所有的记录，成本太高</p>
<p>有序数组索引<strong>只适用于静态存储引擎</strong></p>
</blockquote>
<h3 id="二叉搜索树索引模型"><a href="#二叉搜索树索引模型" class="headerlink" title="二叉搜索树索引模型"></a>二叉搜索树索引模型</h3><blockquote>
<p>根据身份证号查找对应的名字<strong>二叉搜索树</strong>示意图</p>
<img src="/article/53105/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="根据身份证号查找对应的名字">
<p>二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。</p>
<p><strong>时间复杂度是 O(log(N))</strong></p>
<p><strong>优点：</strong>二叉树是搜索效率最高的</p>
<p><strong>缺点：</strong></p>
<ol>
<li>为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是<strong>平衡二叉树</strong>。为了做这个保证，<strong>更新的时间复杂度也是 O(log(N))</strong>。</li>
<li>索引不止存在内存中，还要写到磁盘上（所以大多数的数据库存储并不使用二叉树）</li>
</ol>
<p><strong>解决方法：</strong>为了让一个查询<strong>尽量少地读磁盘</strong>，就必须让查询过程<strong>访问尽量少的数据块</strong>。那么，我们就不应该使用二叉树，而是要使用“<strong>N 叉</strong>”树。这里，<strong>“N 叉”树中的“N”取决于数据块的大小</strong>。</p>
<p><strong>N叉树优点：</strong>读写上的性能优点，以及适配磁盘的访问模式</p>
</blockquote>
<p>在 MySQL 中，<strong>索引是在存储引擎层实现</strong>的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><p>在 InnoDB 中，表都是根据<strong>主键顺序以索引</strong>的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。</p>
<p>InnoDB 使用了 <strong><a href="https://blog.csdn.net/weixin_35871519/article/details/113303881">B+ 树索引模型</a></strong>，所以数据都是存储在 B+ 树中的。</p>
<p><strong>每一个索引在 InnoDB 里面对应一棵 B+ 树</strong></p>
<p><strong>B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</strong></p>
<blockquote>
<p>假设有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; create table T(<br>id int primary key, <br>k int not null, <br>name varchar(16),<br>index (k))engine=InnoDB;<br></code></pre></td></tr></table></figure>
<p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下:</p>
<p><img src="/article/InnoDB 的索引组织结构.png"><span class="image-caption">InnoDB 的索引组织结构</span></p>
<p>图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p>查询时：</p>
<ol>
<li><p>主键查询方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from T where ID=500<br></code></pre></td></tr></table></figure>
<p>只需要搜索 ID 这棵 B+ 树</p>
</li>
<li><p>普通索引查询方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from T where k=5<br></code></pre></td></tr></table></figure>
<p>需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</p>
</li>
</ol>
<p>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该<strong>尽量使用主键查询</strong>。</p>
</blockquote>
<p><strong>主键索引</strong>的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为<strong>聚簇索引</strong>（clustered index）。</p>
<p><strong>非主键索引</strong>的叶子节点内容是<strong>主键的值</strong>。在 InnoDB 里，非主键索引也被称为<strong>二级索引</strong>（secondary index）。</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a><strong>索引维护</strong></h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p>
<blockquote>
<p><strong>页分裂</strong>:新插入的数据符合条件的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。（除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。）</p>
<p><strong>页合并</strong>：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
</blockquote>
<p><strong>性能和存储空间方面考量，自增主键往往是更合理的选择</strong></p>
<p>自增主键的插入数据模式，正符合了递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<blockquote>
<p>适合用业务字段直接做主键的场景:</p>
<ol>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ol>
<p>直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树</p>
</blockquote>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p><strong>经过索引优化，避免回表过程</strong></p>
<blockquote>
<p>搜索由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from T where k between 3 and 5<br></code></pre></td></tr></table></figure>
<p>变为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select ID from T where k between 3 and 5<br></code></pre></td></tr></table></figure>
<p>只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为<strong>覆盖索引</strong>。</p>
</blockquote>
<p>由于覆盖索引可以<strong>减少树的搜索次数</strong>，<strong>显著提升查询性能</strong>，所以使用<strong>覆盖索引</strong>是一个常用的性能优化手段。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p><strong>为一个不频繁的请求创建一个索引感觉很浪费</strong></p>
<p><strong>最左前缀</strong>可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>
<blockquote>
<p><strong>问题：</strong>在建立联合索引的时候，如何安排索引内的字段顺序</p>
<p><strong>评估标准:</strong>索引的复用能力</p>
<ol>
<li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>
<li>(如果既有联合查询，又有基于 a、b 各自的查询)第二原则是,空间</li>
</ol>
</blockquote>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;<br></code></pre></td></tr></table></figure>
<p>无索引下推执行流程</p>
<img src="/article/53105/%E6%97%A0%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" class title="无索引下推执行流程">
<p>索引下推执行流程</p>
<img src="/article/53105/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" class title="索引下推执行流程">
</blockquote>
<hr>
<p><strong>问题：重建索引时，是重建非主键索引还是主键索引？</strong></p>
<p>重建非主键索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table T drop index k;<br>alter table T add index(k);<br></code></pre></td></tr></table></figure>
<p>重建主键索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table T drop primary key;<br>alter table T add primary key(id);<br></code></pre></td></tr></table></figure>
<blockquote>
<p>重建索引 k 的做法是合理的，可以达到省空间的目的。</p>
<p>但是，重建主键的过程不合理。<strong>不论是删除主键还是创建主键，都会将整个表重建。</strong>所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。</p>
</blockquote>
<hr>
<h2 id="全局锁和表锁-：给表加个字段怎么有这么多阻碍？"><a href="#全局锁和表锁-：给表加个字段怎么有这么多阻碍？" class="headerlink" title="全局锁和表锁 ：给表加个字段怎么有这么多阻碍？"></a>全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h2><p>数据库锁设计的<strong>初衷是处理并发问题</strong>。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p>
<p>MySQL 里面的锁大致可以分成<strong>全局锁、表级锁和行锁</strong>三类。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock (FTWRL)</code>。</p>
<p>当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong></p>
<blockquote>
<p>全局锁的问题:</p>
<ol>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li>
</ol>
</blockquote>
<p>官方自带的逻辑备份工具是 <strong>mysqldump</strong>。当 mysqldump 使用参数–<code>single-transaction</code> 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p>
<blockquote>
<p><strong>问题：有了mysqldump功能，为什么还需要 FTWRL 呢？</strong></p>
<p>一致性读是好，但前提是引擎要支持<strong>可重复读</strong>隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p>
</blockquote>
<p><strong><code>single-transaction</code> 方法只适用于所有的表使用事务引擎的库。</strong></p>
<blockquote>
<p><strong>问题：既然要全库只读，为什么不使用 set global readonly=true 的方式呢？</strong></p>
<ol>
<li>一在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议你使用。</li>
<li>在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ol>
</blockquote>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL 里面表级别的锁有两种：一种是<strong>表锁</strong>，一种是<strong>元数据锁</strong>（meta data lock，MDL)。</p>
<p><strong>表锁</strong></p>
<p>表锁的语法是 <code>lock tables … read/write</code>。与 FTWRL 类似，可以用 <code>unlock tables</code> 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法<strong>除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</strong></p>
<p><strong>元数据锁</strong>(MySQL 5.5 版本中引入)</p>
<p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。</p>
<p>MDL 的作用是，<strong>保证读写的正确性</strong>。</p>
<ol>
<li>当对一个表做增删改查操作的时候，加 <strong>MDL 读锁</strong>；</li>
<li>当要对表做结构变更操作的时候，加 <strong>MDL 写锁</strong>。</li>
</ol>
<p>每执行一条DML、DDL语句时都会申请MDL锁，<strong>DML操作需要MDL读锁，DDL操作需要MDL写锁</strong>（MDL加锁过程是系统自动控制，无法直接干预，读读共享，读写互斥，写写互斥）</p>
<ol>
<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ol>
<p><strong>MDL 会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</strong></p>
<p><strong>表锁一般是在数据库引擎 <em>不支持行锁</em> 的时候才会被用到的。</strong></p>
<hr>
<p><strong>问题：如何安全地给小表加字段？</strong></p>
<blockquote>
<p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 <code>information_schema 库的 innodb_trx 表</code>中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p>
</blockquote>
<hr>
<p><strong>问题：如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</strong></p>
<blockquote>
<p>在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p>
<p><code>DDL NOWAIT/WAIT n</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE tbl_name NOWAIT add column ...<br>ALTER TABLE tbl_name WAIT N add column ... <br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><strong>问题：如果你发现你的应用程序里有 lock tables 这样的语句，需要怎么做？</strong></p>
<blockquote>
<ol>
<li>要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；</li>
<li>要么是你的引擎升级了，但是代码还没升级。最后业务开发就是把 lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。</li>
</ol>
</blockquote>
<hr>
<p><strong>问题：备份一般都会在备库上执行，你在用–single-transaction 方法做逻辑备份的过程中，如果主库上的一个小表做了一个 DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</strong></p>
<blockquote>
<p>假设这个 DDL 是针对表 t1 的， 这里我把备份过程中几个关键的语句列出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；<br>/* other tables */<br>Q3:SAVEPOINT sp;<br>/* 时刻 1 */<br>Q4:show create table `t1`;<br>/* 时刻 2 */<br>Q5:SELECT * FROM `t1`;<br>/* 时刻 3 */<br>Q6:ROLLBACK TO SAVEPOINT sp;<br>/* 时刻 4 */<br>/* other tables */<br></code></pre></td></tr></table></figure>
<ol>
<li>如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。</li>
<li>如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；</li>
<li>如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。</li>
<li>从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。</li>
</ol>
</blockquote>
<hr>
<h2 id="行锁功过：怎么减少行锁对性能的影响？"><a href="#行锁功过：怎么减少行锁对性能的影响？" class="headerlink" title="行锁功过：怎么减少行锁对性能的影响？"></a>行锁功过：怎么减少行锁对性能的影响？</h2><p><strong>MySQL 的行锁是在引擎层由各个引擎自己实现的。</strong></p>
<p>(MyISAM 引擎就不支持行锁)</p>
<h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>
<p><strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></p>
<h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为<strong>死锁</strong>。</p>
<p>当出现死锁以后，有两种策略：</p>
<ol>
<li><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</p>
<blockquote>
<p>问题：在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
</blockquote>
</li>
<li><p>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。</p>
<p><code>innodb_deadlock_detect</code> 的默认值本身就是 on。</p>
<blockquote>
<p>问题：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p>
</blockquote>
</li>
</ol>
<hr>
<p><strong>问题：怎么解决由热点行更新导致的性能问题呢？</strong></p>
<blockquote>
<p>问题的症结在于，死锁检测要耗费大量的 CPU 资源。</p>
<ol>
<li><p>如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</p>
</li>
<li><p>控制并发度</p>
<p>并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。</p>
<p>基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p>
</li>
<li><p>设计上优化</p>
<p>将一行改成逻辑上的多行来减少锁冲突</p>
</li>
</ol>
</blockquote>
<hr>
<h2 id="事务到底是隔离的还是不隔离的？"><a href="#事务到底是隔离的还是不隔离的？" class="headerlink" title="事务到底是隔离的还是不隔离的？"></a>事务到底是隔离的还是不隔离的？</h2><p>在 MySQL 里，有两个“视图”的概念：</p>
<p>一个是 <strong>view</strong>。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</p>
<p>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 <code>consistent read view</code>，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。<strong>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</strong></p>
<p><a href="#事务隔离：为什么你改了我还看不见？">参考章节</a></p>
<h3 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h3><p>在<strong>可重复读</strong>隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是<strong>基于整库</strong>的。</p>
<p>InnoDB 里面每个事务有一个<strong>唯一</strong>的事务 ID，叫作 <code>transaction id</code>。它是在事务开始的时候向 InnoDB 的事务系统申请的，是<strong>按申请顺序严格递增</strong>的。</p>
<p>而每行数据也都是有多个版本的。<strong>每次</strong>事务更新数据的时候，都会生成一个<strong>新的数据版本</strong>，并且把 <code>transaction id</code> 赋值给这个数据版本的事务 ID，记为 <code>row trx_id</code>。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p><strong>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</strong></p>
<p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p>
<p>数组里面事务 ID 的最小值记为<strong>低水位</strong>，当前系统里面已经创建过的事务 ID 的最大值加 1 记为<strong>高水位</strong>。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>数据版本的可见性规则，就是<strong>基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</strong></p>
<img src="/article/53105/%E6%95%B0%E6%8D%AE%E7%89%88%E6%9C%AC%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99.png" class title="数据版本可见性规则">
<p>对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>
<ol>
<li><p>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</p>
</li>
<li><p>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</p>
</li>
<li><p>如果落在黄色部分，那就包括两种情况</p>
<ol>
<li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li>
<li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
<p>(高水位的定义是事务创建时所有未提交的事务ID的最大值+1是高水位，但并不是小于高水位大于低水位的事务就都没有提交。所以row trx_id 在这个范围内却不在数组中就是已经提交了的可见)</p>
</li>
</ol>
<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>
<ol>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，而且是在视图创建前提交的，可见。</li>
</ol>
<h3 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h3><p>更新数据都是先读后写的，而这个读，只能读当前的值，称为“<strong>当前读</strong>”（current read）。</p>
<p>除了 update 语句外，select 语句如果加锁，也是当前读。（<code>lock in share mode</code> 或 <code>for update</code>）</p>
<hr>
<p><strong>问题：事务的可重复读的能力是怎么实现的？</strong></p>
<blockquote>
<p>可重复读的<strong>核心就是一致性读</strong>（consistent read）；</p>
<p>而事务更新数据的时候，只能用<strong>当前读</strong>。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ol>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ol>
</blockquote>
<blockquote>
<p>这里需要说明一下，“<code>start transaction with consistent snapshot</code>; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在<strong>读提交</strong>隔离级别下，这个用法就没意义了，等效于普通的 <code>start transaction</code>。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>实习,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-梦开始的地方</title>
    <url>/article/23540.html</url>
    <content><![CDATA[<h2 id="Linux-梦开始的地方"><a href="#Linux-梦开始的地方" class="headerlink" title="Linux-梦开始的地方"></a>Linux-梦开始的地方</h2><p>Linux，全称GNU/Linux，是一种免费使用和自由传播的<a href="https://baike.baidu.com/item/类UNIX/9032872">类UNIX</a>操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到<a href="https://baike.baidu.com/item/Minix/7106045">Minix</a>和Unix思想的启发，是一个基于<a href="https://baike.baidu.com/item/POSIX">POSIX</a>的多用户、<a href="https://baike.baidu.com/item/多任务/1011764">多任务</a>、支持<a href="https://baike.baidu.com/item/多线程/1190404">多线程</a>和多<a href="https://baike.baidu.com/item/CPU">CPU</a>的操作系统。它能运行主要的<a href="https://baike.baidu.com/item/Unix/219943">Unix</a>工具软件、应用程序和网络协议。</p>
<p><a href="https://www.kernel.org">Linux源码</a></p>
<h3 id="网络连接三种模式"><a href="#网络连接三种模式" class="headerlink" title="网络连接三种模式"></a>网络连接三种模式</h3><img src="/article/23540/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png" class title="网络连接三种模式">
<h4 id="Bridged"><a href="#Bridged" class="headerlink" title="Bridged"></a><strong>Bridged</strong></h4><p><strong>桥接模式</strong></p>
<p>桥接模式是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。</p>
<blockquote>
<p>类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中。桥接模式通过虚拟网桥将主机上的网卡与虚拟交换机Vmnet0连接在一起，虚拟机上的虚拟网卡都连接在虚拟交换机Vmnet0上，所以桥接模式的虚拟机IP必须与主机在同一网段且子网掩码、网关与DNS也要与主机网卡一致。</p>
</blockquote>
<p>在桥接模式下，虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问局域网内的任何一台主机，局域网内的任何一台主机也可以访问它。</p>
<p>应用场景：当前虚拟机为整个局域网的用户提供访问服务，其他局域网用户都能访问到当前主机。</p>
<h4 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h4><p><strong>地址转换模式</strong></p>
<p>在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。</p>
<blockquote>
<p>在连接Vmnet8虚拟交换机时，虚拟机会将虚拟NAT设备以及虚拟DHCP服务器连接到Vmnet8虚拟交换机上，同时也会将主机上的虚拟网卡VMWare Network Adapter Vmnet8连接到Vmnet8虚拟交换机上。</p>
<p>网卡VMWare Network Adapter Vmnet8只是作为主机与虚拟机通信的接口，虚拟机并不是依靠网卡VMWare Network Adapter Vmnet8来联网的。</p>
</blockquote>
<p>虚拟机借助NAT功能，<strong>通过宿主机器所在的网络来访问公网</strong>，使用NAT模式可以实现虚拟机访问互联网。</p>
<p>NAT模式下虚拟机的TCP/IP配置信息是由VMnet8虚拟网络的DHCP服务器提供的，<strong>局域网中的其他真实主机将无法访问本虚拟机</strong>，但该主机上其他同一个网段的虚拟机可以访问。</p>
<p>可以理解成我们自己家里的宽带，你可以访问百度，但是其他人无法访问到你。应用场景：只是通过虚拟机上网，其他用户不能访问你的虚拟机。</p>
<h4 id="Host-only"><a href="#Host-only" class="headerlink" title="Host-only"></a>Host-only</h4><p><strong>主机模式</strong></p>
<p>Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只能与主机相互通讯。</p>
<blockquote>
<p>Host-Only模式通过主机的虚拟网卡VMWare Network Adapter VMnet1来连接虚拟交换机VMnet1，从而达到与虚拟机通信的目的。如果想要在Host-Only模式下联网，可以将能联网的主机网卡共享给VMWare Network Adapter VMnet1，以实现虚拟机联网。</p>
<p>Host-Only模式的配置过程和NAT模式基本相同。</p>
</blockquote>
<h2 id="Linux基本内容"><a href="#Linux基本内容" class="headerlink" title="Linux基本内容"></a>Linux基本内容</h2><ol>
<li><p>linux的文件系统是采用层级式的树状目录结构，在此结构的最上层是根目录<code>&quot;/&quot;</code>，然后再此目录下再创建其他的目录。</p>
</li>
<li><p>在linux的世界里，一切皆文件。cpu、磁盘、硬盘等等都会当成文件对待。</p>
</li>
<li>linux的目录是规定好的，和windows可以随意设置盘符名称不一样，而且不同的目录的作用也各有安排，不可更改。</li>
<li>学习linux一定要熟记各个目录。</li>
</ol>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ol>
<li><p><code>/</code> 根目录</p>
</li>
<li><p><code>/bin</code> 是binary的缩写，这个目录存放最经常使用的命令。所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。</p>
<ol>
<li><code>/usr/bin</code> 是系统安装时自带的一些可执行程序,即系统程序。</li>
<li><code>/usr/local/bin</code> 是用户自行编译安装时默认的可执行程序的安装位置。</li>
</ol>
</li>
<li><p><code>/sbin</code> s就是super user的意思，(<code>/usr/sbin</code>,<code>/usr/local/sbin</code>)这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><code>/home</code> 存放普通用户的主目录，在Linux中每个用户都有自己的目录，一般该里面的子目录名都以用户的账号命名。</p>
</li>
<li><p><code>/root</code> 该目录是系统管理员，也称为超级权限者的用户主目录。</p>
</li>
<li><p><code>/lib</code> 系统开机所需要的最基本的动态链接共享库，其作用类似Windows的dll文件，几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><code>/ect</code> 这个目录里面是所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><code>/usr</code> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与Windows下的program files目录。</p>
<ol>
<li><code>/usr/local</code> 这是给主机额外安装软件所安装的目录，是软件安装包的目标安装目录，一般通过编译源码的方式安装软件。</li>
</ol>
</li>
<li><p><code>/opt</code> 这是给主机额外安装软件的安装包源码所摆放的位置，例如安装Oracle数据库的源码就一般约定俗成放到这个目录下，默认为空。</p>
</li>
<li><p><code>/var</code> 这个目录中存放着在不断扩充的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</p>
<hr>
</li>
<li><p><code>/dev</code> 该目录类似Windows的设备管理器，把所有的硬件（例如磁盘、cpu、串口等）用文件的形式存储起来。</p>
</li>
<li><p><code>/mnt</code> 系统提供该目录是为了让用户临时挂载别的文件操作系统，我们可以将外部的存储挂载到 <code>/mnt</code> 上，然后进入这个目录就可以看到外部的存储内容了。注：vmtools可以共享windows的文件就在此目录下。</p>
</li>
<li><p><code>/tmp</code> 这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><code>/selinux</code> 该目录是security-enhanced linux的缩写，是一种安全子系统，类似windows上的360，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置。</p>
</li>
<li><p><code>/proc</code> <strong>[别动]</strong>这个目录是一个虚拟的目录，它是系统内存的映射 ，访问这个目录可以获取系统信息。</p>
</li>
<li><p><code>/srv</code> <strong>[别动]</strong>这是service的缩写，该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><code>/sys</code> <strong>[别动]</strong>这是Linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs。</p>
</li>
<li><p><code>/boot</code> 存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</p>
</li>
<li><p><code>/lost+found</code> 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><code>/media</code> Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别到的设备挂载到这个目录下。</p>
</li>
</ol>
<h3 id="Vi与Vim"><a href="#Vi与Vim" class="headerlink" title="Vi与Vim"></a>Vi与Vim</h3><p>Linux系统会内置<strong>vi文本编辑器</strong>。</p>
<p><strong>vim</strong>具有程序编辑的能力，可以看成是vi的增强版本，可以主动地以字体颜色辨别语法的正确性，方便程序设计，同时具备代码补全、编译和错误跳转等功能，因此被广泛程序员使用。</p>
<h4 id="常用三种模式"><a href="#常用三种模式" class="headerlink" title="常用三种模式"></a>常用三种模式</h4><img src="/article/23540/%E5%B8%B8%E7%94%A8%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png" class title="常用三种模式">
<img src="/article/23540/%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2.png" class title="Snipaste_2022-02-20_12-32-53">
<img src="/article/23540/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%9B%BE.png" class title="Snipaste_2022-02-20_15-32-10">
<h4 id="正常模式下的快捷键"><a href="#正常模式下的快捷键" class="headerlink" title="正常模式下的快捷键"></a>正常模式下的快捷键</h4><ol>
<li><p>拷贝当前行 <code>yy</code> ；</p>
</li>
<li><p>拷贝n行 <code>nyy</code> ；注意小键盘数字不行，用自带的数字。</p>
</li>
<li><p>粘贴 <code>p</code> ；</p>
</li>
<li><p>删除这一行 <code>dd</code> ;</p>
</li>
<li><p>删除n行 <code>ndd</code> ；</p>
</li>
<li><p>跳转到第一行 <code>gg</code> ；</p>
</li>
<li><p>跳转到末尾行 <code>G</code> ；</p>
</li>
<li><p>撤销刚才的操作 <code>u</code> ；</p>
</li>
<li><p>跳转到第i行 <code>i+shift+g</code> 。</p>
</li>
</ol>
<h4 id="命令模式下的快捷键"><a href="#命令模式下的快捷键" class="headerlink" title="命令模式下的快捷键"></a>命令模式下的快捷键</h4><ol>
<li>在命令模式下查找关键单词<ol>
<li>输入<code>/</code>name ，name是你要查找的单词名</li>
<li>按<code>n</code>查找下一个</li>
</ol>
</li>
<li>在命令模式下设置行号 <code>:set nu</code> ；</li>
<li>在命令模式下删除行号 <code>:set nonu</code> 。</li>
</ol>
<h3 id="Linux开机、重启和用户登录注销"><a href="#Linux开机、重启和用户登录注销" class="headerlink" title="Linux开机、重启和用户登录注销"></a>Linux开机、重启和用户登录注销</h3><h4 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h4><p><strong>注意，不管是重启系统还是关机，最好都执行一次sync指令，再重启或关机</strong></p>
<ol>
<li><p><code>shutdown -h now</code> #现在立即关机,h代表halt关机的意思</p>
</li>
<li><p><code>shutdown -h 1</code> #1分钟后关机</p>
</li>
<li><p><code>shutdown -h</code> #默认1分钟后关机</p>
</li>
<li><p><code>shutdown -r now</code> #现在立即重启,r代表reboot</p>
</li>
<li><p><code>halt</code> #关机,作用和上面指令一样</p>
</li>
<li><p><code>reboot</code> #重启计算机</p>
</li>
<li><p><code>sync</code> #把内存数据同步到磁盘</p>
</li>
</ol>
<h4 id="用户注销"><a href="#用户注销" class="headerlink" title="用户注销"></a>用户注销</h4><ol>
<li>登录时尽量少用root账号登录，可以利用普通用户登录，登录后使用<code>su - 用户名</code> ，来切换系统管理员程序；</li>
<li>在提示符下输入<code>logout</code>即可注销用户。<ol>
<li><code>logout</code> 在图形运行级别无效，在运行<a href="#指令运行级别">级别3</a>下有效。</li>
</ol>
</li>
</ol>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="创建删除设置用户"><a href="#创建删除设置用户" class="headerlink" title="创建删除设置用户"></a>创建删除设置用户</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个想要使用系统资源的用户，都必须首先向系统管理员root申请一个账号，然后再以这个账号的身份进入系统。</p>
<p>添加用户默认该用户的家目录在 <code>/home/username</code> ，username是用户的名称，也可以指定目录，但没必要.</p>
<ol>
<li><code>useradd milan</code> #添加milan这个用户</li>
<li><code>useradd -d /home/test milan</code> #添加milan这个用户,但用户文件夹名不是默认的milan，而是指定为 <code>test</code></li>
<li><code>passwd milan</code> #更改milan这个用户的密码</li>
<li><code>userdel milan</code> #删除用户milan，但是保留home家目录</li>
<li><code>userdel -r milan</code> #删除用户milan的所有信息，包括家目录</li>
</ol>
<p><strong>pwd ：该命令显示当前所在目录全程</strong></p>
<h3 id="查询切换用户"><a href="#查询切换用户" class="headerlink" title="查询切换用户"></a>查询切换用户</h3><ol>
<li>查询基本语法 <code>id 用户名</code> ：当不存在改用户时，返回无此用户；</li>
<li>切换基本语法 <code>su 用户名</code> ； <code>exit</code> 返回原用户；从权限高的用户切换到权限低的用户，不需要密码；反之需要。</li>
<li>查看当前登录用户语法 <code>whoami</code> 或者 <code>who am i</code> 。值得注意的是 <code>whoami</code> 返回当前使用的用户， <code>who am i</code> 返回第一次登录服务器的信息。</li>
<li></li>
</ol>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>用户组，类似于角色，系统可以对有共性的多个用户进行统一的管理。</p>
<ol>
<li><p>增加组 <code>groupadd 组名</code>；</p>
</li>
<li><p>删除组 <code>groupdel 组名</code>；</p>
</li>
<li><p>增加用户是直接加组 `useradd -g 用户组 用户名；</p>
</li>
<li><p>修改用户的组 <code>usermod -g 用户组 用户名</code>。</p>
</li>
</ol>
<h3 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h3><ol>
<li><p><code>/etc/passwd</code> </p>
<p>用户user的配置文件，记录用户的各种信息</p>
<p>每行的含义： 用户名：口令：用户表示号：组表示号：注释性描述：主目录：登录Shell</p>
</li>
<li><p><code>/etc/shadow</code></p>
<p>口令的配置文件</p>
<p>每行的含义： 登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p>
</li>
<li><p><code>etc/group</code></p>
<p>组的配置文件，记录Linux包含的组的信息</p>
<p>每行的含义：组名：口令：组标示号：组内用户列表</p>
</li>
</ol>
<h2 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h2><h3 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h3><p><strong>运行级别一共有7种</strong></p>
<ol>
<li>0：关机</li>
<li>1：单用户，root权限，可以帮助找回丢失的密码，用于系统维护，禁止远程登录</li>
<li>2：多用户状态没有网络服务</li>
<li>3：多用户状态有网络服务，登录后进入控制台命令行模式</li>
<li>4：系统未使用保留给用户</li>
<li>5：图形界面</li>
<li>6：系统重启</li>
</ol>
<p>常用运行级别是3和5，也可以指定默认运行级别。</p>
<p><strong>切换运行级别</strong> <code>init [运行级别]</code></p>
<p><strong>修改默认运行级别</strong></p>
<ol>
<li>在CentOs7之前，需要在<code>/etc/inittab</code>中修改；</li>
<li>在CentOs之后<ol>
<li>查看当前运行级别 <code>runlevel</code>；</li>
<li>查看当前默认运行级别 <code>systemctl get-default</code>；</li>
<li>设置默认运行级别<code>systemctl set-default multiuser.target</code>。</li>
</ol>
</li>
</ol>
<h3 id="找回root密码"><a href="#找回root密码" class="headerlink" title="找回root密码"></a>找回root密码</h3><p>进入到单用户模式，就可以修改root密码</p>
<ol>
<li>首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面；</li>
<li>进入编辑界面，使用键盘上的上下键把光标往下移动，找到以<code>Linux16</code>开头内容所在的行数，在行的最后面输入：<code>init=/bin/sh</code>；</li>
<li>接着，输入完成后，直接按快捷键：<code>Ctrl+x</code> 进入单用户模式；</li>
<li>接着，在光标闪烁的位置中输入：<code>mount -o remount,rw /</code>（注意：各个单词间有空格），完成后按键盘的回车键（Enter）；</li>
<li>在新的一行最后面输入：<code>passwd</code>， 完成后按键盘的回车键（Enter）。输入密码，<strong>然后再次确认密码即</strong>可(密码长度最好8位以上,但不是必须的), 密码修改成功后，会显示passwd…..的样式，说明密码修改成功；</li>
<li>接着，在鼠标闪烁的位置中（最后一行中）输入：<code>touch /.autorelabel</code>（注意：touch与 /后面有一个空格），完成后按键盘的回车键（Enter）；</li>
<li>继续在光标闪烁的位置中，输入：<code>exec /sbin/init</code>，完成后按键盘的回车键（Enter）,等待系统自动修改密码(这个过程时间可能有点长)，完成后，系统会自动重启, 新的密码生效了。</li>
</ol>
<h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><ol>
<li><p><code>man</code> 命令或配置信息</p>
<p>基本语法： man [命令或者配置文件]</p>
<p>(输入<code>q</code>退出)</p>
</li>
<li><p><code>help</code> 命令</p>
<p>基本语法： help [命令]</p>
</li>
</ol>
<h3 id="文件操作指令"><a href="#文件操作指令" class="headerlink" title="文件操作指令"></a>文件操作指令</h3><ol>
<li>文件目录<ol>
<li><code>pwd</code> 显示当前工作目录的绝对路径；</li>
<li><code>ls -a</code> 或者 <code>ls -l</code> ：-a显示当前目录的所有文件和目录，<strong>包括隐藏的</strong>；-l表示以列表的方式显示信息；注意可以组合；</li>
<li><code>cd [参数]</code> ：切换目录，后面可以是绝对路径或者相对路径，如果是 <code>/</code> 开头，表示绝对路径；否则为相对路径；<ol>
<li><code>cd ~ 或者 cd</code> ：回到自己的家目录；</li>
<li><code>cd ..</code> ：回到当前目录的上一级目录。</li>
</ol>
</li>
</ol>
</li>
<li>文件创建删除<ol>
<li><code>mkdir 目录名</code> ：创建目录，默认创建一级目录，如果要创建多级，要加 <code>-p</code>；</li>
<li><code>rmdir 目录名</code> ：默认删除空目录，如果目录下有内容无法删除；</li>
<li><code>rm -rf 目录名</code>：递归强制删除，可删除有内容的目录；</li>
<li><code>touch 文件名</code>：创建一个空文件。</li>
</ol>
</li>
<li>文件拷贝删除移动查看<ol>
<li><code>cp 文件 拷贝路径</code> ：拷贝文件到指定路径；</li>
<li><code>cp -r 文件夹 拷贝路径</code> ：递归拷贝文件夹到指定路径；</li>
<li><code>\cp</code> ：强制覆盖不提示拷贝；</li>
<li><code>rm 文件或目录</code> ：删除文件；</li>
<li><code>rm -r 文件夹</code> ：递归删除整个文件夹；</li>
<li><code>rm -f</code> ：强制删除不显示；</li>
<li><code>mv src tar</code> ：移动文件或者重命名文件；</li>
<li><code>cat 文件</code> ：查看文件内容；<ol>
<li><code>cat -n 文件</code> 显示行号；</li>
</ol>
</li>
<li><code>more 文件</code> ：以全屏按页显示文本文件内容，（more指令是一个基于VI编辑器的文本过滤器，以全屏的方式，按页显示文本文件的内容）；<ol>
<li><code>q</code> 退出；</li>
<li><code>=</code> 输出当前行的行号；</li>
<li><code>:f</code> 输出文件名和当前行的行号；</li>
</ol>
</li>
<li><code>less 文件</code>：用来分屏查看文件内容，和 more 功能类似，但比more功能更强大（支持各种显示终端，less指令在西安市文件内容时，并不是一次将整个文件加载后才显示，而是根据需要加载需要的内容，对于显示大型文件具有较高的效率），<code>q</code>退出。</li>
<li><code>echo</code> ：输出内容到控制台；<ol>
<li><code>echo $HOSTNAME</code> ：输出主机名；</li>
<li><code>echo $PATH</code> ：输出环境变量；</li>
</ol>
</li>
<li><code>head [可选 -n 行数] 文件</code>：用于显示文件的开头部分内容，默认情况显示前10行；</li>
<li><code>tail [可选 -n 行数] 文件</code>：用于显示文件的尾部内容，默认显示最后10行；<ol>
<li><code>tail -f 文件名</code> ：实时追踪文档的所有更新，退出按 <code>ctrl+C</code> ，适用于网络抓包、服务器网络监视；</li>
</ol>
</li>
<li><code>&gt;</code> 输出重定向（覆盖原文件）和 <code>&gt;&gt;</code> 追加；</li>
<li><code>ln</code> ：表示link的意思，软链接，也称为符号链接，类似Windows里面的快捷方式，主要存放了链接其他文件的路径；<ol>
<li><code>ln -s [原文件目录] [软连接名]</code> 给原文件创建一个软连接；</li>
<li>删除时不能加 <code>/</code> ,把软连接当成一个文件，而不是目录；</li>
</ol>
</li>
<li><code>history</code> ：查看已经执行过的历史命令；<ol>
<li><code>history n</code> 显示最近使用过的n个指令；</li>
<li><code>history !n</code> 执行历史编号为5的指令。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="时间日期指令"><a href="#时间日期指令" class="headerlink" title="时间日期指令"></a>时间日期指令</h3><ol>
<li><code>date</code> ：显示当前日期；<ol>
<li><code>date &quot;+%Y-%m-%d&quot;</code> 显示当前年月日；</li>
<li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 显示当前年月日时分秒；</li>
<li><code>data -s &quot;时间&quot;</code> 设置系统时间；</li>
</ol>
</li>
<li><code>cal</code> ：显示本月月历；<ol>
<li><code>cal 2022</code> ：显示2022年的所有月历。</li>
</ol>
</li>
</ol>
<h3 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h3><ol>
<li><code>find [搜索范围] [选项] [参数]</code> ：从指定目录向下递归的遍历子目录，将满足的文件或目录显示在终端；<ol>
<li>选项<code>[-name]</code> 按照指定文件名查找模式查找文件；</li>
<li>选项<code>[-usre]</code> 查找属于指定用户名所有文件；</li>
<li>选项<code>[-size [+n 大于n][-n 小于n][n 等于n]]</code> 按照指定的文件大小查找文件；</li>
</ol>
</li>
<li><code>locate</code> ：可以利用数据库快速实现文件搜索，但有的linux没有安装，先安装 yum install mlocate ，然后再使用之前更新数据库 <code>updatedb</code> ，才能使用locate；</li>
<li><code>which 指令</code> ：可以查看某个指令在哪个目录下；</li>
<li><code>grep</code> ：过滤查找，通常和管道符号 <code>|</code> 一起使用；<ol>
<li><code>grep -n &quot;内容&quot; 文件</code> -n表示显示匹配的行号；</li>
<li><code>grep -i &quot;内容&quot; 文件</code> -i表示忽略字母大小写；</li>
</ol>
</li>
</ol>
<h3 id="压缩和解压指令"><a href="#压缩和解压指令" class="headerlink" title="压缩和解压指令"></a>压缩和解压指令</h3><ol>
<li><code>gzip</code> 和 <code>gunzip</code> ：对<strong>单个文件</strong>进行压缩和解压，格式是 <em>.gz</em>；</li>
<li><code>zip</code> 和 <code>unzip</code> ：对<strong>文件夹</strong>压缩和解压，格式是 <em>.zip</em> ；<ol>
<li><code>zip -r 压缩完成后文件名.zip 文件夹或文件</code> 压缩文件夹以及其里面的文件和子文件夹成为压缩完成后文件名.zip；</li>
<li><code>unzip -d 解压后的文件或文件夹目录 压缩文件或文件夹目录</code>：-d表示指定的解压目录；</li>
</ol>
</li>
<li><code>tar [选项] xxx.tar.gz 打包的内容</code> ：既可以压缩，也可以解压，打包得到的文件格式是<em>.tar.gz</em>；<ol>
<li><code>tar -zcvf xxx.tar.gz</code> 打包内容 ：将内容进行打包；</li>
<li><code>tar -zxvf xxx.tar.gz -C 解压目标目录</code> ：将压缩文件解压到特定位置；</li>
<li>选项<code>[-c]</code> 产生 <em>.tar</em> 打包文件；</li>
<li>选项<code>[-v]</code> 显示详细信息；</li>
<li>选项<code>[-f]</code> 指定压缩后文件名；</li>
<li>选项<code>[-z]</code> 打包同时压缩；</li>
<li>选项<code>[-x]</code> 解包 <em>.tar</em> 文件；</li>
</ol>
</li>
</ol>
<h2 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h2><p><strong>Linux每个用户都必须属于一个组</strong>。</p>
<p><strong>Linux每个文件都有所有者、所在组、其他组这三个概念。</strong></p>
<p><strong>修改权限一般要 root 权限</strong></p>
<h3 id="文件和目录的所有者"><a href="#文件和目录的所有者" class="headerlink" title="文件和目录的所有者"></a>文件和目录的所有者</h3><ol>
<li><code>chown -R</code> ：change owner，修改所有者。-R表示递归修改；</li>
<li><code>chown [-R] 用户名 文件名</code> 修改文件所有者；</li>
<li><code>chown newnwner:newgroup 文件/目录</code> 改变所有者和所在组。</li>
</ol>
<h3 id="文件和目录的所在组"><a href="#文件和目录的所在组" class="headerlink" title="文件和目录的所在组"></a>文件和目录的所在组</h3><ol>
<li><code>chgrp -R</code> ：change group，修改所在组。-R表示递归修改；</li>
<li><code>chgrp [-R] newgroup 文件/目录</code> 改变所在组；</li>
</ol>
<p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组。</p>
<h3 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h3><ol>
<li><code>usermod -g 新组名 用户名</code> </li>
<li><code>usermod -d 目录名 用户名</code> 改变该用户登录的初始目录，用户需要有进入新目录的权限；</li>
</ol>
<h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>使用 <code>ls -l</code> 得出的信息，开头10个字符表示文件权限；</p>
<ol>
<li>第0位确定文件类型（ d,-,l,c,b ）<ol>
<li><code>d</code> 表示目录；</li>
<li><code>-</code> 表示普通文件；</li>
<li><code>l</code> 表示链接；</li>
<li><code>c</code> 表示字符设备文件，如鼠标、键盘等；</li>
<li><code>b</code> 表示块设备，比如硬盘等，blog；</li>
</ol>
</li>
<li>第1-3位确定所有者所拥有的权限—User；<ol>
<li>rwx 三种权限，对于文件和目录的作用分别不用；</li>
</ol>
</li>
<li>第4-6位确定所在组的权限—Group；</li>
<li>第7-9位确定其他用户所拥有的权限—Other；</li>
<li>其他说明：<ol>
<li>第10位： 文件：硬连接数 ；目录：子目录数；</li>
<li>第11位： 用户；</li>
<li>第12位： 组；</li>
<li>第13位： 文件大小（字节），如果是文件夹，显示4096字节；</li>
<li>第14位： 最后修改日期；</li>
<li>第15位： 文件名。 </li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:center">文件</th>
<th style="text-align:center">目录</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">读取、查看</td>
<td style="text-align:center">读取、<code>ls</code>查看</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">修改（但不代表可以删除，删除的前提条件是对该文件所在的目录有写权限）</td>
<td style="text-align:center">修改、目录内创建、删除、重命名目录</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">执行</td>
<td style="text-align:center">可以进入该目录</td>
</tr>
</tbody>
</table>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p><code>chmod</code> ：修改文件或目录的文件；</p>
<ol>
<li><p><code>chmod [[u 所有者] [g 所有组] [o 其他人] [a 所有人]][[+ 增加权限] [- 减少权限] [= 设置权限]] 文件/目录</code></p>
</li>
<li><p><code>chmod [[u 的权限求和] [g 的权限求和] [a 的权限求和]] 文件/目录</code> : r = 4 、r = 2、 x = 1;</p>
</li>
</ol>
<h2 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h2><p>任务调度：是指系统在某个时间执行的特定的命令或程序。</p>
<p>分类：</p>
<ol>
<li>系统工作</li>
<li>个别用户工作</li>
</ol>
<h3 id="crontab定时任务"><a href="#crontab定时任务" class="headerlink" title="crontab定时任务"></a>crontab定时任务</h3><p><code>crontab [选项]</code></p>
<ul>
<li><code>-e</code>  编辑crontab定时任务；</li>
<li><code>-l</code>  查询crontab定时任务；</li>
<li><code>-r</code>  删除当前用户所有的crontab任务。</li>
</ul>
<p><code>service crond restart</code> 重启任务调度</p>
<p>定时参数说明</p>
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第一个”*”</td>
<td style="text-align:center">一小时当中的第几分钟</td>
<td style="text-align:center">0～59</td>
</tr>
<tr>
<td style="text-align:center">第二个”*”</td>
<td style="text-align:center">一天当中的第几小时</td>
<td style="text-align:center">0～23</td>
</tr>
<tr>
<td style="text-align:center">第三个”*”</td>
<td style="text-align:center">一个月中的第几天</td>
<td style="text-align:center">1～31</td>
</tr>
<tr>
<td style="text-align:center">第四个”*”</td>
<td style="text-align:center">一年当中第几月</td>
<td style="text-align:center">1～12</td>
</tr>
<tr>
<td style="text-align:center">第五个”*”</td>
<td style="text-align:center">一周当中的星期几</td>
<td style="text-align:center">0～7（0和7都代表周日）</td>
</tr>
<tr>
<td style="text-align:center">‘</td>
<td style="text-align:center">代表不连续的时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">代表连续的时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">*/n</td>
<td style="text-align:center">代表每个多久执行一次</td>
</tr>
</tbody>
</table>
<h3 id="at-定时任务"><a href="#at-定时任务" class="headerlink" title="at 定时任务"></a>at 定时任务</h3><p>crond是定时的，反复执行的；at命令是一次性定时计划任务。</p>
<ol>
<li><code>at</code>命令时一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。</li>
<li>默认情况下，<strong>atd</strong>守护进程每60s检查作业队列，有作业时，会检查作业运行时间，如果运行时间与当前时间匹配，则运行此作业。</li>
<li>at命令是一次性定时计划任务，执行完一个任务后，不再执行此任务。</li>
<li>在使用at命令的时候，一定要保证<strong>atd</strong>进程的启动。</li>
</ol>
<p><code>Ctrl + D</code> 连按两次结束at命令的输入；</p>
<p><code>atq</code> 查看设置的定时任务；</p>
<p><code>atrm +编号</code> 删除该编号的定时任务;</p>
<p><code>at [选项] [时间]</code></p>
<ol>
<li><code>-m</code> 当指定的任务被完成后，将给用户发送于邮件，即使没有标准输出；</li>
<li><code>-I</code> atq的别名</li>
<li><code>-d</code> atrm的别名</li>
<li><code>-v</code> 显示任务将被执行的时间</li>
<li><code>-V</code> 显示版本信息</li>
<li><code>-c</code> 打印任务的内容到标准输出</li>
<li><code>-q &lt;队列&gt;</code> 使用指定的队列</li>
<li><code>-f &lt;文件&gt;</code> 从指定文件读入任务而不是从标准输入读入</li>
<li><code>-t &lt;时间参数&gt;</code> 以时间参数的形式提交要运行的任务</li>
</ol>
<p>时间指定方法：</p>
<ol>
<li>接受在当天的 hh:mm （小时：分钟）式的时间指定。加入该时间已过去，那么就放在第二天执行。</li>
<li>midnighr（深夜） noon（中午） teatime（下午四点）</li>
<li>采用12小时制，在时间后面加上AM或PM</li>
<li>指定命令执行的具体日期  指定格式为 (month day)(月日) 或 mm/dd/yy(月/日/年) 或 dd.mm.yy (日.月.年)</li>
<li>使用相对计时法  指定格式为： (now + count time-units) now是当前时间，time-units是时间单位（minutes分钟 hours小时 days天 weeks星期），count是时间的数量</li>
<li>直接使用today（今天） tomorrow（明天）</li>
</ol>
<h2 id="Linux-磁盘分区和挂载"><a href="#Linux-磁盘分区和挂载" class="headerlink" title="Linux 磁盘分区和挂载"></a>Linux 磁盘分区和挂载</h2><h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h3><p>Linux无论有几个分区，分给哪一个目录来使用，他归根结底就<strong>只有一个根目录</strong>，一个<strong>独立且唯一的文件结构</strong>，Linux中每个分区都是用来组成整个文件系统的一部分。</p>
<p>Linux采用了一种叫“<strong>载入</strong>”的处理方式，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来，这时要载入的一个分区将使它的存储空间在一个目录下获得。</p>
<h3 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a><strong>硬盘说明</strong></h3><ol>
<li>linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘；</li>
<li>对于<strong>IDE硬盘</strong>，驱动器标识符为“hdx~”,其中“hd”表明分区所在设别的类型，这里是指IDE硬盘。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），“~”代表分区，前四个分区用数字1～4表示，他们是主分区或扩展分区，从5开始就是逻辑分区。</li>
<li>对于SCSI硬盘表示为“sdx~” ,SCSI硬盘是用“sd”来表示分区所在设备类型，其余则和IDE硬盘的表示方法一样。</li>
</ol>
<p><code>lsblk</code> ： 查看所有设备的挂载情况</p>
<p><code>lsblk -f</code> ： 显示的UUID是分区的40位的唯一标识符</p>
<p><code>fdisk /dev/sdx</code> ：分区命令</p>
<p><code>mkfs -t ext4 /dev/sdb~</code> 格式化磁盘，ext4是分区类型</p>
<p><code>mount 设备名称 挂载目录</code> 将一个分区与一个目录联系起来</p>
<p><code>umount 设备名称/挂载目录</code> 取消一个分区与一个目录的联系</p>
<p>修改<code>/etc/fstab</code>永久挂载，执行<code>mount -a</code> 即刻生效</p>
<h3 id="虚拟机添加硬盘并连接分区"><a href="#虚拟机添加硬盘并连接分区" class="headerlink" title="虚拟机添加硬盘并连接分区"></a>虚拟机添加硬盘并连接分区</h3><ol>
<li><p>虚拟机添加硬盘</p>
</li>
<li><p>分区</p>
<p><code>fdisk /dev/sdb</code></p>
<p><code>m</code> 显示命令列表</p>
<p><code>p</code> 显示磁盘分区</p>
<p><code>n</code> 新增分区</p>
<p><code>d</code> 删除分区</p>
<p><code>w</code> 写入并退出</p>
<ol>
<li>开始分区后输入n，新增分区</li>
<li>然后选择p，分区类型为主分区</li>
<li>两次回车默认剩余全部空间</li>
<li>最后输入w，写入分区并退出，若不保存退出输入q</li>
</ol>
</li>
<li><p><code>mkfs -t ext4 /dev/sdb1</code> 格式化磁盘，ext4是分区类型</p>
</li>
<li><p><code>mount /dev/sdb1 /newdisk</code> 将一个分区与一个目录联系起来（用命令行挂载，重启失效）</p>
</li>
<li><p>修改<code>/etc/fstab</code>永久挂载</p>
<p><code>/dev/sdb1 /newdisk ext4 defaults 0 0</code></p>
</li>
</ol>
<p>​    执行<code>mount -a</code> 即刻生效</p>
<h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><ol>
<li><p><code>df -h</code> 查询系统整体磁盘使用情况</p>
</li>
<li><p><code>du [选项] 目录</code> 查询指定目录的磁盘占用情况</p>
<p><code>-s</code> 指定目录占用大小汇总</p>
<p><code>-h</code> 带计量单位</p>
<p><code>-a</code> 含文件</p>
<p><code>--max-depth=1</code> 子目录深度</p>
<p><code>-c</code> 列出明细的同时，增加汇总值</p>
</li>
<li><p><code>tree 目录</code> 以树状结构得到显示目录结构</p>
</li>
</ol>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p><code>ping 目的主机ip</code> 测试当前服务器是否可以连接目的主机</p>
<h3 id="Linux网络环境配置"><a href="#Linux网络环境配置" class="headerlink" title="Linux网络环境配置"></a>Linux网络环境配置</h3><p><strong>指定ip</strong></p>
<p>直接修改配置文件来指定IP，并可以连接到外网</p>
<p>编辑 <code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<blockquote>
<p>DEVICE=enth0  #接口名（设备网卡）</p>
<p>HWADDR=xx:xx:xx:xx:xx:xx   #MAC地址</p>
<p>TYPE=Ethernet   #网络类型（通常是Ethernet）</p>
<p>UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   #碎解ID</p>
<p>ONBOOT=yes    #系统启动时网络接口是否有效</p>
<p>BOOTPROTO=static   #IP的配置方法[none(引导时不使用协议)|static(静态分配IP)|bootp(BOOTP协议)|dhcp(DHCP协议)]</p>
<p>IPADDR=xxx.xxx.xxx.xxx   #ip地址</p>
<p>GATEWAY=xxx.xxx.xxx.xxx   #网关</p>
<p>DNSI=xxx.xxx.xxx.xxx   #域名解析器</p>
</blockquote>
<p>重启网络服务或者重启系统生效</p>
<p><code>service network restart</code> 或 <code>reboot</code></p>
<h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><ol>
<li><p>修改主机名</p>
<p><code>hostname</code>  查看主机名</p>
<p>修改文件在<code>/etc/hostname</code> 中指定</p>
</li>
<li><p>设置主机映射</p>
<p>windows ： <code>C:\Windows\System32\drivers\etc\hosts</code> 文件指定</p>
<p>Linux ： <code>/etc/hosts</code> 文件指定</p>
</li>
</ol>
<p><strong>主机名解析机制</strong></p>
<p>Hosts：一个文本文件，用来记录IP和Hostname（主机名）的映射关系</p>
<p>DNS：域名解析系统，是互联网上作为域名和IP地址相互映射的一个分布式数据库</p>
<img src="/article/23540/image-20220327230200902.png" class title="image-20220327230200902">
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>在Linux中，每个执行的程序都称为一个进程，每个进程都分配一个ID号（pid，进程号）</p>
<p>每个进程都可能以两种方式存在，前台与后台。</p>
<p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，知道关机才结束。</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p><code>ps [选项]</code> 显示系统执行的进程</p>
<p><code>-a</code> 显示当前终端的所有进程信息</p>
<p><code>-u</code> 以用户的格式显示进程信息</p>
<p><code>-x</code> 显示后台进程运行的参数</p>
<blockquote>
<p><code>ps -aux</code></p>
<p>PID 进程识别号</p>
<p>TTY 终端机号</p>
<p>TIME 此进程所消耗CPU时间</p>
<p>CMD 正在执行的命令或进程名</p>
<p>%CPU 此进程占用CPU百分比</p>
<p>%MEM 此进程占用物理内存百分比</p>
<p>VSZ 此进程占用虚拟内存大小 KB</p>
<p>RSS 此进程占用物理内存大小 KB</p>
<p>STAT 此进程运行状态【S-休眠 r-正在运行 s-表示该进程是会话的先导进程 N-表示进程拥有比普通优先级更低的优先级 D-短期等待 Z-僵死进程 T-被跟踪或者被停止等待】</p>
<p>START 此进程执行开始时间</p>
<p>COMMAND 执行此进程的指令（过长会被截断）</p>
</blockquote>
<p><code>-e</code> 显示所有进程</p>
<p><code>-f</code> 全格式</p>
<blockquote>
<p><code>ps -ef</code></p>
<p>UID 用户ID</p>
<p>PID 进程ID</p>
<p>PPID 父进程ID</p>
<p>C CPU用于计算执行优先级的因子 </p>
<p>​    数值越大，表明进程时CPU密集型运算，执行优先级会降低</p>
<p>​    数值越小，表明进程时I/O密集型运算，执行优先级会提高</p>
<p>STIME 进程启动时间</p>
<p>TTY 完整的终端名称</p>
<p>TIME CPU时间</p>
<p>CMD 启动进程所用的命令和参数</p>
</blockquote>
<h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><ol>
<li><p><code>kill [选项] pid</code> 杀死某个进程</p>
<p><code>-9</code> 表示强迫进程立即停止</p>
</li>
<li><p><code>killall 进程名称</code> 杀死进程及其子进程</p>
<p>强制终止一个终端 <code>kill -9 bash 对应进程号</code></p>
</li>
</ol>
<h3 id="显示进程树"><a href="#显示进程树" class="headerlink" title="显示进程树"></a>显示进程树</h3><p><code>pstree [选项]</code> 更直观的查看进程信息</p>
<p><code>-p</code> 显示进程的PID</p>
<p><code>-u</code> 显示进程的所属用户</p>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>服务（service）本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，因此我们又称之为守护进程。  </p>
<p><strong>service 管理指令</strong></p>
<p><code>service 服务名 [start|stop|restart|reload|status]</code></p>
<p>service/systemctl</p>
<p>service 指令管理的服务在 <code>/etc/init.d</code> 查看</p>
<p><strong>查看service服务名</strong></p>
<ol>
<li>使用 setup -&gt; 系统服务 就可以看到全部setup</li>
<li><code>ls -l /etc/init.d</code></li>
</ol>
<p><strong>开机的流程说明</strong></p>
<p>开机 -&gt; BIOS -&gt; /boot -&gt; systemd进程1 -&gt; <a href="#指定运行级别运行级别">运行级别</a> -&gt; 运行级别对应的服务</p>
<ol>
<li><p><code>chkconfig</code> 给服务的各个运行级别设置启动/关闭</p>
<ol>
<li><code>chkconfig --list | grep xxx</code> ：查看过滤后的服务service</li>
<li><code>chkconfig --level 3 服务名 off</code> ：设置服务名的3级别自启动关闭</li>
</ol>
<p><code>chkconfig</code> 重新设置服务后自启动或者关闭，需要重启机器<code>reboot</code>生效</p>
</li>
<li><p><code>systemctl</code> ：管理服务指令</p>
<ol>
<li><code>service [start|stop|restart|reload|status] 服务名</code></li>
</ol>
<p>systemctl 指令管理的服务在 <code>usr/lib/systemd/system</code> 查看</p>
<ol start="2">
<li>systemctl设置服务自启动状态<ol>
<li><code>systemctl list-unit-files [|grep 服务名]</code> 查看服务开机启动状态，grep可以进行过滤</li>
<li><code>systemctl enable 服务名</code> 设置服务开机启动</li>
<li><code>systemctl disable 服务名</code> 关闭服务开机启动</li>
<li><code>systemctl is-enable 服务名</code> 查询某个服务是否是自启动的</li>
</ol>
</li>
<li><code>ls -l /usr/lib/systemd/system/ | more</code>：显示systemctl管理的服务名称。</li>
<li><code>systemctl list-unit-files | grep firewalld</code>：查看防火墙开启还是关闭</li>
</ol>
</li>
</ol>
<p><strong>firewalld</strong></p>
<ol>
<li><code>firewall-cmd --permanent --add-port=端口号/协议</code> 打开端口</li>
<li><code>firewall-cmd --permanent --remove-port=端口号/协议</code> 打开端口</li>
<li><code>firewall-cmd --reload</code>  重新载入，才能生效</li>
<li><code>firewall-cmd --query-port=端口号/协议</code> 查询端口是否开放</li>
</ol>
<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p><code>top</code>与<code>ps</code>命令很相似，他们都用来显示正在执行的进程</p>
<p>不同：top在执行一段时间可以更新正在运行的进程</p>
<p><code>top [选项]</code></p>
<p><code>-d 秒数</code> 指定top命令每个几秒更新，默认是3秒</p>
<p><code>-i</code> 使top不显示任何闲置或者僵死进程</p>
<p><code>-p</code> 通过指定监控进程ID来监控某个进程的状态</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>以CPU使用率排序，默认就是此项</td>
</tr>
<tr>
<td>M</td>
<td>以内存使用率排序</td>
</tr>
<tr>
<td>N</td>
<td>以PID排序</td>
</tr>
<tr>
<td>q</td>
<td>退出top</td>
</tr>
<tr>
<td>u + 用户名</td>
<td>监视特定用户</td>
</tr>
<tr>
<td>k</td>
<td>终止指定的进程</td>
</tr>
</tbody>
</table>
<h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p><code>netstat [选项]</code> 查看系统网络情况</p>
<p><code>-an</code> 按一定的顺序排序输出</p>
<p><code>-p</code> 显示哪个进程在调用</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>云e办项目</title>
    <url>/article/5653.html</url>
    <content><![CDATA[<h2 id="前端问题"><a href="#前端问题" class="headerlink" title="前端问题"></a>前端问题</h2><ol>
<li><p>在写完导入 vuex 之后，重启项目，发现空白页</p>
<p>运行时发出了警告</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">export &#x27;watch&#x27; (imported as &#x27;watch&#x27;) was not found in &#x27;vue&#x27;<br>export &#x27;inject&#x27; (imported as &#x27;inject&#x27;) was not found in &#x27;vue&#x27;<br></code></pre></td></tr></table></figure>
<p>问题：</p>
<p>创建项目时没有下载 vuex 后期自己下载的，看了一下下载的 vuex 版本时是 4.x.x 页面报错</p>
<p>解决方法：</p>
<ol>
<li><p>看一下自己的vuex版本是不是4.x.x ，如果是，先卸载 vuex</p>
</li>
<li><p>重新下载vuex</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install vuex@3.4.0<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Mac环境搭建</title>
    <url>/article/42094.html</url>
    <content><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="安装以及多版本切换"><a href="#安装以及多版本切换" class="headerlink" title="安装以及多版本切换"></a>安装以及多版本切换</h3><p><a href="https://www.bilibili.com/video/BV1Qf4y1V7Co">b站up主做了很详细的教程</a></p>
<h3 id="彻底卸载MySQL"><a href="#彻底卸载MySQL" class="headerlink" title="彻底卸载MySQL"></a>彻底卸载MySQL</h3><ol>
<li><p>终端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo su<br></code></pre></td></tr></table></figure>
</li>
<li><p>依次执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo rm /usr/local/mysql<br>sudo rm -rf /usr/local/mysql*<br>sudo rm -rf /Library/StartupItems/MySQLCOM<br>sudo rm -rf /Library/PreferencePanes/My*<br>rm -rf ~/Library/PreferencePanes/My*<br>sudo rm -rf /Library/Receipts/mysql*<br>sudo rm -rf /Library/Receipts/MySQL*<br>sudo rm -rf /var/db/receipts/com.mysql.*<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="node-js-npm"><a href="#node-js-npm" class="headerlink" title="node.js + npm"></a>node.js + npm</h2><p>查看 node 安装目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">which node<br></code></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>(如果安装多版本node，<a href="#多版本管理">跳转多版本管理</a>)</p>
<p>使用<strong>HomeBrew</strong></p>
<ol>
<li><p>查看本机可安装的node版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew search node<br></code></pre></td></tr></table></figure>
</li>
<li><p>安装node</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew install node@版本号<br></code></pre></td></tr></table></figure>
</li>
<li><p>链接（很重要，否则node不能使用）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew link node@版本号<br></code></pre></td></tr></table></figure>
</li>
<li><p>链接之后会报两个建议希望你执行两个命令，按照执行就好了</p>
</li>
</ol>
<ol start="5">
<li><p>检查是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">node -v<br></code></pre></td></tr></table></figure>
<p>如果成功，会显示你安装的版本号</p>
</li>
</ol>
<hr>
<p><strong>安装包安装</strong></p>
<p><a href="https://nodejs.org/zh-cn/">中文官方下载地址</a></p>
<p><a href="https://nodejs.org/zh-cn/download/releases/">往期版本</a></p>
<p>【注意】：下载时，建议选择 <strong>尾缀名是 .pkg 的文件</strong> 下载</p>
<p>直接安装</p>
<h3 id="多版本管理"><a href="#多版本管理" class="headerlink" title="多版本管理"></a>多版本管理</h3><p>如果之前存在非n下载的node，要先<a href="#卸载node">卸载</a>掉</p>
<p><strong>清除 node 缓存</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo npm cache clean -f<br></code></pre></td></tr></table></figure>
<p>node开发中，经常遇到版本不匹配的问题，导致编译失败，卸载该版本重新安装的成本又太高，因此我们需要多版本管理的工具</p>
<p>n相比于nvm更容易安装 node，因此选用 n 作为多node版本的管理工具</p>
<blockquote>
<p>HomeBrew方式安装(如果没有node环境)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew install n<br></code></pre></td></tr></table></figure>
<p>npm方式安装(有node环境)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install -g n<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>查看 n 是否安装成功</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n -V<br></code></pre></td></tr></table></figure>
<ol>
<li><p>查看可用 node 列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n ls<br></code></pre></td></tr></table></figure>
</li>
<li><p>安装指定版本的 node</p>
<ol>
<li><p>查看官方所有的 node 版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm view node versions<br></code></pre></td></tr></table></figure>
</li>
<li><p>以安装 12 版本的 node 为例，命令行执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n 12<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>切换 node 版本</p>
<p>命令行执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n<br></code></pre></td></tr></table></figure>
<p>通过上下键，选择要使用的 node 版本</p>
</li>
</ol>
<blockquote>
<ol>
<li><p>安装n模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo npm install -g n<br></code></pre></td></tr></table></figure>
</li>
<li><p>升级node.js到最新稳定版</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n stable<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>升级到最新版</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n latest<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>n后面也可以跟随版本号,升级到任意版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n v12.22.10或sudo n 17.6.0<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>查看一下已安装的 node 版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n ls<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>切换使用版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n 17.6.0<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>删除指定版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n rm 17.6.0<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>用制定的版本执行脚本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n use 17.6.0 some.js<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="卸载node"><a href="#卸载node" class="headerlink" title="卸载node"></a>卸载node</h3><p><strong>不使用HomeBrew安装时卸载</strong></p>
<ol>
<li><p>终端，确认工具存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">node -v<br>npm -v<br></code></pre></td></tr></table></figure>
</li>
<li><p>依次执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo rm -rf /usr/local/&#123;bin/&#123;node,npm&#125;,lib/node_modules/npm,lib/node,share/man/*/node.*&#125;<br>sudo npm uninstall npm -g<br>sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*<br>sudo rm -rf /usr/local/include/node /Users/$USER/.npm<br>sudo rm /usr/local/bin/node<br>sudo rm /usr/local/share/man/man1/node.1<br>sudo rm /usr/local/lib/dtrace/node.d<br></code></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>使用HomeBrew安装时卸载</strong></p>
<ol>
<li><p>使用brew</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew uninstall node@版本号<br></code></pre></td></tr></table></figure>
</li>
<li><p>进入个人主文件夹，检查各种 local、lib、include 文件夹，删除名字含有<code>node</code>和<code>node_modules</code>的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/local/bin<br>sudo rm -rf /usr/local/bin/npm<br>sudo rm -rf /usr/local/bin/node<br>ls -las 仔细查看，全局安装的npm包一般会在这个目录下创建软连接，发现就删除<br></code></pre></td></tr></table></figure>
</li>
<li><p>其他清理工作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo rm -rf /usr/local/share/man/man1/node.1<br>sudo rm -rf /usr/local/lib/dtrace/node.d<br>sudo rm -rf ~/.npm<br></code></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>版本管理工具 n 中 ，卸载指定版本node</strong></p>
<p>命令行运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n rm 17.6.0<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br><strong>如果删除不成功，可进入<code>/usr/local/n/versions/node</code>目录删除版本</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/local/n/versions/node<br>sudo rm -rf 17.6.0<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><strong>卸载node环境管理工具 n</strong></p>
<ol>
<li><p>命令行执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm uninstall n -g<br>或<br>sudo npm uninstall n -g<br></code></pre></td></tr></table></figure>
</li>
<li><p>进入目录手动删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/local<br></code></pre></td></tr></table></figure>
<p>删除n包</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac,安装</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/article/42622.html</url>
    <content><![CDATA[<blockquote>
<p>You are the big drop of dew under the lotus leaf, I am the smaller one on its upper side,” said the dewdrop to the lake.</p>
<p>露珠对湖水说道；“你是在荷叶下面的大露珠，我是在荷叶上面的较小的露<br>珠。”　</p>
</blockquote>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p><a href="https://www.springcloud.cc">SpringCloud中文网</a></p>
<p><a href="https://spring.io/projects/spring-cloud">SpringCloud官网</a></p>
<p>SpringCloud是一个基于SpringBoot实现的云应用开发工具，它为基于JVM的云应用开发中涉及<strong>的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理</strong>等操作提供了一种简单的开发方式。</p>
<p><strong>微服务架构</strong></p>
<p>微服务(Microservices Architecture)是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</p>
<p>微服务架构的<strong>核心思想</strong>是，一个应用是由多个小的、相互独立的、微服务组成，这些服务运行在自己的进程中，开发和发布都没有依赖。不同服务通过一些<strong>轻量级交互机制来通信</strong>，例如 RPC、HTTP 等，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。简单的来说，一个系统的不同模块转变成不同的服务！而且服务可以使用不同的技术加以实现！</p>
<h3 id="学习环境搭建"><a href="#学习环境搭建" class="headerlink" title="学习环境搭建"></a>学习环境搭建</h3><img src="/article/42622/image-20220223124010573.png" class title="image-20220223124010573">
<p><code>父项目pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.13.1<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">lombok.version</span>&gt;</span>1.18.20<span class="hljs-tag">&lt;/<span class="hljs-name">lombok.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--打包方式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Springcloud依赖--&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2020.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--springboot--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--连接数据库--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--springboot启动器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--日志测试--&gt;</span><br>    <span class="hljs-comment">&lt;!--log4j--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--log4j--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="SpringCloud-api"><a href="#SpringCloud-api" class="headerlink" title="SpringCloud-api"></a>SpringCloud-api</h4><img src="/article/42622/image-20220223124034883.png" class title="image-20220223124034883">
<p>配置SpringCloud-api，pom环境引入父项目依赖，构建实体类。</p>
<h4 id="springcloud-provider-dept-8001"><a href="#springcloud-provider-dept-8001" class="headerlink" title="springcloud-provider-dept-8001"></a>springcloud-provider-dept-8001</h4><img src="/article/42622/image-20220223124230419.png" class title="image-20220223124230419">
<p>构建服务者，springcloud-provider-dept-8001</p>
<p>配置服务者<code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br><br><span class="hljs-comment">#mybatis配置</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.bobo.springcloud.pojo</span><br>  <span class="hljs-attr">config-location:</span> <span class="hljs-string">classpath:mybatis/mybatis-config.xml</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/mapper/*.xml</span><br><br><span class="hljs-comment">#spring配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">springcloud-provider-dept</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="hljs-comment">#数据源</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/(api实体类对应数据库名)?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">密码</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">用户名</span><br></code></pre></td></tr></table></figure>
<p>配置<code>pom.xml</code>版本号依赖于父项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--添加监控信息--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--我们需要拿到实体类  索要配置api module--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bobo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--test--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--web--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--jetty--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--热部署--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="springcloud-consumer-dept-80"><a href="#springcloud-consumer-dept-80" class="headerlink" title="springcloud-consumer-dept-80"></a>springcloud-consumer-dept-80</h4><img src="/article/42622/image-20220223124558372.png" class title="image-20220223124558372">
<p>构建消费者，springcloud-consumer-dept-80</p>
<p>配置消费者<code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>
<p>配置<code>pom.xml</code>版本号依赖于父项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>  <span class="hljs-comment">&lt;!--实体类+web--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bobo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="SpringCloud-Eureka"><a href="#SpringCloud-Eureka" class="headerlink" title="SpringCloud Eureka"></a>SpringCloud Eureka</h2><p><strong>SpringCloud Eureka来实现服务治理</strong></p>
<p>SpringCloud Eureka是SpringCloud Netflix项目下的服务治理模块。而SpringCloud Netflix项目是SpringCloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为SpringBoot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。</p>
<p>它主要提供的模块包括：<strong>服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）</strong>等。</p>
<h3 id="EurekaServer"><a href="#EurekaServer" class="headerlink" title="EurekaServer"></a>EurekaServer</h3><p><strong>提供服务注册和发现  springcloud-eureka-7002</strong></p>
<ol>
<li><p><strong>添加依赖</strong></p>
<p>在项目 <code>pom.xml</code>中引入需要的依赖内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong></p>
<p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在<code>application.yml</code>配置文件中增加如下信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#配置端口号</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-comment">#Eureka</span><br><span class="hljs-attr">eureka:</span><br>	<span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span>   <span class="hljs-comment">#Eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#表示是否向eureka服务中心注册自己</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#如果为false则表示自己为注册中心</span><br>    <span class="hljs-attr">service-url:</span><br>    	<span class="hljs-comment">#监控页面</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.333ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 12629.6 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">{eureka.instance.hostname}:</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
<path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6B" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMAIN-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMATHI-63" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/>
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-65" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-75" x="466" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="1039" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="1490" y="0"/>
 <use xlink:href="#E1-MJMATHI-6B" x="1957" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="2478" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3008" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="3453" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="3798" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="4399" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="4868" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="5230" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="5759" y="0"/>
 <use xlink:href="#E1-MJMATHI-63" x="6360" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="6793" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="7260" y="0"/>
 <use xlink:href="#E1-MJMATHI-68" x="7705" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="8281" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="8767" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="9236" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="9598" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="10198" y="0"/>
 <use xlink:href="#E1-MJMATHI-6D" x="10728" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="11606" y="0"/>
 <use xlink:href="#E1-MJMAIN-3A" x="12351" y="0"/>
</g>
</svg>&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>开启服务注册</strong></p>
<p>通过 <code>@EnableEurekaServer</code> 注解启动一个服务注册中心提供给其他应用进行对话,这个注解需要在SpringBoot工程的主启动类上加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span>   <span class="hljs-comment">//EnableEurekaServer服务端的启动类，可以接受别人注册进来</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServer_7001</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaServer_7001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>访问服务</strong></p>
<p>启动工程后，访问：<a href="http://localhost:7001/">http://localhost:7001/</a></p>
</li>
</ol>
<h3 id="Service-Provider"><a href="#Service-Provider" class="headerlink" title="Service Provider"></a>Service Provider</h3><p>服务提供方:将自身服务注册到 Eureka 注册中心，从而使服务消费方能够找到</p>
<ol>
<li><p><strong>添加依赖<code>pom.xml</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong><code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#Eureka的配置  服务注册到哪里</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka/</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">springcloud-provider-dept8001</span>   <span class="hljs-comment">#修改Eureka 的默认描述信息</span><br><br><span class="hljs-comment">#info配置</span><br><span class="hljs-attr">info:</span><br>  <span class="hljs-attr">app.name:</span> <span class="hljs-string">bobo-springcloud</span><br>  <span class="hljs-attr">company.name:</span> <span class="hljs-string">bobo666</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>开启服务注册</strong></p>
<p>在应用主类中通过加上 <code>@EnableEurekaClient</code>，但只有 Eureka 可用.</p>
<p>也可以使用@EnableDiscoveryClient,需要配置才能找到Eureka注册中心服务器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span>   <span class="hljs-comment">//自动在服务启动后自动注册到Eureka中</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeptProvider_8001</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(DeptProvider_8001.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>访问服务</strong></p>
<p>启动该工程后，再次访问启动工程：<a href="http://localhost:7001/">http://localhost:7001/</a></p>
</li>
</ol>
<h3 id="多集群模拟"><a href="#多集群模拟" class="headerlink" title="多集群模拟"></a>多集群模拟</h3><img src="/article/42622/image-20220224090112639.png" class title="image-20220224090112639">
<p><strong>如果一台主机试验，修改host文件</strong></p>
<p>注释默认映射，添加映射</p>
<img src="/article/42622/image-20220224090049462.png" class title="image-20220224090049462">
<p>分别修改每个项目下<code>application.yam</code>文件，以7001为例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-comment">#Eureka</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7001.com</span>   <span class="hljs-comment">#Eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#表示是否向eureka服务中心注册自己</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#如果为false则表示自己为注册中心</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/,</span> <span class="hljs-string">http://eureka7003.com:7003/eureka/</span><br></code></pre></td></tr></table></figure>
<p>修改<strong>服务提供方</strong><code>application.yam</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#Eureka的配置  服务注册到哪里</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">springcloud-provider-dept8001</span>   <span class="hljs-comment">#修改Eureka 的默认描述信息</span><br><br><span class="hljs-comment">#info配置</span><br><span class="hljs-attr">info:</span><br>  <span class="hljs-attr">app.name:</span> <span class="hljs-string">bobo-springcloud</span><br>  <span class="hljs-attr">company.name:</span> <span class="hljs-string">bobo666</span><br></code></pre></td></tr></table></figure>
<p>启动<strong>7001、7002、7003</strong>项目</p>
<p>以7001为例</p>
<img src="/article/42622/image-20220224090644886.png" class title="image-20220224090644886">
<p>启动<strong>8001服务提供者</strong>项目</p>
<img src="/article/42622/image-20220224090950094.png" class title="image-20220224090950094">
<h3 id="Eureka与Zookeeper的区别"><a href="#Eureka与Zookeeper的区别" class="headerlink" title="Eureka与Zookeeper的区别"></a>Eureka与Zookeeper的区别</h3><p>CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于<strong>分区容错性P在是分布式系统中必须要保证</strong>的，因此我们只能在A和C之间进行权衡。<br><strong>Zookeeper保证CP</strong><br>Zookeeper 为主从结构，有leader节点和follow节点。当leader节点down掉之后，剩余节点会重新进行选举。选举过程中会导致服务不可用，丢掉了可用行。<br><strong>Eureka保证AP</strong><br>Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p>
<blockquote>
<p><strong>为什么CAP只能达到 CP 或者 AP？</strong></p>
<p>由以上我们得知，P是必然存在的。<br>如果我们保证了CP，即一致性与分布容错。当我们通过一个服务器修改数据后，该服务器会向另一个服务器发送请求，将数据进行同步，但此时，该数据应处于锁定状态，不可再次修改，这样，如果此时我们想服务器发送请求，则得不到相应，这样就不能A，高可用。<br>如果我们保证了AP，那么我们不能对服务器进行锁定，任何时候都要得到相应，那么数据的一致性就不好说了。</p>
</blockquote>
<h3 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h3><p>在默认配置中Eureka Server服务在一定时间（<strong>默认为90秒</strong>）没接受到某个服务的心跳连接后，Eureka Server会注销该服务。但是会存在当网络分区发生故障，导致该时间内没有心跳连接，但该服务本身还是健康运行的情况。Eureka通过“自我保护模式”来解决这个问题。</p>
<ol>
<li><p>在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。当他收到的心跳数重新恢复到阈值以上时，该Eureka Server节点会自动退出自我保护模式。</p>
</li>
<li><p>在自我保护模式下，Eureka Server 仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点依然可用。）</p>
</li>
<li>当网络稳定时，当前实例新的注册信息会被同步到其他节点中</li>
</ol>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>SpringCloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端负载均衡</strong>的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。</p>
<p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的<strong>软件负载均衡算法</strong>，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。</p>
<h3 id="LB方案"><a href="#LB方案" class="headerlink" title="LB方案"></a>LB方案</h3><p>负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。</p>
<p>负载均衡构建在原有网络结构之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性。</p>
<p><strong>集中式LB</strong>, 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；</p>
<p><strong>进程内LB</strong>，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。<strong>Ribbon就属于进程内LB</strong>，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p>
<h3 id="集群模拟"><a href="#集群模拟" class="headerlink" title="集群模拟"></a>集群模拟</h3><p><strong>Ribbon Consumer</strong></p>
<p><strong>服务消费者</strong></p>
<ol>
<li><p><strong>添加依赖 <code>pom.xml</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Ribbon负载均衡--&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-ribbon --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--erueka--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><br><span class="hljs-comment">#eureka配置</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#不向eureka注册自己</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/,</span> <span class="hljs-string">http://eureka7003.com:7003/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>开启服务负载均衡</strong></p>
<p>在工程的启动类中,通过<code>@EnableEurekaClient</code>向服务注册中心注册；并且向程序的<code>ioc</code>注入一个<code>bean: restTemplate</code>并通过<code>@LoadBalanced</code>注解表明这个<code>restTemplate</code>开启负载均衡的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeptConsumer_80</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(DeptConsumer_80.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud.config;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigBean</span> </span>&#123;   <span class="hljs-comment">//@Configuration   ----spring applicationContext.xml</span><br><br>  <span class="hljs-comment">//配置负载均衡实现  RestTemplate</span><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@LoadBalanced</span>  <span class="hljs-comment">//Ribbon</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>消费提供者方法</strong></p>
<p>在<code>Controller</code> 类中，调用提供者的 <code>home</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud.controller;<br><span class="hljs-keyword">import</span> com.bobo.springcloud.pojo.Dept;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeptConsumerController</span> </span>&#123;<br>  <span class="hljs-comment">//理解 消费者不应该有service层</span><br>  <span class="hljs-comment">//RestTemplate</span><br>  <span class="hljs-comment">//提供多种便捷访问远程http服务的方法，是一种简单的restful服务模版</span><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>  <span class="hljs-comment">//Ribbon 这里的地址 应该是一个变量，通过服务名来访问</span><br>  <span class="hljs-comment">//private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;;</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REST_URL_PREFIX = <span class="hljs-string">&quot;http://SPRINGCLOUD-PROVIDER-DEPT&quot;</span>;<br><br>  <span class="hljs-meta">@RequestMapping(&quot;/consumer/dept/list&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Dept&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="hljs-string">&quot;/dept/deptlist&quot;</span>, List.class);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>负载均衡</strong></p>
<p>访问<a href="http://localhost/consumer/dept/list`，发现Ribbon已经实现负载均衡">http://localhost/consumer/dept/list`，发现Ribbon已经实现负载均衡</a></p>
</li>
</ol>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ol>
<li><p>轮询法</p>
<p>轮询法，就是将用户的请求轮流分配给服务器，就像是挨个数数，轮流分配。这种算法比较简单，他具有绝对均衡的优点，但是也正是因为绝对均衡它必须付出很大的代价，例如它无法保证分配任务的合理性，无法根据服务器承受能力来分配任务。</p>
</li>
<li><p>随机法</p>
<p>随机法，是随机选择一台服务器来分配任务。它保证了请求的分散性达到了均衡的目的。同时它是没有状态的不需要维持上次的选择状态和均衡因子。但是随着任务量的增大，它的效果趋向轮询后也会具有轮询算法的部分缺点。</p>
</li>
<li><p>最小连接法</p>
<p>最小连接法，将任务分配给此时具有最小连接数的节点，因此它是动态负载均衡算法。一个节点收到一个任务后连接数就会加1，当节点故障时就将节点权值设置为0，不再给节点分配任务。</p>
<p>最小连接法适用于各个节点处理的性能相似时。任务分发单元会将任务平滑分配给服务器。但当服务器性能差距较大时，就无法达到预期的效果。因为此时连接数并不能准确表明处理能力，连接数小而自身性能很差的服务器可能不及连接数大而自身性能极好的服务器。所以在这个时候就会导致任务无法准确的分配到剩余处理能力强的机器上。 </p>
</li>
</ol>
<h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是一个声明式的<strong>伪Http客户端</strong>，它使得写Http客户端变得更简单。</p>
<p>使用Feign，只需要创建一个接口并注解，它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解，<strong>Feign支持可插拔的编码器和解码器</strong>，<strong>Feign默认集成了Ribbo</strong>，并和Eureka结合，<strong>默认实现了负载均衡</strong>的效果。</p>
<p>在<strong>Feign</strong>的实现下，我们只需要创建一个接口并使用注解的方式来配置它。即可以完成对服务提供方的接口绑定，简化了使用SpringCloud Ribbon时，自动封装服务调用客户端的开发量。</p>
<p>Feign远程调用的基本流程</p>
<img src="/article/42622/1.png" class width="1">
<p><strong>Feign 具有如下特性</strong></p>
<ul>
<li>可插拔的注解支持，包括Feign注解和JAX-RS注解</li>
<li>支持可插拔的HTTP编码器和解码器</li>
<li>支持Hystrix和它的Fallback</li>
<li>支持Ribbon的负载均衡</li>
<li>支持HTTP请求和响应的压缩Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。它整合了Ribbon和Hystrix，从而不再需要显式地使用这两个组件。Feign还提供了HTTP请求的模板，通过编写简单的接口和注解，就可以定义好HTTP请求的参数、格式、地址等信息。接下来，Feign会完全代理HTTP的请求，我们只需要像调用方法一样调用它就可以完成服务请求。</li>
</ul>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在SpringCloud可以用RestTemplate+Ribbon和Feign来调用。</p>
<p>由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p>
<p>针对上述问题，在SpringCloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了<strong>服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控</strong>等强大功能。</p>
<table>
<thead>
<tr>
<th style="text-align:center">雪崩场景</th>
<th style="text-align:center">举例</th>
<th style="text-align:center">应对策略</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">硬件故障</td>
<td style="text-align:center">服务器宕机，机房断电，光纤被挖断等</td>
<td style="text-align:center">多机房容灾、异地多活等。</td>
</tr>
<tr>
<td style="text-align:center">流量激增</td>
<td style="text-align:center">异常流量，重试加大流量等</td>
<td style="text-align:center">服务自动扩容、流量控制（限流、关闭重试）等。</td>
</tr>
<tr>
<td style="text-align:center">缓存穿透</td>
<td style="text-align:center">一般发生在应用重启，所有缓存失效时，以及短时间内大量缓存失效时。大量的缓存不命中，使请求直击后端服务，造成服务提供者超负荷运行，引起服务不可用。</td>
<td style="text-align:center">缓存预加载、缓存异步加载等。</td>
</tr>
<tr>
<td style="text-align:center">程序BUG</td>
<td style="text-align:center">如程序逻辑导致内存泄漏，JVM长时间FullGC等。</td>
<td style="text-align:center">修改程序bug、及时释放资源等。</td>
</tr>
<tr>
<td style="text-align:center">同步等待</td>
<td style="text-align:center">服务间采用同步调用模式，同步等待造成的资源耗尽。</td>
<td style="text-align:center">资源隔离、MQ解耦、不可用服务调用快速失败等。资源隔离通常指不同服务调用采用不同的线程池；不可用服务调用快速失败一般通过熔断器模式结合超时机制实现。</td>
</tr>
</tbody>
</table>
<h3 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h3><p>断路器模式源于Martin Fowler的Circuit Breaker一文。“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。</p>
<p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，<strong>通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放</strong>，避免了故障在分布式系统中的蔓延。</p>
<h3 id="使用-Ribbon-Hystrix"><a href="#使用-Ribbon-Hystrix" class="headerlink" title="使用 Ribbon Hystrix"></a>使用 Ribbon Hystrix</h3><p><strong>服务熔断</strong></p>
<ol>
<li><p><strong>添加依赖</strong></p>
<p>在项目<code>pom</code> 加上<code>hystrix</code>的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- hystrix 断路器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在程序的启动类通过 <code>@EnableHystrix</code> 开启 <code>Hystrix</code> 断路器监控.</p>
</li>
<li><p><strong>消费提供者方法</strong></p>
<ol>
<li>新方法<code>defaultStores</code>,当出现雪崩情况，跳转到该方法</li>
<li>修改 <code>DeptConsumerController</code> 类的，<code>list</code> 方法，加上注解<code>@HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)</code></li>
</ol>
</li>
</ol>
<h3 id="服务熔断与降级"><a href="#服务熔断与降级" class="headerlink" title="服务熔断与降级"></a>服务熔断与降级</h3><p><strong>服务熔断:作用在服务提供者</strong></p>
<p>服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用,快速返回”错误”的响应信息。当检测到该节点微服务响应正常后恢复调用链路.</p>
<p><strong>服务降级：作用在消费者</strong></p>
<p><strong>服务降级处理是在客户端实现完成的，与服务端没有关系</strong></p>
<p>服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。\</p>
<p><strong>相同点</strong></p>
<p>目标一致 都是从可用性和可靠性出发，为了防止系统崩溃；</p>
<p>用户体验类似 最终都让用户体验到的是某些功能暂时不可用；</p>
<p><strong>不同点</strong></p>
<p>触发原因不同 服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑； </p>
<h2 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h2><p>务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供<code>REST API</code>的过程中，除了具备<strong>服务路由、均衡负载功能</strong>之外，它还具备了<strong>权限控制</strong>等功能。<code>Spring Cloud</code> <code>Netflix</code>中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p>
<p>路由在微服务体系结构的一个组成部分。例如，/可以映射到您的Web应用程序，<code>/api/users</code>映射到用户服务，并将<code>/api/shop</code>映射到商店服务。<code>Zuul</code>是<code>Netflix</code>的基于<code>JVM</code>的路由器和服务器端负载均衡器。</p>
<h3 id="什么是服务网关"><a href="#什么是服务网关" class="headerlink" title="什么是服务网关"></a>什么是服务网关</h3><p><strong>服务网关 = 路由转发 + 过滤器</strong></p>
<ol>
<li><p>路由转发：接收一切外界请求，转发到后端的微服务上去；</p>
</li>
<li><p>过滤器：在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，这些都可以通过过滤器完成（其实路由转发也是通过过滤器实现的）。</p>
</li>
</ol>
<h3 id="为什么需要服务网关"><a href="#为什么需要服务网关" class="headerlink" title="为什么需要服务网关"></a>为什么需要服务网关</h3><p>上述所说的横切功能（以权限校验为例）可以写在三个位置：</p>
<ul>
<li>每个服务自己实现一遍</li>
<li>写到一个公共的服务中，然后其他所有服务都依赖这个服务</li>
<li>写到服务网关的前置过滤器中，所有请求过来进行权限校验</li>
</ul>
<p><strong>第一种，缺点太明显，基本不用；</strong> </p>
<p><strong>第二种，相较于第一点好很多，代码开发不会冗余，但是有两个缺点：</strong></p>
<ul>
<li>由于每个服务引入了这个公共服务，那么相当于在每个服务中都引入了相同的权限校验的代码，使得每个服务的jar包大小无故增加了一些，尤其是对于使用docker镜像进行部署的场景，jar越小越好；</li>
<li>由于每个服务都引入了这个公共服务，那么我们后续升级这个服务可能就比较困难，而且公共服务的功能越多，升级就越难，而且假设我们改变了公共服务中的权限校验的方式，想让所有的服务都去使用新的权限校验方式，我们就需要将之前所有的服务都重新引包，编译部署。</li>
</ul>
<p><strong>而服务网关恰好可以解决这样的问题：</strong></p>
<ul>
<li>将权限校验的逻辑写在网关的过滤器中，后端服务不需要关注权限校验的代码，所以服务的jar包中也不会引入权限校验的逻辑，不会增加jar包大小；</li>
<li>如果想修改权限校验的逻辑，只需要修改网关中的权限校验过滤器即可，而不需要升级所有已存在的微服务。</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p><strong>新建项目</strong> <code>spring-cloud-zuul-service</code></p>
<ol>
<li><p><strong>添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>开启服务注册</strong></p>
<p>在程序的启动类 <code>ZuulApplication</code> 通过 <code>@EnableZuulProxy</code> 开启 Zuul 服务网关</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;<br><span class="hljs-meta">@EnableZuulProxy</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZuulApplication</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(ZuulApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong></p>
<p>配置文件 <code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-zuul</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9527</span><br><span class="hljs-attr">eureka:</span> <br>	<span class="hljs-attr">client:</span><br>		<span class="hljs-attr">service-url:</span> <br>			<span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/,</span> <span class="hljs-string">,http://eureka7002.com:7002/eureka/,</span> <span class="hljs-string">http://eureka7003.com:7003/eureka/</span><br><span class="hljs-attr">instance:</span><br>	<span class="hljs-attr">instance-id:</span> <span class="hljs-string">zuul9527.com</span><br>	<br><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">routes:</span><br>  	<span class="hljs-attr">mydept.serverId:</span> <span class="hljs-string">springcloud-provider-dept</span><br>  	<span class="hljs-attr">mydept.path:</span> <span class="hljs-string">/mydept/**</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="SpringCloud-Config"><a href="#SpringCloud-Config" class="headerlink" title="SpringCloud Config"></a>SpringCloud Config</h2><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在SpringCloud中，有分布式配置中心组件<strong>pringloud Config</strong>，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是<strong>config server</strong>，二是<strong>config client</strong>。</p>
<p><strong>SpringCloud Config</strong>就是我们通常意义上的配置中心，把应用原本放在本地文件的配置抽取出来放在中心服务器，从而能够提供更好的管理、发布能力。SpringCloud Config分服务端和客户端，<strong>服务端</strong>负责将<strong>git svn</strong>中存储的配置文件发布成<strong>REST接口</strong>，<strong>客户端</strong>可以从<strong>服务端REST接口</strong>获取配置。但客户端并不能主动感知到配置的变化，从而主动去获取新的配置，这需要每个客户端通过<strong>POST</strong>方法触发各自的<code>/refresh</code>。</p>
<p><strong>SpringCloud Bus</strong>通过一个<strong>轻量级消息代理连接分布式系统的节点</strong>。这可以用于广播状态更改（如配置更改）或其他管理指令。SpringCloudBus提供了通过<strong>POST</strong>方法访问的<code>endpoint/bus/refresh</code>，这个接口通常由<strong>git</strong>的钩子功能调用，用以通知各个SpringCloud Config的客户端去服务端更新配置。</p>
<h3 id="服务端配置-Config-Server"><a href="#服务端配置-Config-Server" class="headerlink" title="服务端配置 Config Server"></a>服务端配置 Config Server</h3><ol>
<li><p><strong>新建项目</strong> spring-cloud-config-server</p>
</li>
<li><p><strong>添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong></p>
<p>配置文件 <code>application.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">3344</span><br><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">application:</span><br>		<span class="hljs-attr">name:</span> <span class="hljs-string">config-server</span><br>	<span class="hljs-attr">cloud:</span><br>		<span class="hljs-attr">config:</span> <br>			<span class="hljs-attr">label:</span> <span class="hljs-string">main</span><br>			<span class="hljs-attr">server:</span><br>				<span class="hljs-attr">git:</span> <br>					<span class="hljs-attr">uri:</span> <span class="hljs-string">git仓库HTTPS地址</span><br>					<span class="hljs-attr">search-paths:</span>	<span class="hljs-string">spring-cloud-config</span><br></code></pre></td></tr></table></figure>
<ul>
<li>spring.cloud.config.server.git.uri：配置git仓库地址</li>
<li>spring.cloud.config.server.git.searchPaths：配置仓库路径</li>
<li>spring.cloud.config.label：配置仓库的分支</li>
</ul>
</li>
<li><p><strong>开启服务注册</strong></p>
<p>在程序的启动类 <code>ConfigServerApplication</code> 通过 <code>@EnableConfigServer</code> 开启 SpringCloud Config 服务端 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;<br><span class="hljs-meta">@EnableConfigServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigServerApplication</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(ConfigServerApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="客户端配置-Config-Client"><a href="#客户端配置-Config-Client" class="headerlink" title="客户端配置  Config Client"></a>客户端配置  Config Client</h3><ol>
<li><p><strong>新建项目</strong> spring-cloud-config-client</p>
</li>
<li><p><strong>添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong></p>
<p>配置文件 <code>application.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">application:</span><br>		<span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span><br>	<span class="hljs-attr">cloud:</span><br>		<span class="hljs-attr">config:</span><br>			<span class="hljs-attr">label:</span> <span class="hljs-string">mian</span><br>			<span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span><br>			<span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:3344/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>开启服务注册</strong></p>
<p>在程序的启动类 <code>ConfigClientApplication</code> 通过 <code>@Value</code> 获取服务端的 <code>content</code> 值的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud.controller;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigClientApplication</span> </span>&#123;<br>  <span class="hljs-meta">@Value(&quot;$&#123;content&#125;&quot;)</span><br>  String content;<br>  <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">home</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;content:&quot;</span> + content;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(ConfigClientApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringCloud</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java,SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot Web开发</title>
    <url>/article/43108.html</url>
    <content><![CDATA[<blockquote>
<p>The scabbard is content to be dull when it protects the keenness of the sword.</p>
<p>刀鞘保护刀的锋利，它自己则满足于它的迟钝。</p>
</blockquote>
<h2 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="SpringBoot Web开发"></a>SpringBoot Web开发</h2><a href="/article/4780.html" title="SpringMVC">SpringMVC</a>SpringMVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，其本身就是 Spring 框架的一部分，可以与 Spring 无缝集成，性能方面具有先天的优越性，是当今业界最主流的 Web 开发框架之一。<br><br>SpringBoot 是在 Spring 的基础上创建一款开源框架，它提供了 spring-boot-starter-web（Web 场景启动器） 来为 Web 开发予以支持。spring-boot-starter-web 为我们提供了嵌入的 Servlet 容器以及 SpringMVC 的依赖，并为 SpringMVC 提供了大量自动配置，可以适用于大多数 Web 开发场景。<br><br><br><br>### 静态资源导入<br><br>在 Web 应用中会涉及到大量的静态资源，例如 JS、CSS 和 HTML 等。我们知道，Spring MVC 导入静态资源文件时，需要配置静态资源的映射；但在 SpringBoot 中则不再需要进行此项配置，因为 SpringBoot 已经默认完成了这一工作。<br><br>Spring Boot 默认为我们提供了 3 种静态资源映射规则：<br><br>1. WebJars 映射<br>2. 默认资源映射<br>3. 静态首页（欢迎页）映射<br><br><br><br>#### WebJars 映射<br><br>WebJars 可以将 Web 前端资源（JS，CSS 等）打成一个个的 Jar 包，然后将这些 Jar 包部署到 Maven 中央仓库中进行统一管理，当 Spring Boot 项目中需要引入 Web 前端资源时，只需要访问 <a href="https://www.webjars.org/">WebJars 官网</a>，找到所需资源的 pom 依赖，将其导入到项目中即可。<br><br>所有通过 WebJars 引入的前端资源都存放在当前项目类路径（classpath）下的“<strong>/META-INF/resources/webjars/</strong>” 目录中。<br><br><br><br>#### 默认静态资源映射<br><br>当访问项目中的任意资源（即“/<strong>”）时，SpringBoot 会默认从以下路径中查找资源文件（优先级依次降低）：<br><br>1. classpath:/META-INF/resources/<br>2. classpath:/resources/<br>3. classpath:/static/<br>4. classpath:/public/<br><br>这些路径又被称为静态资源文件夹，它们的优先级顺序为：classpath:/META-INF/resources/ &gt; classpath:/resources/ &gt; classpath:/static/ &gt; classpath:/public/ 。<br><br>当我们请求某个静态资源（即以“.html”结尾的请求）时，SpringBoot 会先查找优先级高的文件夹，再查找优先级低的文件夹，直到找到指定的静态资源为止。<br><br><br><br>#### 静态首页（欢迎页）映射<br><br>静态资源文件夹下的所有 index.html 被称为静态首页或者欢迎页，它们会被被 `/</strong><code>映射，换句话说就是，当我们访问</code>/<code>或者</code>/index.html<code>时，都会跳转到静态首页（欢迎页）。



### Thymeleaf

[官方网站](https://www.thymeleaf.org)

[官方文档](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)

Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。它与 JSP，Velocity，FreeMaker 等模板引擎类似，也可以轻易地与 SpringMVC 等 Web 框架集成。与其它模板引擎相比，Thymeleaf 最大的特点是，即使不启动 Web 应用，也可以直接在浏览器中打开并正确显示模板页面 。



Thymeleaf 支持 HTML 原型，其文件后缀为</code>.html`，因此它可以直接被浏览器打开，此时浏览器会忽略未定义的 Thymeleaf 标签属性，展示 thymeleaf 模板的静态页面效果；当通过 Web 应用程序访问时，Thymeleaf 会动态地替换掉静态内容，使页面动态显示。<br><br>#### 依赖<br><br>使用thymeleaf,Maven导入依赖<br><br><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<img src="/article/43108/image-20220215235857183.png" class title="image-20220215235857183">
<p>我们要将html放在我们的<code>templates</code>目录下</p>
<h4 id="Thymeleaf-的特点"><a href="#Thymeleaf-的特点" class="headerlink" title="Thymeleaf 的特点"></a>Thymeleaf 的特点</h4><p>Thymeleaf 模板引擎具有以下特点：</p>
<ul>
<li>动静结合：Thymeleaf 既可以直接使用浏览器打开，查看页面的静态效果，也可以通过 Web 应用程序进行访问，查看动态页面效果。</li>
<li>开箱即用：Thymeleaf 提供了 Spring 标准方言以及一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li>
<li>多方言支持：它提供了 Thymeleaf 标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式；必要时，开发人员也可以扩展和创建自定义的方言。</li>
<li>与 SpringBoot 完美整合：SpringBoot 为 Thymeleaf 提供了的默认配置，并且还为 Thymeleaf 设置了视图解析器，因此 Thymeleaf 可以与 Spring Boot 完美整合。</li>
</ul>
<h4 id="标准表达式语法"><a href="#标准表达式语法" class="headerlink" title="标准表达式语法"></a>标准表达式语法</h4><p>Thymeleaf 模板引擎支持多种表达式：</p>
<ul>
<li><p>变量表达式：${…}</p>
<ul>
<li>获取对象的属性和方法</li>
<li>使用内置的基本对象<ul>
<li>#ctx ：上下文对象；</li>
<li>#vars ：上下文变量；</li>
<li>#locale：上下文的语言环境；</li>
<li>#request：HttpServletRequest 对象（仅在 Web 应用中可用）；</li>
<li>#response：HttpServletResponse 对象（仅在 Web 应用中可用）；</li>
<li>#session：HttpSession 对象（仅在 Web 应用中可用）；</li>
<li>#servletContext：ServletContext 对象（仅在 Web 应用中可用）。</li>
</ul>
</li>
<li>使用内置的工具对象</li>
</ul>
</li>
<li><p>选择变量表达式：*{…}</p>
<ul>
<li><p>选择变量表达式与变量表达式功能基本一致，只是在变量表达式的基础上增加了与 th:object 的配合使用。当使用 th:object 存储一个对象后，我们可以在其后代中使用选择变量表达式<code>*&#123;...&#125;</code>获取该对象中的属性，其中，<code>*</code> 即代表该对象。</p>
</li>
<li><p><code>`</code>html<br><div th:object="${session.user}"></div></p>
<pre><code>&lt;p th:text=&quot;*&#123;fisrtName&#125;&quot;&gt;firstname&lt;/p&gt;
</code></pre><p></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><br>- 链接表达式：@&#123;...&#125;<br><br>  - 不管是静态资源的引用，还是 form 表单的请求，凡是链接都可以用链接表达式 `@&#123;...&#125;`。 链接表达式的形式结构如下： 无参请求：@&#123;<span class="hljs-regexp">/xxx&#125; 有参请求：@&#123;/xxx</span>(k1=v1,k2=v2)&#125; <br><br>- 国际化表达式：<span class="hljs-comment">#&#123;...&#125;</span><br><br>- 片段引用表达式：~&#123;...&#125;<br><br>  - 推荐：~&#123;templatename::fragmentname&#125;<br>  - 支持：~&#123;templatename::<span class="hljs-comment">#id&#125;</span><br>  - templatename：模版名，Thymeleaf 会根据模版名解析完整路径：/resources/templates/templatename.html，要注意文件的路径。<br>  - fragmentname：片段名，Thymeleaf 通过 <span class="hljs-symbol">th:</span>fragment 声明定义代码块，即：<span class="hljs-symbol">th:</span>fragment=<span class="hljs-string">&quot;fragmentname&quot;</span><br>  - id：HTML 的 id 选择器，使用时要在前面加上 <span class="hljs-comment"># 号，不支持 class 选择器。</span><br><br><span class="hljs-comment">#### th 属性</span><br><br>|   属性    |                             描述                             |<br>| <span class="hljs-symbol">:-------</span>: | <span class="hljs-symbol">:----------------------------------------------------------</span>: |<br>|   <span class="hljs-symbol">th:</span>id   |                     替换 HTML 的 id 属性                     |<br>|  <span class="hljs-symbol">th:</span>text  |                    文本替换，转义特殊字符                    |<br>| <span class="hljs-symbol">th:</span>utext  |                   文本替换，不转义特殊字符                   |<br>|  <span class="hljs-symbol">th:</span>each  |              遍历，支持 Iterable、Map、数组等。              |<br>| <span class="hljs-symbol">th:</span>object | 在父标签选择对象，子标签使用 *&#123;…&#125; 选择表达式选取值。 没有选择对象，那子标签使用选择表达式和 <span class="hljs-variable">$&#123;</span>…&#125; 变量表达式是一样的效果。 同时即使选择了对象，子标签仍然可以使用变量表达式。 |<br>|  <span class="hljs-symbol">th:</span><span class="hljs-keyword">with</span>  |                       局部变量赋值运算                       |<br>|   <span class="hljs-symbol">th:</span>if   |                根据条件判断是否需要展示此标签                |<br>| <span class="hljs-symbol">th:</span><span class="hljs-keyword">unless</span> |             和 <span class="hljs-symbol">th:</span>if 判断相反，满足条件时不显示              |<br><br><br><br><span class="hljs-comment">### SpringBoot定制SpringMVC</span><br><br>SpringBoot 抛弃了传统 xml 配置文件，通过配置类（标注 <span class="hljs-variable">@Configuration</span> 的类，相当于一个 xml 配置文件）以 JavaBean 形式进行相关配置。<br><br>SpringBoot 对 SpringMVC 的自动配置可以满足我们的大部分需求，但是我们也可以通过自定义配置类（标注 <span class="hljs-variable">@Configuration</span> 的类）并实现 WebMvcConfigurer 接口来定制 Spring MVC 配置，<br><br>在 Spring Boot 项目中，我们可以通过以下 <span class="hljs-number">2</span> 中形式定制 Spring <span class="hljs-symbol">MVC:</span><br><br>- 扩展 Spring MVC<br>- 全面接管 Spring MVC<br><br><span class="hljs-comment">#### 扩展 SpringMVC </span><br><br>如果 SpringBoot 对 SpringMVC 的自动配置不能满足我们的需要，我们还可以通过自定义一个 WebMvcConfigurer 类型（**实现 WebMvcConfigurer 接口**）的配置类（**标注 <span class="hljs-variable">@Configuration</span>，但不标注 <span class="hljs-variable">@EnableWebMvc</span>** 注解的类），来扩展 SpringMVC。这样不但能够保留 SpringBoot 对 SpringMVC 的自动配置，享受 SpringBoot 自动配置带来的便利，还能额外增加自定义的 SpringMVC 配置。<br><br><span class="hljs-comment">#### 全面接管 SpringMVC</span><br><br>在一些特殊情况下，我们可能需要抛弃 SpringBoot 对 SpringMVC 的全部自动配置，完全接管 SpringMVC。此时我们可以自定义一个 WebMvcConfigurer 类型（**实现 WebMvcConfigurer 接口**）的配置类，并在该类上**标注 <span class="hljs-variable">@EnableWebMvc</span> 注解**，来实现完全接管 Spring MVC。<br><br><br><br><span class="hljs-comment">### 国际化</span><br><br>国际化（Internationalization 简称 I18n，其中“I”和“n”分别为首末字符，<span class="hljs-number">18</span> 则为中间的字符数）是指软件开发时应该具备支持多种语言和地区的功能。换句话说就是，开发的软件需要能同时应对不同国家和地区的用户访问，并根据用户地区和语言习惯，提供相应的、符合用具阅读习惯的页面和数据，例如，为中国用户提供汉语界面显示，为美国用户提供提供英语界面显示。<br><br>在 Spring 项目中实现国际化，通常需要以下 <span class="hljs-number">3</span> 步：<br><br><span class="hljs-number">1</span>. 编写国际化资源（配置）文件；<br><span class="hljs-number">2</span>. 使用 ResourceBundleMessageSource 管理国际化资源文件；<br><span class="hljs-number">3</span>. 在页面获取国际化内容。<br><span class="hljs-number">4</span>. <br><br><span class="hljs-comment">#### 编写国际化资源文件</span><br><br>在 Spring Boot 的类路径下创建国际化资源文件，文件名格式为：基本名_语言代码_国家或地区代码，例如 login_en_US.properties、login_zh_CN.properties。<br><br>在 src/main/resources 下创建一个 i18n 的目录，并在该目录中按照国际化资源文件命名格式分别创建以下三个文件，<br><br>- login.properties：无语言设置时生效<br>- login_en_US.properties ：英语时生效<br>- login_zh_CN.properties：中文时生效<br><br>以上国际化资源文件创建完成后，IDEA 会自动识别它们，并转换成如下的模式：<br><br>![image<span class="hljs-number">-20220219143717888</span>](SpringBoot-Web开发/image<span class="hljs-number">-20220219143717888</span>.png)<br><br>打开任意一个国际化资源文件，并切换为 Resource Bundle 模式，然后点击“+”号，创建所需的国际化属性<br><br><br><br><span class="hljs-comment">#### 使用 ResourceBundleMessageSource 管理国际化资源文件</span><br><br>SpringBoot 已经对 ResourceBundleMessageSource 提供了默认的自动配置。<br><br>只需要在 SpringBoot 全局配置文件中，使用配置参数`spring.messages.basename`指定我们自定义的国际资源文件的基本名即可，代码如下（当指定多个资源文件时，用逗号分隔）。<br><br>```properties<br>spring.messages.basename=i18n.login<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="获取国际化内容"><a href="#获取国际化内容" class="headerlink" title="获取国际化内容"></a>获取国际化内容</h4><p>由于页面使用的是 Tymeleaf 模板引擎，因此我们可以通过表达式 #{…} 获取国际化内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-lg btn-primary btn-block&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;login.btn&#125;&quot;</span>&gt;</span>Sign in<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;</span>&gt;</span>中文<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;index.html(l=&#x27;en_US&#x27;)&#125;&quot;</span>&gt;</span>English<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="SpringBoot拦截器"><a href="#SpringBoot拦截器" class="headerlink" title="SpringBoot拦截器"></a>SpringBoot拦截器</h3><p>在 Spring Boot 项目中，使用拦截器功能通常需要以下 3 步：</p>
<ol>
<li>定义拦截器；</li>
<li>注册拦截器；</li>
<li>指定拦截规则（如果是拦截所有，静态资源也会被拦截）。</li>
</ol>
<h4 id="定义拦截器"><a href="#定义拦截器" class="headerlink" title="定义拦截器"></a>定义拦截器</h4><p>在 SpringBoot 中定义拦截器十分的简单，只需要创建一个拦截器类，并实现 <code>HandlerInterceptor</code> 接口即可。</p>
<p>HandlerInterceptor 接口中定义以下 3 个方法，如下表。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法声明</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</td>
<td>该方法在控制器处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。</td>
</tr>
<tr>
<td>void</td>
<td>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</td>
<td>该方法在控制器处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步修改。</td>
</tr>
<tr>
<td>void</td>
<td>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</td>
<td>该方法在视图渲染结束后执行，可以通过此方法实现资源清理、记录日志信息等工作。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginHandlerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    <span class="hljs-comment">//登录成功 有用户的session</span><br>    Object loginUser = request.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>);<br>    <span class="hljs-comment">//没有登录</span><br>    <span class="hljs-keyword">if</span> (loginUser==<span class="hljs-keyword">null</span>)&#123; <br>      request.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;没有权限，请先登录&quot;</span>);<br>      request.getRequestDispatcher(<span class="hljs-string">&quot;/index.html&quot;</span>).forward(request,response);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h4><p>创建一个实现了 WebMvcConfigurer 接口的配置类（使用了 <code>@Configuration</code> 注解的类），重写 <code>addInterceptors()</code> 方法，并在该方法中调用 <code>registry.addInterceptor()</code> 方法将自定义的拦截器注册到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.ViewControllerRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><span class="hljs-comment">//@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的&lt;beans&gt;，作用为：配置spring容器(应用上下文)</span><br><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> LoginHandlerInterceptor());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="指定拦截规则"><a href="#指定拦截规则" class="headerlink" title="指定拦截规则"></a>指定拦截规则</h4><p>在使用 registry.addInterceptor() 方法将拦截器注册到容器中后，我们便可以继续指定拦截器的拦截规则了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">registry.addInterceptor(<span class="hljs-keyword">new</span> LoginHandlerInterceptor())<br>        .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>        .excludePathPatterns(<span class="hljs-string">&quot;/index.html&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;/user/login&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>在指定拦截器拦截规则时，调用了两个方法，这两个方法的说明如下：</p>
<ul>
<li>addPathPatterns：该方法用于指定拦截路径，例如拦截路径为“/**”，表示拦截所有请求，包括对静态资源的请求。</li>
<li>excludePathPatterns：该方法用于排除拦截路径，即指定不需要被拦截器拦截的请求。</li>
</ul>
<h3 id="SpringBoot-JDBC访问数据库"><a href="#SpringBoot-JDBC访问数据库" class="headerlink" title="SpringBoot JDBC访问数据库"></a>SpringBoot JDBC访问数据库</h3><p>进行<a href="/article/37040.html" title="JDBC配置">JDBC配置</a>:</p>
<ol>
<li>在 pom.xml 中导入 JDBC 场景启动器：spring-boot-starter-data-jdbc</li>
<li>JDBC 的场景启动器中并没有导入数据库驱动，我们需要根据自身的需求引入所需的数据库驱动。</li>
<li>在导入了 JDBC 场景启动器和数据库驱动后，接下来我们就可以在配置文件（application.properties/yml）中配置数据源了</li>
</ol>
<h3 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h3><p>MyBatis 是一个半自动化的 ORM 框架，所谓半自动化是指 MyBatis 只支持将数据库查出的数据映射到 POJO 实体类上，而实体到数据库的映射则需要我们自己编写 SQL 语句实现，相较于Hibernate 这种完全自动化的框架，Mybatis 更加灵活，我们可以根据自身的需求编写 sql 语句来实现复杂的数据库操作。</p>
<p>进行<a href="/article/37040.html" title="MyBatis配置">MyBatis配置</a>:</p>
<ol>
<li>在项目的 pom.xml 中引入 mybatis-spring-boot-starter 的依赖</li>
<li>在 SpringBoot 的配置文件（application.properties/yml）中对 MyBatis 进行配置，例如指定 mapper.xml 的位置、实体类的位置、是否开启驼峰命名法等等</li>
</ol>
<h3 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h3><p>SpringSecurity 是 Spring 家族中的一个安全管理框架，实际上，在 SpringBoot 出现之前，SpringSecurity 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。</p>
<p><strong>Apache Shiro</strong><br>一个功能强大且易于使用的Java安全框架，提供了认证、授权、加密、会话管理。<br><strong>Spring Security</strong><br>Spring家族的一员，是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring的IOC（控制反转）、DI（依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，为了减少企业系统安全控制编写大量重复代码的工作。</p>
<a href="/article/37040.html" title="SpringSecurity配置">SpringSecurity配置</a>
<p><strong>通过SpringSecurity 对不同用户角色进行授权</strong></p>
<img src="/article/43108/image-20220220111203172.png" class title="image-20220220111203172">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<br><span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<br><br><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br>  <span class="hljs-comment">//链式编程</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//首页所有人可以访问 ,功能也只有对应有权限的人才能反应</span><br><br>    <span class="hljs-comment">//请求授权的规则</span><br>    http.authorizeRequests().antMatchers(<span class="hljs-string">&quot;/&quot;</span>).permitAll()<br>      .antMatchers(<span class="hljs-string">&quot;/level1/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip1&quot;</span>)<br>      .antMatchers(<span class="hljs-string">&quot;/level2/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip2&quot;</span>)<br>      .antMatchers(<span class="hljs-string">&quot;/level3/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip3&quot;</span>);<br><br>    <span class="hljs-comment">//没有权限默认到登录页面   需要开启登录的页面</span><br>    http.formLogin().loginPage(<span class="hljs-string">&quot;/toLogin&quot;</span>);<br><br>    <span class="hljs-comment">//防止网站攻击  get post</span><br>    <span class="hljs-comment">//http.csrf().disable();  //关闭请求跨站攻击</span><br><br>    <span class="hljs-comment">//注销 注销完成跳转到首页</span><br>    http.logout().logoutSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>);<br><br>    <span class="hljs-comment">//开启记住我功能  cookie 自定义接收前端的参数</span><br>    http.rememberMe().rememberMeParameter(<span class="hljs-string">&quot;remember&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//认证</span><br>  <span class="hljs-comment">//密码编码：passwordEncoder</span><br>  <span class="hljs-comment">//springSecurity 5.0+ 新增了很多加密方法</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    auth.inMemoryAuthentication().passwordEncoder(<span class="hljs-keyword">new</span> BCryptPasswordEncoder())<br>      .withUser(<span class="hljs-string">&quot;bobo&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>)).roles(<span class="hljs-string">&quot;vip2&quot;</span>,<span class="hljs-string">&quot;vip3&quot;</span>)<br>      .and()<br>      .withUser(<span class="hljs-string">&quot;root&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>)).roles(<span class="hljs-string">&quot;vip1&quot;</span>,<span class="hljs-string">&quot;vip2&quot;</span>,<span class="hljs-string">&quot;vip3&quot;</span>)<br>      .and()<br>      .withUser(<span class="hljs-string">&quot;guest&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>)).roles(<span class="hljs-string">&quot;vip1&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h3><p><a href="https://shiro.apache.org/tutorial.html">官方文档</a></p>
<p>Apache Shiro 是一个强大灵活的开源安全框架，可以完全处理身份验证、授权、加密和会话管理。</p>
<p>Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。</p>
<img src="/article/43108/1.png" class title="img">
<ul>
<li><strong>Authentication</strong>：身份认证 / 登录，验证用户是不是拥有相应的身份；</li>
<li><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li>
<li><strong>Session</strong> <strong>Management</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</li>
<li><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li>
<li><strong>Web Support</strong>：Web 支持，可以非常容易的集成到 Web 环境；</li>
<li><strong>Caching</strong>：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；</li>
<li><strong>Concurrency</strong>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li><strong>Testing</strong>：提供测试支持；</li>
<li><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
<li></li>
</ul>
<p><strong>从外部</strong></p>
<img src="/article/43108/2.png" class title="img">
<p>应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject</p>
<ul>
<li><p><strong>Subject</strong>：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p>
</li>
<li><p><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</p>
</li>
<li><p><strong>Realm</strong>：域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p>
</li>
</ul>
<p>也就是说对于我们而言，最简单的一个 <code>Shiro</code> 应用：</p>
<ol>
<li>应用代码通过 <code>Subject</code> 来进行认证和授权，而 <code>Subject</code> 又委托给 <code>SecurityManager</code>；</li>
<li>我们需要给 <code>Shiro</code> 的 <code>SecurityManager</code> 注入 <code>Realm</code>，从而让 <code>SecurityManager</code> 能得到合法的用户及其权限进行判断。</li>
</ol>
<p><strong>从以上也可以看出，Shiro 不提供维护用户 / 权限，而是通过 Realm 让开发人员自己注入。</strong></p>
<p><strong>从内部</strong></p>
<img src="/article/43108/3.png" class title="img">
<ul>
<li><strong>Subject</strong>：主体，可以看到主体可以是任何可以与应用交互的 “用户”；</li>
<li><strong>SecurityManager</strong>：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。</li>
<li><strong>Authenticator</strong>：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</li>
<li><strong>Authorizer</strong>：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li>
<li><strong>Realm</strong>：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm；</li>
<li><strong>SessionManager</strong>：如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所以呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</li>
<li><strong>SessionDAO</strong>：DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</li>
<li><strong>CacheManager</strong>：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</li>
<li><strong>Cryptography</strong>：密码模块，Shiro 提供了一些常见的加密组件用于如密码加密 / 解密的。</li>
</ul>
<h4 id="Shiro快速开始"><a href="#Shiro快速开始" class="headerlink" title="Shiro快速开始"></a>Shiro快速开始</h4><a href="/article/37040.html" title="Shiro配置">Shiro配置</a>
<p><strong>导入shiro依赖包</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Shiro uses SLF4J for logging.  We&#x27;ll use the &#x27;simple&#x27; binding</span><br><span class="hljs-comment">             in this example app.  See http://www.slf4j.org for more info. --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong><code>shiro.ini</code></strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[users]</span><br><span class="hljs-attr">root</span> = secret, admin<br><span class="hljs-attr">guest</span> = guest, guest<br><span class="hljs-attr">presidentskroob</span> = <span class="hljs-number">12345</span>, president<br><span class="hljs-attr">darkhelmet</span> = ludicrousspeed, darklord, schwartz<br><span class="hljs-attr">lonestarr</span> = vespa, goodguy, schwartz<br><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-comment"># Roles with assigned permissions</span><br><span class="hljs-comment"># roleName = perm1, perm2, ..., permN</span><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-section">[roles]</span><br><span class="hljs-attr">admin</span> = *<br><span class="hljs-attr">schwartz</span> = lightsaber:*<br><span class="hljs-attr">goodguy</span> = winnebago:drive:eagle5<br></code></pre></td></tr></table></figure>
<p><code>Quickstart</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<br><span class="hljs-keyword">import</span> org.apache.shiro.authc.*;<br><span class="hljs-keyword">import</span> org.apache.shiro.ini.IniSecurityManagerFactory;<br><span class="hljs-keyword">import</span> org.apache.shiro.mgt.SecurityManager;<br><span class="hljs-keyword">import</span> org.apache.shiro.session.Session;<br><span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<br><span class="hljs-keyword">import</span> org.apache.shiro.lang.util.Factory;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Simple Quickstart application showing how to use Shiro&#x27;s API.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 0.9 RC2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quickstart</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> Logger log = LoggerFactory.getLogger(Quickstart.class);<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <br>    <br>    Factory&lt;SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">&quot;classpath:shiro.ini&quot;</span>);<br>    SecurityManager securityManager = factory.getInstance();<br>    SecurityUtils.setSecurityManager(securityManager);<br><br>    <span class="hljs-comment">// get the currently executing user:</span><br>    <span class="hljs-comment">//获取当前的用户对象：Subject</span><br>    Subject currentUser = SecurityUtils.getSubject();<br><br>    <span class="hljs-comment">//通过当前对象拿到Session</span><br>    Session session = currentUser.getSession();<br>    <br>    session.setAttribute(<span class="hljs-string">&quot;someKey&quot;</span>, <span class="hljs-string">&quot;aValue&quot;</span>);<br>    String value = (String) session.getAttribute(<span class="hljs-string">&quot;someKey&quot;</span>);<br>    <span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;aValue&quot;</span>)) &#123;<br>      log.info(<span class="hljs-string">&quot;Retrieved the correct value! [&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 测试当前用户是否被认证</span><br>    <span class="hljs-keyword">if</span> (!currentUser.isAuthenticated()) &#123;<br>      <br>      <span class="hljs-comment">//Token 令牌</span><br>      UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;lonestarr&quot;</span>, <span class="hljs-string">&quot;vespa&quot;</span>);<br>      <span class="hljs-comment">//设置记住我</span><br>      token.setRememberMe(<span class="hljs-keyword">true</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//执行登陆操作</span><br>        currentUser.login(token);<br>      &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException uae) &#123;<br>        log.info(<span class="hljs-string">&quot;There is no user with username of &quot;</span> + token.getPrincipal());<br>      &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice) &#123;<br>        log.info(<span class="hljs-string">&quot;Password for account &quot;</span> + token.getPrincipal() + <span class="hljs-string">&quot; was incorrect!&quot;</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (LockedAccountException lae) &#123;<br>        log.info(<span class="hljs-string">&quot;The account for username &quot;</span> + token.getPrincipal() + <span class="hljs-string">&quot; is locked.  &quot;</span> +<br>                 <span class="hljs-string">&quot;Please contact your administrator to unlock it.&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// ... catch more exceptions here (maybe custom ones specific to your application?</span><br>      <span class="hljs-keyword">catch</span> (AuthenticationException ae) &#123;<br>        <span class="hljs-comment">//认证异常</span><br>        <span class="hljs-comment">//unexpected condition?  error?</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//say who they are:</span><br>    <span class="hljs-comment">//print their identifying principal (in this case, a username):</span><br>    log.info(<span class="hljs-string">&quot;User [&quot;</span> + currentUser.getPrincipal() + <span class="hljs-string">&quot;] logged in successfully.&quot;</span>);<br><br>    <span class="hljs-comment">//test a role:</span><br>    <span class="hljs-keyword">if</span> (currentUser.hasRole(<span class="hljs-string">&quot;schwartz&quot;</span>)) &#123;<br>      log.info(<span class="hljs-string">&quot;May the Schwartz be with you!&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      log.info(<span class="hljs-string">&quot;Hello, mere mortal.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//粗粒度</span><br>    <span class="hljs-comment">//test a typed permission (not instance-level)</span><br>    <span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">&quot;lightsaber:wield&quot;</span>)) &#123;<br>      log.info(<span class="hljs-string">&quot;You may use a lightsaber ring.  Use it wisely.&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      log.info(<span class="hljs-string">&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//细粒度</span><br>    <span class="hljs-comment">//a (very powerful) Instance Level permission:</span><br>    <span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">&quot;winnebago:drive:eagle5&quot;</span>)) &#123;<br>      log.info(<span class="hljs-string">&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot;</span> +<br>               <span class="hljs-string">&quot;Here are the keys - have fun!&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      log.info(<span class="hljs-string">&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//all done - log out!</span><br>    currentUser.logout();<br><br>    System.exit(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="SpringBoot整合shiro"><a href="#SpringBoot整合shiro" class="headerlink" title="SpringBoot整合shiro"></a>SpringBoot整合shiro</h4><p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- spring整合shiro的包 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--web--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--thymeleaf--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>Shiro 配置类 config</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.config; <br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration; <br><span class="hljs-comment">//声明为配置类 </span><br><span class="hljs-meta">@Configuration</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123; <br>  <br>  <span class="hljs-comment">//创建 ShiroFilterFactoryBean </span><br>  <span class="hljs-meta">@Bean</span> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">getShiroFilterFactoryBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;securityManager&quot;)</span>DefaultWebSecurityMan ager securityManager)</span></span>&#123; <br>    ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean(); <br>    <span class="hljs-comment">//设置安全管理器 </span><br>    shiroFilterFactoryBean.setSecurityManager(securityManager); 、<br>    <span class="hljs-comment">/* 添加Shiro内置过滤器，常用的有如下过滤器： </span><br><span class="hljs-comment">      anon： 无需认证就可以访问 </span><br><span class="hljs-comment">      authc： 必须认证才可以访问 </span><br><span class="hljs-comment">      user： 如果使用了记住我功能就可以直接访问 </span><br><span class="hljs-comment">      perms: 拥有某个资源权限才可以访问 </span><br><span class="hljs-comment">      role： 拥有某个角色权限才可以访问 </span><br><span class="hljs-comment">    */</span><br>    Map&lt;String,String&gt; filterMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, String&gt;();<br>    <span class="hljs-comment">//&quot;跳转目标&quot;,&quot;权限&quot;</span><br>    filterMap.put(<span class="hljs-string">&quot;/user/add&quot;</span>,<span class="hljs-string">&quot;authc&quot;</span>); <br>    shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);<br>    <span class="hljs-keyword">return</span> shiroFilterFactoryBean; <br>  &#125;<br>  <br>  <span class="hljs-comment">//创建 DefaultWebSecurityManager </span><br>  <span class="hljs-meta">@Bean(name = &quot;securityManager&quot;)</span> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">getDefaultWebSecurityManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;userRealm&quot;)</span>UserRealm userRealm)</span></span>&#123; <br>    DefaultWebSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager(); <br>    <span class="hljs-comment">//关联Realm </span><br>    securityManager.setRealm(userRealm); <br>    <span class="hljs-keyword">return</span> securityManager; <br>  &#125;<br>  <br>  <span class="hljs-comment">//创建 realm 对象 </span><br>  <span class="hljs-meta">@Bean</span> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> UserRealm <span class="hljs-title">userRealm</span><span class="hljs-params">()</span></span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserRealm(); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>realm</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.config; <br><span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationException; <br><span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationInfo; <br><span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationToken; <br><span class="hljs-keyword">import</span> org.apache.shiro.authz.AuthorizationInfo; <br><span class="hljs-keyword">import</span> org.apache.shiro.realm.AuthorizingRealm; <br><span class="hljs-keyword">import</span> org.apache.shiro.subject.PrincipalCollection; <br><span class="hljs-comment">//自定义Realm </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123; <br>  <span class="hljs-comment">//执行授权逻辑 </span><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123; <br>    System.out.println(<span class="hljs-string">&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;</span>); <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <br>  &#125;<br>  <span class="hljs-comment">//执行认证逻辑 </span><br>  <span class="hljs-meta">@Override</span> <br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123; <br>    System.out.println(<span class="hljs-string">&quot;执行了=&gt;认证逻辑AuthenticationToken&quot;</span>); <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h3><p><a href="https://swagger.io">Swagger官方网站</a></p>
<p>Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>
<p>Swagger 的目标是对 REST API 定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过 Swagger 进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger 消除了调用服务时可能会有的猜测。</p>
<p><strong>优势</strong></p>
<ul>
<li>支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。</li>
<li>提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。</li>
</ul>
<h4 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a><strong>SpringBoot集成Swagger</strong></h4><a href="/article/37040.html" title="Swagger配置">Swagger配置</a>
<p><strong>springboot版本使用2.5.6 swagger版本使用3.0.0</strong></p>
<h4 id="Swagger-UI配置"><a href="#Swagger-UI配置" class="headerlink" title="Swagger-UI配置"></a>Swagger-UI配置</h4><p>访问测试 ：<a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a> ，可以看到swagger的界面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.swagger.config;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> springfox.documentation.oas.annotations.EnableOpenApi;<br><span class="hljs-keyword">import</span> springfox.documentation.service.ApiInfo;<br><span class="hljs-keyword">import</span> springfox.documentation.service.Contact;<br><span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<br><span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> * EnableOpenApi 开启Swagger2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableOpenApi</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  配置Swagger 的 Docket的 Bean实例</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)<br>      .apiInfo(apiInfo());<br>  &#125;<br><br>  <span class="hljs-comment">//    //配置Swagger信息 apiInfo</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;<br>    Contact contact = <span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;Bobo&quot;</span>, <span class="hljs-string">&quot;https://boyolo.github.io&quot;</span>, <span class="hljs-string">&quot;beau_renbo@163.com&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(<br>      <span class="hljs-string">&quot;BoBo Api Documentation&quot;</span>,<br>      <span class="hljs-string">&quot;Boyolo Api Documentation&quot;</span>,<br>      <span class="hljs-string">&quot;1.0&quot;</span>,<br>      <span class="hljs-string">&quot;https://boyolo.github.io&quot;</span>,<br>      contact,<br>      <span class="hljs-string">&quot;Apache 2.0&quot;</span>,<br>      <span class="hljs-string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,<br>      <span class="hljs-keyword">new</span> ArrayList());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/43108/image-20220221145938830.png" class title="image-20220221145938830">
<h4 id="swagger配置扫描接口以及开关"><a href="#swagger配置扫描接口以及开关" class="headerlink" title="swagger配置扫描接口以及开关"></a>swagger配置扫描接口以及开关</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  配置Swagger 的 Docket的 Bean实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)<br>    .apiInfo(apiInfo())<br>    <span class="hljs-comment">//是否启动swagger ，如果为false，则swagger不能再浏览器中访问</span><br>    .enable(<span class="hljs-keyword">false</span>)<br>    .select()<br>    <span class="hljs-comment">//RequestHandlerSelectors 配置要扫描接口的方式</span><br>    <span class="hljs-comment">//basePackage 指定要扫描的包  RequestHandlerSelectors.basePackage(&quot;com.bobo.swagger.controller&quot;)</span><br>    <span class="hljs-comment">//RequestHandlerSelectors.any()  扫描全部</span><br>    <span class="hljs-comment">//RequestHandlerSelectors.none() 都不扫描</span><br>    <span class="hljs-comment">//RequestHandlerSelectors.withClassAnnotation() 扫描类上的注解   参数是一个注解的反射对象</span><br>    <span class="hljs-comment">//RequestHandlerSelectors.withMethodAnnotation()  扫描方法上的注解</span><br>    .apis(RequestHandlerSelectors.withMethodAnnotation(GetMapping.class))<br>    <span class="hljs-comment">//过滤什么路径</span><br>    .paths(PathSelectors.ant(<span class="hljs-string">&quot;bobo/**&quot;</span>))<br>    .build();<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>.select() 与 .build() 属于一套</p>
<p>中间除了.apis() 与 .paths() 不能再添加其他方法</p>
</blockquote>
<p><strong>思考</strong></p>
<p>如何做使Swagger在生产环境中使用，在发布的时候不使用？</p>
<ul>
<li>判断是不是生产环境   flag == false</li>
<li>注入enable(flag)</li>
</ul>
<p><strong>配置swagger API文档的分组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docketA</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;A&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docketB</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;B&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/43108/image-20220221153135200.png" class title="image-20220221153135200">
<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>分布式系统（<em>distributed system</em>）是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。</p>
<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>RPC是远程过程调用（Remote Procedure Call）的缩写形式，是一种进程间的通信方式，是一种技术思想，而不是规范。SAP系统RPC调用的原理其实很简单，有一些类似于三层构架的C/S系统，第三方的客户程序通过接口调用SAP内部的标准或自定义函数，获得函数返回的数据进行处理后显示或打印。</p>
<p><strong>基本流程</strong></p>
<img src="/article/43108/86E55D7D3EBC4093ABAFF624FF75F523.png" class title="六、RPC基本原理_RPC基本原理">
<p>RPC两个核心模块：序列化、通讯</p>
<h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><p><a href="https://dubbo.apache.org/zh/docs/">官方文档</a></p>
<p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。</p>
<img src="/article/43108/20151223153918914.jpeg" class title="dubbo架构图">
<p>Provider: 暴露服务的服务提供方。；<br>Consumer: 调用远程服务的服务消费方；<br>Registry: 服务注册与发现的注册中心；<br>Monitor: 统计服务的调用次调和调用时间的监控中心；<br>Container: 服务运行容器。</p>
<h4 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h4><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<p><a href="https://zookeeper.apache.org/releases.html">下载地址</a></p>
<p>3.5版本以后要下载后缀为<strong>bin.tar.gz</strong>的文件</p>
<p>更改默认配置文件名称 将conf目录下 <strong>zoo_sample.cfg</strong> 改为 zoo.cfg</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">&gt; /apache-zookeeper<span class="hljs-number">-3.6</span><span class="hljs-number">.3</span>-bin/bin/zkServer.sh start<br> .jenv/shims/java<br> ZooKeeper JMX enabled <span class="hljs-keyword">by</span> <span class="hljs-literal">default</span><br> apache-zookeeper<span class="hljs-number">-3.6</span><span class="hljs-number">.3</span>- bin/bin/../conf/zoo.cfg<br> Starting zookeeper ... STARTED<br></code></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">&gt; ./zkServer.sh stop <br> ZooKeeper JMX enabled <span class="hljs-keyword">by</span> <span class="hljs-literal">default</span><br> Using config: zookeeper<span class="hljs-number">-3.4</span><span class="hljs-number">.10</span>/bin/../conf/zoo.cfg<br> Stopping zookeeper ... STOPPED<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBootWeb开发</category>
        <category>SpringBootWeb开发</category>
      </categories>
      <tags>
        <tag>SpringBootWeb开发</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot（基础配置及原理）</title>
    <url>/article/33757.html</url>
    <content><![CDATA[<blockquote>
<p>The scabbard is content to be dull when it protects the keenness of the sword.</p>
<p>刀鞘保护刀的锋利，它自己则满足于它的迟钝。</p>
</blockquote>
<h2 id="SpringBoot（基础配置及原理）"><a href="#SpringBoot（基础配置及原理）" class="headerlink" title="SpringBoot（基础配置及原理）"></a>SpringBoot（基础配置及原理）</h2><p>什么是<a href="/article/18155.html" title="Spring">Spring</a>?</p>
<h3 id="什么是SpringBoot？"><a href="#什么是SpringBoot？" class="headerlink" title="什么是SpringBoot？"></a>什么是SpringBoot？</h3><p><a href="https://spring.io/projects/spring-boot">SpringBoot官方网站</a></p>
<p>SpringBoot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架，其目的是为了简化 Spring 应用的搭建和开发过程。SpringBoot 去除了大量的 XML 配置文件，简化了复杂的依赖管理。</p>
<p>SpringBoot 具有 Spring 一切优秀特性，Spring 能做的事，SpringBoot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。随着近些年来微服务技术的流行，Spring Boot 也成了时下炙手可热的技术。</p>
<p>SpringBoot 集成了大量常用的第三方库配置，SpringBoot 应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 SpringBoot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。 </p>
<p><strong>特点</strong></p>
<p>Spring Boot 具有以下特点：</p>
<ol>
<li><p>独立运行的 Spring 项目</p>
<p>SpringBoot 可以以 jar 包的形式独立运行，SpringBoot 项目只需通过命令“ java–jar xx.jar” 即可运行。</p>
</li>
<li><p>内嵌 Servlet 容器</p>
<p>SpringBoot 使用嵌入式的 Servlet 容器（例如 Tomcat、Jetty 或者 Undertw 等），应用无需打成 WAR 包 。</p>
</li>
<li><p>提供 starter 简化 Maven 配置</p>
<p>Spring Boot 提供了一系列的“starter”项目对象模型（POMS）来简化 Maven 配置。</p>
</li>
<li><p>提供了大量的自动配置</p>
<p>SpringBoot 提供了大量的默认自动配置，来简化项目的开发，开发人员也通过配置文件修改默认配置。</p>
</li>
<li><p>自带应用监控</p>
<p>Spring Boot 可以对正在运行的项目提供监控。</p>
</li>
<li><p>无代码生成和 xml 配置</p>
<p>SpringBoot 不需要任何 xml 配置即可实现 Spring 的所有配置。</p>
</li>
</ol>
<p><strong>配置</strong></p>
<p><strong>maven中导入配置：</strong>spring-boot-starter-web、spring-boot-starter-test</p>
<a href="/article/37040.html" title="点击跳转SpringBoot配置">点击跳转SpringBoot配置</a>
<p>spring-boot-starter-web用于实现HTTP接口（该依赖中包含了SpringMVC）</p>
<p>spring-boot-starter-test用于编写单元测试的依赖包</p>
<h3 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h3><p>一种软件开发技术-面向服务的体系结构（SOA）架构样式的一种变体，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。</p>
<p>每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。</p>
<p>每个服务都围绕着具体业务进行构建，并且能够独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据上下文，选择合适的语言、工具对其进行构建。</p>
<h3 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h3><h4 id="SpringFactories-机制"><a href="#SpringFactories-机制" class="headerlink" title="SpringFactories 机制"></a>SpringFactories 机制</h4><p>SpringBoot 的自动配置是基于 SpringFactories 机制实现的。</p>
<p>SpringFactories 机制是 SpringBoot 中的一种服务发现机制，这种扩展机制与 Java SPI 机制十分相似。SpringBoot 会自动扫描所有 Jar 包类路径下 <code>META-INF/spring.factories</code> 文件，并读取其中的内容，进行实例化，这种机制也是 Spring-Boot-Starter 的基础。</p>
<p><strong>自动配置的生效和修改</strong></p>
<p>spring.factories 文件中的所有自动配置类（xxxAutoConfiguration），都是必须在一定的条件下才会作为组件添加到容器中，配置的内容才会生效。这些限制条件在 SpringBoot 中以 @Conditional 派生注解的形式体现。</p>
<a href="/article/37040.html" title="点击跳转SpringBoot自动配置注解">点击跳转SpringBoot自动配置注解</a>
<p><strong>spring.factories</strong></p>
<p>spring.factories 文件本质上与 properties 文件相似，其中包含一组或多组键值对（key=vlaue），其中，key 的取值为接口的完全限定名；value 的取值为接口实现类的完全限定名，一个接口可以设置多个实现类，不同实现类之间使用“，”隔开。</p>
<img src="/article/33757/image-20220210171223244.png" class title="image-20220210171223244">
<p><strong>SpringFactories 实现原理</strong></p>
<p>spring-core 包里定义了 SpringFactoriesLoader 类，这个类会扫描所有 Jar 包类路径下的 META-INF/spring.factories 文件，并获取指定接口的配置。在 SpringFactoriesLoader 类中定义了两个对外的方法，如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">返回值</th>
<th>方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><T>List<T></T></T></td>
<td>loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader)</T></td>
<td style="text-align:left">静态方法； <br>根据接口获取其实现类的实例； 该方法返回的是实现类对象列表。</td>
</tr>
<tr>
<td style="text-align:center">List<String></String></td>
<td>loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</td>
<td style="text-align:left">公共静态方法； <br>根据接口l获取其实现类的名称； 该方法返回的是实现类的类名的列表</td>
</tr>
</tbody>
</table>
<h4 id="SpringBoot自动装配流程"><a href="#SpringBoot自动装配流程" class="headerlink" title="SpringBoot自动装配流程"></a>SpringBoot自动装配流程</h4><ol>
<li><p><strong>spring-boot-dependencies</strong>:核心依赖在父工程中</p>
</li>
<li><p><strong>启动器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringBoot 的启动场景--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>SpringBoot会将所有的功能场景，都变成一个个的启动器。</p>
<p>要使用什么功能只要找到对应的启动器即可。</p>
<p>如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--要使用什么功能，就启动对应的启动器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>主程序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot01HelloworldApplication</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Springboot01HelloworldApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>@SpringBootApplication</code>注解</p>
<p>标注这个类是一个springboot应用  启动类下的所有资源被导入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><p><strong>@SpringBootConfiguration</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//Spring配置类，说明这也是一个组件</span><br><span class="hljs-meta">@Indexed</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>@EnableAutoConfiguration</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span>  <span class="hljs-comment">//自动配置包</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>@EnableAutoConfiguration</strong></p>
<ol>
<li><p><strong>@AutoConfigurationPackage</strong>：扫描并注册我们自己写的java类到spring容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>向容器中导入了一个AutoConfigurationPackages.Registrar的实例对象</p>
<blockquote>
<p><strong>AutoConfigurationPackages.Registrar</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">DeterminableImports</span> </span>&#123;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>			register(registry, <span class="hljs-keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br>		&#125;<br>		...<br>	&#125;<br></code></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">register(registry, <span class="hljs-keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br></code></pre></td></tr></table></figure>
<p>其实就是完成了我们自己写的类的扫描。</p>
<p>获取到的是指定扫描包的路径，如果未明确指定，默认为主启动类所在的包名。</p>
</blockquote>
</li>
<li><p><strong>@Import(AutoConfigurationImportSelector.class)</strong>：注册springboot提供的自动配置类到spring容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DeferredImportSelector</span>, <span class="hljs-title">BeanClassLoaderAware</span>,</span><br><span class="hljs-class">      <span class="hljs-title">ResourceLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">EnvironmentAware</span>, <span class="hljs-title">Ordered</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>将springboot提供好的自动配置装载进spring容器</p>
<blockquote>
<p><strong>AutoConfigurationImportSelector</strong></p>
<p>将springboot提供好的自动配置装载进spring容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法是获取所有的自动配置类的实体</p>
<p>spring-boot在启动时，默认就装载了springboot写好的127个自动配置类实体(spring.factories)，但是并没有启用，只有在引入相关依赖包的时候，这些自动配置才真正被启用，这种按需加载的原理是基于条件注解实现的</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>SpringApplication.run(Springboot01HelloworldApplication.class, args); </p>
<img src="/article/33757/%E4%B8%BB%E5%90%AF%E5%8A%A8%E7%B1%BB.png" class title="主启动类">
<p><a href="https://blog.csdn.net/qq_42261668/article/details/103029333">原理剖析</a></p>
<ol>
<li><p>run方法</p>
<p>大多数应用程序上下文(如果不是全部的话)将实现SPI（服务提供者）接口。</p>
<p>这里<strong>封装了配置和生命周期方法</strong>，以避免它们被ApplicationContext客户端代码发现（避免配置文件被公开给使用者）。目前的方法只能在启动和关闭代码中使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;···&#125;<br>---------------------------------------------------------<br><span class="hljs-comment">//可配置的应用上下文</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource,String... args)</span> </span>&#123;<br>    <span class="hljs-comment">//重载传入 将要被加载的类放到一个对应的CLASS数组中</span><br>    <span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);<br>  &#125;<br>  ---------------------------------------------------------<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources,String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建一个启动类传入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(primarySources).run(args);<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>run()方法启动Spring应用，实质上是为Spring应用创建并初始化Spring上下文</p>
<blockquote>
<ol>
<li>推断应用的类型是普通的项目还是Web项目</li>
<li>查找并加载所有可用初始化器，设置到initializers属性中</li>
<li>找出所有的应用程序监听器，设置到listeners属性中</li>
<li>推断并设置main方法的定义类，找到运行的主类</li>
</ol>
</blockquote>
<p>在启动时会加载三个jar将其对应的spring.factories工厂文件的接口实现类到MultiValueMap集合当中，并将对应加载器作为key,接口实现类作为value放到缓存当中</p>
<ul>
<li>spring-boot-2.1.3.RELEASE.jar!/META-INF/spring.factories</li>
<li>spring-boot-autocinfiggure-2.1.3.RELEASE.jar!/META-INF/spring.factories</li>
<li>spring-bean-5.1.5.RELEASE.jar!/META-INF/spring.factories</li>
</ul>
<blockquote>
<p><strong>执行流程：</strong></p>
<ol>
<li><p>初始化监听器，以及添加到SpringApplication的自定义监听器;</p>
</li>
<li><p>发布ApplicationStartedEvent事件;</p>
</li>
<li><p>装配参数和环境，确定是web环境还是非web环境;</p>
</li>
<li><p>装配完环境后，就触发ApplicationEnvironmentPreparedEvent事件;</p>
</li>
<li><p>如果SpringApplication的showBanner属性被设置为true，则打印启动的Banner;</p>
</li>
<li><p>创建ApplicationContext，会根据是否是web环境，来决定创建什么类型的ApplicationContext;</p>
</li>
<li><p>装配Context的环境变量，注册Initializers、beanNameGenerator等;</p>
</li>
<li><p>发布ApplicationPreparedEvent事件;</p>
</li>
<li><p>注册springApplicationArguments、springBootBanner，加载资源等;</p>
</li>
<li><p>遍历调用所有SpringApplicationRunListener的contextLoaded()方法;</p>
</li>
<li><p>调用ApplicationContext的refresh()方法,装配context beanfactory等非常重要的核心组件;</p>
</li>
<li><p>查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们;</p>
</li>
<li><p>发布ApplicationReadyEvent事件，启动完毕，表示服务已经可以开始正常提供服务了。通常我们这里会监听这个事件来打印一些监控性质的日志，表示应用正常启动了。</p>
</li>
</ol>
<p>SpringBoot会触发其他的一些事件，这些事件按下列顺序触发：</p>
<p>（1）ApplicationStartingEvent：项目刚启动时触发，此时除了注册监听器和初始器之外，其他所有处理都没有开始；</p>
<p>（2）ApplicationEnvironmentPreparedEvent：上下文得到环境信息之后触发，此时上下文创建还没有创建；</p>
<p>（3）ApplicationPreparedEvent：bean的定义信息加载完成之后触发，此时bean还没有初始化；</p>
<p>（4）ApplicationReadyEvent：在所有bean初始化完毕，所有回调处理完成，系统准备处理服务请求时触发；</p>
<p>（5）ApplicationFailedEvent：启动过程出现异常时候触发。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<pre><code>2. **SpringApplication构造器**

   <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, primarySources);<br>&#125;<br></code></pre></td></tr></table></figure>

   <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;<br>  <span class="hljs-comment">//null</span><br>  <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;<br>  <span class="hljs-comment">//断言  PrimarySources 不能为空</span><br>  Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>  <span class="hljs-comment">//将传过来对象数组放到集合中 并为primarySources 赋值</span><br>  <span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));<br>  <span class="hljs-comment">//推断webApplicationType 的枚举类型 一般都是SERVLET 标准webservice</span><br>  <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>  <span class="hljs-comment">//设置初始化器 读取一些控制器 </span><br>  <span class="hljs-comment">//获取实现了ApplicationContextInitializer初始化器的工厂并将其实例化 读取相应的一些控制器</span><br>  setInitializers((Collection) getSpringFactoriesInstances(<br>    ApplicationContextInitializer.class));<br>  <span class="hljs-comment">//设置监听器 流程同上</span><br>  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br>  <span class="hljs-comment">//存储带有main方法的启动对象（本例MyApplication）</span><br>  <span class="hljs-comment">//deduceMainApplicationClass 获取推断主应用类 获取对应的MyApplication.class</span><br>  <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure>

   [构造方法内容详解](https://blog.csdn.net/qq_42261668/article/details/103029333)
</code></pre><h3 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h3><p>SpringBoot 提供了大量的自动配置，极大地简化了spring 应用的开发过程，当用户创建了一个 SpringBoot 项目后，即使不进行任何配置，该项目也能顺利的运行起来。当然，用户也可以根据自身的需要使用配置文件修改 SpringBoot 的默认设置。</p>
<p>SpringBoot 默认使用以下 2 种全局的配置文件，其文件名是固定的。</p>
<ul>
<li>application.properties</li>
<li>application.yml</li>
</ul>
<p>YAML 全称 YAML Ain’t Markup Language，它是一种以数据为中心的标记语言，比 XML 和 JSON 更适合作为配置文件。</p>
<p>想要使用 YAML 作为属性配置文件（以 .yml 或 .yaml 结尾），需要将 SnakeYAML 库添加到 classpath 下，SpringBoot 中的 spring-boot-starter-web 或 spring-boot-starter 都对 SnakeYAML 库做了集成， 只要项目中引用了这两个 Starter 中的任何一个，SpringBoot 会自动添加 SnakeYAML 库到 classpath 下。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><p><strong>YAML 的语法如下：</strong></p>
<ul>
<li>使用缩进表示层级关系。</li>
<li>缩进时不允许使用 Tab 键，只允许使用空格。</li>
<li>缩进的空格数不重要，但同级元素必须左侧对齐。</li>
<li>大小写敏感。</li>
<li>‘#’表示注释</li>
</ul>
<p><strong>YAML 支持以下三种数据结构：</strong></p>
<ul>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li>
<li>字面量：单个的、不可拆分的值</li>
</ul>
<p><strong>YAML 字面量写法</strong></p>
<p>字面量是指单个的，不可拆分的值，例如：数字、字符串、布尔值、以及日期等。</p>
<p>字面量直接写在键值对的“value<strong>”</strong>中即可，且默认情况下字符串是不需要使用单引号或双引号的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">boolean:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-literal">TRUE</span>  <span class="hljs-comment">#true,True都可以</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-literal">FALSE</span>  <span class="hljs-comment">#false，False都可以</span><br><span class="hljs-attr">float:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">3.14</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">6.8523015e+5</span>  <span class="hljs-comment">#可以使用科学计数法</span><br><span class="hljs-attr">int:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">123</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">0b1010_0111_0100_1010_1110</span>    <span class="hljs-comment">#二进制表示</span><br><span class="hljs-attr">null:</span><br>    <span class="hljs-attr">nodeName:</span> <span class="hljs-string">&#x27;node&#x27;</span><br>    <span class="hljs-attr">parent:</span> <span class="hljs-string">~</span>  <span class="hljs-comment">#使用~表示null</span><br><span class="hljs-attr">string:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">哈哈</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;Hello world&#x27;</span>  <span class="hljs-comment">#可以使用双引号或者单引号包裹特殊字符</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">newline</span><br>      <span class="hljs-string">newline2</span>    <span class="hljs-comment">#字符串可以拆成多行，每一行会被转化成一个空格</span><br><span class="hljs-attr">date:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">2018-02-17</span>    <span class="hljs-comment">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="hljs-attr">datetime:</span> <br>    <span class="hljs-bullet">-</span>  <span class="hljs-number">2018-02-17T15:02:31+08:00</span>    <span class="hljs-comment">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br></code></pre></td></tr></table></figure>
<p><strong>YAML 对象写法</strong></p>
<p>在 YAML 中，对象可能包含多个属性，每一个属性都是一对键值对。<br>YAML 为对象提供了 2 种写法：</p>
<p>普通写法，使用缩进表示对象与属性的层级关系。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">key:</span> <br> <span class="hljs-attr">child-key:</span> <span class="hljs-string">value</span><br> <span class="hljs-attr">child-key2:</span> <span class="hljs-string">value2</span><br></code></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">?</span>  <br> <span class="hljs-bullet">-</span> <span class="hljs-string">complexkey1</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">complexkey2</span><br><span class="hljs-string">:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">complexvalue1</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">complexvalue2</span><br><span class="hljs-comment">#对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]</span><br></code></pre></td></tr></table></figure>
<p>行内写法：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">website:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">bianchengbang</span>,<span class="hljs-attr">url:</span> <span class="hljs-string">www.biancheng.net</span>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>YAML 数组写法</strong></p>
<p>YAML 使用“-”表示数组中的元素，普通写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">A</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">B</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">C</span><br></code></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">key</span>:<span class="hljs-meta"> [value1, value2, ...]</span><br></code></pre></td></tr></table></figure>
<p><strong>复合结构</strong></p>
<p>以上三种数据结构可以任意组合使用，以实现不同的用户需求</p>
<p><strong>引用</strong></p>
<p><strong>&amp;</strong> 锚点和 <strong>*</strong> 别名，可以用来引用:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">defaults:</span> <span class="hljs-meta">&amp;defaults</span><br>  <span class="hljs-attr">adapter:</span>  <span class="hljs-string">postgres</span><br>  <span class="hljs-attr">host:</span>     <span class="hljs-string">localhost</span><br><br><span class="hljs-attr">development:</span><br>  <span class="hljs-attr">database:</span> <span class="hljs-string">myapp_development</span><br>  <span class="hljs-string">&lt;&lt;:</span> <span class="hljs-meta">*defaults</span><br><br><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">database:</span> <span class="hljs-string">myapp_test</span><br>  <span class="hljs-string">&lt;&lt;:</span> <span class="hljs-meta">*defaults</span><br></code></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">defaults:</span><br>  <span class="hljs-attr">adapter:</span>  <span class="hljs-string">postgres</span><br>  <span class="hljs-attr">host:</span>     <span class="hljs-string">localhost</span><br><br><span class="hljs-attr">development:</span><br>  <span class="hljs-attr">database:</span> <span class="hljs-string">myapp_development</span><br>  <span class="hljs-attr">adapter:</span>  <span class="hljs-string">postgres</span><br>  <span class="hljs-attr">host:</span>     <span class="hljs-string">localhost</span><br><br><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">database:</span> <span class="hljs-string">myapp_test</span><br>  <span class="hljs-attr">adapter:</span>  <span class="hljs-string">postgres</span><br>  <span class="hljs-attr">host:</span>     <span class="hljs-string">localhost</span><br></code></pre></td></tr></table></figure>
<p><strong>&amp;</strong> 用来建立锚点（defaults），<strong>&lt;&lt;</strong> 表示合并到当前数据，<strong>*</strong> 用来引用锚点。</p>
<p><strong>YAML 组织结构</strong></p>
<p>YAML 文件可以由一或多个文档组成（也即相对独立的组织结构组成），文档间使用“—”（三个横线）在每文档开始作为分隔符,且个文档相互独立，互不干扰。同时，文档也可以使用“…”（三个点号）作为结束符（可选）。如果只是单个文档，分隔符“—”可省略。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">---website:</span>  <span class="hljs-attr">name: bianchengbang  url:</span> <span class="hljs-string">www.biancheng.net</span><br><span class="hljs-string">---website:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">bianchengbang</span>,<span class="hljs-attr">url:</span> <span class="hljs-string">www.biancheng.net</span>&#125;<span class="hljs-attr">pets:  -dog  -cat  -pig---pets:</span> [<span class="hljs-string">dog</span>,<span class="hljs-string">cat</span>,<span class="hljs-string">pig</span>]<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;zhangsan \n lisi&quot;</span><span class="hljs-string">---name:</span> <span class="hljs-string">&#x27;zhangsan \n lisi&#x27;</span><br></code></pre></td></tr></table></figure>
<h4 id="给属性赋值"><a href="#给属性赋值" class="headerlink" title="给属性赋值"></a>给属性赋值</h4><p><strong>@ConfigurationProperties</strong>：告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定；</p>
<p>prefix = “ClassName”：配置文件中哪个下面的所有属性进行一一映射</p>
<p>例：</p>
<ol>
<li><p>在全局配置文件 application.yml 中添加以下自定义属性</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">person:</span><br>  <span class="hljs-attr">lastName:</span> <span class="hljs-string">bobo</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">boss:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">birth:</span> <span class="hljs-number">1997</span><span class="hljs-string">/07/09</span><br>  <span class="hljs-attr">maps:</span> &#123; <span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>,<span class="hljs-attr">k2:</span> <span class="hljs-number">12</span> &#125;<br>  <span class="hljs-attr">lists:</span><br>    <span class="hljs-string">‐</span> <span class="hljs-number">111</span><br>    <span class="hljs-string">‐</span> <span class="hljs-number">222</span><br>  <span class="hljs-attr">dog:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">旺财</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>创建一个名为 Person 的实体类，并将配置文件中的属性映射到这个实体类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将配置文件中配置的每一个属性的值，映射到这个组件中</span><br><span class="hljs-comment">* 只有这个组件是容器中的组件，才能使用容器提供的<span class="hljs-doctag">@ConfigurationProperties</span>功能；</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String lastName;<br>  <span class="hljs-keyword">private</span> Integer age;<br>  <span class="hljs-keyword">private</span> Boolean boss;<br>  <span class="hljs-keyword">private</span> Date birth;<br>  <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; maps;<br>  <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;<br>  <span class="hljs-keyword">private</span> Dog dog;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;lastName=&#x27;&quot;</span> + lastName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>      <span class="hljs-string">&quot;, boss=&quot;</span> + boss +<br>      <span class="hljs-string">&quot;, birth=&quot;</span> + birth +<br>      <span class="hljs-string">&quot;, maps=&quot;</span> + maps +<br>      <span class="hljs-string">&quot;, lists=&quot;</span> + lists +<br>      <span class="hljs-string">&quot;, dog=&quot;</span> + dog +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String age;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>@Value</strong></p>
<p>只需要读取配置文件中的某一个配置时，可以通过 @Value 注解获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> net.biancheng.www.bean;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-meta">@Value(&quot;$&#123;person.lastName&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> String lastName;<br>  <span class="hljs-meta">@Value(&quot;$&#123;person.age&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> Integer age;<br>  <span class="hljs-meta">@Value(&quot;$&#123;person.boss&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> Boolean boss;<br>  <span class="hljs-meta">@Value(&quot;$&#123;person.birth&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> Date birth;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;lastName=&#x27;&quot;</span> + lastName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>      <span class="hljs-string">&quot;, boss=&quot;</span> + boss +<br>      <span class="hljs-string">&quot;, birth=&quot;</span> + birth +<br>      <span class="hljs-string">&quot;, maps=&quot;</span> + maps +<br>      <span class="hljs-string">&quot;, lists=&quot;</span> + lists +<br>      <span class="hljs-string">&quot;, dog=&quot;</span> + dog +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<a href="/article/37040.html" title="点击跳转SpringBoot注解">点击跳转SpringBoot注解</a>
<h3 id="给属性赋值的两种方法"><a href="#给属性赋值的两种方法" class="headerlink" title="给属性赋值的两种方法"></a>给属性赋值的两种方法</h3><ol>
<li><p>通过yaml文件赋值</p>
<p><a href="#给属性赋值">点击跳转通过yaml文件注解赋值</a></p>
<p>第一种方法通过<strong>@ConfigurationProperties</strong>或<strong>@Value</strong>给属性赋值</p>
</li>
<li><p>通过注解<strong>@PropertySource</strong>给属性赋值</p>
<p>如果将所有的配置都集中到 <code>application.properties</code> 或 <code>application.yml</code>中，那么这个配置文件会十分的臃肿且难以维护，因此我们通常会将与 SpringBoot 无关的配置（例如自定义配置）提取出来，写在一个单独的配置文件中，并在对应的 JavaBean 上使用 @PropertySource 注解指向该配置文件。</p>
<a href="/article/37040.html" title="点击跳转SpringBoot注解">点击跳转SpringBoot注解</a>
<p>例：</p>
<ol>
<li><p><strong>将与 <code>person</code> 相关的自定义配置移动到 <code>src/main/resources</code> 下的 <code>person.properties</code> 中（注意，必须把 application.properties 或 application.yml 中的相关配置删除）</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">person.last-name</span>=<span class="hljs-string">李四</span><br><span class="hljs-meta">person.age</span>=<span class="hljs-string">12</span><br><span class="hljs-meta">person.birth</span>=<span class="hljs-string">2000/12/15</span><br><span class="hljs-meta">person.boss</span>=<span class="hljs-string">false</span><br><span class="hljs-meta">person.maps.k1</span>=<span class="hljs-string">v1</span><br><span class="hljs-meta">person.maps.k2</span>=<span class="hljs-string">14</span><br><span class="hljs-meta">person.lists</span>=<span class="hljs-string">a,b,c</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在 Person 使用 @PropertySource 注解指向 person.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> net.biancheng.www.bean;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.PropertySource;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@PropertySource(value = &quot;classpath:person.properties&quot;)</span><span class="hljs-comment">//指向对应的配置文件</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String lastName;<br>  <span class="hljs-keyword">private</span> Integer age;<br>  <span class="hljs-keyword">private</span> Boolean boss;<br>  <span class="hljs-keyword">private</span> Date birth;<br>  <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; maps;<br>  <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;lastName=&#x27;&quot;</span> + lastName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>      <span class="hljs-string">&quot;, boss=&quot;</span> + boss +<br>      <span class="hljs-string">&quot;, birth=&quot;</span> + birth +<br>      <span class="hljs-string">&quot;, maps=&quot;</span> + maps +<br>      <span class="hljs-string">&quot;, lists=&quot;</span> + lists +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="多-Profile-文件方式"><a href="#多-Profile-文件方式" class="headerlink" title="多 Profile 文件方式"></a>多 Profile 文件方式</h4><p>在实际的项目开发中，一个项目通常会存在多个环境。</p>
<p>SpringBoot 的配置文件共有两种形式：.properties 文件和 .yml 文件，不管哪种形式，它们都能通过文件名的命名形式区分出不同的环境的配置，文件命名格式为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">application-&#123;profile&#125;.properties/yml</span><br></code></pre></td></tr></table></figure>
<p>其中，{profile} 一般为各个环境的名称或简称，例如 dev、test 和 prod 等等。</p>
<p>在 项目 的 src/main/resources 下添加 4 个配置文件：</p>
<ul>
<li>application.properties/yml：主配置文件</li>
<li>application-dev.properties/yml：开发环境配置文件</li>
<li>application-test.properties/yml：测试环境配置文件</li>
<li>application-prod.properties/yml：生产环境配置文件</li>
</ul>
<p>激活配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#properties 激活指定的profile</span><br><span class="hljs-meta">spring.profiles.active</span>=<span class="hljs-string">prod</span><br></code></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#yml 激活开发环境配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#激活开发环境配置</span><br></code></pre></td></tr></table></figure>
<h4 id="多-Profile-文档块模式"><a href="#多-Profile-文档块模式" class="headerlink" title="多 Profile 文档块模式"></a>多 Profile 文档块模式</h4><p>在 YAML 配置文件中，可以使用“—”把配置文件分割成了多个文档块，因此我们可以在不同的文档块中针对不同的环境进行不同的配置，并在第一个文档块内对配置进行切换。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#默认配置</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-comment">#切换配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">test</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#开发环境</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">activate:</span><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">dev</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#测试环境</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">activate:</span><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">test</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#生产环境</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">activate:</span><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">prod</span><br></code></pre></td></tr></table></figure>
<h4 id="Spring-Boot默认配置文件"><a href="#Spring-Boot默认配置文件" class="headerlink" title="Spring Boot默认配置文件"></a>Spring Boot默认配置文件</h4><p>通常情况下，SpringBoot 在启动时会将 resources 目录下的 application.properties 或 apllication.yml 作为其默认配置文件，我们可以在该配置文件中对项目进行配置，但这并不意味着 SpringBoot 项目中只能存在一个 application.properties 或 application.yml。</p>
<p>SpringBoot 项目中可以存在多个 application.properties 或 apllication.yml。</p>
<p>SpringBoot 启动时会扫描以下 5 个位置的 application.properties 或 apllication.yml 文件，并将它们作为 Spring boot 的默认配置文件。</p>
<ol>
<li>file:./config/</li>
<li>file:./config/*/</li>
<li>file:./</li>
<li>classpath:/config/</li>
<li>classpath:/</li>
</ol>
<blockquote>
<p>注：file: 指当前项目根目录；classpath: 指当前项目的类路径，即 resources 目录。</p>
</blockquote>
<p>以上所有位置的配置文件都会被加载，且它们<strong>优先级依次降低，序号越小优先级越高</strong>。其次，位于相同位置的 application.properties 的优先级高于 application.yml。</p>
<p><strong>高优先级配置会覆盖低优先级配置，形成互补配置</strong>，即：</p>
<ul>
<li>存在相同的配置内容时，高优先级的内容会覆盖低优先级的内容；</li>
<li>存在不同的配置内容时，高优先级和低优先级的配置内容取并集。</li>
</ul>
<p><strong>SpringBoot 配置文件加载位置及优先级</strong></p>
<img src="/article/33757/1544595010-1.png" class title="SpringBoot 配置文件加载顺序">
<ul>
<li>/myBoot：表示 JAR 包所在目录，目录名称自定义；</li>
<li>/childDir：表示 JAR 包所在目录下 config 目录的子目录，目录名自定义；</li>
<li>JAR：表示 Spring Boot 项目打包生成的 JAR；</li>
<li><strong>其余带有“/”标识的目录的目录名称均不能修改。</strong></li>
<li>红色数字：表示该配置文件的优先级，数字越小优先级越高。</li>
</ul>
<p>这些配置文件得优先级顺序，遵循以下规则：</p>
<ol>
<li>先加载 JAR 包外的配置文件，再加载 JAR 包内的配置文件；</li>
<li>先加载 config 目录内的配置文件，再加载 config 目录外的配置文件；</li>
<li>先加载 config 子目录下的配置文件，再加载 config 目录下的配置文件；</li>
<li>先加载 appliction-{profile}.properties/yml，再加载 application.properties/yml；</li>
<li>先加载 .properties 文件，再加载 .yml 文件。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/article/3410.html</url>
    <content><![CDATA[<blockquote>
<p>Let life be beautiful like summer flowers and death like autumn leaves.</p>
<p>使生如夏花之绚烂，死如秋叶之静美。　　</p>
</blockquote>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON: <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation(JavaScript 对象表示法)</p>
<p>JSON 是存储和交换文本信息的语法，类似 XML。</p>
<p>JSON 比 XML 更小、更快，更易解析。</p>
<p>JSON 是轻量级的文本数据交换格式</p>
<p>JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。</p>
<p>JSON 具有自我描述性，更易理解</p>
<h3 id="JSON-语法"><a href="#JSON-语法" class="headerlink" title="JSON 语法"></a>JSON 语法</h3><p><strong>语法规则</strong></p>
<p>JSON 语法是 JavaScript 对象表示语法的子集。</p>
<ul>
<li><p>数据在名称/值对中</p>
</li>
<li><p>数据由逗号分隔</p>
</li>
<li><p>大括号 <strong>{}</strong> 保存对象</p>
</li>
<li><p>中括号 <strong>[]</strong> 保存数组，数组可以包含多个对象</p>
<p>数组可包含多个对象：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">[<br>    &#123; key1 : value1<span class="hljs-number">-1</span> , key2:value1<span class="hljs-number">-2</span> &#125;, <br>    &#123; key1 : value2<span class="hljs-number">-1</span> , key2:value2<span class="hljs-number">-2</span> &#125;, <br>    &#123; key1 : value3<span class="hljs-number">-1</span> , key2:value3<span class="hljs-number">-2</span> &#125;, <br>    ...<br>    &#123; key1 : valueN<span class="hljs-number">-1</span> , key2:valueN<span class="hljs-number">-2</span> &#125;, <br>]<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>JSON 名称/值对</strong></p>
<p>JSON 数据的书写格式是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">key : value<br></code></pre></td></tr></table></figure>
<p>名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值</p>
<p>JSON 值可以是：</p>
<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在中括号中）</li>
<li>对象（在大括号中）</li>
<li>null</li>
</ul>
<hr>
<p><strong>JSON 文件</strong></p>
<ul>
<li>JSON 文件的文件类型是 <strong>.json</strong></li>
<li>JSON 文本的 MIME 类型是 <strong>application/json</strong></li>
</ul>
<h3 id="Json方法"><a href="#Json方法" class="headerlink" title="Json方法"></a>Json方法</h3><p>JSON 通常用于与服务端交换数据。</p>
<p>在接收服务器数据时一般是字符串。</p>
<h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a><strong>JSON.parse()</strong></h4><p>将一个 JSON 字符串转换为 JavaScript 对象。</p>
<p>我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">JSON.parse(text[, reviver])<br></code></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>text:</strong>必需， 一个有效的 JSON 字符串。</li>
<li><strong>reviver:</strong> 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。</li>
</ul>
<p><strong>异常</strong></p>
<p>解析数据:</p>
<p>JSON 不能存储 Date 对象。如果你需要存储 Date 对象，需要将其转换为字符串。之后再将字符串转换为 Date 对象。</p>
<p><strong>解析函数</strong></p>
<p>JSON 不允许包含函数，但你可以将函数作为字符串存储，之后再将字符串转换为函数。</p>
<h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a><strong>JSON.stringify()</strong></h4><p>用于将 JavaScript 值转换为 JSON 字符串。</p>
<p>我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">JSON.stringify(value[, replacer[, space]])<br></code></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><p>value:</p>
<p>必需， 要转换的 JavaScript 值（通常为对象或数组）。</p>
</li>
<li><p>replacer:</p>
<p>可选。用于转换结果的函数或数组。</p>
<p>如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。</p>
<p>如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。</p>
</li>
<li><p>space:</p>
<p>可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\t。</p>
</li>
</ul>
<p><strong>解析数据</strong></p>
<p>JSON 不能存储 Date 对象。</p>
<p>JSON.stringify() 会将所有日期转换为字符串。</p>
<p><strong>解析函数</strong></p>
<p>JSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value。</p>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><p>由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。</p>
<p>eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> obj = eval (<span class="hljs-string">&quot;(&quot;</span> + txt + <span class="hljs-string">&quot;)&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p><strong>对象语法</strong></p>
<p>JSON 对象使用在大括号({})中书写。</p>
<p>对象可以包含多个 <strong>key/value（键/值）</strong>对。</p>
<p>key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。</p>
<p>key 和 value 中使用冒号(:)分割。</p>
<p>每个 key/value 对使用逗号(,)分割。</p>
<p><strong>访问对象值</strong></p>
<p>可以使用点号 . 来访问对象的值；</p>
<p>也可以使用中括号 [] 来访问对象的值。</p>
<p><strong>嵌套 JSON 对象</strong></p>
<p>JSON 对象中可以包含另外一个 JSON 对象</p>
<p><strong>修改值</strong></p>
<p>可以使用点号 . 来修改 JSON 对象的值</p>
<p>可以使用中括号 [] 来修改 JSON 对象的值</p>
<p><strong>删除对象属性</strong></p>
<p>我们可以使用 <strong>delete</strong> 关键字来删除 JSON 对象的属性</p>
<h3 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h3><p>JSON 数组在中括号中书写。</p>
<p>JSON 中数组值必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。</p>
<p>JavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript 的表达式，包括函数，日期，及 <em>undefined</em>。</p>
<p><strong>JSON 对象中的数组</strong></p>
<p>对象属性的值可以是一个数组，我们可以使用索引值来访问数组</p>
<p><strong>嵌套 JSON 对象中的数组</strong></p>
<p>JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象</p>
<p><strong>修改数组值</strong></p>
<p>可以使用索引值来修改数组值</p>
<p><strong>删除数组属性</strong></p>
<p>我们可以使用 <strong>delete</strong> 关键字来删除 JSON 数组元素</p>
<h3 id="Json乱码问题"><a href="#Json乱码问题" class="headerlink" title="Json乱码问题"></a>Json乱码问题</h3><p>在SpringMVC配置文件中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    JSON乱码问题解决--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span> <span class="hljs-attr">register-defaults</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;objectMapper&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;failOnEmptyBeans&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JSON</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/article/4780.html</url>
    <content><![CDATA[<blockquote>
<p>In my solitude of heart I feel the sigh of this widowed evening veiled with mist and rain.</p>
<p>这寡独的黄昏，幕着雾与雨，我在我的心的孤寂里，感觉到它的叹息。　</p>
</blockquote>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html">SpringMVC官方文档</a></p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。</p>
<p><strong>Spring MVC 是结构最清晰的 Servlet+JSP+JavaBean 的实现</strong></p>
<p>在 Spring MVC 框架中，Controller 替换 Servlet 来担负控制器的职责，用于接收请求，调用相应的 Model 进行处理，处理器完成业务处理后返回处理结果。Controller 调用相应的 View 并对处理结果进行视图渲染，最终客户端得到响应信息。</p>
<p>Spring的模型-视图-控制器（MVC）框架是围绕一个<code>DispatcherServlet</code>来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。</p>
<p>在Spring Web MVC中，你可以使用任何对象来作为命令对象或表单返回对象，而无须实现一个框架相关的接口或基类。</p>
<p><strong>使用SpringMVC基础配置</strong></p>
<a href="/article/37040.html" title="点击跳转springmvc">点击跳转springmvc</a>
<h3 id="原生配置实现SpringMVC"><a href="#原生配置实现SpringMVC" class="headerlink" title="原生配置实现SpringMVC"></a>原生配置实现SpringMVC</h3><p><strong>SpringMVC执行原理</strong></p>
<img src="/article/4780/1619751763609616.png" class title="img">
<p><code>DispatcherServlet</code>其实就是个<code>Servlet</code>（它继承自<code>HttpServlet</code>基类），同样也需要在你web应用的<code>web.xml</code>配置文件下声明。你需要在<code>web.xml</code>文件中把你希望<code>DispatcherServlet</code>处理的请求映射到对应的URL上去。</p>
<blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.bobo.servlet.helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<img src="/article/4780/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90.jpg" class title="springmvc执行流程解析">
</blockquote>
<img src="/article/4780/1066923-20190307172453210-409890354-20220125171300287.png" class title="img">
<p>实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现</p>
<ol>
<li><p>DispatcherServlet表示前置控制器，使整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求；</p>
<ul>
<li>假设请求为：<a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></li>
<li><a href="http://localhost:8080服务器域名">http://localhost:8080服务器域名</a></li>
<li>SpringMVC表示部署在服务器上的web站点</li>
<li>hello表示控制器</li>
<li>通过分析，如上请求表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器</li>
</ul>
<blockquote>
<img src="/article/4780/image-20220125170144231.png" class title="image-20220125170144231">
</blockquote>
</li>
<li><p>HandlerMapping为处理器映射，DispatcherServlet调用HandlerMapping，HandlerMapping根据请求查找Handler；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Handler 处理器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.Controller.HelloController&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>HandlerExecution表示具体的Handler，其主要作用是根据请求查找控制器，比如 <em>SpringMVC站点的hello控制器</em>；</p>
</li>
<li><p>HandlerExecution将解析后的信息传递给DispatcherServlet，如解析控制器映射等；</p>
<blockquote>
<img src="/article/4780/image-20220125170209664.png" class title="image-20220125170209664">
</blockquote>
</li>
<li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler；</p>
</li>
<li><p>Handler让具体的Controller执行；</p>
<blockquote>
<img src="/article/4780/image-20220125170358415.png" class title="image-20220125170358415">
</blockquote>
</li>
<li><p>controller将具体执行的信息返回给HandlerAdapter，如ModelAndView；</p>
<blockquote>
<img src="/article/4780/image-20220125170447409.png" class title="image-20220125170447409">
</blockquote>
</li>
<li><p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet调用试图解析器（ViewResolver）来解析HandlerAdapter传递的逻辑视图名；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView</span><br><span class="hljs-comment">    1。获取了ModelAndView中的数据</span><br><span class="hljs-comment">    2。解析ModelAndView中的视图名</span><br><span class="hljs-comment">    3。拼接视图名字，找到对应视图</span><br><span class="hljs-comment">    4。将数据渲染到视图上</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<img src="/article/4780/image-20220125170532472.png" class title="image-20220125170532472">
</blockquote>
</li>
<li><p>视图解析器将解析的逻辑视图名传递给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图；</p>
</li>
<li><p>最终视图呈现给用户。</p>
<blockquote>
<img src="/article/4780/image-20220125170607589.png" class title="image-20220125170607589">
</blockquote>
</li>
</ol>
<h3 id="注解开发SpringMVC"><a href="#注解开发SpringMVC" class="headerlink" title="注解开发SpringMVC"></a>注解开发SpringMVC</h3><p>首先，进行<a href="/article/37040.html" title="SpringMVC基础配置+注解配置">SpringMVC基础配置+注解配置</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bobo.controller&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 让Spring MVC不处理静态资源    .css .js  .html .mp3 .mp4 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 支持mvc注解驱动</span><br><span class="hljs-comment">在spring中一般采用@RequestMapping注解来完成映射关系</span><br><span class="hljs-comment">要想使@RequestMapping注解生效</span><br><span class="hljs-comment">必须向上下文中注册DefaultAnnotationHandlerMapping</span><br><span class="hljs-comment">和一个AnnotationMethodHandlerAdapter实例</span><br><span class="hljs-comment">这两个实例分别在类级别和方法级别处理。</span><br><span class="hljs-comment">而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>pring 2.5以后引入了基于注解的编程模型，你可以在你的控制器实现上添加<code>@RequestMapping</code>、<code>@RequestParam</code>、<code>@ModelAttribute</code>等注解。</p>
<a href="/article/37040.html" title="点击跳转注解，查看SpringMVC相关注解">点击跳转注解，查看SpringMVC相关注解</a>
<p><strong>实例</strong></p>
<blockquote>
<p><code>HelloController</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.controller;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.ui.Model;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/h1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        <span class="hljs-comment">//封装数据</span><br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;Hello,SpringMVCAnnotation&quot;</span>);<br><br>        <span class="hljs-comment">//会被视图解析器处理</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>hello.jsp</code></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%--<br>  Created by IntelliJ IDEA.<br>  User: pro<br>  Date: <span class="hljs-number">2021</span>/<span class="hljs-number">10</span>/<span class="hljs-number">14</span><br>  Time: <span class="hljs-number">23</span>:<span class="hljs-number">10</span><br>  To change <span class="hljs-keyword">this</span> template use File | Settings | File Templates.<br>--%&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>  &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>$&#123;msg&#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>控制器Controller</strong></p>
<ol>
<li>控制器负责提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现；</li>
<li>控制器负责解析用户的请求并将其转换为一个模型；</li>
<li>在Spring MVC中一个控制器类可以包含多个方法；</li>
<li>在SpringMVC中，对Controller的配置方法有很多种。</li>
</ol>
<h3 id="Spring-MVC-视图重定向"><a href="#Spring-MVC-视图重定向" class="headerlink" title="Spring MVC 视图重定向"></a>Spring MVC 视图重定向</h3><p>控制器通常都会返回一个逻辑视图名，然后视图解析器会把它解析到一个具体的视图技术上去渲染。</p>
<p><strong>重定向前缀——redirect:</strong></p>
<p><code>redirect:</code>。如果返回的视图名中含有<code>redirect:</code>前缀，那么<code>UrlBasedViewResolver</code>（及它的所有子类）就会接受到这个信号，意识到这里需要发生重定向。然后视图名剩下的部分会被解析成重定向URL。</p>
<p>这种方式与通过控制器返回一个重定向视图<code>RedirectView</code>所达到的效果是一样的，不过这样一来控制器就可以只专注于处理并返回逻辑视图名了。</p>
<p><strong>重定向前缀——forward:</strong></p>
<p>对于最终会被<code>UrlBasedViewResolver</code>或其子类解析的视图名，你可以使用一个特殊的前缀：<code>forward:</code>。这会导致一个<code>InternalResourceView</code>视图对象的创建（它最终会调用<code>RequestDispatcher.forward()</code>方法），后者会认为视图名剩下的部分是一个URL</p>
<h2 id="RestFul风格"><a href="#RestFul风格" class="headerlink" title="RestFul风格"></a>RestFul风格</h2><p>一种软件架构风格、设计风格，而<strong>不是</strong>标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p><strong>特性</strong></p>
<ol>
<li><p><strong>表现层(Representation)</strong>：把资源具体呈现出来的形式，叫做它的表现层(Representation)。</p>
</li>
<li><p><strong>状态转换(State Transfer)</strong>：每发出一个请求，就代表了客户端和服务器的一次交互过程。</p>
<p>HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转换”(State Transfer)。</p>
<p>而这种转换是建立在表现层之上的，所以就是“表现层状态转换”。</p>
<p>具体说，就是HTTP协议里面，四个表示操作方式的动词：<strong>GET、POST、PUT、DELETE</strong>。他们分别对应四种基本操作：GET用来获取资源，POST用来新建资源，PUT用来更新资源，DELETE用来删除资源。</p>
<blockquote>
<p>传统方式操作资源</p>
<p><a href="http://127.0.0.1/item/queryUser.action?id=1">http://127.0.0.1/item/queryUser.action?id=1</a>   查询,GET<br><a href="http://127.0.0.1/item/saveUser.action">http://127.0.0.1/item/saveUser.action</a>         新增,POST<br><a href="http://127.0.0.1/item/updateUser.action">http://127.0.0.1/item/updateUser.action</a>       更新,POST<br><a href="http://127.0.0.1/item/deleteUser.action?id=1">http://127.0.0.1/item/deleteUser.action?id=1</a>  删除,GET或POST</p>
<p>使用RESTful操作资源</p>
<p><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a>     查询,GET</p>
<p><a href="http://127.0.0.1/item">http://127.0.0.1/item</a>       新增,POST </p>
<p><a href="http://127.0.0.1/item">http://127.0.0.1/item</a>       更新,POST </p>
<p><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a>     删除,GET或POST</p>
</blockquote>
</li>
</ol>
<p><strong>SpringMVC对RESTful的支持</strong></p>
<a href="/article/37040.html" title="点击跳转SpringMVC对RESTful的支持">点击跳转SpringMVC对RESTful的支持</a>
<ol>
<li>使路径变得更加简洁</li>
<li>获得参数更加方便，框架会自动进行类型转换</li>
<li>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求</li>
<li>安全</li>
</ol>
<p><strong>API设计风格基本规则</strong></p>
<ol>
<li><p>使用名词而不是动词</p>
</li>
<li><p>Get方法和查询参数不应该涉及状态改变</p>
<p>使用<strong>PUT, POST</strong> 和<strong>DELETE</strong> 方法 而不是 <strong>GET</strong> 方法来改变状态，不要使用<strong>GET</strong> 进行状态改变:</p>
</li>
<li><p>使用复数名词</p>
<p>不要混淆名词单数和复数，为了保持简单，只对所有资源使用复数。</p>
</li>
<li><p>使用子资源表达关系</p>
<p>如果一个资源与另外一个资源有关系，使用子资源</p>
</li>
<li><p>使用Http头声明序列化格式</p>
<p>在客户端和服务端，双方都要知道通讯的格式，格式在HTTP-Header中指定</p>
</li>
<li><p>为集合提供<strong>过滤 排序 选择和分页等功能</strong></p>
</li>
<li><p>使用Http状态码处理错误</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringMVC</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/article/18155.html</url>
    <content><![CDATA[<blockquote>
<p>The grass seeks her crowd in the earth.<br>The tree seeks his solitude of the sky.</p>
<p>绿草求她地上的伴侣。　　　　　　　　　　　　　　　　　　　　　　　<br>树木求他天空的寂寞。　</p>
</blockquote>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring框架是由于<a href="https://baike.baidu.com/item/软件开发/3448966">软件开发</a>的复杂性而创建的。Spring使用的是基本的<a href="https://baike.baidu.com/item/JavaBean/529577">JavaBean</a>来完成以前只可能由<a href="https://baike.baidu.com/item/EJB/144195">EJB</a>完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p>
<p><strong>Spring</strong>是一个轻量级控制反转（IOC）哥面向切面（AOP）的容器框架</p>
<p><a href="https://spring.io/projects/spring-framework">点击跳转Spring官方地址</a></p>
<p><a href="https://repo.spring.io/release/org/springframework/spring">点击跳转Spring官方下载地址</a></p>
<p><a href="https://github.com/spring-projects/spring-framework">点击跳转Spring官方GitHub地址</a></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用maven配置<code>spring-webmvc</code> <code>spring-jdbc</code></p>
<a href="/article/37040.html" title="点击跳转Spring-Maven配置">点击跳转Spring-Maven配置</a>
<p><strong>优点</strong></p>
<ol>
<li>Spring是一个开源的免费的框架（容器）</li>
<li>Spring是一个轻量级的、非入侵式框架</li>
<li><strong>AOP编程的支持</strong></li>
<li><strong>IOC编程的支持</strong></li>
<li>支持事务的处理、对框架整合的支持</li>
</ol>
<p><strong>缺点</strong></p>
<p>配置十分繁琐</p>
<p><strong>组成</strong></p>
<img src="/article/18155/Spring%E7%BB%84%E6%88%90.jpg" class title="Spring组成">
<h3 id="IOC理论"><a href="#IOC理论" class="headerlink" title="IOC理论"></a>IOC理论</h3><p>IOC是Inversion of Control的缩写，即为控制反转</p>
<p><strong>IOC 容器</strong>具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作不由程序员来做而是交给Spring容器来做。</p>
<ol>
<li>耦合的对象</li>
</ol>
<img src="/article/18155/1.png" class title="img">
<ol start="2">
<li><p>解耦的过程</p>
<img src="/article/18155/2.png" class title="img">
</li>
<li><p>理想的系统</p>
<img src="/article/18155/3.png" class title="img">
<p>在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度</p>
</li>
</ol>
<p><strong>控制反转是一种通过获得描述（XML或注解）并通过第三方去生产或获取的特定对象的方式，在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入<code>dependency injection(DI)</code></strong></p>
<img src="/article/18155/Spring%E4%B8%8EBean%E7%9A%84%E5%85%B3%E7%B3%BB.png" class title="Spring Bean">
<h4 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h4><blockquote>
<p>  实体类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br> <span class="hljs-keyword">private</span> String str;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStr</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> str;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStr</span><span class="hljs-params">(String str)</span> </span>&#123;<br>     <span class="hljs-keyword">this</span>.str = str;<br> &#125;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&#123;&quot;</span> +<br>             <span class="hljs-string">&quot;str=&#x27;&quot;</span> + str + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>             <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="IOC-XML配置"><a href="#IOC-XML配置" class="headerlink" title="IOC-XML配置"></a><strong>IOC-XML配置</strong></h5><p><code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--使用spring来创建对象，在Spring这些都称为Bean</span><br><span class="hljs-comment">        类型 变量名 = new 类型；</span><br><span class="hljs-comment">        bean = 对象  new Hello();</span><br><span class="hljs-comment">        id = 变量名</span><br><span class="hljs-comment">        class = new 的对象；</span><br><span class="hljs-comment">        property 相当于给对象中的属性设置一个值</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Hello&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;str&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h5 id="实例化容器"><a href="#实例化容器" class="headerlink" title="实例化容器"></a><strong>实例化容器</strong></h5><p>提供给ApplicationContext构造函数的位置路径是资源字符串，允许容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code>等）加载配置元数据。</p>
<p>获取Spring的上下文对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br></code></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.pojo.Hello;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//获取Spring的上下文对象</span><br>    ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>    <span class="hljs-comment">//我们的对象现在都在Spring中管理了，我们要使用，直接去里面取出来</span><br>    Hello hello =(Hello)context.getBean(<span class="hljs-string">&quot;hello&quot;</span>);<br>    System.out.println(hello.toString());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>hello对象是由Spring创建的，hello对象的属性是由Spring设置的</li>
</ul>
<h4 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h4><p>当在 Spring 中定义一个 bean 时，你必须声明该 bean 的作用域的选项。</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton</td>
<td>在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，默认值</td>
</tr>
<tr>
<td>prototype</td>
<td>每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()</td>
</tr>
<tr>
<td>request</td>
<td>每次HTTP请求都会创建一个新的Bean，该作用域<strong>仅适用于WebApplicationContext环境</strong></td>
</tr>
<tr>
<td>session</td>
<td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境</td>
</tr>
<tr>
<td>global-session</td>
<td>一般用于Portlet应用环境，该作用域<strong>仅适用于WebApplicationContext环境</strong></td>
</tr>
</tbody>
</table>
<p><strong>singleton 作用域</strong></p>
<p>singleton 是默认的作用域</p>
<p>当一个bean的作用域为 <code>Singleton</code>，那么 Spring IoC 容器中<strong>只会存在一个共享的 bean 实例</strong>，并且所有对 bean 的请求，只要 id 与该 bean 定义相匹配，则只会返回 bean 的同一实例。</p>
<p>也就是说，当将一个 bean 定义设置为 singleton 作用域的时候，Spring IoC 容器只会创建该 bean 定义的<strong>唯一实例</strong>。</p>
<img src="/article/18155/singleton.png" class title="singleton">
<p>Singleton 是<strong>单例类型</strong>，就是在创建起容器时就同时自动创建了一个 bean 的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton 作用域是 Spring 中的缺省作用域。</p>
<p><strong>prototype 作用域</strong></p>
<p>当一个 bean 的作用域为 <code>Prototype</code>，表示<strong>一个 bean 定义对应多个对象实例</strong>。Prototype 作用域的 bean 会导致在每次对该 bean 请求（将其注入到另一个 bean 中，或者以程序的方式调用容器的 getBean() 方法）时都会创建一个新的 bean 实例。</p>
<img src="/article/18155/prototype.png" class title="prototype">
<p>Prototype 是<strong>原型类型</strong>，<strong>它在我们创建容器的时候并没有实例化</strong>，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的 bean 应该使用 prototype 作用域，而对无状态的bean则应该使用 singleton 作用域。</p>
<h4 id="IOC创建对象的方式"><a href="#IOC创建对象的方式" class="headerlink" title="IOC创建对象的方式"></a>IOC创建对象的方式</h4><p><strong>在创建<code>ApplicationContext</code>实例时，<code>bean</code>已经被注册</strong></p>
<blockquote>
<p>例：</p>
<p><code>User</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br> <span class="hljs-keyword">private</span> String name;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;User的无参构造&quot;</span>);<br> &#125;<br>  <span class="hljs-comment">//有参构造</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span></span>&#123;<br>   <span class="hljs-keyword">this</span>.name=name;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> name;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>   <span class="hljs-keyword">this</span>.name = name;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;name+&quot;</span> + name);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>MyTest.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//在配置文件加载的时候，容器中管理的对象就已经初始化了</span><br>    ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>    User user = (User) context.getBean(<span class="hljs-string">&quot;user&quot;</span>);<br>    user.show();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>使用无参构造创建对象（默认）</p>
<p><code>beans.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--无参构造创建对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>输出结果</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">User的无参构造<br>name+bobo<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>使用有参构造创建对象</p>
<ol>
<li><p>第一种：下标赋值</p>
<p><code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--第一种：下标赋值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;第一种有参构造 &quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>输出结果</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">name+第一种有参构造<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>第二种：类型赋值 <strong>多个相同类型不建议使用</strong></p>
<p><code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第二种：类型赋值 多个相同类型不建议使用--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;第二种有参构造&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>基本类型可以直接用，引用类型必须写全限定名</p>
<blockquote>
<p><code>输出结果</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">name+第二种有参构造<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>第三种：直接通过参数名</p>
<p><code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;第三种有参构造&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>输出结果</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">name+第三种有参构造<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</li>
</ol>
<p><strong>取别名</strong></p>
<ol>
<li><code>alias</code>标签</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--给对象取别名--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;userbobo&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li><p>创建<code>bean</code>时通过<code>name</code>属性取别名，可以取多个别名，用多种方法分割，</p>
<p>u1 u2 u3 u4 都是user的别名</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;u1,u2 u3;u4&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h3><p>Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系。</p>
<h4 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h4><p>当容器调用带有一组参数的类构造函数时，基于构造函数的 DI 就完成了，其中每个参数代表一个对其他类的依赖。</p>
<p>即<strong>使用有参构造创建对象</strong></p>
<p><strong>例</strong></p>
<blockquote>
<p><strong>DI.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.dao;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DI</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> IDI idi;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DI</span><span class="hljs-params">(IDI idi)</span></span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;IDI被注入&quot;</span>);<br>     <span class="hljs-keyword">this</span>.idi = idi;<br>  &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">diCheck</span><span class="hljs-params">()</span></span>&#123;<br>       idi.checkIDI();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>IDI.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.dao;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDI</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IDI</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;IDI注入&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkIDI</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Inside checkIDI.&quot;</span> );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;di&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.dao.DI&quot;</span>&gt;</span><br>  	<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;idi&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;idi&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.dao.IDI&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面这个例子里，将依赖类 IDI.java注入到DI.java 文件,便称为依赖注入。</p>
<h4 id="基于设值函数的依赖注入（重点）"><a href="#基于设值函数的依赖注入（重点）" class="headerlink" title="基于设值函数的依赖注入（重点）"></a>基于设值函数的依赖注入（重点）</h4><p><strong>依赖：</strong>bean对象的创建依赖于容器</p>
<p><strong>注入：</strong>bean对象的所有属性，由容器来注入</p>
<p><strong>例</strong></p>
<blockquote>
<p><strong>Student.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> Address address;<br>  <span class="hljs-keyword">private</span> String[] books;<br>  <span class="hljs-keyword">private</span> List&lt;String&gt; hobbies;<br>  <span class="hljs-keyword">private</span> Map&lt;String,String&gt; card;<br>  <span class="hljs-keyword">private</span> Set&lt;String&gt; games;<br>  <span class="hljs-keyword">private</span> String wife;<br>  <span class="hljs-keyword">private</span> Properties info;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getWife</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> wife;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWife</span><span class="hljs-params">(String wife)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.wife = wife;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Address <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> address;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(Address address)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.address = address;<br>  &#125;<br>  <span class="hljs-keyword">public</span> String[] getBooks() &#123;<br>    <span class="hljs-keyword">return</span> books;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBooks</span><span class="hljs-params">(String[] books)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.books = books;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getHobbies</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> hobbies;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHobbies</span><span class="hljs-params">(List&lt;String&gt; hobbies)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.hobbies = hobbies;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">getCard</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> card;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCard</span><span class="hljs-params">(Map&lt;String, String&gt; card)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.card = card;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getGames</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> games;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGames</span><span class="hljs-params">(Set&lt;String&gt; games)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.games = games;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Properties <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> info;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInfo</span><span class="hljs-params">(Properties info)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.info = info;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, address=&quot;</span> + address.toString() +<br>      <span class="hljs-string">&quot;, books=&quot;</span> + Arrays.toString(books) +<br>      <span class="hljs-string">&quot;, hobbies=&quot;</span> + hobbies +<br>      <span class="hljs-string">&quot;, card=&quot;</span> + card +<br>      <span class="hljs-string">&quot;, games=&quot;</span> + games +<br>      <span class="hljs-string">&quot;, wife=&#x27;&quot;</span> + wife + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, info=&quot;</span> + info +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Address.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String address;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> address;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.address = address;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Address&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>注入</strong></p>
<blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Address&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;西安&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--普通注入 value--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--bean注入 ref--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--数组注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;books&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>红楼梦<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>水浒传<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>三国演义<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>西游记<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--List注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>听歌<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>敲代码<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>看电影<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Map--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123123123123123123&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;银行卡&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;456456456456456456&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Set--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;games&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>SCII<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BOB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--null--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wife&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--properites--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;学号&quot;</span>&gt;</span>123123123<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;性别&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="拓展方式注入"><a href="#拓展方式注入" class="headerlink" title="拓展方式注入"></a>拓展方式注入</h4><ol>
<li><p><code>c</code>注入</p>
<p>必须有有参构造器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--c命名空间注入，通过构造器注入 : constructs-args--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span> <span class="hljs-attr">c:age</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">c:name</span>=<span class="hljs-string">&quot;bobo&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>p</code>注入</p>
<p>p 命名空间注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--p命名注入，可以直接注入属性的值 ：property--&gt;</span><br><span class="hljs-comment">&lt;!--scope=&quot;singleton&quot; 单例模式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;bobo&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意</strong></p>
<p>c 、 p 命名空间注入不能直接使用，需要导入约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot; <br>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;<br></code></pre></td></tr></table></figure>
<h3 id="SpringBean-自动装配"><a href="#SpringBean-自动装配" class="headerlink" title="SpringBean 自动装配"></a>SpringBean 自动装配</h3><p>Spring 容器可以在不使用<code>&lt;constructor-arg&gt;</code>和<code>&lt;property&gt;</code> 元素的情况下<strong>自动装配</strong>相互协作的 bean 之间的关系。</p>
<blockquote>
<p><strong>显式装配</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Cat&quot;</span>/&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Dog&quot;</span>/&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.People&quot;</span>&gt;</span>--&gt;<br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>--&gt;<br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dog&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>--&gt;<br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;cat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>--&gt;<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>--&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>Spring 自动装配 byName</p>
<ol>
<li>这种模式由属性名称指定自动装配。Spring 容器看作 beans，在 XML 配置文件中 beans 的 <em>auto-wire</em> 属性设置为 <em>byName</em>。</li>
<li>然后，它尝试将它的属性与配置文件中定义为相同名称的 beans 进行匹配和连接。</li>
<li>如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Dog&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--隐式装配   autowire=&quot;byName&quot;</span><br><span class="hljs-comment">	会在容器中上下文中查找，和自己对象set方法后面的值对应的beanid！</span><br><span class="hljs-comment">	需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.People&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>使用byName，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法一致</strong></p>
</li>
<li><p>Spring 自动装配 byType</p>
<ol>
<li>这种模式由属性类型指定自动装配。Spring 容器看作 beans ，在 XML 配置文件中 beans 的 autowire 属性设置为 byType 。</li>
<li>然后，如果它的 type 恰好与配置文件中 beans 名称中的一个相匹配，它将尝试匹配和连接它的属性。</li>
<li>如果找到匹配项，它将注入这些 beans ，否则，它将抛出异常。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Dog&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--隐式装配   autowire=&quot;byType&quot;</span><br><span class="hljs-comment">	会在容器中上下文中查找，和自己对象属性类型相同的beanid！</span><br><span class="hljs-comment">	要保证类型全局唯一</span><br><span class="hljs-comment">	需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.People&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>即使</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog111&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Dog&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>对象名称不匹配，也可以根据类型找到对应的bean</p>
</li>
</ul>
<p><strong>要保证类型全局唯一</strong><br><strong>需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</strong></p>
</li>
<li><p>Spring <strong>注解</strong> 自动装配 </p>
</li>
</ol>
   <a href="/article/37040.html" title="点击跳转注解配置">点击跳转注解配置</a>
<p>   <code>@Autowire</code> 默认通过<code>byType</code>的方式实现 ，如果存在多个类型相同的，通过byname实现，必须要求这个对象存在<br>   <code>@Resource</code> 默认通过<code>byname</code>的方式实现 ，如果找不到名字，则通过byType实现 ！ 如果两个都找不到的情况下报错 </p>
<blockquote>
<p><strong><code>People.java</code>类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br>  <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-comment">//@Qualifier  允许beans 中对象名 与类中id与类型都不同</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(value = &quot;dogdog&quot;)</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--context、aop 支持注解装配--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">  &lt;!<span class="hljs-attr">--</span>支持注解装配  开启注解支持<span class="hljs-attr">--</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--注解装配--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Cat&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dogdog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Dog&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.People&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--@Autowired 与 @Resource区别</span><br><span class="hljs-comment">     都是用来自动装配的</span><br><span class="hljs-comment">     @Autowire 默认通过byType的方式实现 ，如果存在多个类型相同的，通过byname实现，必须要求这个对象存在</span><br><span class="hljs-comment">     @Resource 默认通过byname的方式实现 ，如果找不到名字，则通过byType实现 ！ 如果两个都找不到的情况下报错</span><br><span class="hljs-comment">     --&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h3><p>使用注解开发，必须要保证<code>aop</code>的包导入</p>
<a href="/article/37040.html" title="点击跳转使用注解开发">点击跳转使用注解开发</a>
<p>有两种方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--制定扫描包，包下注解会生效--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bobo&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="使用component-scan"><a href="#使用component-scan" class="headerlink" title="使用component-scan"></a>使用<code>component-scan</code></h4><p><code>&lt;context:component-scan base-package=&quot;com.bobo&quot;/&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-comment">//@Component  等价于   &lt;bean id=&quot;user&quot; class=&quot;com.bobo.pojo.User&quot;&gt;&lt;/bean&gt;</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-comment">//@Value(&quot;bobo&quot;) 相当于  &lt;property name=&quot;name&quot; value=&quot;bobo&quot;&gt;&lt;/property&gt;</span><br>  <span class="hljs-meta">@Value(&quot;bobo&quot;)</span><br>  <span class="hljs-keyword">public</span> String name;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-comment">//@Component  等价于   &lt;bean id=&quot;user&quot; class=&quot;com.bobo.pojo.User&quot;&gt;&lt;/bean&gt;</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-comment">//@Value(&quot;bobo&quot;) 相当于  &lt;property name=&quot;name&quot; value=&quot;bobo&quot;&gt;&lt;/property&gt;</span><br>  <span class="hljs-keyword">public</span> String name;<br>  <span class="hljs-comment">//也可以注入在set方法上</span><br>  <span class="hljs-meta">@Value(&quot;bobo&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>@Component</strong>衍生注解</p>
<ol>
<li><p>@Repository   与 @Component功能相似，作用在dao层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.dao;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><span class="hljs-comment">//@Repository 与 @Component功能相似，作用在dao层</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>@Service   与 @Component功能相似，作用在service层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.service;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-comment">//@Service 与 @Component功能相似，作用在service层</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>@Controller   与 @Component功能相似，作用在controller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.controller;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-comment">//@Controller 与 @Component功能相似，作用在controller层</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="使用-Scope"><a href="#使用-Scope" class="headerlink" title="使用@Scope"></a><strong>使用</strong><code>@Scope</code></h4><p>作用就和在bean标签中使用scope属性实现的功能是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope</span><br></code></pre></td></tr></table></figure>
<p>用于指定bean的作用范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br></code></pre></td></tr></table></figure>
<p>指定范围的取值</p>
<h3 id="使用Java的方式配置Spring"><a href="#使用Java的方式配置Spring" class="headerlink" title="使用Java的方式配置Spring"></a>使用Java的方式配置Spring</h3><a href="/article/37040.html" title="点击跳转基于Java注解的配置">点击跳转基于Java注解的配置</a>
<p><strong>@import、@Configuration 和 @Bean 注解</strong></p>
<p><strong>@Configuration</strong> 注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。</p>
<p><strong>@Bean</strong> 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。</p>
<p><strong>@import</strong> 注解允许从另一个配置类中加载 @Bean 定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.config;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Import;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">//@Configuration 相当于&lt;beans&gt;</span><br><span class="hljs-comment">//@Configuration 代表这是一个配置累 与beans.xml是一样的</span><br><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-meta">@ComponentScan(&quot;com.bobo.pojo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">boboConfig</span> </span>&#123;<br><br>  <span class="hljs-comment">//注册一个bean，就相当于我门之前写的一个bean标签</span><br>  <span class="hljs-comment">//这个方法的名字，就相当于bean标签中的id属性</span><br>  <span class="hljs-comment">//这个方法的返回值就相当于bean标签中的class属性</span><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();  <span class="hljs-comment">//就是返回要注入到bean 的对象</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>这个方法的返回值就相当于bean标签中的class属性</strong>,所以在测试类中可以识别到User类</p>
<p>带有 @Bean 注解的方法名称作为 bean 的 ID，它创建并返回实际的 bean。你的配置类可以声明多个 @Bean。</p>
<p>一旦定义了配置类，你就可以使用 <code>AnnotationConfigApplicationContext</code>来加载并把他们提供给 Spring 容器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.config.boboConfig;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//如果完全使用了配类方式去做，只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载</span><br>    ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(boboConfig.class);<br>    User getUser = (User) context.getBean(<span class="hljs-string">&quot;user&quot;</span>);<br>    System.out.println(user.getName());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="AOP框架"><a href="#AOP框架" class="headerlink" title="AOP框架"></a>AOP框架</h3><p>使用AOP织入，需要导入<code>aspectjweaver</code>依赖包</p>
<a href="/article/37040.html" title="点击跳转Spring-AOP配置">点击跳转Spring-AOP配置</a>
<p>Spring 框架的一个关键组件是<strong>面向切面的编程</strong>(AOP)框架。</p>
<p>跨一个应用程序的多个点的功能被称为<strong>横切关注点</strong>，这些横切关注点在概念上独立于应用程序的业务逻辑。在软件开发过程中有各种各样的很好的切面的例子，如日志记录、审计、声明式事务、安全性和缓存等。</p>
<p><strong>AOP 术语</strong></p>
<table>
<thead>
<tr>
<th>项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Aspect（切面）</td>
<td>一个模块具有一组提供横切需求的 APIs。例如，一个日志模块为了记录日志将被 AOP 方面调用。应用程序可以拥有任意数量的方面，这取决于需求。</td>
</tr>
<tr>
<td>Join point（连接点）</td>
<td>在你的应用程序中它代表一个点，你可以在插件 AOP 方面。你也能说，它是在实际的应用程序中，其中一个操作将使用 Spring AOP 框架。</td>
</tr>
<tr>
<td>Advice（通知）</td>
<td>这是实际行动之前或之后执行的方法。这是在程序执行期间通过 Spring AOP 框架实际被调用的代码。</td>
</tr>
<tr>
<td>Pointcut（切入点）</td>
<td>这是一组一个或多个连接点，通知应该被执行。你可以使用表达式或模式指定切入点正如我们将在 AOP 的例子中看到的。</td>
</tr>
<tr>
<td>Introduction</td>
<td>引用允许你添加新方法或属性到现有的类中。</td>
</tr>
<tr>
<td>Target object（被通知对象）</td>
<td>被一个或者多个方面所通知的对象，这个对象永远是一个被代理对象。也称为被通知对象。</td>
</tr>
<tr>
<td>Weaving</td>
<td>Weaving 把方面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时，类加载时和运行时完成。</td>
</tr>
<tr>
<td>Proxy（代理）</td>
<td>向目标对象应用通知之后创建的对象</td>
</tr>
</tbody>
</table>
<p><strong>通知的类型</strong></p>
<table>
<thead>
<tr>
<th>通知</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置通知</td>
<td>在一个方法执行之前，执行通知。</td>
</tr>
<tr>
<td>后置通知</td>
<td>在一个方法执行之后，不考虑其结果，执行通知。</td>
</tr>
<tr>
<td>返回后通知</td>
<td>在一个方法执行之后，只有在方法成功完成时，才能执行通知。</td>
</tr>
<tr>
<td>抛出异常后通知</td>
<td>在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。</td>
</tr>
<tr>
<td>环绕通知</td>
<td>在建议方法调用之前和之后，执行通知。</td>
</tr>
</tbody>
</table>
<h4 id="基于-AOP-的-XML架构"><a href="#基于-AOP-的-XML架构" class="headerlink" title="基于 AOP 的 XML架构"></a><strong>基于 AOP 的 XML架构</strong></h4><p>在xml中使用 aop 命名空间标签，你需要导入 spring-aop 架构</p>
<blockquote>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.service.UserService;<br><span class="hljs-keyword">import</span> com.bobo.service.UserServiceImpl;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>    <span class="hljs-comment">//动态代理 代理的是接口</span><br>    UserService userService = context.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserService.class);<br>    userService.add();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>方式一</strong>  自定义类</p>
<ol>
<li><p><strong>声明一个 aspect</strong></p>
<p>一个 <strong>aspect</strong> 是使用 元素声明的，支持的 bean 是使用 <strong>ref</strong> 属性引用的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>声明一个切入点</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.bobo.service..*.*(..))&quot;</span>/&gt;</span><br>   ...<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>一个切入点表达式决定了我们感兴趣的哪个方法会真正被执行。</li>
<li>一个切入点标签包含一个名称和任意数量的参数。方法的真正内容是不相干的，并且实际上它应该是空的。</li>
</ul>
</li>
<li><p><strong>例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.diy.DiyPointCut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--自定义切面，ref要引用的类--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;diy&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--切入点--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;point&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.bobo.service.UserServiceImpl.*(..) )&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--通知--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;point&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;point&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>Class DiyPointCut</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.diy;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiyPointCut</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;=============方法执行前=============&quot;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;=============方法执行后=============&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>测试结果：</p>
<img src="/article/18155/image-20220119212811856.png" class title="image-20220119212811856">
</li>
</ol>
<p><strong>方式二</strong>   使用原生Spring API接口</p>
<ol>
<li><p>声明一个通知器</p>
<p>定义<code>&lt; aop:advisor &gt;</code>中引用的通知时，通知必须实现Advice接口</p>
</li>
</ol>
<ol start="2">
<li><p><strong>例</strong></p>
<blockquote>
<ol>
<li><p>通知前环绕</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> com.bobo.log;<br><span class="hljs-keyword">import</span> org.springframework.aop.MethodBeforeAdvice;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;<br>  <span class="hljs-comment">//method   要执行的目标对象的方法</span><br>  <span class="hljs-comment">//Object   参数</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>	System.out.println(target.getClass().getName()+<span class="hljs-string">&quot;的&quot;</span>+method.getName()+<span class="hljs-string">&quot;被执行了&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>通知后环绕</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.log;<br><span class="hljs-keyword">import</span> org.springframework.aop.AfterAdvice;<br><span class="hljs-keyword">import</span> org.springframework.aop.AfterReturningAdvice;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AfterReturningAdvice</span> </span>&#123;<br>    <span class="hljs-comment">//returnValue  返回值</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法，返回结果为：&quot;</span>+returnValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>配置XML</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.log.Log&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.log.AfterLog&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    配置aop:需要导入aop的约束--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.bobo.service.UserServiceImpl.*(..) )&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--执行环绕增加--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试结果：</p>
<img src="/article/18155/image-20220119212737264.png" class title="image-20220119212737264">
</li>
</ol>
<p>​    </p>
<p><strong>方式三</strong>   使用注解配置</p>
<p>配置XML，开启注解支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li><p>声明一个 aspect</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectModule</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>声明一个切入点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-meta">@Pointcut(&quot;execution(* com.bobo.service.UserServiceImpl.*(..))&quot;)</span> <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;AnnotationPointCut&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.diy.AnnotationPointCut&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--开启注解支持   JDK（默认）proxy-target-class=&quot;false&quot;     cglib:proxy-target-class=&quot;true&quot;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.Signature;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><br><span class="hljs-meta">@Aspect</span>   <span class="hljs-comment">//标注这个类是一个切面</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationPointCut</span> </span>&#123;<br><br>  <span class="hljs-meta">@Before(&quot;execution(* com.bobo.service.UserServiceImpl.*(..))&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;=============方法执行前=============&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@After(&quot;execution(* com.bobo.service.UserServiceImpl.*(..))&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;=============方法执行后=============&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Around(&quot;execution(* com.bobo.service.UserServiceImpl.*(..))&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;环绕前&quot;</span>);<br>    <span class="hljs-comment">//执行方法</span><br>    Object proceed = proceedingJoinPoint.proceed();<br>    System.out.println(<span class="hljs-string">&quot;环绕后&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><code>ProceedingJoinPoint proceedingJoinPoint</code>代表当前执行的方法</p>
<p>测试结果：</p>
<img src="/article/18155/image-20220119212640569.png" class title="image-20220119212640569">
</li>
</ol>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p><code>aop:aspect</code>与<code>op:advisor</code>不同</p>
<ol>
<li><p>实现方式不同</p>
<p><a href="aop:aspect">aop:aspect</a>定义切面时，只需要定义一般的bean就行，而定义<a href="aop:advisor">aop:advisor</a>中引用的通知时，通知必须实现Advice接口。</p>
</li>
<li><p>使用场景不同</p>
<p><a href="aop:advisor">aop:advisor</a>大多用于事务管理</p>
</li>
</ol>
</li>
<li><p><strong>execution表达式</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">execution(* com.bobo.service..*. *(..))<br></code></pre></td></tr></table></figure>
<ol>
<li>第一个 <code>*</code> 表示返回类型， *号表示所有的类型</li>
<li>包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.bobo.service包、子孙包下所有类的方法 (“..”出现在类名中时，后面必须跟“*”)</li>
<li>第二个 <code>*</code> 号：表示类名，*号表示所有的类</li>
<li><code>*(..)</code>:最后这个星号表示方法名，*号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</li>
</ol>
</li>
</ol>
<h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><p><a href="http://mybatis.org/spring/zh/index.html">整合Mybatis步骤官方中文文档</a></p>
<a href="/article/13919.html" title="点击跳转Mybatis详解">点击跳转Mybatis详解</a>
<p>导入相关jar包  <a href="/article/37040.html" title="点击跳转Spring-Mybatis Maven配置">点击跳转Spring-Mybatis Maven配置</a></p>
<ol>
<li><p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 <code>SqlSessionFactory</code> 和至少一个数据映射器类。</p>
<p>在 MyBatis-Spring 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>。 </p>
<ol>
<li><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sqlSessionFactory--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/数据库名?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8<span class="hljs-symbol">&amp;amp;</span>useUnicode=true&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;用户名&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;密码&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="3">
<li><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SqlSessionTemplate 就是我们使用的sqlSession--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--只能使用构造器注入sqlSessionFactory ，因为没有set方法--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<ol>
<li><p><code>SqlSessionTemplate</code> 是 MyBatis-Spring 的核心。作为 <code>SqlSession</code> 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 <code>SqlSession</code>。 <code>SqlSessionTemplate</code> 是线程安全的，可以被多个 DAO 或映射器所共享使用。</p>
</li>
<li><p>当调用 SQL 方法时（包括由 <code>getMapper()</code> 方法返回的映射器中的方法），<code>SqlSessionTemplate</code> 将会保证使用的 <code>SqlSession</code> 与当前 Spring 的事务相关。 此外，它管理 session 的生命周期，包含必要的关闭、提交或回滚操作。另外，它也负责将 MyBatis 的异常翻译成 Spring 中的 <code>DataAccessExceptions</code>。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>现在，这个 sqlSession 就可以直接注入到你的 Mapper bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.mybatis.spring.SqlSessionTemplate;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserMapper</span></span>&#123;<br><br>  <span class="hljs-comment">//我们的所有操作都使用sqlSession来执行，在原来，现在我们都使用SqlSessionTrmplate</span><br>  <span class="hljs-keyword">private</span> SqlSessionTemplate sqlSession;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSqlSession</span><span class="hljs-params">(SqlSessionTemplate sqlSession)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.sqlSession=sqlSession;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>按下面这样，注入 <code>SqlSessionTemplate</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.mapper.UserMapperImpl&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSession&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>现在所有的映射语句可以进行批量操作了，可以在 Mapper.xml 中编写如下的代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.bobo.mapper.UserMapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    select * from mybatis.user;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>  ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>  UserMapper userMapper = context.getBean(<span class="hljs-string">&quot;userMapper&quot;</span>, UserMapper.class);<br><br>  <span class="hljs-keyword">for</span> (User user : userMapper.selectUser()) &#123;<br>    System.out.println(user);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>完整实例</strong></p>
<img src="/article/18155/image-20220120203442870.png" class title="image-20220120203442870">
<blockquote>
<p><strong>pojo.User</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String pwd;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>Mapper.UserMapper</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">selectUser</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Mapper.UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.bobo.mapper.UserMapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>    select * from mybatis.user;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>Mapper.UserMapperImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.mybatis.spring.SqlSessionTemplate;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserMapper</span></span>&#123;<br><br>  <span class="hljs-comment">//我们的所有操作都使用sqlSession来执行，在原来，现在我们都使用SqlSessionTrmplate</span><br>  <span class="hljs-keyword">private</span> SqlSessionTemplate sqlSession;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSqlSession</span><span class="hljs-params">(SqlSessionTemplate sqlSession)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.sqlSession=sqlSession;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">selectUser</span><span class="hljs-params">()</span> </span>&#123;<br>    UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>    <span class="hljs-keyword">return</span> mapper.selectUser();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>resources.mybatis-config.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.bobo.pojo&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;mappers&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--    &lt;mapper class=&quot;com.bobo.mapper.UserMapper&quot;/&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;/mappers&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>resources.spring-dao.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--DataSource:使用Spring的数据源替换Mybatis的配置</span><br><span class="hljs-comment">        使用Spring提供的JDBC</span><br><span class="hljs-comment">      --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306数据库名?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8<span class="hljs-symbol">&amp;amp;</span>useUnicode=true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>用户名/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;密码&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--sqlSessionFactory--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--绑定Mybatis配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath*:com/bobo/mapper/UserMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--SqlSessionTemplate 就是我们使用的sqlSession--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--只能使用构造器注入sqlSessionFactory ，因为没有set方法--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>resources.applicationContext.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;spring-dao.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.mapper.UserMapperImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSession&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>MyTest</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.mapper.UserMapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>        UserMapper userMapper = context.getBean(<span class="hljs-string">&quot;userMapper&quot;</span>, UserMapper.class);<br><br>        <span class="hljs-keyword">for</span> (User user : userMapper.selectUser()) &#123;<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>SqlSessionDaoSupport</strong></p>
<p><code>SqlSessionDaoSupport</code> 是一个抽象的支持类，用来为你提供 <code>SqlSession</code>。调用 <code>getSqlSession()</code> 方法你会得到一个 <code>SqlSessionTemplate</code>，之后可以用于执行 SQL 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.mybatis.spring.support.SqlSessionDaoSupport;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SqlSessionDaoSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserMapper</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">selectUser</span><span class="hljs-params">()</span> </span>&#123;<br>        SqlSession sqlSession = getSqlSession();<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-keyword">return</span> mapper.selectUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>一个使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 <code>DataSourceTransactionManager</code> 来实现事务管理。</p>
<p><strong>标准配置</strong></p>
<p>要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 <code>DataSourceTransactionManager</code> 对象：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transcationManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>传入的 <code>DataSource</code> 可以是任何能够与 Spring 兼容的 JDBC <code>DataSource</code>。包括连接池和通过 JNDI 查找获得的 <code>DataSource</code>。</p>
<p>注意：为事务管理器指定的 <code>DataSource</code> <strong>必须</strong>和用来创建 <code>SqlSessionFactoryBean</code> 的是同一个数据源，否则事务管理器就无法工作了。</p>
<h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p>（交由容器管理事务）</p>
<p><strong>配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transcationManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>结合AOP实现事务的织入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置事务的类 通知--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transcationManager&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--给哪些方法配置事务--&gt;</span><br>  <span class="hljs-comment">&lt;!--配置事务的传播特性--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;query&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br><span class="hljs-comment">&lt;!--配置事务切入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txPointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.bobo.mapper.*.*(..))&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;txPointCut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/article/41682.html</url>
    <content><![CDATA[<blockquote>
<p>Thank the flame for its light, but do not forget the lampholder<br>standing in the shade with constancy of patience.</p>
<p>谢谢火焰给你光明，但是不要忘了那执灯的人，他是坚忍地站在黑暗当中呢。</p>
</blockquote>
<img src="/article/41682/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg" class title="点击查看源网页">
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p><strong>什么是 GOF?</strong></p>
<p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 的书，该书首次提到了软件开发中设计模式的概念。</p>
<p>四位作者合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong>。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>
<ul>
<li>对接口编程而不是对实现编程。</li>
<li>优先使用对象组合而不是继承。</li>
</ul>
<p>模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。</p>
<p><strong>创建型模式</strong>:这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<blockquote>
<ul>
<li>工厂模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
</blockquote>
<p><strong>结构型模式</strong>:这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<blockquote>
<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>过滤器模式（Filter、Criteria Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ul>
</blockquote>
<p><strong>行为型模式</strong>:这些设计模式特别关注对象之间的通信。</p>
<blockquote>
<ul>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>空对象模式（Null Object Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板模式（Template Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
</ul>
</blockquote>
<img src="/article/41682/the-relationship-between-design-patterns.jpg" class title="设计模式之间的关系">
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p><strong>满足原则</strong></p>
<ul>
<li>开闭原则</li>
<li>依赖倒转原则</li>
<li>迪米特法则</li>
</ul>
<p><strong>实质</strong></p>
<ol>
<li>实例化对象不能new，用工厂方法代替</li>
<li>将选择实现类，创建对象统一管理和控制，从而将调度这跟我们实现类解耦</li>
</ol>
<p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p><strong>主要解决：</strong>主要解决接口选择的问题。</p>
<p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</p>
<p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p><strong>关键代码：</strong>创建过程在其子类执行。</p>
<p><strong>优点：</strong> </p>
<ol>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ol>
<p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p>
<p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<p><strong>实例</strong></p>
<blockquote>
<p>Car接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span> </span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>TSL实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TSL</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;TSL&quot;</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>WL实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WL</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;WL&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>CarFactory接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><span class="hljs-comment">//工厂方法模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CarFactory</span> </span>&#123;<br><span class="hljs-function">Car <span class="hljs-title">getCar</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>TSLFactory工厂实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TSLFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">getCar</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TSL();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p> WLFactory工厂实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WLFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">getCar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WL();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Consumer实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//使用工厂创建</span><br>        Car car = <span class="hljs-keyword">new</span> WLFactory().getCar();<br>        Car car1 = <span class="hljs-keyword">new</span> TSLFactory().getCar();<br>        car.name();<br>        car1.name();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">WL<br>TSL<br></code></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/article/13919.html</url>
    <content><![CDATA[<blockquote>
<p>The woodcutter’s axe begged for its handle from the tree.<br>The tree gave it.</p>
<p>樵夫的斧头，问树要斧柄。　　　　　　　　　　　　　　　　　　<br>树便给了他。</p>
</blockquote>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p><a href="https://github.com/mybatis">点击跳转Mybatis-Github官方</a></p>
<p><code>MyBatis</code> 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。</p>
<ul>
<li><strong>持久层：</strong> 可以将业务数据<strong>存储到磁盘，具备长期存储能力</strong>，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。</li>
<li><strong>优点：</strong> 可以<strong>使用巨大的磁盘空间</strong>存储相当量的数据，并且很<strong>廉价</strong></li>
<li><strong>缺点：慢</strong>（相对于内存而言）</li>
</ul>
<p><strong>为什么使用 MyBatis</strong></p>
<p>在我们<strong>传统的 JDBC 中</strong>，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的<strong>繁琐又枯燥</strong>。</p>
<p>而我们在使用了 <strong>MyBatis</strong> 之后，<strong>只需要提供 SQL 语句就好了</strong>，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的<strong>关注点于是可以就此集中在 SQL 语句上</strong>，关注在增删改查这些操作层面上。</p>
<p>并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<p><strong>特点</strong></p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
<li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li>
<li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li>
<li>提供映射标签，支持对象与数据库的orm字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供xml标签，支持编写动态sql。 </li>
</ul>
<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>创建maven项目，配置<code>pom.xml</code>依赖包</p>
<a href="/article/37040.html" title="点击跳转Mybatis_Maven环境配置">点击跳转Mybatis_Maven环境配置</a>
<p><a href="https://mybatis.org/mybatis-3/zh/index.html">Mybaitis官方中文配置文件</a></p>
<p><strong>从 XML 中构建 SqlSessionFactory</strong></p>
<p>每个基于 MyBatis 的应用都是以一个 <code>SqlSessionFactory</code> 的实例为核心的。SqlSessionFactory 的实例可以通过 <code>SqlSessionFactoryBuilder</code> 获得。而 SqlSessionFactoryBuilder 则可以从 <code>XML</code> 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p>
<p>在<code>rescouces</code>文件下创建<code>mybatis-config.xml</code>配置文件</p>
<a href="/article/37040.html" title="点击跳转Mybatis_XML环境配置">点击跳转Mybatis_XML环境配置</a>
<p><strong>例</strong></p>
<a href="/article/37040.html" title="点击跳转Mybatis环境配置">点击跳转Mybatis环境配置</a>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--核心配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/数据库名?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8<span class="hljs-symbol">&amp;amp;</span>useUnicode=true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;用户名&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;密码&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>封装工具类</strong></p>
<p>获取sqlSessionFactory对象，从sqlSessionFactory中获取SqlSession</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.utils;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-comment">//sqlSessionFaction  --&gt; sqlSession</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUtils</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br>  <span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//使用Mybatis的第一步：获取sqlSessionFactory对象</span><br>      String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>      InputStream inputStream = Resources.getResourceAsStream(resource);<br>      sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</span><br>  <span class="hljs-comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</span><br>  <span class="hljs-comment">// 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h4><p><strong>引入配置文件</strong></p>
<blockquote>
<p>通过<code>propertise</code>配置文件实现引用</p>
<p><code>db.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/数据库名?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=true</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">用户名</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">密码</span><br></code></pre></td></tr></table></figure>
<p><code>mybatis-config.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--当在这里配置属性时，优先使用外部配置文件--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载：</p>
<ul>
<li>首先读取在 properties 元素体内指定的属性。</li>
<li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。</li>
<li>最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。</li>
</ul>
<p>因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。</p>
</blockquote>
<p><strong>配置别名</strong></p>
<blockquote>
<p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--别名</span><br><span class="hljs-comment">    用来减少完全限定名的冗余</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--方法一：可以给实体类其别名--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAlias</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">		方法二：</span><br><span class="hljs-comment">    指定一个包名，Mybatis会在包名下搜索所需要的JavaBean</span><br><span class="hljs-comment">    扫描实体类的包，它的默认别名就是这个类的类名</span><br><span class="hljs-comment">		在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名</span><br><span class="hljs-comment">    也可以在实体类上增加注解</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.bobo.pojo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方法一--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    select * from mybatis.user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--方法二--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    select * from mybatis.user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>设置（settings）</strong></p>
<table>
<thead>
<tr>
<th>设置名</th>
<th>描述</th>
<th>有效值</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>cacheEnabled</td>
<td>全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td>
<td>true \</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>mapUnderscoreToCamelCase</td>
<td>是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td>
<td>true \</td>
<td>false</td>
<td>False</td>
</tr>
<tr>
<td>logImpl</td>
<td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td>SLF4J \</td>
<td>LOG4J(deprecated since 3.5.9) \</td>
<td>LOG4J2 \</td>
<td>JDK_LOGGING \</td>
<td>COMMONS_LOGGING \</td>
<td>STDOUT_LOGGING \</td>
<td>NO_LOGGING</td>
<td>未设置</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td>
<td>true \</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><strong>映射器（mappers）</strong></p>
<p>可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等告诉 MyBatis 到哪里去找映射文件.</p>
<blockquote>
<p>方式一：resource<br><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><br>方式二：class<br><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure></p>
<p><strong>注意：</strong></p>
<ol>
<li>接口和Mapper配置文件必须同名</li>
<li>接口和Mapper配置文件必须在同一个包下</li>
</ol>
<p>方式三：package</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis.builder&quot;</span>/&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><p>MyBatis 提供的所有特性都可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行</p>
<img src="/article/13919/image-20220108215520312.png" class title="image-20220108215520312">
<p><strong>例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--命名空间  绑定一个对应的Mapper接口--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.bobo.Mapper.UserMapper&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">id:对应的namespace中的方法名</span><br><span class="hljs-comment">resultType：SQL语句执行的返回值</span><br><span class="hljs-comment">parameterType：参数类型</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>        select * from mybatis.user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>与之对应的是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.Mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 查询全部用户</span><br><span class="hljs-comment">     * 得到用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>绑定</p>
<p>每一个<code>Mapper.XML</code>都需要在Mybatis核心配置文件中注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/bobo/dao/UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>如果绑定失败，可能是资源目录没有导出成功,<a href="/article/37040.html" title="点击跳转Maven资源导出配置">点击跳转Maven资源导出配置</a></p>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.Mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> com.bobo.utils.MybatisUtils;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperTest</span></span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1.获得SqlSession对象</span><br>        SqlSession sqlSession = MybatisUtils.getSqlSession();<br>        <span class="hljs-comment">//方式一：getMapper</span><br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        List&lt;User&gt; userList = mapper.getUserList();<br><br>        <span class="hljs-comment">//方式二：</span><br><span class="hljs-comment">//        List&lt;User&gt; userList = sqlSession.selectList(&quot;com.bobo.dao.UserMapper.getUserList&quot;);</span><br>        <span class="hljs-keyword">for</span> (User user : userList) &#123;<br>            System.out.println(user);<br>        &#125;<br><br>        <span class="hljs-comment">//关闭SqlSession</span><br>        sqlSession.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>注意：</strong>增删改需要提交事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提交事务</span><br>        sqlSession.commit();<br>        sqlSession.close();<br></code></pre></td></tr></table></figure>
<h3 id="对命名空间的一点补充"><a href="#对命名空间的一点补充" class="headerlink" title="对命名空间的一点补充"></a><strong>对命名空间的一点补充</strong></h3><p>在之前版本的 MyBatis 中，<strong>命名空间（Namespaces）</strong>的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。</p>
<p>命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p>
<p><strong>命名解析：</strong>为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。</p>
<ol>
<li><p>全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。</p>
</li>
<li><p>短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。</p>
</li>
</ol>
<h3 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h3><p><strong>对象生命周期和依赖注入框架</strong></p>
<p>依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。</p>
<ol>
<li><p><strong>SqlSessionFactoryBuilder</strong></p>
<p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
</li>
<li><p><strong>SqlSessionFactory</strong></p>
<p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。  SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
</li>
<li><p><strong>SqlSession</strong></p>
<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。  <strong>绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中。</strong></p>
</li>
</ol>
<h3 id="XML-映射文件"><a href="#XML-映射文件" class="headerlink" title="XML 映射文件"></a>XML 映射文件</h3><ul>
<li><code>cache</code> – 该命名空间的缓存配置。</li>
<li><code>cache-ref</code> – 引用其它命名空间的缓存配置。</li>
<li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li>
<li><code>resultType</code> - 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</li>
<li><del>parameterMap</del> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。</li>
<li><code>parameterType</code> - 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</li>
<li><code>sql</code> – 可被其它语句引用的可重用语句块。</li>
<li><code>insert</code> – 映射插入语句。</li>
<li><code>update</code> – 映射更新语句。</li>
<li><code>delete</code> – 映射删除语句。</li>
<li><code>select</code> – 映射查询语句</li>
</ul>
<p><strong>结果映射</strong></p>
<p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。</p>
<p>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p>
<p>举例<br><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;hashed_password&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span><br>  select user_id, user_name, hashed_password<br>  from some_table<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>复杂查询</strong></p>
<ol>
<li><p>多对一查询（多个同学对应一个老师）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-comment">//学生要关联一个老师</span><br>  <span class="hljs-keyword">private</span> Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.Mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.Student;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentMapper</span> </span>&#123;<br>  <span class="hljs-comment">//查询所有的学生信息，以及对应的老师的信息</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">getStudent</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>方法一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--思路：</span><br><span class="hljs-comment">1。查询所有学生信息</span><br><span class="hljs-comment">2。根据查询出来的学生的tid 寻找对应的老师</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudent&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span>&gt;</span><br>  select * from student<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--复杂的属性需要单独处理</span><br><span class="hljs-comment">       对象：association</span><br><span class="hljs-comment">       集合：collection</span><br><span class="hljs-comment"> javaType 指定的属性类型</span><br><span class="hljs-comment">--&gt;</span><br>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>  select * from teacher where id = #&#123;tid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>方法二：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--按照结果集嵌套处理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudent&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span>&gt;</span><br>  select s.id sid,s.name sname,t.name tname,t.id tid<br>  from student s,teacher t where s.tid = t.id;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>一对多（一个老师对应多个同学）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> com.bobo.pojo.Student;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">private</span> String name;<br><br>  <span class="hljs-comment">//一个老师拥有多个学生</span><br>  <span class="hljs-keyword">private</span> List&lt;Student&gt; students;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.Mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.Teacher;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeacherMapper</span> </span>&#123;<br>  <span class="hljs-comment">//获取所有老师</span><br>  <span class="hljs-comment">//List&lt;Teacher&gt; getTeacher();</span><br>  <span class="hljs-comment">//获取指定老师下的所有学生以及老师的信息</span><br>  <span class="hljs-function">Teacher <span class="hljs-title">getTeacher</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;tid&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>方法一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--按照结果嵌套查询--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span>&gt;</span><br>  select s.id sid, s.name sname, t.name tname, t.id tid<br>  from student s,teacher t<br>  where s.tid = t.id and t.id = #&#123;tid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--复杂的属性，我们需要单独处理</span><br><span class="hljs-comment">        javaType 指定的属性类型</span><br><span class="hljs-comment">        集合中的泛型信息，我们使用ofType获取</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>方法二：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span>&gt;</span><br>  select * from mybatis.teacher where id = #&#123;tid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;ArrayList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getStudentByTeacherId&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentByTeacherId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>  select *<br>  from mybatis.student where tid = #&#123;tid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>SLF4J | <strong>LOG4J(deprecated since 3.5.9)</strong> | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | <strong>STDOUT_LOGGING</strong> | NO_LOGGING</p>
<p><strong>STDOUT_LOGGING</strong> 标准日志输出</p>
<p><code>mybatis-config.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--标准日志工厂实现--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>LOG4J(deprecated since 3.5.9)</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--LOG4J日志--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>使用LOG4J需要添加propertise配置文件<code>log4j.properties</code>(直接百度)</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">DEBUG,console,file</span><br><br><span class="hljs-meta">log4j.appender.console</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.console.Target</span> = <span class="hljs-string">System.out</span><br><span class="hljs-meta">log4j.appender.console.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.console.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">[%c]-%m%n</span><br><br><span class="hljs-meta">log4j.appender.file</span> = <span class="hljs-string">org.apache.log4j.RollingFileAppender</span><br><span class="hljs-meta">log4j.appender.file.File</span>=<span class="hljs-string">./log/bobo.log</span><br><span class="hljs-meta">log4j.appender.file.MaxFileSize</span>=<span class="hljs-string">10mb</span><br><span class="hljs-meta">log4j.appender.file.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.file.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="hljs-string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><br><span class="hljs-meta">log4j.logger.org.mybatis</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.Statement</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.ResultSet</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="hljs-string">DEBUG</span><br></code></pre></td></tr></table></figure>
<p><strong>log4j使用</strong></p>
<ol>
<li><p>在要使用Log4j的类中，导入包<code>org.apache.log4j.Logger;</code></p>
</li>
<li><p>日志对象，参数为当前类的class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Logger logger = Logger.getLogger(UserDaoTest.class);<br></code></pre></td></tr></table></figure>
</li>
<li><p>日志级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">logger.info(<span class="hljs-string">&quot;info:进入了testLog4j&quot;</span>);<br>logger.debug(<span class="hljs-string">&quot;debug:进入了testLog4j&quot;</span>);<br>logger.error(<span class="hljs-string">&quot;error:进入了testLog4j&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{} 和 ${} 的区别"></a>#{} 和 ${} 的区别</h3><p>#{}和${}这两个语法是为了动态传递参数而存在的，是Mybatis实现动态SQL的基础，总体上他们的作用是一致的（为了动态传参），但是在编译过程、是否自动加单引号、安全性、使用场景等方面有很多不同，下面详细比较两者间的区别： </p>
<ol>
<li><p>编译过程</p>
<ol>
<li><strong>#{}</strong> <strong>是</strong> <strong>占位符</strong> <strong>：动态解析 -&gt; 预编译 -&gt; 执行</strong></li>
<li><strong>${}</strong> <strong>是</strong> <strong>拼接符</strong> <strong>：动态解析 -&gt; 编译 -&gt; 执行</strong></li>
</ol>
<p>预编译可以类比java类的编译，java类被编译成class文件，载入虚拟机，载入虚拟机的字节码文件可以先被编译成机器吗，那么在执行某行代码的时候就可以直接执行编译后的机器码，而不用从字节码开始编译再执行，那么执行效率就高了。这也是为啥热机状态比冷机状态可以抗更多负载的原因。</p>
<p>sql的预编译也是一样的道理，在执行执行前就编译好，等执行时直接取编译结果去执行。省去编译时间。sql预编译后会在参数位置用<a href="https://so.csdn.net/so/search?q=占位符">占位符</a>表示。 </p>
<p>预编译：数据库驱动在发送sql和参数到DBMS之前，先对sql语句进行编译处理，之后DBMS则可以直接对sql进行处理，不需要再次编译，提高了性能。这一点mybatis 默认情况下，将对所有的 sql 进行预编译处理。</p>
<ul>
<li>预编译可以将多个操作步骤合并成一个步骤，一般而言，越复杂的sql，编译程度也会复杂，难度大，耗时，费性能，而预编译可以合并这些操作，预编译之后DBMS可以省去编译直接运行sql。</li>
<li>预编译语句可以重复利用。<br>把一个 sql 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。</li>
</ul>
</li>
<li><p>是否自动加单引号</p>
<ol>
<li><strong>#{}</strong> 对应的变量会自动加上单引号</li>
<li><strong>${}</strong> 对应的变量不会加上单引号</li>
</ol>
</li>
<li><p>安全性</p>
<ol>
<li><strong>#{} </strong>能防止sql注入</li>
<li><strong>${}</strong> 不能防止sql注入</li>
</ol>
</li>
<li><p>Mybatis默认值不同</p>
<ol>
<li><strong>#{}</strong> 默认值 arg0、arg1、arg2 或 0、 1</li>
<li><strong>${}</strong> 默认值param1、param2、param3</li>
</ol>
</li>
<li><p>如何选择 #{} 和 ${}</p>
<ol>
<li>能用 <strong>#{}</strong> 的地方就用 <strong>#{}</strong>，尽量少用 ${}</li>
<li>表名作参数，或者order by 排序时用 <strong>${}</strong></li>
<li>传参时参数使用<strong>@Param(“”)</strong>注解，<strong>@Param</strong>注解的作用是给参数命名，参数命名后就能根据名字得到参数值（相当于又加了一层密），正确的将参数传入sql语句中（一般通过#{}的方式，${}会有sql注入的问题）。</li>
</ol>
</li>
</ol>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>使用缓存， 我们可以避免频繁的与数据库进行交互， 尤其是在查询越多、缓存命中率越高的情况下， 使用缓存对性能的提高更明显。</p>
<p>mybatis 也提供了对缓存的支持， 分为一级缓存和二级缓存。 但是在默认的情况下， 只开启一级缓存（一级缓存是对同一个 SqlSession 而言的）。</p>
<p><strong>缓存</strong>就是数据交换的缓冲区（称作Cache），是存贮数据（使用频繁的数据）的临时地方。当用户查询数据，首先在缓存中寻找，如果找到了则直接执行。如果找不到，则去数据库中查找。</p>
<p>MyBatis 提供了<strong>一级缓存</strong>和<strong>二级缓存</strong>的支持，默认情况下只有一级缓存</p>
<ol>
<li><p><strong>一级缓存</strong>: 基于PerpetualCache 的 HashMap本地缓存，其<strong>存储作用域为</strong> <strong>Session</strong>，当 <strong>Session flush</strong> <strong>或</strong> <strong>close</strong> 之后，该<strong>Session中的所有 Cache 就将清空</strong>。</p>
<p><strong>增删改也会刷新缓存</strong></p>
<p><strong>手动清理缓存：</strong><code>sqlSession.clearCache();</code></p>
</li>
<li><p><strong>二级缓存</strong>与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，不同在于其<strong>存储作用域为 Mapper(Namespace)</strong>，并且<strong>可自定义存储源</strong>，如 Ehcache。 要启用全局的二级缓存，首先开启全局缓存：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--显示的开启全剧缓存--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>然后只需要在你的 SQL 映射文件中添加一行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>工作机制：</p>
<ol>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；</li>
<li>会话关闭之后，一级缓存中的数据会被保存在二级缓存中；</li>
<li>新的会话查询消息，就会从二级缓存中获取内容；</li>
<li>不同的mapper查出 的数据会放在自己对应的缓存（map）中</li>
</ol>
</li>
</ol>
<ul>
<li>映射语句文件中的所有 select 语句的结果将会被缓存。</li>
<li><strong>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</strong></li>
<li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li>
<li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li>
<li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li>
<li><p>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</p>
<p><strong>提示</strong> 缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。</p>
<p><strong>提示</strong> 二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
        <category>SSM</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC三层架构</title>
    <url>/article/30326.html</url>
    <content><![CDATA[<blockquote>
<p>God says to man, “I heal you therefore I hurt, love you therefore punish.”</p>
<p>神对人说：“我医治你所以伤害你，爱你所以惩罚你。”</p>
</blockquote>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><strong>MVC模式</strong>是软件工程中常见的一种软件架构模式，该模式把软件系统（项目）分为三个基本部分：<strong>模型（Model）、视图（View）和控制器（Controller）。</strong></p>
<p>具体来讲，MVC模式可以将项目划分为模型（M）、视图（V）和控制器（C）三个部分，并赋予各个部分不同的功能，方便开发人员进行分组。</p>
<p><strong>（1）视图（View）：</strong>负责界面的显示，以及与用户的交互功能，例如表单、网页等。</p>
<p><strong>（2）控制器（Controller）：</strong>可以理解为一个分发器，用来决定对于视图发来的请求，需要用哪一个模型来处理，以及处理完后需要跳回到哪一个视图。即用来连接视图和模型。</p>
<p>实际开发中，通常用控制器对客户端的请求数据进行封装（如将form表单发来的若干个表单字段值，封装到一个实体对象中），然后调用某一个模型来处理此请求，最后再转发请求（或重定向）到视图（或另一个控制器）。</p>
<p><strong>（3）模型（Model）：</strong>模型持有所有的数据、状态和程序逻辑。模型接受视图数据的请求，并返回最终的处理结果。 </p>
<img src="/article/30326/webp-20220104132315604" class title="img">
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>首先来说，三层架构与MVC的目标一致：都是为了解耦和、提高代码复用。</p>
<p><strong>MVC是一种设计模式，而三层架构是一种软件架构。</strong></p>
<p>三层架构分为：</p>
<p>表现层（UI）(web层)、业务逻辑层（BLL）(service层)、数据访问层（DAL）(dao层)，再加上实体类库（Model）</p>
<ol>
<li><p>实体类库（Model），在Java中，往往将其称为Entity实体类。数据库中用于存放数据，而我们通常选择会用一个专门的类来抽象出数据表的结构，类的属性就一对一的对应这表的属性。</p>
<p>一般来说，Model实体类库层需要被DAL层，BIL层和UI层引用。</p>
</li>
<li><p>数据访问层（DAL），主要是存放对数据类的访问，即对数据库的添加、删除、修改、更新等基本操作</p>
<p>DAL就是根据业务需求，构造SQL语句，构造参数，调用帮助类，获取结果，DAL层被BIL层调用</p>
</li>
<li><p>业务逻辑层（BLL）</p>
<p>BLL层好比是桥梁，将UI表示层与DAL数据访问层之间联系起来。所要负责的，就是处理涉及业务逻辑相关的问题，比如在调用访问数据库之前，先处理数据、判断数据。</p>
</li>
</ol>
<img src="/article/30326/webp" class title="img">
<h2 id="MVC与三层架构的关系"><a href="#MVC与三层架构的关系" class="headerlink" title="MVC与三层架构的关系"></a>MVC与三层架构的关系</h2><img src="/article/30326/webp-20220104140153015" class title="img">
<h2 id="SSM与三层架构的关系"><a href="#SSM与三层架构的关系" class="headerlink" title="SSM与三层架构的关系"></a>SSM与三层架构的关系</h2><p>SSM，即 SpringMVC、Spring 与 MyBatis 三个框架。它们在三层架构中所处的位置是不同的，即它们在三层架构中的功能各不相同，各司其职。</p>
<ol>
<li><p>SpringMVC：作为 View 层的实现者，完成用户的请求接收功能。SpringMVC 的 Controller作为整个应用的控制器，完成用户请求的转发及对用户的响应。</p>
</li>
<li><p>MyBatis：作为 Dao 层的实现者，完成对数据库的增、删、改、查功能。</p>
</li>
<li><p>Spring：以整个应用大管家的身份出现。整个应用中所有 Bean 的生命周期行为，均由Spring 来管理。即整个应用中所有对象的创建、初始化、销毁，及对象间关联关系的维护，均由 Spring 进行管理。</p>
</li>
</ol>
<img src="/article/30326/webp-20220104140331755" class title="img">
]]></content>
      <categories>
        <category>Java</category>
        <category>MVC三层架构</category>
        <category>MVC三层架构</category>
      </categories>
      <tags>
        <tag>Java,JavaWeb, MVC三层架构</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP</title>
    <url>/article/6685.html</url>
    <content><![CDATA[<blockquote>
<p>Take my wine in my own cup, friend.<br>It loses its wreath of foam when poured into that of others.</p>
<p>在我自己的杯中，饮了我的酒吧，朋友。一倒在别人的杯里，这酒的腾跳的泡沫便要消失了。</p>
</blockquote>
<h2 id="Java-Server-Pages"><a href="#Java-Server-Pages" class="headerlink" title="Java Server Pages"></a>Java Server Pages</h2><p>JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p>
<p>JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。</p>
<p>JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p>
<p>JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。</p>
<h3 id="JSP-处理"><a href="#JSP-处理" class="headerlink" title="JSP 处理"></a>JSP 处理</h3><p>以下步骤表明了 Web 服务器是如何使用JSP来创建网页的：</p>
<ul>
<li>就像其他普通的网页一样，您的浏览器发送一个 HTTP 请求给服务器。</li>
<li>Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成。</li>
<li>JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码。</li>
<li>JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎。</li>
<li>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。</li>
<li>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。</li>
<li>最终，Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样。</li>
</ul>
<img src="/article/6685/jsp-processing.jpg" class title="img">
<p>一般情况下，JSP 引擎会检查 JSP 文件对应的 Servlet 是否已经存在，并且检查 JSP 文件的修改日期是否早于 Servlet。如果 JSP 文件的修改日期早于对应的 Servlet，那么容器就可以确定 JSP 文件没有被修改过并且 Servlet 有效。这使得整个流程与其他脚本语言（比如 PHP）相比要高效快捷一些。</p>
<p>总的来说，JSP 网页就是用另一种方式来编写 Servlet 而不用成为 Java 编程高手。除了解释阶段外，JSP 网页几乎可以被当成一个普通的 Servlet 来对待。</p>
<h3 id="JSP-生命周期"><a href="#JSP-生命周期" class="headerlink" title="JSP 生命周期"></a>JSP 生命周期</h3><p>JSP生命周期就是从创建到销毁的整个过程，类似于servlet生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。</p>
<p>以下是JSP生命周期中所走过的几个阶段：</p>
<ol>
<li><p>编译阶段：</p>
<p>servlet容器编译servlet源文件，生成servlet类</p>
</li>
<li><p>初始化阶段：</p>
<p>加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p>
</li>
<li><p>执行阶段：</p>
<p>调用与JSP对应的servlet实例的服务方法</p>
</li>
<li><p>销毁阶段：</p>
<p>调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p>
<img src="/article/6685/jsp_life_cycle.jpg" class title="img">
</li>
</ol>
<h3 id="JSP编译"><a href="#JSP编译" class="headerlink" title="JSP编译"></a>JSP编译</h3><p>当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。</p>
<p><code>Mac</code>文件地址：<code>~/Library/Caches/JetBrains/IntelliJIdea/tomcat/项目名/work/Catalina/localhost/ROOT/org/apache/jsp/index_jsp.java</code></p>
<p>编译的过程包括三个步骤：</p>
<ul>
<li>解析JSP文件。</li>
<li>将JSP文件转为servlet。</li>
<li>编译servlet。</li>
</ul>
<ol>
<li><p>JSP初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspInit</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">// 初始化代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>一般来讲程序只初始化一次，servlet也是如此。通常情况下您可以在jspInit()方法中初始化数据库连接、打开文件和创建查询表。</p>
</li>
<li><p>JSP执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_jspService</span><span class="hljs-params">(HttpServletRequest request,HttpServletResponse response)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// 服务端处理代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>当JSP网页完成初始化后，JSP引擎将会调用_jspService()方法。</p>
</li>
<li><p>JSP清理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspDestroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// 清理代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>输出页面前新增的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>); <span class="hljs-comment">//设置相应的页面类型</span><br>pageContext = _jspxFactory.getPageContext(<span class="hljs-keyword">this</span>, request, response,<br>         <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">8192</span>, <span class="hljs-keyword">true</span>);<br>_jspx_page_context = pageContext;<br>application = pageContext.getServletContext();<br>config = pageContext.getServletConfig();<br>session = pageContext.getSession();<br>out = pageContext.getOut();<br>_jspx_out = out;<br></code></pre></td></tr></table></figure>
<p>以上这些对象可以在jsp对象中直接使用</p>
<h3 id="JSP-隐式对象-内置"><a href="#JSP-隐式对象-内置" class="headerlink" title="JSP 隐式对象(内置)"></a>JSP 隐式对象(内置)</h3><p>JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> javax.servlet.jsp.PageContext pageContext;<br>javax.servlet.http.HttpSession session = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">final</span> javax.servlet.ServletContext application;<br><span class="hljs-keyword">final</span> javax.servlet.ServletConfig config;<br>javax.servlet.jsp.JspWriter out = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">final</span> java.lang.Object page = <span class="hljs-keyword">this</span>;<br>javax.servlet.jsp.JspWriter _jspx_out = <span class="hljs-keyword">null</span>;<br>javax.servlet.jsp.PageContext _jspx_page_context = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>对象</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">request</td>
<td style="text-align:center"><strong>HttpServletRequest</strong> 接口的实例</td>
</tr>
<tr>
<td style="text-align:center">response</td>
<td style="text-align:center"><strong>HttpServletResponse</strong> 接口的实例</td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td style="text-align:center"><strong>JspWriter</strong>类的实例，用于把结果输出至网页上</td>
</tr>
<tr>
<td style="text-align:center">session</td>
<td style="text-align:center"><strong>HttpSession</strong>类的实例</td>
</tr>
<tr>
<td style="text-align:center">application</td>
<td style="text-align:center"><strong>ServletContext</strong>类的实例，与应用上下文有关</td>
</tr>
<tr>
<td style="text-align:center">config</td>
<td style="text-align:center"><strong>ServletConfig</strong>类的实例</td>
</tr>
<tr>
<td style="text-align:center">pageContext</td>
<td style="text-align:center"><strong>PageContext</strong>类的实例，提供对JSP页面所有对象以及命名空间的访问</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">类似于Java类中的this关键字</td>
</tr>
<tr>
<td style="text-align:center">Exception</td>
<td style="text-align:center"><strong>Exception</strong>类的对象，代表发生错误的JSP页面中对应的异常对象</td>
</tr>
</tbody>
</table>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%--内置对象--%&gt;<br>&lt;%<br>    pageContext.setAttribute(<span class="hljs-string">&quot;name1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>);  <span class="hljs-comment">//保存的数据只在一个页面中有效</span><br>    request.setAttribute(<span class="hljs-string">&quot;name2&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>);  <span class="hljs-comment">//保存的数据只在一次请求中有效，请求转发会携带这个数据</span><br>    session.setAttribute(<span class="hljs-string">&quot;name3&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);  <span class="hljs-comment">//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器</span><br>    application.setAttribute(<span class="hljs-string">&quot;name4&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>);  <span class="hljs-comment">//保存的数据只在一次服务器中有效，从打开服务器到关闭服务器</span><br>%&gt;<br><br>&lt;%<br>		<span class="hljs-comment">//通过pageContext取出我们保存的值</span><br>    <span class="hljs-comment">//通过寻找的方式</span><br>    String name1 = (String) pageContext.findAttribute(<span class="hljs-string">&quot;name1&quot;</span>);<br>    String name2 = (String) pageContext.findAttribute(<span class="hljs-string">&quot;name2&quot;</span>);<br>    String name3 = (String) pageContext.findAttribute(<span class="hljs-string">&quot;name3&quot;</span>);<br>    String name4 = (String) pageContext.findAttribute(<span class="hljs-string">&quot;name4&quot;</span>);<br>    String name5 = (String) pageContext.findAttribute(<span class="hljs-string">&quot;name5&quot;</span>);<br>%&gt;<br><br>&lt;%--使用EL表达式输出  $&#123;&#125;--%&gt;<br>&lt;h1&gt;取出的值为：&lt;/h1&gt;<br>&lt;h3&gt;$&#123;name1&#125;&lt;/h3&gt;<br>&lt;h3&gt;$&#123;name2&#125;&lt;/h3&gt;<br>&lt;h3&gt;$&#123;name3&#125;&lt;/h3&gt;<br>&lt;h3&gt;$&#123;name4&#125;&lt;/h3&gt;<br>&lt;%--使用EL表达式输出  不存在不会输出--%&gt;<br>&lt;h3&gt;$&#123;name5&#125;&lt;/h3&gt;<br>&lt;%--原始方式输出 不存在会输出<span class="hljs-keyword">null</span>--%&gt;<br>&lt;h3&gt;&lt;%=name5%&gt;&lt;/h3&gt;<br></code></pre></td></tr></table></figure>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><a href="/article/37040.html" title="JSPMaven导包">JSPMaven导包</a>
<p><strong>JSP注释</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>语法</strong></th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;%– 注释 –%&gt;</td>
<td style="text-align:center">JSP注释，注释内容不会被发送至浏览器甚至不会被编译</td>
</tr>
<tr>
<td style="text-align:center"><!-- 注释 --></td>
<td style="text-align:center">HTML注释，通过浏览器查看网页源代码时可以看见注释内容</td>
</tr>
<tr>
<td style="text-align:center">&lt;\%</td>
<td style="text-align:center">代表静态 &lt;%常量</td>
</tr>
<tr>
<td style="text-align:center">%></td>
<td style="text-align:center">代表静态 %&gt; 常量</td>
</tr>
<tr>
<td style="text-align:center">\’</td>
<td style="text-align:center">在属性中使用的单引号</td>
</tr>
<tr>
<td style="text-align:center">\”</td>
<td style="text-align:center">在属性中使用的双引号</td>
</tr>
</tbody>
</table>
<p><strong>脚本程序</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;% 代码片段 %&gt;<br>&lt;!-- 或 --&gt;<br>&lt;jsp:scriptlet&gt;<br>   代码片段<br>&lt;/jsp:scriptlet&gt;<br></code></pre></td></tr></table></figure>
<p><strong>中文编码问题</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span><br>    pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span>%&gt;<br></code></pre></td></tr></table></figure>
<p><strong>JSP声明</strong></p>
<p>一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，您必须先声明这些变量和方法然后才能使用它们。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%! declaration; [ declaration; ]+ ... %&gt;<br>&lt;!-- 或 --&gt;<br>&lt;jsp:expression&gt;<br>   代码片段<br>&lt;/jsp:expression&gt;<br></code></pre></td></tr></table></figure>
<p><strong>JSP表达式</strong></p>
<p>将程序结果输出到客户端</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%= 表达式 %&gt;<br>&lt;!-- 或 --&gt;<br>&lt;jsp:declaration&gt;<br>   代码片段<br>&lt;/jsp:declaration&gt;<br></code></pre></td></tr></table></figure>
<p><strong>JSP指令</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ directive attribute=<span class="hljs-string">&quot;value&quot;</span> %&gt;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>指令</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;%@ page … %&gt;</td>
<td style="text-align:center">定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td>
</tr>
<tr>
<td style="text-align:center">&lt;%@ include … %&gt;</td>
<td style="text-align:center">包含其他文件</td>
</tr>
<tr>
<td style="text-align:center">&lt;%@ taglib … %&gt;</td>
<td style="text-align:center">引入标签库的定义，可以是自定义标签</td>
</tr>
</tbody>
</table>
<p><strong>JSP行为</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;jsp:action_name attribute=<span class="hljs-string">&quot;value&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>语法</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">jsp:include</td>
<td style="text-align:center">用于在当前页面中包含静态或动态资源</td>
</tr>
<tr>
<td style="text-align:center">jsp:useBean</td>
<td style="text-align:center">寻找和初始化一个JavaBean组件</td>
</tr>
<tr>
<td style="text-align:center">jsp:setProperty</td>
<td style="text-align:center">设置 JavaBean组件的值</td>
</tr>
<tr>
<td style="text-align:center">jsp:getProperty</td>
<td style="text-align:center">将 JavaBean组件的值插入到 output中</td>
</tr>
<tr>
<td style="text-align:center">jsp:forward</td>
<td style="text-align:center">从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td>
</tr>
<tr>
<td style="text-align:center">jsp:plugin</td>
<td style="text-align:center">用于在生成的HTML页面中包含Applet和JavaBean对象</td>
</tr>
<tr>
<td style="text-align:center">jsp:element</td>
<td style="text-align:center">动态创建一个XML元素</td>
</tr>
<tr>
<td style="text-align:center">jsp:attribute</td>
<td style="text-align:center">定义动态创建的XML元素的属性</td>
</tr>
<tr>
<td style="text-align:center">jsp:body</td>
<td style="text-align:center">定义动态创建的XML元素的主体</td>
</tr>
<tr>
<td style="text-align:center">jsp:text</td>
<td style="text-align:center">用于封装模板数据</td>
</tr>
</tbody>
</table>
<ul>
<li><code>&lt;%@ include %&gt;</code>将两个页面合为一整个页面</li>
<li><code>&lt;jsp:include&gt;</code>将页面拼接</li>
</ul>
<p><strong>JSTL标签</strong></p>
<p>弥补HTML标签的不足</p>
<ol>
<li><p>核心标签</p>
<p>导入标签库</p>
 <figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ taglib prefix=<span class="hljs-string">&quot;c&quot;</span> uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span>%&gt;<br></code></pre></td></tr></table></figure>
<p> |      标签       |                             描述                             |<br> | :————-: | :———————————————————-: |<br> |    &lt;&lt;c:out&gt;&gt;    |              用于在JSP中显示数据，就像&lt;%= … &gt;              |<br> |    &lt;&lt;c:set&gt;&gt;    |                         用于保存数据                         |<br> |    &lt;&lt;c:if&gt;&gt;     | &lt;&lt;c:if&gt;&gt;标签判断表达式的值，如果表达式的值为 true 则执行其主体内容。 |<br> |  &lt;&lt;c:remove&gt;&gt;   |                         用于删除数据                         |<br> |  &lt;&lt;c:forEach&gt;&gt;  |                基础迭代标签，接受多种集合类型                |<br> |    &lt;&lt;c:url&gt;&gt;    |               使用可选的查询参数来创造一个URL                |<br> |  &lt;&lt;c:choose&gt;&gt;   |        本身只当做&lt;&lt;c:when&gt;&gt;和&lt;&lt;c:otherwise&gt;&gt;的父标签         |<br> |   &lt;&lt;c:when&gt;&gt;    |          &lt;&lt;c:choose&gt;&gt;的子标签，用来判断条件是否成立          |<br> | &lt;&lt;c:otherwise&gt;&gt; | &lt;&lt;c:choose&gt;&gt;的子标签，接在&lt;&lt;c:when&gt;&gt;标签后，当&lt;&lt;c:when&gt;&gt;标签判断为false时被执行 |</p>
</li>
</ol>
<h3 id="JSP-JavaBean"><a href="#JSP-JavaBean" class="headerlink" title="JSP JavaBean"></a>JSP JavaBean</h3><p>JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的<a href="https://baike.baidu.com/item/构造器/9844976"><code>构造器</code></a>。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制(反射机制)发现和操作这些JavaBean 的属性。</p>
<ul>
<li>提供一个默认的无参构造函数。</li>
<li>需要被序列化并且实现了 Serializable 接口。</li>
<li>可能有一系列可读写属性。</li>
<li>可能有一系列的 <strong>getter</strong> 或 <strong>setter</strong> 方法</li>
</ul>
<p><strong>JavaBean 属性</strong></p>
<p>一个 JavaBean 对象的属性应该是可访问的。这个属性可以是任意合法的 Java 数据类型，包括自定义 Java 类。</p>
<p>一个 JavaBean 对象的属性可以是可读写，或只读，或只写。JavaBean 对象的属性通过 JavaBean 实现类中提供的两个方法来访问：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>方法</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>getPropertyName()</strong></td>
<td style="text-align:left">举例来说，如果属性的名称为 myName，那么这个方法的名字就要写成 getMyName() 来读取这个属性。这个方法也称为访问器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>setPropertyName()</strong></td>
<td style="text-align:left">举例来说，如果属性的名称为 myName，那么这个方法的名字就要写成 setMyName()来写入这个属性。这个方法也称为写入器。</td>
</tr>
</tbody>
</table>
<p>一个只读的属性只提供 getPropertyName() 方法，一个只写的属性只提供 setPropertyName() 方法。</p>
<p><strong>访问JavaBean</strong></p>
<p>&lt;<a href="jsp:useBean">jsp:useBean</a>&gt;标签可以在 JSP 中声明一个 JavaBean，然后使用。声明后，JavaBean 对象就成了脚本变量，可以通过脚本元素或其他自定义标签来访问。&lt;<a href="jsp:useBean">jsp:useBean</a>&gt;标签的语法格式如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;bean 的名字&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.bobo.pojo.类名&quot;</span> scope=<span class="hljs-string">&quot;bean 的作用域&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>
<p>scope 的值可以是 page，request，session 或 application。id值可任意只要不和同一 JSP 文件中其它 &lt;<a href="jsp:useBean">jsp:useBean</a>&gt; 中 id 值一样就行了</p>
<p><strong>访问 JavaBean 对象的属性</strong></p>
<p>在 &lt;<a href="jsp:useBean">jsp:useBean</a>&gt; 标签主体中使用 &lt;<a href="jsp:getProperty/">jsp:getProperty/</a>&gt; 标签来调用 <strong>getter</strong> 方法，使用 &lt;<a href="jsp:setProperty/">jsp:setProperty/</a>&gt; 标签来调用 <strong>setter</strong> 方法，语法格式如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;bean 编译的类&quot;</span> scope=<span class="hljs-string">&quot;bean 作用域&quot;</span>&gt;<br>   &lt;jsp:setProperty name=<span class="hljs-string">&quot;bean 的 id&quot;</span> property=<span class="hljs-string">&quot;属性名&quot;</span>  <br>                    value=<span class="hljs-string">&quot;value&quot;</span>/&gt;<br>   &lt;jsp:getProperty name=<span class="hljs-string">&quot;bean 的 id&quot;</span> property=<span class="hljs-string">&quot;属性名&quot;</span>/&gt;<br>   ...........<br>&lt;/jsp:useBean&gt;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JavaWeb,JSP,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie_Session</title>
    <url>/article/32177.html</url>
    <content><![CDATA[<blockquote>
<p>Take my wine in my own cup, friend.</p>
<p>It loses its wreath of foam when poured into that of others.</p>
<p>在我自己的杯中，饮了我的酒吧，朋友。</p>
<p>一倒在别人的杯里，这酒的腾跳的泡沫便要消失了。</p>
</blockquote>
<p><strong>会话（Session）</strong>跟踪是Web程序中常用的技术，用来<strong>跟踪用户的整个会话</strong>。常用的会话跟踪技术是Cookie与Session。<strong>Cookie通过在客户端记录信息确定用户身份</strong>，<strong>Session通过在服务器端记录信息确定用户身份</strong>。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><strong>客户端技术</strong></p>
<p>Cookie意为“甜饼”，是<strong>由W3C组织提出</strong>，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。</p>
<p>由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就<strong>给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理</strong>。</p>
<p>Java中把Cookie封装成了<code>javax.servlet.http.Cookie</code>类。每个Cookie都是该Cookie类的对象。服务器通过操作Cookie类对象对客户端Cookie进行操作。通过<strong>request.getCookie()获取客户端提交的所有Cookie</strong>（以Cookie[]数组形式返回），<strong>通过response.addCookie(Cookiecookie)向客户端设置Cookie。</strong></p>
<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ol>
<li><p>创建一个 Cookie 对象：可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>设置最大生存周期：</strong>可以使用 setMaxAge 方法来指定 cookie 能够保持有效的时间（以秒为单位）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">cookie.setMaxAge(<span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">24</span>); <br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>发送 Cookie 到 HTTP 响应头：</strong>可以使用 <strong>response.addCookie</strong> 来添加 HTTP 响应头中的 Cookie.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">response.addCookie(cookie);<br></code></pre></td></tr></table></figure>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>public void setDomain(String pattern)</strong></td>
<td style="text-align:center">该方法设置 cookie 适用的域</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getDomain()</strong></td>
<td style="text-align:center">该方法获取 cookie 适用的域</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setMaxAge(int expiry)</strong></td>
<td style="text-align:center">该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public int getMaxAge()</strong></td>
<td style="text-align:center">该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getName()</strong></td>
<td style="text-align:center">该方法返回 cookie 的名称。名称在创建后不能改变。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setValue(String newValue)</strong></td>
<td style="text-align:center">该方法设置与 cookie 关联的值。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getValue()</strong></td>
<td style="text-align:center">该方法获取与 cookie 关联的值。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setPath(String uri)</strong></td>
<td style="text-align:center">该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getPath()</strong></td>
<td style="text-align:center">该方法获取 cookie 适用的路径。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setSecure(boolean flag)</strong></td>
<td style="text-align:center">该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setComment(String purpose)</strong></td>
<td style="text-align:center">设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getComment()</strong></td>
<td style="text-align:center">获取 cookie 的注释，如果 cookie 没有注释则返回 null。</td>
</tr>
</tbody>
</table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>保存用户上一次访问的时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> javax.xml.crypto.Data;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">//保存用户上一次访问的时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cookieLastTime</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//服务器提供访问的时间  封装成一个信件</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><br><br>        PrintWriter out = resp.getWriter();<br>        <span class="hljs-comment">//cookie 服务器端从客户端获取</span><br>        Cookie[] cookies = req.getCookies();  <span class="hljs-comment">//返回数组  说明Cookie可能存在多个</span><br>        <span class="hljs-comment">//判断Cookie是否存在</span><br>        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//如果存在cookie</span><br>            out.write(<span class="hljs-string">&quot;你上一次访问的时间是：&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;cookies.length;i++) &#123;<br>                Cookie cookie = cookies[i];<br>                <span class="hljs-comment">//获得cookie名字</span><br>                <span class="hljs-keyword">if</span> (cookie.getName().equals(<span class="hljs-string">&quot;lastLoginTime&quot;</span>))&#123;<br>                    <span class="hljs-comment">//获取cookie中的值  parseLong()解析成长整型</span><br>                    <span class="hljs-keyword">long</span> lastLoginTime = Long.parseLong(cookie.getValue());<br>                    Date date = <span class="hljs-keyword">new</span> Date(lastLoginTime);<br>                    out.write(date.toLocaleString());<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            out.write(<span class="hljs-string">&quot;这是您第一次访问本站&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//服务给客户端响应一个cookie</span><br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;lastLoginTime&quot;</span>, System.currentTimeMillis()+<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//cookie有效期为1天</span><br>        cookie.setMaxAge(<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>);<br>        resp.addCookie(cookie);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>Cookie功能需要浏览器的支持</li>
</ul>
<img src="/article/32177/image-20220102212000322.png" class title="image-20220102212000322">
<p><strong>删除Cookie</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">//删除Cookie</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cookieDel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//服务器提供访问的时间  封装成一个信件</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><br>        <span class="hljs-comment">//创建一个Cookie，名字必须要和要删除的名字一致</span><br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;lastLoginTime&quot;</span>,System.currentTimeMillis()+<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//有效期设置为0 立马过期</span><br>        cookie.setMaxAge(<span class="hljs-number">0</span>);<br>        resp.addCookie(cookie);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>中文传递数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.URLDecoder;<br><span class="hljs-keyword">import</span> java.net.URLEncoder;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">//中文数据传递</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cookieEncode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//服务器提供访问的时间  封装成一个信件</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><br>        <span class="hljs-comment">//cookie 服务器端从客户端获取</span><br>        Cookie[] cookies = req.getCookies();  <span class="hljs-comment">//返回数组  说明Cookie可能存在多个</span><br>        PrintWriter out = resp.getWriter();<br>        <span class="hljs-comment">//判断Cookie是否存在</span><br>        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//如果存在cookie</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;cookies.length;i++) &#123;<br>                Cookie cookie = cookies[i];<br>                <span class="hljs-comment">//获得cookie名字</span><br>                <span class="hljs-keyword">if</span> (cookie.getName().equals(<span class="hljs-string">&quot;name&quot;</span>))&#123;<br>                    <span class="hljs-comment">//中文解码  URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;);</span><br>                    String decode = URLDecoder.decode(cookie.getValue(), <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                    out.write(<span class="hljs-string">&quot;你访问名字为：&quot;</span> + decode);<br>                    System.out.println(decode);<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            out.write(<span class="hljs-string">&quot;这是您第一次访问本站&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//中文编码  URLEncoder.encode(&quot;波波&quot;,&quot;utf-8&quot;)</span><br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;name&quot;</span>, URLEncoder.encode(<span class="hljs-string">&quot;波波&quot;</span>,<span class="hljs-string">&quot;utf-8&quot;</span>));<br>        resp.addCookie(cookie);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>cookie的安全属性</strong></p>
<p>HTTP协议不仅是无状态的，而且是不安全的。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。使用HTTP协议传输很机密的内容是一种隐患。如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。下面的代码设置secure属性为true：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;time&quot;</span>, <span class="hljs-string">&quot;20080808&quot;</span>); <br><span class="hljs-comment">// 新建Cookie</span><br>cookie.setSecure(<span class="hljs-keyword">true</span>);                           <br><span class="hljs-comment">// 设置安全属性</span><br>response.addCookie(cookie);                        <br><span class="hljs-comment">// 输出到客户端</span><br></code></pre></td></tr></table></figure>
<p>提示：secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，<strong>需要在程序中对Cookie内容加密、解密，以防泄密</strong></p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><strong>服务器技术</strong></p>
<p><strong>Session是服务器端使用的一种记录客户端状态的机制</strong></p>
<p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p>Session对应的类为<code>javax.servlet.http.HttpSession</code>类。每个来访者对应一个Session对象，所有该客户的状态信息都保存在这个Session对象里。<strong>Session对象是在客户端第一次请求服务器的时候创建的</strong>。Session也是一种key-value的属性对，通过<code>getAttribute(Stringkey)</code>和<code>setAttribute(String key，Objectvalue)</code>方法读写客户状态信息。Servlet里通过<code>request.getSession()</code>方法获取该客户的Session。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>public Object getAttribute(String name)</strong></td>
<td style="text-align:center">该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public Enumeration getAttributeNames()</strong></td>
<td style="text-align:center">该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public long getCreationTime()</strong></td>
<td style="text-align:center">该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getId()</strong></td>
<td style="text-align:center">该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public long getLastAccessedTime()</strong></td>
<td style="text-align:center">该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public int getMaxInactiveInterval()</strong></td>
<td style="text-align:center">该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void invalidate()</strong></td>
<td style="text-align:center">该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public boolean isNew()</strong></td>
<td style="text-align:center">如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void removeAttribute(String name)</strong></td>
<td style="text-align:center">该方法将从该 session 会话移除指定名称的对象。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setAttribute(String name, Object value)</strong></td>
<td style="text-align:center">该方法使用指定的名称绑定一个对象到该 session 会话。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setMaxInactiveInterval(int interval)</strong></td>
<td style="text-align:center">该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。</td>
</tr>
</tbody>
</table>
<h3 id="Session的生命周期"><a href="#Session的生命周期" class="headerlink" title="Session的生命周期"></a>Session的生命周期</h3><p>Session保存在服务器端。<strong>为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。</strong></p>
<p><strong>Session在用户第一次访问服务器的时候自动创建</strong>。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。</p>
<p><strong>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session</strong>。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><strong>设置Session</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.*;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sessionLast</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//解决乱码问题</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>      <br>        <span class="hljs-comment">//得到Session</span><br>        HttpSession session = req.getSession();<br>        <span class="hljs-comment">//向Session存东西</span><br>        session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;bobo&quot;</span>);<br>      <br>        <span class="hljs-comment">//获取sessionID</span><br>        String sessionid = session.getId();<br>        <span class="hljs-comment">//判断是不是新创建的Session</span><br>        <span class="hljs-keyword">if</span> (session.isNew())&#123;<br>            resp.getWriter().write(<span class="hljs-string">&quot;Session创建成功，ID：&quot;</span> + sessionid);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            resp.getWriter().write(<span class="hljs-string">&quot;Session已在服务器中存在,ID:&quot;</span> + sessionid);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/32177/image-20220103101453948.png" class title="image-20220103101453948">
<ul>
<li>request还可以使用getSession(boolean create)来获取Session。区别是如果该客户的Session不存在，request.getSession()方法会返回null，而getSession(true)会先创建Session再将Session返回。</li>
</ul>
<p><strong>移除Session</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionDemo03</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        HttpSession session = req.getSession();<br>        session.removeAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br>        session.invalidate();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>设置 session 会话过期时间：</strong>可以调用 <code>public void setMaxInactiveInterval(int interval)</code> 方法来单独设置 session 会话超时。</li>
</ul>
<p><strong>在web.xml中设置Session默认失效时间</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--设置默认的失效时间--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>	<span class="hljs-comment">&lt;!--15分钟自动Session失效 以分钟为单位--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="Session对浏览器的要求"><a href="#Session对浏览器的要求" class="headerlink" title="Session对浏览器的要求"></a>Session对浏览器的要求</h3><p>虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。</p>
<img src="/article/32177/Session-Cookie%E8%AF%86%E5%88%AB%E6%A0%87%E5%BF%97.png" class title="image-20220103103050610">
<p>该Cookie为服务器自动生成的，它的maxAge属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。</p>
<p>因此同一机器的两个浏览器窗口访问服务器时，会生成两个不同的Session。但是由浏览器窗口内的链接、脚本等打开的新窗口（也就是说不是双击桌面浏览器图标等打开的窗口）除外。这类子窗口会共享<strong>父窗口的Cookie</strong>，因此会共享一个Session。</p>
<p><strong>注意</strong>：新开的浏览器窗口会生成新的Session，但子窗口除外。子窗口会共用父窗口的Session。例如，在链接上右击，在弹出的快捷菜单中选择“在新窗口中打开”时，子窗口便可以访问父窗口的Session。</p>
<p>如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：<a href="#URL 重写">URL地址重写</a>。</p>
<h3 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h3><p>可以在每个 URL 末尾追加一些额外的数据来标识 session 会话，服务器会把该 session 会话标识符与已存储的有关 session 会话的数据相关联。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。</p>
<p>URL 重写是一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的<strong>缺点</strong>是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态 HTML 页面中也会如此。</p>
<p><code>HttpServletResponse</code>类提供了<code>encodeURL(Stringurl)</code>实现URL地址重写</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;td&gt;<br>    &lt;a href=<span class="hljs-string">&quot;&lt;%=response.encodeURL(&quot;</span>index.jsp?c=<span class="hljs-number">1</span>&amp;wd=Java<span class="hljs-string">&quot;) %&gt;&quot;</span>&gt;Homepage&lt;/a&gt;<br>&lt;/td&gt;<br></code></pre></td></tr></table></figure>
<p>该方法会自动判断客户端是否支持Cookie。如果客户端支持Cookie，会将URL原封不动地输出来。如果客户端不支持Cookie，则会将用户Session的id重写到URL中。</p>
<p>重写后的输出可能是这样的：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;td&gt;<br>&lt;ahref=<span class="hljs-string">&quot;index.jsp;jsessionid=0CCD096E7F8D97B0BE608AFDC3E1931E?c=1&amp;wd=Java&quot;</span>&gt;Homepage&lt;/a&gt;<br>&lt;/td&gt;<br></code></pre></td></tr></table></figure>
<p>如果是页面重定向（Redirection），URL地址重写可以这样写：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%<br>   <span class="hljs-keyword">if</span>(“administrator”.equals(userName))&#123;<br>    response.sendRedirect(response.encodeRedirectURL(“administrator.jsp”));<br>    <span class="hljs-keyword">return</span>;<br>   &#125;<br>%&gt;<br></code></pre></td></tr></table></figure>
<p>效果跟<code>response.encodeURL(String url)</code>是一样的：如果客户端支持Cookie，生成原URL地址，如果不支持Cookie，传回重写后的带有jsessionid字符串的地址。</p>
<p><strong>注意</strong>：TOMCAT判断客户端浏览器是否支持Cookie的依据是请求中是否含有Cookie。尽管客户端可能会支持Cookie，但是由于第一次请求时不会携带任何Cookie（因为并无任何Cookie可以携带），URL地址重写后的地址中仍然会带有jsessionid。当第二次访问时服务器已经在浏览器中写入Cookie了，因此URL地址重写后的地址中就不会带有jsessionid了。</p>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><ol>
<li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上</p>
<p>Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个）；</p>
<p>Session是把用户的数据写到用户独占的Session中，服务器保存（保存重要的信息，减少服务器资源的浪费）；</p>
<blockquote>
<p>简单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的session_id，服务器根据当前session_id判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。</p>
<p>由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的session_id，用特殊的浏览器伪造该用户的请求也是能够成功的。</p>
<p>session_id是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性。</p>
<p>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</p>
</blockquote>
</li>
<li><p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session；</p>
</li>
<li>设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话；</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie；</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)；</li>
</ol>
<p><strong>注意</strong>:</p>
<ul>
<li>session很容易失效,用户体验很差;</li>
<li>虽然cookie不安全,但是可以加密 ;</li>
<li>cookie也分为永久和暂时存在的;</li>
<li>浏览器 有禁止cookie功能 ,但一般用户都不会设置;</li>
<li>一定要设置失效时间,要不然浏览器关闭就消失了;</li>
</ul>
<p><strong>两者最大的区别在于生存周期，一个是浏览器启动到浏览器关闭.(浏览器页面一关 ,session就消失了)，一个是预先设置的生存周期，或永久的保存于本地的文件。(cookie)</strong></p>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Servlet</category>
        <category>Servlet</category>
        <category>Cookie_Session</category>
      </categories>
      <tags>
        <tag>Servlet,Cookie,Session</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode小点心</title>
    <url>/article/8368.html</url>
    <content><![CDATA[<blockquote>
<p>在我自己的杯中，饮了我的酒吧，朋友。　　　　　　　　　　　　　　　<br>一倒在别人的杯里，这酒的腾跳的泡沫便要消失了。　　　　　　　　　　<br>Take my wine in my own cup, friend.<br>It loses its wreath of foam when poured into that of others.</p>
</blockquote>
<p><a href="https://blog.csdn.net/syysyf99/article/details/106211336">https://blog.csdn.net/syysyf99/article/details/106211336</a></p>
<ol>
<li><p>Arraylist和数组互相转换</p>
<p>网上搜Arraylist和数组互相转换的方法时，举的例子都是String类型的</p>
<img src="/article/8368/20170629170103520.png" class title="img">
</li>
</ol>
<p>​    但是对于int类型如果这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; a=<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><span class="hljs-keyword">int</span>[] array=(<span class="hljs-keyword">int</span>[])a.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size]);<span class="hljs-comment">//会报错</span><br></code></pre></td></tr></table></figure>
<p>则会报错，这是因为int[]并不等同于Integer[]。因此如果换成Integer[]数组，则能正确运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[list.size()]);<span class="hljs-comment">//能正确运行</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> element:array)&#123;<br>     System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果非得希望得到int[]的话，只能用循环赋值来得到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;<br>    d[i] = list.get(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果既不想用循环，又想要得到int[]，那就只能在jdk8中使用IntStream了。 </p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/article/55715.html</url>
    <content><![CDATA[<blockquote>
<p>The hurricane seeks the shortest road by the no-road, and suddenly ends its search in the Nowhere.</p>
<p>风于无路之中寻求最短之路，又突然地在“无何有之国”终之了它的追求。</p>
</blockquote>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的<a href="https://baike.baidu.com/item/服务器/100571">服务器</a>端程序，具有独立于平台和<a href="https://baike.baidu.com/item/协议/13020269">协议</a>的特性，主要功能在于交互式地浏览和生成数据，生成动态<a href="https://baike.baidu.com/item/Web/150564">Web</a>内容。</p>
<p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于<a href="https://baike.baidu.com/item/HTTP协议/1276942">HTTP协议</a>的Web服务器。</p>
<p>最早支持Servlet标准的是JavaSoft的Java <a href="https://baike.baidu.com/item/Web Server/9306055">Web Server</a>，此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。</p>
<h3 id="Servlet原理"><a href="#Servlet原理" class="headerlink" title="Servlet原理"></a>Servlet原理</h3><p>Servlet运行过程</p>
<img src="/article/55715/Servlet%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B1.jpg" class title="资源分配图">
<p><strong>Servlet的工作过程</strong></p>
<p>步骤：</p>
<ol>
<li>Web Client 向Servlet容器（Tomcat）发出Http请求</li>
<li>Servlet容器接收Web Client的请求</li>
<li>Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。</li>
<li>Servlet容器创建一个HttpResponse对象</li>
<li>Servlet容器调用HttpServlet对象的doservice方法，把HttpRequest对象与HttpResponse对象作为参数传给HttpServlet 对象。</li>
<li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。</li>
<li>HttpServlet调用HttpResponse对象的有关方法，生成响应数据。</li>
<li>Servlet容器把HttpServlet的响应结果传给Web Client。</li>
</ol>
<blockquote>
<ol>
<li>客户端的网络请求首先会被Http服务器接收（也叫Web服务器、web容器，其需要提供web应用运行所需的环境，接收客户端的Http请求）；</li>
<li>Web服务器根据请求的路径将请求转交给对应的Servlet容器（也称Servlet引擎，为Servlet的运行提供环境支持，可以理解为tomcat或其他服务器）；</li>
<li>Servlet容器根据对应的虚拟路径（@WebServlet中配置的）来加载Servlet，如果Serlvet没有被实例化则创建该Servlet的一个实例（调用init方法）；</li>
<li>Servlet容器根据用户的HTTP请求，创建一个ServletRequest对象（HTTP的请求信息被封装在其中）和一个可以对HTTP请求进行响应的ServletResponse对象（类似于寄信，并在信中说明回信的地址），然后调用HttpServlet中重写的service(ServletRequest req, ServletResponse res)方法，并在这个方法中，将ServletRequest、ServletResponse这两个对象向下转型，得到我们非常熟悉的HttpServletRequest和HttpServletResponse两个对象，然后将客户端的请求转发到HttpServlet中protected修饰的service(HttpServletRequest req, HttpServletResponse resp）；</li>
<li>service(HttpServletRequest req, HttpServletResponse resp)根据请求的method（get、post、put、delete、head、options、trace）来调用不同的方法，如doGet、doPost；</li>
<li>服务端处理完Http的请求后，根据HttpServletResponse对象将处理结果作为Http响应返回给客户端。</li>
</ol>
</blockquote>
<p><strong>Servlet UML关系图</strong></p>
<p><img src="/article/Servlet UML关系图.png"><span class="image-caption">img</span></p>
<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a><strong>ServletContext</strong></h3><p>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；</p>
<ol>
<li><p><strong>共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ServletContext context = <span class="hljs-keyword">this</span>.getServletContext(); <br>context.setAttribute(<span class="hljs-string">&quot;数据key&quot;</span>,数据value); <span class="hljs-comment">//将一个数据保存</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>获取初始化参数</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--web.xml--&gt;</span> <br><span class="hljs-comment">&lt;!--配置一些web应用初始化参数--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/javaweb<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123; <br>  ServletContext context = <span class="hljs-keyword">this</span>.getServletContext(); <br>  String url = context.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>); <br>  resp.getWriter().print(url); <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>请求转发</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123; <br>  ServletContext context = <span class="hljs-keyword">this</span>.getServletContext(); <br>  <br>  context.getRequestDispatcher(<span class="hljs-string">&quot;/forwardpath&quot;</span>).forward(req,resp); <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>读取资源文件</strong></p>
<p>Properties</p>
<ul>
<li><p>在java目录下新建properties</p>
</li>
<li><p>在resources目录下新建properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">username</span>=<span class="hljs-string">root12312 </span><br><span class="hljs-attr">password</span>=<span class="hljs-string">zxczxczxc</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123; <br>  InputStream is = <span class="hljs-keyword">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">&quot;/WEB- INF/classes/com/bobo/xx.properties&quot;</span>); <br>  Properties prop = <span class="hljs-keyword">new</span> Properties(); <br>  prop.load(is); <br>  String user = prop.getProperty(<span class="hljs-string">&quot;username&quot;</span>); <br>  String pwd = prop.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>  resp.getWriter().print(user+<span class="hljs-string">&quot;:&quot;</span>+pwd);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<img src="/article/55715/Servlet%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B2.jpg" class title="资源分配图">
<h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><ol>
<li><p>简单分类</p>
<p><strong>负责向浏览器发送数据的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">ServletOutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><span class="hljs-function">PrintWriter <span class="hljs-title">getWriter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br></code></pre></td></tr></table></figure>
<p> 从中我们可以看到，getOutputStream()方法返回ServletOutputStream对象，更适合向客户端写入二进制数据，并且Servlet容器不会对这些二进制数据进行编码，因此我们常用ServletOutputStream来向客户端发送如图片、文件等内容；对于getWriter()方法返回的PrintWriter对象，里面封装了更多的写入字符文本的函数，并且我们上文提到的setContentType()方法设置的MIME类型对其输出内容有效，因此也可以很好地解决中文乱码问题。</p>
<ul>
<li><p><strong>还有一点需要注意的是，这两个方法在一个response对象中不可以同时调用，否则会抛出一个IllegalStateException</strong>，也就是非法状态异常，因为输出流只能有一个（如果可以多次获取的话，客户端又如何确认哪个Http响应是最后一个呢）。</p>
<p><a href="https://blog.csdn.net/qq_34666857/article/details/104838171">点击跳转大佬</a></p>
</li>
</ul>
<p><strong>负责向浏览器发送响应头的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCharacterEncoding</span><span class="hljs-params">(String var1)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentType</span><span class="hljs-params">(String var1)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDateHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">long</span> var2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDateHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">long</span> var2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(String var1, String var2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addHeader</span><span class="hljs-params">(String var1, String var2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setIntHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">int</span> var2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIntHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">int</span> var2)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>相应状态码的常量</strong></p>
<p>| Name |       discribtion        |                   释义                    |<br>| :–: | :———————-: | :—————————————: |<br>| 200  |          SC_OK           |             此次请求已经成功              |<br>| 301  |   SC_MOVED_PERMANENTLY   |       请求的网页已永久移动到新位置        |<br>| 302  |   SC_MOVED_TEMPORARILY   |          临时移动、请求地址不变           |<br>| 401  |     SC_UNAUTHORIZED      |            未授权、用户需登录             |<br>| 403  |       SC_FORBIDDEN       |     服务器拒绝了此次请求（权限问题）      |<br>| 404  |       SC_NOT_FOUND       |           服务器没找到URI匹配的           |<br>| 405  |  SC_METHOD_NOT_ALLOWED   |  调用的方法不允许使用（get、post不匹配）  |<br>| 500  | SC_INTERNAL_SERVER_ERROR |       服务器内部发生异常，请求中断        |<br>| 502  |      SC_BAD_GATEWAY      | 网关错误（如Nginx），无法收到服务器的响应 |<br>| 504  |    SC_GATEWAY_TIMEOUT    |  请求超时，在约定时间内没有收到Http响应   |</p>
</li>
<li><p>常见应用</p>
<ol>
<li><p>向浏览器输出信息</p>
</li>
<li><p>下载文件</p>
<ol>
<li>要获取下载文件的路径</li>
<li>下载的文件名</li>
<li>使浏览器可以支持下载 (Content-disposition) 中文文件名用  URLEncoder.encode 编码，否则可能乱码</li>
<li>获取下载文件输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区中的数据输出到客户端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URLEncoder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>      <br>        <span class="hljs-comment">//1.要获取下载文件的路径</span><br>        String realPath = <span class="hljs-string">&quot;绝对路径&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;下载的文件的路径：&quot;</span> + realPath);<br>        <span class="hljs-comment">//2.下载的文件名</span><br>        <span class="hljs-comment">//substring()截取字符串   lastIndexOf()截取/之后的字符串</span><br>        String fileName = realPath.substring(realPath.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//3.使浏览器可以支持下载 (Content-disposition)   attachment：以附件方式下载    中文文件名用  URLEncoder.encode 编码，否则可能乱码</span><br>        resp.setHeader(<span class="hljs-string">&quot;Content-disposition&quot;</span>,<span class="hljs-string">&quot;attachment;filename&quot;</span> + URLEncoder.encode(<span class="hljs-string">&quot;fileName&quot;</span>,<span class="hljs-string">&quot;utf-8&quot;</span>));<br>        <span class="hljs-comment">//4.获取下载文件输入流</span><br>        FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>        <span class="hljs-comment">//5.创建缓冲区</span><br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//6.获取OutputStream对象</span><br>        ServletOutputStream out = resp.getOutputStream();<br>        <span class="hljs-comment">//7.将FileOutputStream流入到buffer缓冲区</span><br>      	<span class="hljs-comment">//in.read(buffer)</span><br>        <span class="hljs-comment">//8.使用OutputStream将缓冲区中的数据输出到客户端</span><br>        <span class="hljs-keyword">while</span> ((len = in.read(buffer))&gt; <span class="hljs-number">0</span>)&#123;<br>            out.write(buffer,<span class="hljs-number">0</span>,len);<br>        &#125;<br>        in.close();<br>        out.close();<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>验证码功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//如何让浏览器5s自动刷新一次</span><br>        resp.setHeader(<span class="hljs-string">&quot;refresh&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-comment">//在内存中创建一个图片</span><br>        BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(<span class="hljs-number">80</span>,<span class="hljs-number">20</span>,BufferedImage.TYPE_INT_RGB);<br>        <span class="hljs-comment">//得到图片</span><br>        Graphics2D g = (Graphics2D) image.getGraphics();<br>        <span class="hljs-comment">//设置图片背景颜色</span><br>        g.setColor(Color.white);<br>        g.fillRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">80</span>,<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">//给图片写数据</span><br>        g.setColor(Color.BLUE);<br>        g.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-keyword">null</span>,Font.BOLD,<span class="hljs-number">20</span>));<br><br>        g.drawString(makeNum(),<span class="hljs-number">0</span>,<span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">//告诉浏览器这个请求用图片方式打开</span><br>        resp.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);<br>        <span class="hljs-comment">//网站存在缓存 不让浏览器缓存</span><br>        resp.setDateHeader(<span class="hljs-string">&quot;expires&quot;</span>,-<span class="hljs-number">1</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;pragma&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br><br>        <span class="hljs-comment">//将图片写给浏览器</span><br>        <span class="hljs-keyword">boolean</span> write = ImageIO.write(image,<span class="hljs-string">&quot;png&quot;</span>, resp.getOutputStream());<br>    &#125;<br><br>    <span class="hljs-comment">//生成随机数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">makeNum</span><span class="hljs-params">()</span></span>&#123;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>      	<span class="hljs-comment">//6个9 代表6位数</span><br>        String num = random.nextInt(<span class="hljs-number">999999</span>) + <span class="hljs-string">&quot;&quot;</span>;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();  <br>      	<span class="hljs-comment">//保证输出6位数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>-num.length() ; i++) &#123;<br>            sb.append(<span class="hljs-string">&quot;0&quot;</span>);<br>        &#125;<br>        String s = sb.toString() + num;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>实现重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//resp.setHeader(&quot;location&quot;,&quot;/&quot;);</span><br><span class="hljs-comment">//resp.setStatus(302);//重定向常量</span><br><span class="hljs-comment">//重定向一定要注意路径问题</span><br>resp.sendRedirect(<span class="hljs-string">&quot;/img&quot;</span>);   <span class="hljs-comment">//重定向</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过HttpServletRequest方法，获得客户端的所有信息。</p>
<img src="/article/55715/image-20220102153458150.png" class title="image-20220102153458150">
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Cookie[] getCookies()</strong></td>
<td style="text-align:left">返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</td>
</tr>
<tr>
<td style="text-align:left"><strong>ServletInputStream getInputStream()</strong></td>
<td style="text-align:left">使用 ServletInputStream，以二进制数据形式检索请求的主体。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getCharacterEncoding()</strong></td>
<td style="text-align:left">返回请求主体中使用的字符编码的名称。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getContentType()</strong></td>
<td style="text-align:left">返回请求主体的 MIME 类型，如果不知道类型则返回 null。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getContextPath()</strong></td>
<td style="text-align:left">返回指示请求上下文的请求 URI 部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getHeader(String name)</strong></td>
<td style="text-align:left">以字符串形式返回指定的请求头的值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getMethod()</strong></td>
<td style="text-align:left">返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getParameter(String name)</strong></td>
<td style="text-align:left">以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getPathInfo()</strong></td>
<td style="text-align:left">当请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getProtocol()</strong></td>
<td style="text-align:left">返回请求协议的名称和版本。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getQueryString()</strong></td>
<td style="text-align:left">返回包含在路径后的请求 URL 中的查询字符串。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getRemoteAddr()</strong></td>
<td style="text-align:left">返回发送请求的客户端的互联网协议（IP）地址。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getRemoteHost()</strong></td>
<td style="text-align:left">返回发送请求的客户端的完全限定名称。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getRemoteUser()</strong></td>
<td style="text-align:left">如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getRequestURI()</strong></td>
<td style="text-align:left">从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getRequestedSessionId()</strong></td>
<td style="text-align:left">返回由客户端指定的 session 会话 ID。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getServletPath()</strong></td>
<td style="text-align:left">返回调用 JSP 的请求的 URL 的一部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>int getContentLength()</strong></td>
<td style="text-align:left">以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。</td>
</tr>
<tr>
<td style="text-align:left"><strong>int getIntHeader(String name)</strong></td>
<td style="text-align:left">返回指定的请求头的值为一个 int 值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>int getServerPort()</strong></td>
<td style="text-align:left">返回接收到这个请求的端口号。</td>
</tr>
<tr>
<td style="text-align:left"><strong>int getParameterMap()</strong></td>
<td style="text-align:left">将参数封装成 Map 类型。</td>
</tr>
</tbody>
</table>
<ol>
<li><p>获取前端参数，请求转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doGet(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//后台接收中文乱码问题  </span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><br>        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;============================&quot;</span>);<br>        <br>        System.out.println(username);<br>        System.out.println(password);<br>        System.out.println(<span class="hljs-string">&quot;============================&quot;</span>);<br><br>        <span class="hljs-comment">//通过请求转发</span><br>        <span class="hljs-comment">// 这里的/代表当前的web应用</span><br>        req.getRequestDispatcher(<span class="hljs-string">&quot;/success.jsp&quot;</span>).forward(req,resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie_Session"></a>Cookie_Session</h2><p><strong>会话（Session）</strong>跟踪是Web程序中常用的技术，用来<strong>跟踪用户的整个会话</strong>。常用的会话跟踪技术是Cookie与Session。<strong>Cookie通过在客户端记录信息确定用户身份</strong>，<strong>Session通过在服务器端记录信息确定用户身份</strong>。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie意为“甜饼”，是<strong>由W3C组织提出</strong>，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。</p>
<p>　　由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就<strong>给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理</strong>。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。<strong>Session是服务器端使用的一种记录客户端状态的机制</strong>，使用上比Cookie简单一些，相应的也<strong>增加了服务器的存储压力</strong>。</p>
<p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<a href="/article/32177.html" title="点击跳转Cookie_Session详解">点击跳转Cookie_Session详解</a>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>JavaWeb,Java,Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>/article/60206.html</url>
    <content><![CDATA[<blockquote>
<p>My day is done, and I am like a boat drawn on the beach,listening to the dance-music of the tide in the evening.</p>
<p>我的白昼已经完了，我象一只泊在海滩上的小船，谛听着晚潮跳舞的乐声。　</p>
</blockquote>
<p>Java Web，是用Java技术来解决相关web互联网领域的技术栈。web包括：web<a href="https://baike.baidu.com/item/服务端/6492316">服务端</a>和web<a href="https://baike.baidu.com/item/客户端/101081">客户端</a>两部分。Java在客户端的应用有Java Applet，不过<a href="https://baike.baidu.com/item/使用/7741550">使用</a>得很少，Java在<a href="https://baike.baidu.com/item/服务器端/3369401">服务器端</a>的应用非常的丰富，比如<a href="https://baike.baidu.com/item/Servlet/477555">Servlet</a>，<a href="https://baike.baidu.com/item/JSP/141543">JSP</a>、第三方<a href="https://baike.baidu.com/item/框架/1212667">框架</a>等等。Java技术对Web领域的发展注入了强大的动力。</p>
<h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><p>搭建Java Web应用的开发环境—–部署Tomcat服务器、用eclipse创建Server服务、构建Java Web项目、建立第一个JSP文件、 运行JSP文件。</p>
<p>第一个要点是掌握<a href="https://baike.baidu.com/item/tomcat/255751">tomcat</a>的安装和部署。</p>
<p>第二个要点是在IDEA中添加Server服务。把tomcat与IDEA进行关联，方便IDEA管理tomcat。</p>
<p>第三个要点是构建Java Web项目。Web项目开发的第一步就是要建立项目。</p>
<p>第四个要点是建立的项目如何在<a href="https://baike.baidu.com/item/Server/8873208">Server</a>中运行。</p>
<h3 id="Maven项目管理工具"><a href="#Maven项目管理工具" class="headerlink" title="Maven项目管理工具"></a>Maven项目管理工具</h3><p>Maven的核心思想：<strong>约定大于配置</strong></p>
<a href="/article/37040.html" title="&#96;点击跳转Maven配值&#96;">&#96;点击跳转Maven配值&#96;</a>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><a href="/article/55715.html" title="点击跳转Servlet详解">点击跳转Servlet详解</a>
<p>Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的<a href="https://baike.baidu.com/item/服务器/100571">服务器</a>端程序，具有独立于平台和<a href="https://baike.baidu.com/item/协议/13020269">协议</a>的特性，主要功能在于交互式地浏览和生成数据，生成动态<a href="https://baike.baidu.com/item/Web/150564">Web</a>内容。</p>
<p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于<a href="https://baike.baidu.com/item/HTTP协议/1276942">HTTP协议</a>的Web服务器。</p>
<p>最早支持Servlet标准的是JavaSoft的Java <a href="https://baike.baidu.com/item/Web Server/9306055">Web Server</a>，此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。</p>
<a href="/article/37040.html" title="&#96;点击跳转Servlet配值&#96;">&#96;点击跳转Servlet配值&#96;</a>
<p><strong>写一个Servlet程序</strong></p>
<ol>
<li><p>写一个类去继承父类HttpServlet<br>HttpServlet是一个抽象类，但是没有任何抽象方法<br>HttpServlet类中自定义了很多doXxxx方法，每一种方法都对应了浏览器发送请求的方法，一般常用的浏览器发请求方式为get和post，这两种方式分别对应了这个类中的doGet方法和doPost方法。<br>HttpServlet类中，有两个service方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>      PrintWriter writer = resp.getWriter();   <span class="hljs-comment">//响应流 			   </span><br>      writer.print(<span class="hljs-string">&quot;Hello,Serlvet&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>在web.xml里面添加Servlet配置</p>
<p>Servlet映射</p>
<p><a href="#Mapping问题">点击跳转servlet映射问题</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ServletClass<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.bobo.servlet.ServletClass<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ServletClass<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/path<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>配置Tomcat</p>
<img src="/article/60206/%E9%85%8D%E7%BD%AEtomcat0.png" class title="配置tomcat0">
<img src="/article/60206/%E9%85%8D%E7%BD%AEtomcat1.png" class title="image-20220101162955274">
<img src="/article/60206/%E9%85%8D%E7%BD%AEtomcat2.png" class title="image-20220101163103863">
<img src="/article/60206/%E9%85%8D%E7%BD%AEtomcat3.png" class title="image-20220101163153053">
</li>
<li><p>启动Tomcat服务</p>
</li>
</ol>
<h4 id="Servlet原理"><a href="#Servlet原理" class="headerlink" title="Servlet原理"></a>Servlet原理</h4><p><strong>Servlet的工作过程</strong></p>
<p>步骤：</p>
<ol>
<li>Web Client 向Servlet容器（Tomcat）发出Http请求</li>
<li>Servlet容器接收Web Client的请求</li>
<li>Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。</li>
<li>Servlet容器创建一个HttpResponse对象</li>
<li>Servlet容器调用HttpServlet对象的doservice方法，把HttpRequest对象与HttpResponse对象作为参数传给HttpServlet 对象。</li>
<li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。</li>
<li>HttpServlet调用HttpResponse对象的有关方法，生成响应数据。</li>
<li>Servlet容器把HttpServlet的响应结果传给Web Client。</li>
</ol>
<h4 id="Mapping问题"><a href="#Mapping问题" class="headerlink" title="Mapping问题"></a>Mapping问题</h4><ul>
<li><p>一个Servlet可以指定一个映射路径</p>
</li>
<li><p>一个Servlet可以指定多个映射路径</p>
</li>
<li><p>一个Servlet可以指定通用映射路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>默认请求路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--默认请求路径--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>指定一些后缀或者前缀</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以自定义后缀实现请求映射 注意点，*前面不能加项目映射的路径--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.bobo<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>优先级问题</p>
<p>指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--404--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.bobo.servlet.ErrorServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p><strong>JSP</strong>（全称<strong>J</strong>ava<strong>S</strong>erver <strong>P</strong>ages）是由<a href="https://baike.baidu.com/item/Sun Microsystems">Sun Microsystems</a>公司主导创建的一种<a href="https://baike.baidu.com/item/动态网页技术/9415956">动态网页技术</a>标准。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成<a href="https://baike.baidu.com/item/HTML">HTML</a>、<a href="https://baike.baidu.com/item/XML">XML</a>或其他格式文档的<a href="https://baike.baidu.com/item/Web">Web</a>网页，然后返回给请求者。JSP技术以<a href="https://baike.baidu.com/item/Java">Java</a>语言作为<a href="https://baike.baidu.com/item/脚本语言">脚本语言</a>，为用户的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。</p>
<p>JSP将Java代码和特定变动内容嵌入到静态的页面中，实现以静态页面为模板，动态生成其中的部分内容。JSP引入了被称为“JSP动作”的XML标签，用来调用内建功能。另外，可以创建JSP标签库，然后像使用标准HTML或XML标签一样使用它们。标签库能增强功能和服务器性能，而且不受<a href="https://baike.baidu.com/item/跨平台">跨平台</a>问题的限制。JSP文件在运行时会被其编译器转换成更原始的<a href="https://baike.baidu.com/item/Servlet">Servlet</a>代码。JSP编译器可以把JSP文件编译成用Java代码写的Servlet，然后再由Java编译器来编译成能快速执行的二进制<a href="https://baike.baidu.com/item/机器码">机器码</a>，也可以直接编译成二进制码。</p>
<a href="/article/6685.html" title="点击跳转JSP">点击跳转JSP</a>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><a href="/article/30326.html" title="点击跳转MVC三层架构">点击跳转MVC三层架构</a>
<p>MVC指MVC模式的某种框架，它强制性地使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。最典型的MVC就是<a href="/article/6685.html" title="JSP">JSP</a> + <a href="/article/55715.html" title="servlet">servlet</a> + <a href="/article/6685.html" title="JavaBean">JavaBean</a>的模式。</p>
<p><strong>视图View</strong></p>
<p>负责页面的显示；与用户的交互。包含各种表单。</p>
<p><strong>控制器Controller</strong></p>
<p>控制器负责将视图与模型一一对应起来。相当于一个模型分发器。所谓分发就是：①接收请求，并将该请求跳转（转发，重定向）到模型进行处理。②模型处理完毕后，再通过控制器，返回给视图中的请求处。建议使用Servlet实现控制器。</p>
<p><strong>模型Model</strong></p>
<p>模型负责各个功能的实现（如登录、增加、删除功能）。模型用JavaBean实现。</p>
<blockquote>
<p>JavaBeans :<br>①是Java中一种特殊的类（换言之：JavaBean就是一个Java类）.<br>一个Java类 ，满足以下要求，则可称为一个JavaBean<br>  a. public修饰的类，提供public 无参构造方法<br>  b. 所有属性 都是private<br>  c. 提供getter和setter方法</p>
<p>②从使用层面来看，JavaBean分为2大类：<br>  a. 封装业务逻辑的JavaBean （eg:LoginDao.java 封装了登录逻辑）<br>  b. 封装数据的JavaBean （实体类：eg：Student.java  Vedio.java 。往往对应于数据库中的一张表，即数据库中有个Student表，项目中就有个Student.java类）</p>
<p>③JavaBean 是一个可以重复使用的组件，通过编写一个组件来实现某种通用功能，“一次编写、任何地方执行、任何地方重用”。</p>
</blockquote>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><img src="/article/60206/%E8%BF%87%E6%BB%A4%E5%99%A8.png" class title="img">
<p><strong>过滤器如何编写</strong></p>
<ol>
<li><p>过滤器(Filter接口)是一个接口，所以需要一个实现这个接口的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>filterChain.doFilter()方法；</strong><br>执行目标资源，或是执行下一个过滤器！如果没有下一个过滤器那么执行的是目标资源，如果有，那么执行下一个过滤器</p>
</li>
</ol>
<ol start="2">
<li><p>配置:在<code>web.xml</code>文件中配置，配置之后才会有效果，就如servlet一样</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>MyFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.bobo.filter.MyFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>MyFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>  	<span class="hljs-comment">&lt;!--只要是/filter下面的任何请求都会经过这个过滤器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/filter/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>多个过滤器的执行顺序</strong></p>
<p>配置顺序决定了过滤器的执行顺序<br>就是哪个文件在第一个，谁就是第一个执行</p>
<p><strong>过滤器的四种拦截方式</strong>：</p>
<ul>
<li>REQUEST 是默认的，当输入其他的，那么默认的将取消（消失）</li>
<li>请求（拦的是直接请求，不拦转发请求）：REQUEST</li>
<li>转发（专门拦转发）：FORWARD</li>
<li>包含（专门拦包含）：INCLUDE</li>
<li>错误（专门拦错误）：ERROR</li>
</ul>
</li>
</ol>
<p><strong>Filter接口的生命周期</strong></p>
<p>初始化(init())到使用（doFilter()）到关闭之前（destroy()）</p>
<ol>
<li>init(FilterConfig)<br>什么执行：创建Filter之后，马上执行；<br>什么时候创建呢：Filter会在服务器启动时就创建</li>
<li>doFilter(ServletRequest,ServletResponse,FilterChain)<br>什么时候执行：每次过滤时都会执行</li>
<li>destroy()<br>什么时候执行：在销毁之前执行<br>什么时候销毁呢：在服务器关闭时销毁</li>
</ol>
<blockquote>
<p>当启动服务器时init方法马上执行了（在还没打开网页前已经执行了）<br>在过滤时(网页刷新时)才运行doFilter方法<br>当关掉服务器时执行destroy方法，就是当你点击关闭服务器是，就在执行了，伴随关闭一起执行</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharaterEncodingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-comment">//web服务启动就初始化</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;CharaterEncodingFilter初始化&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        servletRequest.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        servletResponse.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>        <span class="hljs-comment">//chain链</span><br>        <span class="hljs-comment">//过滤中的所有代码，在特定请求的时候都会执行</span><br>        <span class="hljs-comment">//必须要让过滤器继续同行</span><br>        System.out.println(<span class="hljs-string">&quot;CharaterEncodingFilter执行前&quot;</span>);<br>        filterChain.doFilter(servletRequest,servletResponse);  <span class="hljs-comment">//让我们的请求继续走，如果不写，程序到这里就会被拦截</span><br>        System.out.println(<span class="hljs-string">&quot;CharaterEncodingFilter执行后&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//注销</span><br>    <span class="hljs-comment">//web服务器关闭时 过滤会注销</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;CharaterEncodingFilter注销&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>通过监听获取Seesion中用户</strong></p>
<p>因为要用到HttpServletRequest中的方法，所以对ServletRequest进行了强转，将<code>ServletRequest servletRequest</code>强制转换为子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">HttpServletRequest req = (HttpServletRequest) servletRequest;<br></code></pre></td></tr></table></figure>
<p>此时有一些困惑：子类除了完全继承父类的方法外还会拓展自己的方法，所以我们在调用子类方法时可能在父类实现中是找不到的，所以向下转型不安全的。</p>
<p>其实<code>doFilter</code>的参数request对象的生成方式不是<code>ServletRequest request = new ServletRequest();</code>这种形式，而是<code>ServletRequest request = new HttpServletRequest();</code>这种形式，参数里的request不是父类ServletRequest的对象，而是HttpServletRequest的上转型对象。</p>
<p>在这篇<a href="https://www.cnblogs.com/gwyy/p/9078135.html">博客</a>中，博主给了很好的解释。</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>监听器就是监听某个对象的的状态变化的组件</p>
<ul>
<li>被监听的对象（三个域对象 request，session，servletContext）</li>
<li>监听器：监听事件源对象， 事件源对象的状态的变化都会触发监听器 。</li>
<li>注册监听器：将监听器与事件源进行绑定。</li>
<li>响应行为：监听器监听到事件源的状态变化时，所涉及的功能代码（程序员编写代码）</li>
</ul>
<p>监听器的编写步骤：</p>
<ol>
<li><p>编写一个监听器类去实现监听器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.http.HttpSessionEvent;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSessionListener;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>覆盖监听器的方法</p>
</li>
<li><p>需要在web.xml中进行配置（注册）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    注册监听器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">listenerclass</span>&gt;</span>com.bobo.listenre.MyListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.ServletContext;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSessionEvent;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSessionListener;<br><br><span class="hljs-comment">//统计网站在线人数 --统计session</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span></span>&#123;<br>    <span class="hljs-comment">//创建session的监听</span><br>    <span class="hljs-comment">//一旦创建session就会触发一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;<br>        ServletContext ctx = httpSessionEvent.getSession().getServletContext();<br>        System.out.println(httpSessionEvent.getSession().getId());<br>        Integer onlineCount =(Integer) ctx.getAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>);<br>        <span class="hljs-keyword">if</span> (onlineCount==<span class="hljs-keyword">null</span>)&#123;<br>            onlineCount = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> count = onlineCount.intValue();<br>            onlineCount = <span class="hljs-keyword">new</span> Integer(count+<span class="hljs-number">1</span>);<br>        &#125;<br>        ctx.setAttribute(<span class="hljs-string">&quot;onlineCount&quot;</span>,onlineCount);<br>    &#125;<br>    <span class="hljs-comment">//销毁session的监听</span><br>    <span class="hljs-comment">//一旦销毁session就会触发一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;<br>        ServletContext ctx = httpSessionEvent.getSession().getServletContext();<br><br>        Integer onlineCount =(Integer) ctx.getAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>);<br>        <span class="hljs-keyword">if</span> (onlineCount==<span class="hljs-keyword">null</span>)&#123;<br>            onlineCount = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> count = onlineCount.intValue();<br>            onlineCount = <span class="hljs-keyword">new</span> Integer(count-<span class="hljs-number">1</span>);<br>        &#125;<br>        ctx.setAttribute(<span class="hljs-string">&quot;onlineCount&quot;</span>,onlineCount);<br>    &#125;<br><br><span class="hljs-comment">//    session销毁：</span><br>    <span class="hljs-comment">//1。手动销毁  httpSessionEvent.getSession().invalidate();</span><br>    <span class="hljs-comment">//2。自动销毁   web.xml中配置</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&lt;%@ page contentType=&quot;text/html; charset=utf-8&quot; language=&quot;java&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.055ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 2176.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">Title</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-54" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMATHI-6C" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/>
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-54" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="704" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="1050" y="0"/>
 <use xlink:href="#E1-MJMATHI-6C" x="1411" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="1710" y="0"/>
</g>
</svg><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>当前有<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&lt;%=this.getServletConfig().getServletContext().getAttribute(&quot;onlineCount&quot;)%&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>人在线<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>首先导入<code>commons-io-版本.jar</code>与<code>commons-fileupload-版本.jar</code></p>
<p>注意事项：</p>
<ol>
<li>为保证服务器安全，上传文件应该放在外界无法直接访问的目录下，比如放于WEB-INF目录下。</li>
<li>为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名。</li>
<li>为防止一个目录下面出现太多文件，要使用hash算法打散存储。</li>
<li>要限制上传文件的最大值。</li>
<li>要限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法。</li>
</ol>
<p><strong>通过表单上传文件</strong></p>
<ul>
<li>get  上传文件大小有限制</li>
<li>post   上传文件大小没有限制</li>
</ul>
<p>必须要用 post 进行提交，这种方式，将会把数据封装在请求体中进行发送。</p>
<p><strong>使用的类</strong></p>
<ol>
<li><p>FileItem类</p>
<p>表单如果包含一个文件上传输入选项，这个表单的<code>enctype</code>属性必须设置为<code>enctype=&quot;multipart/form-date&quot;</code>。</p>
</li>
<li><p>ServletFileUpload类</p>
<p>负责处理上传的文件数据，并将表单中的每个输入项封装成一个<code>FileItem</code>对象，使用parseRequest(HttpServletReqquest)方法可以将通过表单中的每一个HTML标签提交的数据封装成一个FileItem对象，然后以List列表的形式返回。</p>
<p>在使用<code>ServletFileUpload</code>对象解析请求时需要<code>DiskFileItemFactory</code>对象，所以，我们需要在进行解析工作前构造好<code>DiskFileItemFactory</code>对象，并通过<code>ServletFileUpload</code>对象的构造方法或<code>setFileItemFactory()</code>方法设置<code>ServletFileUpload</code>对象的<code>fileItmlFactory</code>属性。</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/linghuainian/article/details/82253247">博文推荐</a></p>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>配置</title>
    <url>/article/37040.html</url>
    <content><![CDATA[<blockquote>
<p>You idol is shattered in the dust to prove that God’s dust is greaterthan your idol.</p>
<p>你的偶像委散在尘土中了，这可证明神的尘土比你的偶像还伟大。</p>
</blockquote>
<h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><p><a href="https://mvnrepository.com">Maven仓库</a></p>
<p><strong>Maven头部</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>Maven资源导出配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resources  防止我们资源导出失败的问题--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><strong>web.xml</strong></h2><p><code>web.xml</code>头文件要保持最新，与maven版本一致</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">metadata-complete</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="Servlet配置"><a href="#Servlet配置" class="headerlink" title="Servlet配置"></a>Servlet配置</h2><h3 id="Servlet依赖包"><a href="#Servlet依赖包" class="headerlink" title="Servlet依赖包"></a>Servlet依赖包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="JSP依赖包"><a href="#JSP依赖包" class="headerlink" title="JSP依赖包"></a>JSP依赖包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Servlet依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- JSP依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--JSTL表达式依赖--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--standard标签库依赖--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="数据库依赖包"><a href="#数据库依赖包" class="headerlink" title="数据库依赖包"></a>数据库依赖包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="Mybatis配置"><a href="#Mybatis配置" class="headerlink" title="Mybatis配置"></a><strong>Mybatis配置</strong></h2><p><strong>Maven导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>从 XML 中构建 SqlSessionFactory</strong></p>
<p>在<code>rescouces</code>文件下创建<code>mybatis-config.xml</code>配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String resource = <span class="hljs-string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;<br>InputStream inputStream = Resources.getResourceAsStream(resource);<br>SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br></code></pre></td></tr></table></figure>
<p><strong>Mybatis日志</strong></p>
<p>SLF4J | <strong>LOG4J(deprecated since 3.5.9)</strong> | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | <strong>STDOUT_LOGGING</strong> | NO_LOGGING</p>
<p><strong>STDOUT_LOGGING</strong> 标准日志输出</p>
<p><code>mybatis-config.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--标准日志工厂实现--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>LOG4J(deprecated since 3.5.9)</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--LOG4J日志--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>使用LOG4J需要添加propertise配置文件<code>log4j.properties</code>(直接百度)</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">DEBUG,console,file</span><br><br><span class="hljs-meta">log4j.appender.console</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.console.Target</span> = <span class="hljs-string">System.out</span><br><span class="hljs-meta">log4j.appender.console.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.console.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">[%c]-%m%n</span><br><br><span class="hljs-meta">log4j.appender.file</span> = <span class="hljs-string">org.apache.log4j.RollingFileAppender</span><br><span class="hljs-meta">log4j.appender.file.File</span>=<span class="hljs-string">./log/bobo.log</span><br><span class="hljs-meta">log4j.appender.file.MaxFileSize</span>=<span class="hljs-string">10mb</span><br><span class="hljs-meta">log4j.appender.file.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.file.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="hljs-string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><br><span class="hljs-meta">log4j.logger.org.mybatis</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.Statement</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.ResultSet</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="hljs-string">DEBUG</span><br></code></pre></td></tr></table></figure>
<h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><p><strong>maven导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>IOC配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>AOP配置</strong></p>
<p><code>XML配置</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd </span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/aop </span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- bean definition &amp; AOP specific configuration --&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>Maven配置</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>Spring-Mybatis整合 导入Maven依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--单元测试--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--数据库--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--Mybatis--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--Spring操作数据库的，还需要一个Spring-jdbc--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--AOP--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--mybatis-spring--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--lombok注解--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="Spring-自动装配-注解配置"><a href="#Spring-自动装配-注解配置" class="headerlink" title="Spring 自动装配 注解配置"></a>Spring 自动装配 注解配置</h3><p>从 Spring 2.5 开始就可以使用<strong>注解</strong>来配置依赖注入。而不是采用 XML 来描述一个 bean 连线，你可以使用相关类，方法或字段声明的注解，将 bean 配置移动到组件类本身。</p>
<p>在 XML 注入之前进行注解注入，因此后者的配置将通过两种方式的属性连线被前者重写。</p>
<p>使用注解配置文件 <code>applicaitonContext.xml</code> 导入<code>context</code> 约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- 开启注解支持 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>注解</th>
<th>注解 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Required</td>
<td>@Required 注解应用于 bean 属性的 setter 方法。</td>
</tr>
<tr>
<td>@Autowired</td>
<td>@Autowired 注解可以应用到 bean 属性的 setter 方法，非 setter 方法，构造函数和属性。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>通过指定确切的将被连线的 bean，@Autowired 和 @Qualifier 注解可以用来删除混乱。</td>
</tr>
<tr>
<td>JSR-250 Annotations</td>
<td>Spring 支持 JSR-250 的基础的注解，其中包括了 @Resource，@PostConstruct 和 @PreDestroy 注解。</td>
</tr>
</tbody>
</table>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ol>
<li><p>首先，我们从所属范围来看，事实上这个注解是属于 Spring 的容器配置的一个注解@Autowired 注解是一个用于容器 ( container ) 配置的注解。</p>
</li>
<li><p>其次，我们可以直接从字面意思来看，@autowired 注解来源于英文单词 autowire,这个单词的意思是自动装配的意思。</p>
</li>
<li><p>自动装配指的就是使用将 Spring 容器中的 bean 自动的和我们需要这个 bean 的类组装在一起。</p>
</li>
</ol>
<ul>
<li>将 @Autowired 注解应用于构造函数</li>
<li>将 @Autowired 注解应用于 setter 方法</li>
<li>将 @Autowired 注解应用于具有任意名称和多个参数的方法</li>
<li>将 @Autowired 注解应用于字段，或者将其与构造函数混合</li>
<li>将 @Autowired 注解添加到需要该类型数组的字段或方法，则 Spring 会从 ApplicationContext 中搜寻符合指定类型的所有 bean</li>
<li>…</li>
</ul>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>可能会有这样一种情况，当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 <strong>@Qualifier</strong> 注解和 <strong>@Autowired</strong> 注解通过指定哪一个真正的 bean 将会被装配来消除混乱。</p>
<h4 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h4><p><strong>@Required</strong> 注解应用于 bean 属性的 setter 方法，它表明受影响的 bean 属性在配置时必须放在 XML 配置文件中，否则容器就会抛出一个 BeanInitializationException 异常。</p>
<h3 id="Java注解配置"><a href="#Java注解配置" class="headerlink" title="Java注解配置"></a>Java注解配置</h3><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>@Resource ，用来激活一个命名资源（namedresource）的依赖注入，在JavaEE应用程序中，该注解被典型地转换为绑定于JNDI context中的一个对象。</p>
<p>spring确实支持使用@Resource通过JNDIlookup来解析对象，默认地，拥有与@Resource注解所提供名字相匹配的“beanname（bean名字）”的Spring管理对象会被注入。</p>
<p>@Resource装配顺序</p>
<ol>
<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常；</li>
<li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常；</li>
<li>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常；</li>
<li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li>
</ol>
<hr>
<h4 id="Configuration-和-Bean-注解"><a href="#Configuration-和-Bean-注解" class="headerlink" title="@Configuration 和 @Bean 注解"></a><strong>@Configuration 和 @Bean 注解</strong></h4><p><strong>@Configuration</strong> 注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。</p>
<p><strong>@Bean</strong> 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.*;<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldConfig</span> </span>&#123;<br>   <span class="hljs-meta">@Bean</span> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> HelloWorld <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloWorld();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Spring使用注解开发"><a href="#Spring使用注解开发" class="headerlink" title="Spring使用注解开发"></a>Spring使用注解开发</h3><p>使用注解开发，必须要保证<code>aop</code>的包导入</p>
<p><code>aop</code>存在于<code>spring-webmvc</code>中</p>
<img src="/article/37040/image-20220117160906000.png" class title="image-20220117160906000">
<p>同样需要导入<code>context</code>约束，增加注解支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">方法一：<br><span class="hljs-comment">&lt;!--制定扫描包，包下注解会生效--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;包&quot;</span>/&gt;</span><br>方法二：<br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>使用<code>component-scan</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br></code></pre></td></tr></table></figure>
<p>用于把当前类对象存入spring容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br></code></pre></td></tr></table></figure>
<p>用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。</p>
<p><strong>@Component</strong>衍生注解</p>
<ol>
<li>@Repository   与 @Component功能相似，作用在dao层</li>
<li>@Service   与 @Component功能相似，作用在service层</li>
<li>@Controller   与 @Component功能相似，作用在controller层</li>
</ol>
<p><strong>使用</strong><code>@Scope</code></p>
<p>作用就和在bean标签中使用scope属性实现的功能是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope</span><br></code></pre></td></tr></table></figure>
<p>可取值：prototype、request、ression、singleton</p>
<p>用于指定bean的作用范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br></code></pre></td></tr></table></figure>
<p>指定范围的取值</p>
<h3 id="SpringMVC相关注解"><a href="#SpringMVC相关注解" class="headerlink" title="SpringMVC相关注解"></a>SpringMVC相关注解</h3><h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><p><code>@Controller</code>注解表明了一个类是作为控制器的角色而存在的。Spring不要求你去继承任何控制器基类，也不要求你去实现Servlet的那套API。当然，如果你需要的话也可以去使用任何与Servlet相关的特性和设施。</p>
<p><code>@Controller</code>注解可以认为是被标注类的原型（stereotype），表明了这个类所承担的角色。分派器（<code>DispatcherServlet</code>）会扫描所有注解了<code>@Controller</code>的类，检测其中通过<code>@RequestMapping</code>注解配置的方法。</p>
<p><strong>使用这个注解的类中的所有的方法，如果返回值是<code>String</code>，并且有具体页面可以跳转，那么就会被视图解析器解析</strong></p>
<h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><p>你可以使用<code>@RequestMapping</code>注解来将请求URL，映射到整个类上或某个特定的处理器方法上。</p>
<p>一般来说，类级别的注解负责将一个特定（或符合某种模式）的请求路径映射到一个控制器上，同时通过方法级别的注解来细化映射，即根据特定的HTTP请求方法（“GET”“POST”方法等）、HTTP请求中是否携带特定参数等条件，将请求映射到匹配的方法上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;&quot;, method = )</span><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>method</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>RequestMethod.GET</td>
<td>它仅接受GET方法的请求</td>
</tr>
<tr>
<td>RequestMethod.POST</td>
<td>它仅接受GET方法的请求</td>
</tr>
</tbody>
</table>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-controller">点击跳转官方注解</a></p>
<ol>
<li><p>@RequestMapping 处理多个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &#123;  </span><br><span class="hljs-meta">  &quot;&quot;,  </span><br><span class="hljs-meta">  &quot;/page&quot;,  </span><br><span class="hljs-meta">  &quot;page*&quot;,  </span><br><span class="hljs-meta">  &quot;view/*,**/msg&quot;  </span><br><span class="hljs-meta">&#125;)</span> <br></code></pre></td></tr></table></figure>
</li>
<li><p>带有 @RequestParam 的 @RequestMapping</p>
<p>@RequestParam 注解使用的时候可以有一个值，也可以没有值。这个值指定了需要被映射到处理方法参数的请求参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/id&quot;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getIdByValue</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> String personId)</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;ID is &quot;</span> + personId);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get ID from query string of URL with value element&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/personId&quot;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getId</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String personId)</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;ID is &quot;</span> + personId);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get ID from query string of URL without value element&quot;</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>@RequestParam 注解的 required 这个参数定义了参数值是否是必须要传的。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestParam(value = &quot;person&quot;, required = false)</span><br></code></pre></td></tr></table></figure>
<p>@RequestParam 的 defaultValue 取值就是用来给取值为空的请求参数提供一个默认值的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestParam(value = &quot;person&quot;, defaultValue = &quot;Bobo&quot;)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>@RequestMapping 快捷方式</p>
<p>Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。组合注解可以更好的表达被注解方法的语义。它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。 </p>
<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@DeleteMapping</li>
<li>@PatchMapping</li>
</ul>
</li>
</ol>
<h4 id="ResponseBody注解"><a href="#ResponseBody注解" class="headerlink" title="@ResponseBody注解"></a>@ResponseBody注解</h4><p>注解 @ResponseBody，使用在控制层（controller）的方法上</p>
<p>该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区,进而将数据返回给客户端。</p>
<p>POST模式下，使用@RequestBody绑定请求对象，Spring会帮你进行协议转换，将Json、Xml协议转换成你需要的对象。@ResponseBody可以标注任何对象，由Spring完成对象——协议的转换。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(User user)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>User字段：userName pwd<br>那么在前台接收到的数据为：’{“userName”:”xxx”,”pwd”:”xxx”}’</p>
</blockquote>
<h4 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h4><p>在Spring中@RestController的作用等同于@Controller + @ResponseBody</p>
<p>不会走视图解析器，直接返回一个字符串</p>
<h4 id="SpringMVC对RESTful风格的支持"><a href="#SpringMVC对RESTful风格的支持" class="headerlink" title="SpringMVC对RESTful风格的支持"></a>SpringMVC对RESTful风格的支持</h4><p><strong>@PathVariable</strong></p>
<p>@PathVariable是spring3.0的一个新功能：接收请求路径中占位符的值</p>
<p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span><br></code></pre></td></tr></table></figure>
<h3 id="SpringBoot相关注解"><a href="#SpringBoot相关注解" class="headerlink" title="SpringBoot相关注解"></a><strong>SpringBoot相关注解</strong></h3><h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><p>通过 SpringBoot 提供的 @ConfigurationProperties 注解，可以将全局配置文件中的配置数据绑定到 JavaBean 中。</p>
<p>告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定；</p>
<p>prefix = “ClassName”：配置文件中哪个下面的所有属性进行一一映射</p>
<a href="/article/33757.html" title="点击跳转yaml使用注解给属性赋值">点击跳转yaml使用注解给属性赋值</a>
<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><p>只需要读取配置文件中的某一个配置时，可以通过 @Value 注解获取</p>
<a href="/article/33757.html" title="点击跳转yaml使用注解给属性赋值">点击跳转yaml使用注解给属性赋值</a>
<blockquote>
<p><strong>@Value 与 @ConfigurationProperties 对比</strong></p>
<p>@Value 和 @ConfigurationProperties 注解都能读取配置文件中的属性值并绑定到 JavaBean 中，但两者存在以下不同。</p>
<ol>
<li><p>使用位置不同</p>
<ul>
<li><p>@ConfigurationProperties：标注在 JavaBean 的类名上；</p>
</li>
<li><p>@Value：标注在 JavaBean 的属性上。</p>
</li>
</ul>
</li>
<li><p>功能不同</p>
<ul>
<li><p>@ConfigurationProperties：用于批量绑定配置文件中的配置；</p>
</li>
<li><p>@Value：只能一个一个的指定需要绑定的配置。</p>
</li>
</ul>
</li>
<li><p>松散绑定支持不同</p>
<p>@ConfigurationProperties：支持松散绑定（松散语法），例如实体类 Person 中有一个属性为 lastName，那么配置文件中的属性名支持以下写法：</p>
<ul>
<li>person.firstName</li>
<li>person.first-name</li>
<li>person.first_name</li>
<li><p>PERSON_FIRST_NAME</p>
<p>@Vaule：不支持松散绑定。</p>
</li>
</ul>
</li>
<li><p>SpEL 支持不同</p>
<ul>
<li>@ConfigurationProperties：不支持 SpEL 表达式;</li>
<li>@Value：支持 SpEL 表达式。</li>
</ul>
</li>
<li><p>复杂类型封装</p>
<ul>
<li><p>@ConfigurationProperties：支持所有类型数据的封装，例如 Map、List、Set、以及对象等；</p>
</li>
<li><p>@Value：只支持基本数据类型的封装，例如字符串、布尔值、整数等类型。</p>
</li>
</ul>
</li>
<li><p>应用场景不同</p>
<p>@Value 和 @ConfigurationProperties 两个注解之间，并没有明显的优劣之分，它们只是适合的应用场景不同而已。</p>
<ul>
<li>若只是获取配置文件中的某项值，则推荐使用 @Value 注解；</li>
<li>若专门编写了一个 JavaBean 来和配置文件进行映射，则建议使用 @ConfigurationProperties 注解。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><p>如果将所有的配置都集中到 application.properties 或 application.yml 中，那么这个配置文件会十分的臃肿且难以维护，因此我们通常会将与 SpringBoot 无关的配置（例如自定义配置）提取出来，写在一个单独的配置文件中，并在对应的 JavaBean 上使用 @PropertySource 注解指向该配置文件。</p>
<a href="/article/33757.html" title="点击跳转给属性赋值的两种方法之一">点击跳转给属性赋值的两种方法之一</a>
<h4 id="Conditional派生注解"><a href="#Conditional派生注解" class="headerlink" title="@Conditional派生注解"></a>@Conditional派生注解</h4><p>spring.factories 文件中的所有自动配置类（xxxAutoConfiguration），都是必须在一定的条件下才会作为组件添加到容器中，配置的内容才会生效。这些限制条件在 SpringBoot 中以 @Conditional 派生注解的形式体现，如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">注解</th>
<th style="text-align:center">生效条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@ConditionalOnJava</td>
<td style="text-align:center">应用使用指定的 Java 版本时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnBean</td>
<td style="text-align:center">容器中存在指定的 Bean 时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnMissingBean</td>
<td style="text-align:center">容器中不存在指定的 Bean 时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnExpression</td>
<td style="text-align:center">满足指定的 SpEL 表达式时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnClass</td>
<td style="text-align:center">存在指定的类时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnMissingClass</td>
<td style="text-align:center">不存在指定的类时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnSingleCandidate</td>
<td style="text-align:center">容器中只存在一个指定的 Bean 或这个 Bean 为首选 Bean 时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnProperty</td>
<td style="text-align:center">系统中指定属性存在指定的值时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnResource</td>
<td style="text-align:center">类路径下存在指定的资源文件时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnWebApplication</td>
<td style="text-align:center">当前应用是 web 应用时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnNotWebApplication</td>
<td style="text-align:center">当前应用不是 web 应用生效</td>
</tr>
</tbody>
</table>
<h2 id="SpringMVC配置"><a href="#SpringMVC配置" class="headerlink" title="SpringMVC配置"></a>SpringMVC配置</h2><p><strong>基础配置</strong></p>
<p><code>Maven依赖</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>web.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--配置DispatchServlet：这个是SpringMVC的核心 ：请求分发器、前端控制器--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--DispatchServlet要绑定SpringMVC的配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--启动级别--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- / 只匹配所有的请求，不会去匹配jsp页面--&gt;</span><br>  <span class="hljs-comment">&lt;!-- /* 匹配所有的请求，包括jsp页面--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/app/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>springmvc-servlet.xml</code></p>
<p><strong>处理器映射器、处理器适配器 可以不用配置，spring默认配置</strong></p>
<p><strong>视图解析器不可以省略</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--处理器映射器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--处理器适配器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter &quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--视图解析器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>BeanNameUrlHandlerMapping：根据bean的名字匹配</p>
<p><strong>注解配置相关</strong></p>
<p><code>springmvc-servlet.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><br><br>  <span class="hljs-comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bobo.controller&quot;</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 让Spring MVC不处理静态资源    .css .js  .html .mp3 .mp4--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 支持mvc注解驱动</span><br><span class="hljs-comment">    在spring中一般采用@RequestMapping注解来完成映射关系</span><br><span class="hljs-comment">    要想使@RequestMapping注解生效</span><br><span class="hljs-comment">    必须向上下文中注册DefaultAnnotationHandlerMapping</span><br><span class="hljs-comment">    和一个AnnotationMethodHandlerAdapter实例</span><br><span class="hljs-comment">    这两个实例分别在类级别和方法级别处理。</span><br><span class="hljs-comment">    而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- 视图解析器 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver &quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;internalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 前缀 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 后缀 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h2><p><code>Maven依赖</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h3><p>使用thymeleaf,<code>Maven依赖</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>在使用 Thymeleaf 之前，首先要在页面的 html 标签中声明名称空间</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">xmlns:th=&quot;http://www.thymeleaf.org&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>在 html 标签中声明此名称空间，可避免编辑器出现 html 验证错误，但这一步并非必须进行的，即使我们不声明该命名空间，也不影响 Thymeleaf 的使用。</p>
</blockquote>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p><code>pom.xml</code></p>
<p>导入 JDBC 场景启动器：spring-boot-starter-data-jdbc</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入JDBC的场景启动器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>JDBC 的场景启动器中并没有导入数据库驱动，我们需要根据自身的需求引入所需的数据库驱动。例如，访问 MySQL 数据库时，需要导入 MySQL 的数据库驱动：mysql-connector-java。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Mysql Driver--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>application.properties/yml</code></p>
<p>在导入了 JDBC 场景启动器和数据库驱动后，接下来我们就可以在配置文件（application.properties/yml）中配置数据源了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#数据源连接信息</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">用户名</span>	<br>    <span class="hljs-attr">password:</span> <span class="hljs-string">密码</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p><code>pom.xml</code></p>
<p>引入 mybatis-spring-boot-starter 的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入 mybatis-spring-boot-starter 的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>application.properties/yml</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">用户名	</span><br><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">密码</span><br><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/数据库名?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#mybatis</span><br><span class="hljs-comment">#扫描实体类的位置,在此处指明扫描实体类的包，在 mapper.xml 中就可以不写实体类的全路径名</span><br><span class="hljs-meta">mybatis.type-aliases-package</span>=<span class="hljs-string">com.bobo.pojo</span><br><span class="hljs-comment"># 指定 mapper.xml 的位置</span><br><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mybatis/mapper/*.xml</span><br></code></pre></td></tr></table></figure>
<h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><p><code>pom.xml</code>        </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- spring security依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- web模块 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 测试包依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- security测试包 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><p><code>pom.xml</code>    </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Shiro uses SLF4J for logging.  We&#x27;ll use the &#x27;simple&#x27; binding</span><br><span class="hljs-comment">             in this example app.  See http://www.slf4j.org for more info. --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><p><strong>springboot版本使用2.5.6 swagger版本使用3.0.0</strong></p>
<blockquote>
<p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-comment">&lt;!--swagger2--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>config</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Configuration</span><br>&gt;<span class="hljs-meta">@EnableOpenApi</span>  <span class="hljs-comment">//开启Swagger2</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br><br>&gt;&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>访问测试 ：<a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a> ，可以看到swagger的界面</p>
<img src="/article/37040/image-20220221135603241.png" class title="image-20220221135603241">
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP的请求和响应</title>
    <url>/article/4338.html</url>
    <content><![CDATA[<blockquote>
<p>The perfect decks itself in beauty for the love of the Imperfect.</p>
<p>“完全”为了对“不全”的爱，把自己装饰得美丽。　　</p>
</blockquote>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a href="https://cloud.tencent.com/developer/doc/1117">参考手册</a></p>
<p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在<a href="https://baike.baidu.com/item/TCP/33012">TCP</a>之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以<a href="https://baike.baidu.com/item/ASCII/309296">ASCII</a>形式给出；而消息内容则具有一个类似<a href="https://baike.baidu.com/item/MIME/2900607">MIME</a>的格式。这个简单模型是早期<a href="https://baike.baidu.com/item/Web/150564">Web</a>成功的有功之臣，因为它使开发和部署非常地直截了当。</p>
<p><code>HTTP</code>是基于<strong>TCP/IP</strong>协议的，可以使用<code>http</code>进行内容的传输，比如图片，视频，音频，文档等等。</p>
<p>客户端和服务端需要进行通信的话，通常会使用<code>request response cycle</code>的形式。</p>
<p>客户端需要发送<strong>request请求</strong>，这样服务端才知道要通信；之后，服务端对请求进行<strong>response响应</strong>。</p>
<ol>
<li>HTTP是无连接的：在发出请求后，客户端和服务端断开连接，然后当响应准备就绪的时候，服务端再次重新建立连接并发送响应。</li>
<li>HTTP可以提供任何类型的数据，只要客户端和服务端两边的电脑能够读取理解它。</li>
<li>HTTP是无状态的：客户端和服务器只是在<strong>当前请求期间</strong>了解彼此。如果它关闭了，并且两台电脑想要再次连接，它们需要重新提供信息。</li>
</ol>
<h2 id="request请求"><a href="#request请求" class="headerlink" title="request请求"></a>request请求</h2><p><strong>HTTP请求信息由部分组成</strong></p>
<ol>
<li><p>请求方法（GET/POST）、<em>URI</em>、协议<em>/</em>版本</p>
</li>
<li><p>请求头<em>(Request Header)</em></p>
</li>
<li><p>请求正文</p>
</li>
</ol>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/5bU_dTmfKgQFm2e88IuM_a/union.gif</span> <span class="hljs-meta">HTTP/1.1</span><br>-------------------------------------------------<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>XXXxXxxxxxxxxxxxxxxxx<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>image/webp,image/png,image/svg+xml,image/*;q=0.8,video/*;q=0.8,*/*;q=0.5<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>sp1.baidu.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.1 Safari/605.1.15<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh-Hans;q=0.9<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>https://www.baidu.com/s?wd=baidu&amp;tn=84053098_3_dg&amp;ie=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br></code></pre></td></tr></table></figure>
<p><strong>请求方法、URI、协议版本</strong></p>
<p>根据<em>HTTP</em>标准，HTTP请求可以使用多种请求方法。例如：<em>HTTP1.1</em>目前支持7种请求方</p>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求获取由Request-URI所标识的资源</td>
</tr>
<tr>
<td>POST</td>
<td>在Request-URI所标识的资源后附加新的数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>请求获取由Request-URI所标识的资源的响应消息报头</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>请求查询服务器的性能，或查询与资源相关的选项和需求</td>
</tr>
<tr>
<td>PUT</td>
<td>请求服务器存储一个资源，并用Request-URI作为其标识</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除由Request-URI所标识的资源</td>
</tr>
<tr>
<td>TRACE</td>
<td>请求服务器回送收到的请求信息，主要用语测试或诊断</td>
</tr>
</tbody>
</table>
<p><strong>请求头(Request Header)</strong></p>
<p>请求头包含许多有关的客户端环境和请求正文的有用信息。</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cookie</td>
<td>这是最重要的请求头信息之一</td>
</tr>
<tr>
<td>Accept</td>
<td>浏览器可接受的MIME类型</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间</td>
</tr>
<tr>
<td>Host</td>
<td>指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到</td>
</tr>
<tr>
<td>Referer</td>
<td>包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小</td>
</tr>
<tr>
<td>Referer</td>
<td>包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可接受的字符集</td>
</tr>
<tr>
<td>Authorization</td>
<td>授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中</td>
</tr>
<tr>
<td>From</td>
<td>请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答</td>
</tr>
<tr>
<td>Pragma</td>
<td>指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝</td>
</tr>
</tbody>
</table>
<p><strong>请求正文</strong></p>
<p>请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息</p>
<h2 id="Response响应"><a href="#Response响应" class="headerlink" title="Response响应"></a>Response响应</h2><p><em>HTTP</em>应答与<em>HTTP</em>请求相似，<em>HTTP</em>响应也由<em>3</em>个部分构成，分别是：</p>
<ol>
<li><p>状态行</p>
</li>
<li><p>响应头(Response Header)</p>
</li>
<li><p>响应正文</p>
</li>
</ol>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br>------------------------------------------------------<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>image/gif<br><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>BDORZ=FFFB88E999055A3F8A630C64834BD6D0; max-age=86400; domain=.baidu.com; path=/<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Wed, 07 Nov 2012 16:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=315360000<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Keep-Alive<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 31 Dec 2021 11:14:09 GMT<br><span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>0<br><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Mon, 29 Dec 2031 11:14:09 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;0-0509a8580&quot;<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache 2.0<br></code></pre></td></tr></table></figure>
<p><strong>状态行</strong></p>
<p>由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p>
<ul>
<li>状态代码：状态代码由<em>3</em>位数字组成，表示请求是否被理解或被满足。</li>
<li>状态描述：状态描述给出了关于状态代码的简短的文字描述。</li>
<li>状态代码的第一个数字定义了响应的类别，后面两位没有具体的分类。<ul>
<li>第一个数字有五种可能的取值：<ul>
<li><em>- 1xx:</em>  指示信息—表示请求已接收，继续处理。</li>
<li><em>- 2xx:</em>  成功—表示请求已经被成功接收、理解、接受。</li>
<li><em>- 3xx:</em>  重定向—要完成请求必须进行更进一步的操作。</li>
<li><em>- 4xx:</em>  客户端错误—请求有语法错误或请求无法实现。</li>
<li><em>- 5xx:</em> 服务器端错误—服务器未能实现合法的请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>状态代码</th>
<th>状态描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>客户端请求成功</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>由于客户端请求有语法错误，不能被服务器所理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthonzed</td>
<td>请求未经授权。这个状态代码必须和<em>WWW-Authenticate</em>报头域一起使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>请求的资源不存在，例如，输入了错误的<em>URL</em>。</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器发生不可预期的错误，导致无法完成客户端的请求。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</td>
</tr>
</tbody>
</table>
<p><strong>响应头</strong></p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content-Type</td>
<td><em>Content-Type</em>实体报头域用语指明发送给接收者的实体正文的媒体类型</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>浏览器会在当前页面所在域名设置cookie字符串</td>
</tr>
<tr>
<td>Last-Modified</td>
<td><em>Last-Modified</em>实体报头域用于指示资源最后的修改日期及时间</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>通用头字段用于指定在两个，请求和响应的缓存机制的指令。缓存指令是单向的，这意味着请求中的给定指令并不意味着将在响应中给出相同的指令</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小</td>
</tr>
<tr>
<td>Date</td>
<td>通用 HTTP 报头包含在该消息起源的日期和时间。</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>响应的 HTTP 标头是由服务器使用以通告其支持部分请求的标志物。此字段的值表示可用于定义范围的单位。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体报头指示该实体主体的大小，以字节为单位的十进制数，发送到接收方</td>
</tr>
<tr>
<td>Expires</td>
<td>标头包含的日期/时间之后，响应被视为失效。</td>
</tr>
<tr>
<td>ETag</td>
<td>HTTP 响应报头为资源的特定版本的标识符。它允许缓存更高效，并节省带宽，因为如果内容没有改变，Web 服务器不需要发送完整的响应。另一方面，如果内容发生了变化，etags 有助于防止资源的同时更新互相覆盖（“空中冲突”）。 如果给定 URL 处的资源发生更改，则<code>Etag</code>必须生成新值。因此，Etags 与指纹相似，也可能用于某些服务器的跟踪目的。它们的比较可以快速确定资源的两个表示是否相同，但它们也可能被设置为无限期地由跟踪服务器持续存在。</td>
</tr>
<tr>
<td>Server</td>
<td>头包含有关用作原始服务器处理请求的软件信息。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>网络编程</category>
        <category>JavaWeb</category>
        <category>HTTP的请求和响应</category>
        <category>HTTP的请求和响应</category>
      </categories>
      <tags>
        <tag>HTTP的请求和响应</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC加载数据库驱动</title>
    <url>/article/45336.html</url>
    <content><![CDATA[<blockquote>
<p>My day is done, and I am like a boat drawn on the beach, listening to the dance-music of the tide in the evening.</p>
<p>我的白昼已经完了，我象一只泊在海滩上的小船，谛听着晚潮跳舞的乐声。</p>
</blockquote>
<h2 id="JDBC基本使用"><a href="#JDBC基本使用" class="headerlink" title="JDBC基本使用"></a>JDBC基本使用</h2><p>Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的<a href="https://baike.baidu.com/item/应用程序接口/10418844">应用程序接口</a>，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。我们通常说的JDBC是面向关系型数据库的。</p>
<p>导入<code>mysql-connector-java-版本.jar</code>,然后将jar包添加入项目库中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;<br>        <span class="hljs-comment">//固定写法，加载驱动 Mysql 8.0以上</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        <span class="hljs-comment">//2.用户信息和url</span><br>        String url = <span class="hljs-string">&quot;jdbc:mysql://localhost:端口/数据库名?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&quot;</span>;<br>        String username = <span class="hljs-string">&quot;用户名&quot;</span>;  <span class="hljs-comment">//数据库用户名</span><br>        String password = <span class="hljs-string">&quot;密码&quot;</span>;<span class="hljs-comment">//数据库密码</span><br><br>        Connection connection = DriverManager.getConnection(url,username,password);<br>  <br>				<span class="hljs-comment">//执行SQL的对象 statement</span><br>        Statement statement = connection.createStatement();<br>				<span class="hljs-comment">//sql语句</span><br>        String sql = <span class="hljs-string">&quot;SELECT * FROM 数据库名.表名&quot;</span>;<br>  			<span class="hljs-comment">//执行sql</span><br>        ResultSet resultSet = statement.executeQuery(sql);<br><br>  			<span class="hljs-comment">//从获取的结果中输出</span><br>        <span class="hljs-keyword">while</span> (resultSet.next())&#123;<br>            System.out.println(<span class="hljs-string">&quot;variable=&quot;</span>+ resultSet.getObject(<span class="hljs-string">&quot;列名&quot;</span>));<br>        &#125;<br>			<br>  			<span class="hljs-comment">//依次关闭连接</span><br>        resultSet.close();<br>        statement.close();<br>        connection.close();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a><strong>驱动</strong></h4><p><code>com.mysql.cj.jdbc.Driver</code>部分源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException var1) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DriverManager.registerDriver(new Driver());   不推荐使用</span><br><span class="hljs-comment">//因为Drive类中静态代码块中已经注册了</span><br><span class="hljs-comment">//固定写法，加载驱动 Mysql 8.0以上</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);   <span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String url = <span class="hljs-string">&quot;jdbc:mysql://主机地址:3306/数据库名?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&quot;</span>;<br><br>mysql -- <span class="hljs-number">3306</span><br>oralce -- <span class="hljs-number">1521</span><br>jdbc:oralce:thin:<span class="hljs-meta">@localhost</span>:<span class="hljs-number">1521</span>:sid<br></code></pre></td></tr></table></figure>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a><strong>Connection</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Connection connection = DriverManager.getConnection(url,username,password);<br></code></pre></td></tr></table></figure>
<p><code>connection</code>代表数据库，是数据库的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">connection.rollback();<br>connection.commit();<br>connection.setAutoCommit();<br></code></pre></td></tr></table></figure>
<h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a><strong>Statement</strong></h4><p>不能防止sql注入<a href="#PreparedStatement"><code>点击跳转PreparedStatement</code></a></p>
<p><code>statement</code> 具体的执行类，是执行sql的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">statement.executeQuery();  <span class="hljs-comment">//查询操作返回ResultSet</span><br>statement.execute();   <span class="hljs-comment">//查询任何sql</span><br>statement.executeUpdate();  <span class="hljs-comment">//更新 插入  删除  返回一个受影响的行数</span><br></code></pre></td></tr></table></figure>
<h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a><strong>ResultSet</strong></h4><p><code>resultSet</code> 查询的结果集，封装了所有的结果集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">resultSet.getObject();   <span class="hljs-comment">//在不知道列类型的情况下使用</span><br>resultSet.getString();<br>resultSet.getInt();<br><br>resultSet.beforeFirst();  <span class="hljs-comment">//移动到最前面</span><br>resultSet.afterLast();  <span class="hljs-comment">//移动到最后面</span><br>resultSet.next();  <span class="hljs-comment">//移动到下一个数据</span><br>resultSet.previous();  <span class="hljs-comment">//移动到前一行</span><br>resultSet.absolute(row);  <span class="hljs-comment">//移动到制定行</span><br></code></pre></td></tr></table></figure>
<h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a><strong>释放资源</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">resultSet.close();<br>statement.close();<br>connection.close();<br></code></pre></td></tr></table></figure>
<h2 id="提取工具类"><a href="#提取工具类" class="headerlink" title="提取工具类"></a>提取工具类</h2><p>创建<code>db.properties</code>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span> = <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">jdbc:mysql://localhost:端口/数据库名?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=true</span><br><span class="hljs-attr">username</span> = <span class="hljs-string">用户名</span><br><span class="hljs-attr">password</span> = <span class="hljs-string">密码</span><br></code></pre></td></tr></table></figure>
<p><strong>通过反射获取类加载器来拿到资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtils</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driver = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String username = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//通过反射获取类加载器来拿到资源（mysql配置文件），返回一个输入流</span><br>            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;db.properties&quot;</span>);<br>            Properties properties = <span class="hljs-keyword">new</span> Properties();<br>            <span class="hljs-comment">//将配置文件读出</span><br>            properties.load(in);<br>						<br>            driver = properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>            url = properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>            username = properties.getProperty(<span class="hljs-string">&quot;username&quot;</span>);<br>            password = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br><br>            <span class="hljs-comment">//驱动只用加载一次</span><br>            Class.forName(driver);<br><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">//获取连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url,username,password);<br>    &#125;<br><br>    <span class="hljs-comment">//释放连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(Connection conn, Statement st, ResultSet rs)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(rs!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                rs.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(st!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                st.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(conn!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                conn.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Class是当前类的Class对象，Class.getClassLoader()是获取当前类的类加载器。类加载器的大概作用是当需要使用一个类时，加载该类的”.class”文件，并创建对应的class对象，将class文件加载到虚拟机的内存。getResourceAsStream()是获取资源的输入流。类加载器默认是从classPath路径加载资源。</p>
<p>因此，当使用<code>Class.getClassLoader.getResourceAsStream()</code>加载资源时，是从classPath路径下进行加载，放在resources下的文件加载时不能加（“/”）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">InputStream in = PropertiesUtil.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;xx.properties&quot;</span>);<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>Class.getResourceAsStream()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当前类的URI目录，不包括自己</span><br>Class.getResourceAsStream(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//当前的classpath的绝对URI路径</span><br>Class.getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>在使用 Class.getResourceAsStream()时，一定注意要加载的资源路径与当前类所在包的路径是否一致【使用时注意子目录】。</p>
<p>1）要加载的资源路径与当前类所在包的路径一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">InputStream in = PropertiesUtil.class.getResourceAsStream(<span class="hljs-string">&quot;xx.properties&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>2）要加载的资源路径在resources下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">InputStream in = PropertiesUtil.class.getResourceAsStream(<span class="hljs-string">&quot;/xx.properties&quot;</span>);<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>提取插入类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInsert</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>				<span class="hljs-comment">//提高作用域</span><br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        Statement st = <span class="hljs-keyword">null</span>;<br>        ResultSet rs = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            conn = JdbcUtils.getConnection();    <span class="hljs-comment">//获取数据库连接</span><br>            st = conn.createStatement();    <span class="hljs-comment">//获得sql的执行对象</span><br>            String sql = <span class="hljs-string">&quot;插入的sql语句&quot;</span>;<br><br>            <span class="hljs-keyword">int</span> i = st.executeUpdate(sql);<br>            <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;插入成功&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(conn,st,rs);<br>        &#125;	<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h2><p>SQL注入即是指<a href="https://baike.baidu.com/item/web应用程序/2498090">web应用程序</a>对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的<a href="https://baike.baidu.com/item/SQL语句/5714895">SQL语句</a>，在管理员不知情的情况下实现非法操作，以此来实现欺骗<a href="https://baike.baidu.com/item/数据库服务器/613818">数据库服务器</a>执行非授权的任意查询，从而进一步得到相应的数据信息。</p>
<p><strong>注入实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SQL</span>注入 </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//        login(&quot;bobobobo&quot;,&quot;123123&quot;);</span><br>        login(<span class="hljs-string">&quot;&#x27;or&#x27;1=1&quot;</span>,<span class="hljs-string">&quot;&#x27;or&#x27;1=1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//登陆业务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>&#123;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        Statement st = <span class="hljs-keyword">null</span>;<br>        ResultSet rs = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            conn = JdbcUtils.getConnection();<br>            st = conn.createStatement();<br>            <br>            <span class="hljs-comment">//select * from users where `NAME` = &#x27;&#x27; or &#x27;1=1&#x27; and `password` = &#x27;&#x27; or &#x27;1=1&#x27;</span><br>            String sql = <span class="hljs-string">&quot;select * from users where `NAME`=&#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27; AND  `password` = &#x27;&quot;</span> + password + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>            rs = st.executeQuery(sql);<br><br>            <span class="hljs-keyword">while</span>(rs.next())&#123;<br>                    System.out.println(<span class="hljs-string">&quot;查询成功&quot;</span>);<br>                    System.out.println(rs.getString(<span class="hljs-string">&quot;NAME&quot;</span>));<br>                    System.out.println(rs.getString(<span class="hljs-string">&quot;password&quot;</span>));<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(conn,st,rs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>login()</code>方法传递进去的参数会被拼接入sql语句中，称为执行sql语句的一部分，使sql语句保持正确的语法，进而被执行；</p>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p><a href="#Statement"><code>点击跳转Statement</code></a></p>
<p>PreparedStatement可以防止sql注入，效率更好</p>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.lesson02.utils.JdbcUtils;<br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SQL</span>注入 </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        login(<span class="hljs-string">&quot;&#x27;&#x27; or 1=1&quot;</span>,<span class="hljs-string">&quot;123123&quot;</span>);  <span class="hljs-comment">//防止sql注入</span><br>    &#125;<br><br>    <span class="hljs-comment">//登陆业务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>&#123;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        PreparedStatement st = <span class="hljs-keyword">null</span>;<br>        ResultSet rs = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            conn = JdbcUtils.getConnection();<br><br>						<span class="hljs-comment">//区别</span><br>            <span class="hljs-comment">//使用 ？占位符  代替参数</span><br>            <span class="hljs-comment">//把传递进来的参数当作字符  假设其中存在转义字符 直接忽略 &#x27; 会被直接转义</span><br>            String sql = <span class="hljs-string">&quot;select * from users where `NAME`= ? and `password` = ?&quot;</span>;<br>						<br>          	<span class="hljs-comment">//预编译sql语句</span><br>            st = conn.prepareStatement(sql);<br>          	<br>          	<span class="hljs-comment">//从1开始，1代表第一个占位符 ？ 以此类推，填入参数</span><br>            st.setString(<span class="hljs-number">1</span>,username);<br>            st.setString(<span class="hljs-number">2</span>,password);<br><br>          	<span class="hljs-comment">//与之前不同，不需要sql参数，因为之前已经进行过预编译，直接执行对象</span><br>            rs = st.executeQuery();<br><br>            <span class="hljs-keyword">while</span>(rs.next())&#123;<br>                    System.out.println(<span class="hljs-string">&quot;查询成功&quot;</span>);<br>                    System.out.println(rs.getString(<span class="hljs-string">&quot;NAME&quot;</span>));<br>                    System.out.println(rs.getString(<span class="hljs-string">&quot;password&quot;</span>));<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(conn,st,rs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>login()</code>传递进来的参数会被当作字符串，只相当于参数，而不是sql执行语句中的一部分，字符串的转义字符会被忽略，无法创造满足的条件。</p>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h3><p><strong>概念</strong></p>
<p>池化技术：把一些能够复用的东西（比如说数据库连接、线程）放到池中，避免重复创建、销毁的开销，从而极大提高性能。</p>
<p>在开发过程中我们会用到很多的连接池，像是数据库连接池、HTTP 连接池、Redis 连接池等等。而连接池的管理是连接池设计的核心，我就以数据库连接池为例，来说明一下连接池管理的关键点。</p>
<p><strong>数据库连接池</strong></p>
<p>数据库连接池有两个最重要的配置：最小连接数和最大连接数，它们控制着从连接池中获取连接的流程：</p>
<ul>
<li>如果当前连接数小于最小连接数，则创建新的连接处理数据库请求</li>
<li>如果线程池中有空闲连接，则使用空闲连接</li>
<li>如果没有空闲连接，并且当前连接数小于最大连接数，则继续创建新的连接</li>
<li>如果当前连接数大于等于最大连接数，并且没有空闲连接了，则请求按照超时时间等待旧连接可用。、</li>
<li>超时之后，则获取数据库连接失败</li>
</ul>
<p>对于数据库连接池，根据我的经验，一般在线上我建议最小连接数控制在 10 左右，最大连接数控制在 20～30 左右即可。</p>
<h3 id="IDEA使用DBCP连接池"><a href="#IDEA使用DBCP连接池" class="headerlink" title="IDEA使用DBCP连接池"></a>IDEA使用DBCP连接池</h3><p>导入<code>commons-dbcp-版本号.jar</code> <code>commons-pool-版本号.jar</code> ,然后将jar包添加入项目库中</p>
<p>DBCP2还需要导入<code>commons-logging-版本号.jar</code></p>
<p><strong>提取工具类</strong></p>
<p>创建<code>dbcpconfig.properties</code>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#连接设置</span><br><span class="hljs-attr">driverClassName</span> = <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">jdbc:mysql://localhost:端口/数据库名?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=true</span><br><span class="hljs-attr">username</span> = <span class="hljs-string">用户名</span><br><span class="hljs-attr">password</span> = <span class="hljs-string">密码</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#初始化连接</span><br><span class="hljs-attr">initialSize</span>=<span class="hljs-string">10</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#最大连接数量</span><br><span class="hljs-attr">maxActive</span>=<span class="hljs-string">50</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#最大空闲连接</span><br><span class="hljs-attr">maxIdle</span>=<span class="hljs-string">20</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#最小空闲连接</span><br><span class="hljs-attr">minIdle</span>=<span class="hljs-string">5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#超时等待时间以毫秒为单位 6000毫秒/1000等于60秒</span><br><span class="hljs-attr">maxWait</span>=<span class="hljs-string">60000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;]</span><br><span class="hljs-comment">#注意：“user” 与 “password” 两个属性会被明确地传递，因此这里不需要包含他们。</span><br><span class="hljs-attr">connectionProperties</span>=<span class="hljs-string">useUnicode=true;characterEncoding=UTF8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#指定由连接池所创建的连接的自动提交（auto-commit）状态。</span><br><span class="hljs-attr">defaultAutoCommit</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#driver default 指定由连接池所创建的连接的只读（read-only）状态。</span><br><span class="hljs-comment">#如果没有设置该值，则&quot;setReadOnly&quot;方法将不被调用。（某些驱动并不支持只读模式，如：Informix）</span><br><span class="hljs-attr">defaultReadOnly</span>=<span class="hljs-string"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。</span><br><span class="hljs-comment">#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE</span><br><span class="hljs-attr">defaultTransactionIsolation</span>=<span class="hljs-string">READ_UNCOMMITTED</span><br></code></pre></td></tr></table></figure>
<p><strong>DBCP工具类</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.dbcp2.BasicDataSource;<br><span class="hljs-keyword">import</span> org.apache.commons.dbcp2.BasicDataSourceFactory;<br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtils_DBCP</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource dataSource = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            InputStream in = JdbcUtils_DBCP.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;dbcpconfig.properties&quot;</span>);<br>            Properties properties = <span class="hljs-keyword">new</span> Properties();<br>            properties.load(in);<br><br>            <span class="hljs-comment">//创建数据源   工厂模式 =》创建对象   返回一个数据源</span><br>            dataSource = BasicDataSourceFactory.createDataSource(properties);<br><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//获取连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>      	<span class="hljs-comment">//数据源中自带连接，自动连接</span><br>        <span class="hljs-keyword">return</span> dataSource.getConnection();<br>    &#125;<br><br>    <span class="hljs-comment">//释放连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(Connection conn, Statement st, ResultSet rs)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(rs!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                rs.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(st!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                st.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(conn!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                conn.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Mysql</category>
        <category>JDBC</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>Mysql,JDBC,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql基础</title>
    <url>/article/33736.html</url>
    <content><![CDATA[<blockquote>
<p>I thank thee that I am none of the wheels of power but I am one with the living creatures that are crushed by it.</p>
<p>谢谢神，我不是一个权力的轮子，而是被压在这轮子下的活人之一。</p>
</blockquote>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>
<p>每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。</p>
<p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</p>
<p>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p>
<p>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：</p>
<ul>
<li>数据以表格的形式出现</li>
<li>每行为各种记录名称</li>
<li>每列为记录名称所对应的数据域</li>
<li>许多的行和列组成一张表单</li>
<li>若干的表单组成database</li>
</ul>
<h2 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h2><ul>
<li><strong>数据库:</strong> 数据库是一些关联表的集合。</li>
<li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>
<li><strong>列:</strong> 一列(数据元素) 包含了相同类型的数据。</li>
<li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据。</li>
<li><strong>冗余</strong>：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>
<li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li><strong>外键：</strong>外键用于关联两个表。</li>
<li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
<li><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li>
</ul>
<ul>
<li>表头(header): 每一列的名称;</li>
<li>列(col): 具有相同数据类型的数据的集合;</li>
<li>行(row): 每一行用来描述某条记录的具体信息;</li>
<li>值(value): 行的具体信息, 每个值必须与该列的数据类型相同;</li>
<li><strong>键(key)</strong>: 键的值在当前列中具有唯一性。</li>
</ul>
<h2 id="Mysql安装与卸载"><a href="#Mysql安装与卸载" class="headerlink" title="Mysql安装与卸载"></a>Mysql安装与卸载</h2><blockquote>
<p>本来网上对Mac Mysql的介绍就参差不齐，换了M1MAX之后更找不到好的教程！</p>
<p>功夫不负有心人，还是被我找到了！</p>
<p>亲测可用！</p>
</blockquote>
<p><code>Mac</code></p>
<img src="/article/33736/image-20211226102545359.png" class title="image-20211226102545359">
<p><strong>安装</strong></p>
<p><a href="https://www.bilibili.com/video/BV1Qf4y1V7Co">B站高人的视频</a></p>
<p><strong>卸载</strong> </p>
<p>可以彻底删除Mac的所有残留Mysql文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini">打开终端：<br>sudo su<br><br>执行代码：<br>sudo rm /usr/local/mysql<br>sudo rm -rf /usr/local/mysql*<br>sudo rm -rf /Library/StartupItems/MySQLCOM<br>sudo rm -rf /Library/PreferencePanes/My*<br>rm -rf ~/Library/PreferencePanes/My*<br>sudo rm -rf /Library/Receipts/mysql*<br>sudo rm -rf /Library/Receipts/MySQL*<br>sudo rm -rf /var/db/receipts/com.mysql.*<br><br>即可彻底卸载<br></code></pre></td></tr></table></figure>
<p><strong>配置</strong></p>
<p><code>/Users/你的用户名/.zshrc</code></p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><code class="hljs zsh"><span class="hljs-comment">#Mysql</span><br><span class="hljs-built_in">alias</span> mysqlstop=<span class="hljs-string">&#x27;sudo /usr/local/mysql/support-files/mysql.server stop&#x27;</span><br><span class="hljs-built_in">alias</span> mysqlstart=<span class="hljs-string">&#x27;sudo /usr/local/mysql/support-files/mysql.server start&#x27;</span><br><span class="hljs-built_in">alias</span> mysql=/usr/<span class="hljs-built_in">local</span>/mysql/bin/mysql<br><span class="hljs-built_in">alias</span> mysqladmin=/usr/<span class="hljs-built_in">local</span>/mysql/bin/mysqladmin<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/<span class="hljs-built_in">local</span>/mysql/bin<br></code></pre></td></tr></table></figure>
<h2 id="命令行操作Mysql"><a href="#命令行操作Mysql" class="headerlink" title="命令行操作Mysql"></a>命令行操作Mysql</h2><ul>
<li><p>检查MySQL服务器是否启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps -ef | grep mysqld<br></code></pre></td></tr></table></figure>
</li>
<li><p>启动与停止Mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mysqlstart<br>mysqlstop<br></code></pre></td></tr></table></figure>
</li>
<li><p>进入Mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mysql -uroot -p<br></code></pre></td></tr></table></figure>
</li>
<li><p>进入Mysql之后</p>
<p>所有的语句都要使用<code>;</code>结尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">---单行注释<br>/*<br>多行注释<br>*/<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>刷新权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; flush privileges;<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; use mysql;<br>mysql&gt; FLUSH PRIVILEGES;<br>mysql&gt; ALTER user &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;newpassward&#x27;<br></code></pre></td></tr></table></figure>
</li>
<li><p>列出 MySQL 数据库管理系统的数据库列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW DATABASES;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| DB01               |<br>| information_schema |<br>| jdbc               |<br>| mybatis            |<br>| mysql              |<br>| performance_schema |<br>| smbms              |<br>| ssmbuild           |<br>| sys                |<br>+--------------------+<br>9 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
</li>
<li><p>选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; use smbms;<br>Database changed<br></code></pre></td></tr></table></figure>
</li>
<li><p>显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW TABLES;<br>+-----------------+<br>| Tables_in_smbms |<br>+-----------------+<br>| smbms_address   |<br>| smbms_bill      |<br>| smbms_provider  |<br>| smbms_role      |<br>| smbms_user      |<br>+-----------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
</li>
<li><p>显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW COLUMNS FROM smbms_address;<br>+--------------+-------------+------+-----+---------+----------------<br>| Field        | Type        | Null | Key | Default | Extra          <br>+--------------+-------------+------+-----+---------+----------------<br>| id           | bigint      | NO   | PRI | NULL    | auto_increment <br>| contact      | varchar(15) | YES  |     | NULL    |                <br>| addressDesc  | varchar(50) | YES  |     | NULL    |                <br>| postCode     | varchar(15) | YES  |     | NULL    |                <br>| tel          | varchar(20) | YES  |     | NULL    |                <br>| createdBy    | bigint      | YES  |     | NULL    |                <br>| creationDate | datetime    | YES  |     | NULL    |                <br>| modifyBy     | bigint      | YES  |     | NULL    |                <br>| modifyDate   | datetime    | YES  |     | NULL    |                <br>| userId       | bigint      | YES  |     | NULL    |                <br>+--------------+-------------+------+-----+---------+----------------<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
</li>
<li><p>显示数据表的详细索引信息，包括PRIMARY KEY（主键）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW INDEX FROM smbms_address;<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE DATABASE [IF NOT EXISTS] 数据库名;<br></code></pre></td></tr></table></figure>
</li>
<li><p>删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; drop database [IF EXISTS] 数据库名;<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建Mysql数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE table_name (column_name column_type);<br></code></pre></td></tr></table></figure>
</li>
<li><p>删除MySQL数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; DROP TABLE [IF EXISTS] `表名` ;<br></code></pre></td></tr></table></figure>
</li>
<li><p>向MySQL数据表插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO `表名` ( `字段1`, `字段2`,...`字段N` )<br>                       VALUES<br>                       ( value1, value2,...valueN );<br></code></pre></td></tr></table></figure>
</li>
<li><p>在MySQL数据库中查询数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT[ALL|DISTINCT|DISTINCTROW|TOP]<br>&#123;*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]&#125;<br>FROM tableexpression[,…][IN externaldatabase]<br>[WHERE…]<br>[GROUP BY…]<br>[HAVING…]<br>[ORDER BY…]<br></code></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>&gt; - 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。
&gt; - SELECT 命令可以读取一条或者多条记录。
&gt; - 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据
&gt; - 你可以使用 WHERE 语句来包含任何条件。
&gt; - 你可以使用 LIMIT 属性来设定返回的记录数。
&gt; - 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。
&gt; - 可以将使用`CONCAT(&quot;拼接的字符串：&quot; ，字段1)` 查询出来的结果将被拼接字符串

* SQL SELECT 语句使用 DISTINCT 将读取出来的数据去重

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT DISTINCT `字段1` <br>FROM `表名`<br>[WHERE Clause]<br>[LIMIT 查询起始下标,pageSize][ OFFSET M];<br></code></pre></td></tr></table></figure>

* SQL SELECT 语句使用 WHERE 子句从数据表中读取数据

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT `字段1`, `字段2`,...`字段N` FROM `表名1`, `表名2`...<br>[WHERE condition1 [AND [OR]] condition2.....<br></code></pre></td></tr></table></figure>

* SQL SELECT 语句使用 LIKE 子句从数据表中读取数据

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT `字段1`, `字段2`,...`字段N` <br>FROM `表名`<br>WHERE `字段1` LIKE condition1 [AND [OR]] `字段2` = &#x27;somevalue&#x27;<br></code></pre></td></tr></table></figure>

  `%`代表0～任意个字符  `__`代表一个字符

* MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT expression1, expression2, ... expression_n<br>FROM tables<br>[WHERE conditions]<br>UNION [ALL | DISTINCT]<br>SELECT expression1, expression2, ... expression_n<br>FROM tables<br>[WHERE conditions];<br></code></pre></td></tr></table></figure>

* SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT `字段1`, `字段2`,...`字段N` FROM `表名1`, `表名2`...<br>ORDER BY `字段1` [ASC [DESC][默认 ASC]], [`字段2...`] [ASC [DESC][默认 ASC]<br></code></pre></td></tr></table></figure>

* GROUP BY 语句根据一个或多个列对结果集进行分组

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT `字段`, function(`字段`)<br>FROM table_name<br>WHERE `字段` operator value<br>GROUP BY column_name;<br></code></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>UPDATE 命令修改 MySQL 数据表数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; UPDATE `表名` SET `字段1`=&#x27;new-value1&#x27;, `字段2`=&#x27;new-value2&#x27;<br>[WHERE Clause]<br></code></pre></td></tr></table></figure>
</li>
<li><p>SQL DELETE 语句从 MySQL 数据表中删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; DELETE FROM `表名` [WHERE Clause]<br></code></pre></td></tr></table></figure>
<p>TRUNCATE完全清空一个数据库表，表的结构和索引约束不会变！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; TRUNCATE `表名`<br></code></pre></td></tr></table></figure>
<ul>
<li>相同点：都能删除数据，不会删除表结构</li>
<li>不同点：<ul>
<li>TRUNCATE 重新设置自增列，计数器会归零</li>
<li>TRUNCATE不会影响事务 </li>
</ul>
</li>
</ul>
</li>
<li><p>修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令</p>
<ul>
<li><p>修改表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `旧表名` RENAME <span class="hljs-keyword">TO</span> `新表名`;<br></code></pre></td></tr></table></figure>
</li>
<li><p>删除，添加或修改表字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE `表名` DROP `字段`;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE 表`名` ADD `字段` 字段数据类型;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE `表名` ADD `字段` INT FIRST;<br>mysql&gt; ALTER TABLE `表名` ADD `字段A` INT AFTER `字段B`;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE `表名` MODIFY `字段` 新字段数据类型;<br>mysql&gt; ALTER TABLE `表名` CHANGE `旧字段名` `新字段名` 新字段数据类型;<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; alter table `表名` engine=myisam;<br></code></pre></td></tr></table></figure>
</li>
<li><p>添加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE `表名` ADD CONSTRAINT `约束名` FOREIGN KEY(`作为外键的列`) REFERENCES `被引用的表名`(`被引用表的字段`)<br></code></pre></td></tr></table></figure>
</li>
<li><p>MySQL 连接的使用</p>
<ul>
<li><strong>INNER JOIN（内连接,或等值连接）</strong>：获取两个表中字段匹配关系的记录。</li>
<li><strong>LEFT JOIN（左连接）：</strong>获取左表所有记录，即使右表没有对应匹配的记录。</li>
<li><strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>退出Mysql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; exit<br>Bye<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>MySQL 支持所有标准 SQL 数值数据类型。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">范围（有符号）</th>
<th style="text-align:center">范围（无符号）</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TINYINT</td>
<td style="text-align:center">1 Bytes</td>
<td style="text-align:center">(-128，127)</td>
<td style="text-align:center">(0，255)</td>
<td style="text-align:center">小整数值</td>
</tr>
<tr>
<td style="text-align:center">SMALLINT</td>
<td style="text-align:center">2 Bytes</td>
<td style="text-align:center">(-32 768，32 767)</td>
<td style="text-align:center">(0，65 535)</td>
<td style="text-align:center">大整数值</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMINT</td>
<td style="text-align:center">3 Bytes</td>
<td style="text-align:center">(-8 388 608，8 388 607)</td>
<td style="text-align:center">(0，16 777 215)</td>
<td style="text-align:center">大整数值</td>
</tr>
<tr>
<td style="text-align:center">INT或INTEGER</td>
<td style="text-align:center">4 Bytes</td>
<td style="text-align:center">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:center">(0，4 294 967 295)</td>
<td style="text-align:center">大整数值</td>
</tr>
<tr>
<td style="text-align:center">BIGINT</td>
<td style="text-align:center">8 Bytes</td>
<td style="text-align:center">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td style="text-align:center">(0，18 446 744 073 709 551 615)</td>
<td style="text-align:center">极大整数值</td>
</tr>
<tr>
<td style="text-align:center">FLOAT</td>
<td style="text-align:center">4 Bytes</td>
<td style="text-align:center">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td style="text-align:center">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td style="text-align:center">单精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:center">DOUBLE</td>
<td style="text-align:center">8 Bytes</td>
<td style="text-align:center">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:center">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:center">双精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:center">DECIMAL</td>
<td style="text-align:center">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td style="text-align:center">依赖于M和D的值</td>
<td style="text-align:center">依赖于M和D的值</td>
<td style="text-align:center">小数值</td>
</tr>
</tbody>
</table>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CHAR</td>
<td style="text-align:center">0-255 bytes</td>
<td style="text-align:center">定长字符串</td>
</tr>
<tr>
<td style="text-align:center">VARCHAR（常用）</td>
<td style="text-align:center">0-65535 bytes</td>
<td style="text-align:center">变长字符串</td>
</tr>
<tr>
<td style="text-align:center">TINYBLOB</td>
<td style="text-align:center">0-255 bytes</td>
<td style="text-align:center">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:center">TINYTEXT</td>
<td style="text-align:center">0-255 bytes</td>
<td style="text-align:center">短文本字符串</td>
</tr>
<tr>
<td style="text-align:center">BLOB</td>
<td style="text-align:center">0-65535 bytes</td>
<td style="text-align:center">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:center">TEXT</td>
<td style="text-align:center">0-65535 bytes</td>
<td style="text-align:center">长文本数据</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMBLOB</td>
<td style="text-align:center">0-16777 215 bytes</td>
<td style="text-align:center">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMTEXT</td>
<td style="text-align:center">0-16777 215 bytes</td>
<td style="text-align:center">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:center">LONGBLOB</td>
<td style="text-align:center">0-4294967295 bytes</td>
<td style="text-align:center">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:center">LONGTEXT</td>
<td style="text-align:center">0-4294967295 bytes</td>
<td style="text-align:center">极大文本数据</td>
</tr>
</tbody>
</table>
<ul>
<li>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数</li>
<li>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</li>
<li>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</li>
<li>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</li>
<li>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</li>
</ul>
<h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小 ( bytes)</th>
<th style="text-align:center">范围</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DATE</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1000-01-01/9999-12-31</td>
<td style="text-align:center">YYYY-MM-DD</td>
<td style="text-align:center">日期值</td>
</tr>
<tr>
<td style="text-align:center">TIME</td>
<td style="text-align:center">3</td>
<td style="text-align:center">‘-838:59:59’/‘838:59:59’</td>
<td style="text-align:center">HH:MM:SS</td>
<td style="text-align:center">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:center">YEAR</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1901/2155</td>
<td style="text-align:center">YYYY</td>
<td style="text-align:center">年份值</td>
</tr>
<tr>
<td style="text-align:center">DATETIME（常用）</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td style="text-align:center">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:center">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:center">TIMESTAMP</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1970-01-01 00:00:00/2038 结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td style="text-align:center">YYYYMMDD HHMMSS</td>
<td style="text-align:center">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p>
<p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p>
<p>缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。</p>
<p><strong>普通索引：</strong>这是最基本的索引，它没有任何限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE INDEX indexName ON table_name (column_name)<br></code></pre></td></tr></table></figure>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<ul>
<li><strong>修改表结构(添加索引)</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)<br>#该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。<br>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list)<br>#这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。<br>ALTER TABLE tbl_name ADD INDEX index_name (column_list)<br>#添加普通索引，索引值可出现多次。<br>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)<br>#该语句指定了索引为 FULLTEXT ，用于全文索引。<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>创建表的时候直接指定</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE mytable(  <br>ID INT NOT NULL,   <br>username VARCHAR(16) NOT NULL,  <br>INDEX [indexName] (username(length))  <br>);  <br></code></pre></td></tr></table></figure>
<ul>
<li>删除索引的语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DROP INDEX [indexName] ON mytable; <br></code></pre></td></tr></table></figure>
<p><strong>主键索引：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">PRIMARY KEY<br></code></pre></td></tr></table></figure>
<p><strong>唯一索引:</strong>索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">UNIQUE KEY<br></code></pre></td></tr></table></figure>
<p><strong>全文索引：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">FULLTEXT<br></code></pre></td></tr></table></figure>
<h2 id="MySQL字段属性"><a href="#MySQL字段属性" class="headerlink" title="MySQL字段属性"></a>MySQL字段属性</h2><table>
<thead>
<tr>
<th style="text-align:center">MySQL关键字</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NULL</td>
<td style="text-align:center">数据列可包含NULL值</td>
</tr>
<tr>
<td style="text-align:center">NOT NULL</td>
<td style="text-align:center">数据列不允许包含NULL值</td>
</tr>
<tr>
<td style="text-align:center">DEFAULT</td>
<td style="text-align:center">默认值</td>
</tr>
<tr>
<td style="text-align:center">PRIMARY KEY</td>
<td style="text-align:center">主键</td>
</tr>
<tr>
<td style="text-align:center">AUTO_INCREMENT</td>
<td style="text-align:center">自动递增，适用于整数类型（通常用于主键）</td>
</tr>
<tr>
<td style="text-align:center">UNSIGNED</td>
<td style="text-align:center">无符号的整数（不能为负数）</td>
</tr>
<tr>
<td style="text-align:center">CHARACTER SET name</td>
<td style="text-align:center">指定一个字符集</td>
</tr>
<tr>
<td style="text-align:center">ZEROFILL</td>
<td style="text-align:center">如果值长度不够，在前面补0表示</td>
</tr>
<tr>
<td style="text-align:center">COMMENT</td>
<td style="text-align:center">注释</td>
</tr>
</tbody>
</table>
<ul>
<li>表的名称和字段尽量使用 <code>`</code> `括起来</li>
<li>字符串使用单引号<code>&#39;&#39;</code>括起来</li>
<li>所有的语句后面 <code>,</code>,最后一个不用加</li>
</ul>
<h3 id="Mysql数据库引擎"><a href="#Mysql数据库引擎" class="headerlink" title="Mysql数据库引擎"></a>Mysql数据库引擎</h3><p><strong>InnoDB存储引擎</strong></p>
<p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，上图也看到了，InnoDB是默认的MySQL引擎。InnoDB主要特性有：</p>
<ol>
<li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</li>
<li>InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的</li>
<li>InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的**操作系统上</li>
<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</li>
<li>InnoDB被用在众多需要高性能的大型数据库站点上</li>
</ol>
<p>InnoDB不创建目录，使用InnoDB时，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件</p>
<p><strong>MyISAM存储引擎</strong></p>
<p>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但<strong>不支持事物务</strong>。MyISAM主要特性有：</p>
<ol>
<li>大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持</li>
<li>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成</li>
<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>
<li>最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</li>
<li>BLOB和TEXT列可以被索引</li>
<li>NULL被允许在索引的列中，这个值占每个键的0~1个字节</li>
<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li>
<li>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快</li>
<li>可以把数据文件和索引文件放在不同目录</li>
<li>每个字符列可以有不同的字符集</li>
<li>有VARCHAR的表可以固定或动态记录长度</li>
<li>VARCHAR和CHAR列可以多达64KB</li>
</ol>
<p>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：.frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）</p>
<p><strong>MEMORY存储引擎</strong></p>
<p>MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。MEMORY主要特性有：</p>
<ol>
<li>MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度</li>
<li>MEMORY存储引擎执行HASH和BTREE缩影</li>
<li>可以在一个MEMORY表中有非唯一键值</li>
<li>MEMORY表使用一个固定的记录长度格式</li>
<li>MEMORY不支持BLOB或TEXT列</li>
<li>MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引</li>
<li>MEMORY表在所由客户端之间共享（就像其他任何非TEMPORARY表）</li>
<li>MEMORY表内存被存储在内存中，内存是MEMORY表和服务器在查询处理时的空闲中，创建的内部表共享</li>
<li>当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）</li>
</ol>
<img src="/article/33736/1200.png" class title="img">
<h3 id="MySQL-运算符"><a href="#MySQL-运算符" class="headerlink" title="MySQL 运算符"></a>MySQL 运算符</h3><p><strong>比较运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">等于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt;, !=</td>
<td style="text-align:center">不等于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">BETWEEN AND</td>
<td style="text-align:center">在两值之间</td>
<td style="text-align:center">&gt;=min&amp;&amp;&lt;=max</td>
</tr>
<tr>
<td style="text-align:center">NOT BETWEEN</td>
<td style="text-align:center">不在两值之间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IN</td>
<td style="text-align:center">在集合中</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">NOT IN</td>
<td style="text-align:center">不在集合中</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;=&gt;</td>
<td style="text-align:center">严格比较两个NULL值是否相等</td>
<td style="text-align:center">两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0</td>
</tr>
<tr>
<td style="text-align:center">LIKE</td>
<td style="text-align:center">模糊匹配</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">REGEXP 或 RLIKE</td>
<td style="text-align:center">正则式匹配</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IS NULL</td>
<td style="text-align:center">为空</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IS NOT NULL</td>
<td style="text-align:center">不为空</td>
</tr>
</tbody>
</table>
<p><strong>算术运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加法</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减法</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘法</td>
</tr>
<tr>
<td style="text-align:center">/ 或 DIV</td>
<td style="text-align:center">除法</td>
</tr>
<tr>
<td style="text-align:center">% 或 MOD</td>
<td style="text-align:center">取余</td>
</tr>
</tbody>
</table>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符号</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NOT 或 !</td>
<td style="text-align:center">逻辑非</td>
</tr>
<tr>
<td style="text-align:center">AND</td>
<td style="text-align:center">逻辑与</td>
</tr>
<tr>
<td style="text-align:center">OR</td>
<td style="text-align:center">逻辑或</td>
</tr>
<tr>
<td style="text-align:center">XOR</td>
<td style="text-align:center">逻辑异或</td>
</tr>
</tbody>
</table>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>事务用来管理 insert,update,delete 语句</li>
</ul>
<p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p>
<ul>
<li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p><strong>事务控制语句</strong></p>
<ul>
<li>BEGIN 或 START TRANSACTION 显式地开启一个事务；</li>
<li>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；</li>
<li>ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li>
<li>SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li>
<li>RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li>
<li>ROLLBACK TO identifier 把事务回滚到标记点；</li>
<li>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li>
</ul>
<p><strong>MYSQL 事务处理主要有两种方法</strong></p>
<p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>
<ul>
<li><strong>BEGIN</strong> 开始一个事务</li>
<li><strong>ROLLBACK</strong> 事务回滚</li>
<li><strong>COMMIT</strong> 事务确认</li>
</ul>
<p>2、直接用 SET 来改变 MySQL 的自动提交模式: </p>
<ul>
<li><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li>
<li><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li>
</ul>
<h2 id="关系数据库中的几种设计范式"><a href="#关系数据库中的几种设计范式" class="headerlink" title="关系数据库中的几种设计范式"></a>关系数据库中的几种设计范式</h2><p><strong>1 第一范式（1NF）</strong></p>
<p>在任何一个<a href="https://baike.baidu.com/item/关系数据库">关系数据库</a>中，第一范式（1NF） 是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<p>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>
<p>简而言之，第一范式就是无重复的列。</p>
<p><strong>2 第二范式（2NF）</strong></p>
<p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。这个唯一属性列被称为<a href="https://baike.baidu.com/item/主关键字">主关键字</a>或主键、主码。</p>
<p>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。</p>
<p>简而言之，第二范式就是非主属性完全依赖于主关键字。</p>
<p><strong>3 第三范式（3NF）</strong></p>
<p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</p>
<p>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在图3-2的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p>
<p>简而言之，第三范式就是属性不依赖于其它非主属性。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>注解与反射</title>
    <url>/article/1621.html</url>
    <content><![CDATA[<blockquote>
<p>Shadow, with her veil drawn, follows Light in secret meekness,with her silent steps of love.</p>
<p>阴影戴上她的面幕，秘密地，温顺地，用她的沉默的爱的脚步，跟在“光”后边。</p>
</blockquote>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p>
<p>Java 语言中的类、方法、变量、参数和包等都可以被标注。</p>
<p><strong>Annotation作用</strong></p>
<ul>
<li>不是程序本身，可以对程序作出解释</li>
<li>可以被其他程序（如编译器等）读取</li>
</ul>
<p><strong>Annotation格式</strong></p>
<ul>
<li>注解是以”@注释名”在代码中存在，还可以添加一些参数值</li>
</ul>
<p><strong>Annotation在哪里使用？</strong></p>
<p>可以附加在package，class，method，field等上面相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</p>
<h3 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h3><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p>
<p><strong>作用在代码的注解是</strong></p>
<ul>
<li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。表示不鼓励程序员</li>
<li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。</li>
</ul>
<p><strong>作用在其他注解的注解(或者说 元注解)是</strong></p>
<ul>
<li><p><code>@Retention</code> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。(SOURCE &lt; CLASS &lt; RUNTIME)</p>
<blockquote>
<ul>
<li>a) 若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li>
<li>b) 若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li>
<li>c) 若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li>
</ul>
</blockquote>
</li>
<li><p><code>@Documented</code> - 标记这些注解是否包含在用户文档中。</p>
</li>
<li><p><code>@Target</code> - 标记这个注解应该是哪种 Java 成员。(被描述的注解可以用在什么地方)</p>
</li>
<li><p><code>@Inherited</code> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</p>
</li>
<li><p><strong>使用元注解自定义一个简单注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation1 &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>@interface</li>
</ol>
<p>使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。</p>
<p><strong>定义 Annotation 时，@interface 是必须的。</strong></p>
<p>注意：它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。</p>
<ol start="2">
<li>@Documented*</li>
</ol>
<p>类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。</p>
<p>定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。</p>
<ol start="3">
<li>@Target(ElementType.TYPE)</li>
</ol>
<p>前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。</p>
<p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p>
<p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p>
<ol start="4">
<li>@Retention(RetentionPolicy.RUNTIME)</li>
</ol>
<p>前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。</p>
<p>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。</p>
<p>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p>
</blockquote>
</li>
</ul>
<p><strong>从 Java 7 开始，额外添加了 3 个注解</strong></p>
<ul>
<li><code>@SafeVarargs</code> - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
<li><code>@FunctionalInterface</code> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li><code>@Repeatable</code> - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
<p><strong>Annotation 架构</strong></p>
<img src="/article/1621/Annotation%E6%9E%B6%E6%9E%84.jpg" class title="img">
<p>从中，我们可以看出：</p>
<ol>
<li><p>1 个 Annotation 和 1 个 RetentionPolicy 关联。</p>
<p>每1个Annotation对象，都会有唯一的RetentionPolicy属性。</p>
</li>
<li><p>1 个 Annotation 和 1~n 个 ElementType 关联。</p>
<p>对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。</p>
</li>
<li><p>Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</p>
<p>Annotation 的每一个实现类，都 “和 1 个 RetentionPolicy 关联” 并且 “ 和 1~n 个 ElementType 关联”。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Deprecated</span>  -- <span class="hljs-meta">@Deprecated</span> 所标注内容，不再被建议使用。<br><span class="hljs-meta">@Override</span>    -- <span class="hljs-meta">@Override</span> 只能标注方法，表示该方法覆盖父类中的方法。<br><span class="hljs-meta">@Documented</span>  -- <span class="hljs-meta">@Documented</span> 所标注内容，可以出现在javadoc中。<br><span class="hljs-meta">@Inherited</span>   -- <span class="hljs-meta">@Inherited</span>只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。<br><span class="hljs-meta">@Retention</span>   -- <span class="hljs-meta">@Retention</span>只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。<br><span class="hljs-meta">@Target</span>      -- <span class="hljs-meta">@Target</span>只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。<br><span class="hljs-meta">@SuppressWarnings</span> -- <span class="hljs-meta">@SuppressWarnings</span> 所标注内容产生的警告，编译器会对这些警告保持静默。<br></code></pre></td></tr></table></figure>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a><strong>自定义注解</strong></h3><p>使用@interface自定义注解时，自动继承 java.lang.annotation.Annotation接口</p>
<p>分析：</p>
<ul>
<li>@interface用来声明一个注解，格式<code>public @interface 注解名&#123;定义内容&#125;</code></li>
<li>其中每一个方法实际上是声明了一个参数配置；</li>
<li>方法的名称就是参数的名称；</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型，Class，String，enum）；</li>
<li>可以通过default来声明参数的默认值；</li>
<li>如果只有一个参数成员，一般参数名为value；</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义注解类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAnnotation</span></span>&#123;<br>  <span class="hljs-meta">@MyAnnotation(name = &quot;bobo&quot;)</span><span class="hljs-comment">// name没有默认值，所以必须赋值，age有默认值可以不赋值</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-meta">@MyAnnotation0(&quot;bobo&quot;)</span>  <span class="hljs-comment">//当只有一个参数并且参数名为value时，可以直接写参数值，省略参数名</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> MyAnnotation&#123;<br>  <span class="hljs-comment">//注解的参数  :  参数类型 + 参数名();</span><br>  <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span></span>;  <span class="hljs-comment">//如果默认值为 -1 ，代表不存在</span><br>&#125;<br><br><span class="hljs-meta">@interface</span> MyAnnotation0&#123;<br>  <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//当只有一个参数时，参数名可以默认为value</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Annotation-的作用"><a href="#Annotation-的作用" class="headerlink" title="Annotation 的作用"></a>Annotation 的作用</h3><ol>
<li>编译检查</li>
<li>在反射中使用 Annotation</li>
<li>根据 Annotation 生成帮助文档</li>
<li>能够帮忙查看查看代码</li>
</ol>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p><code>Class c = Class.forName(&quot;java.lang.String&quot;)</code></p>
<p>反射指的是我们可以在运行期间加载、探知、使用编译期间完全未知的类。是一个动态的机制，允许我们通过字符串来指挥程序实例化，操作属性、调用方法。使得代码提高了灵活性，但是同时也带来了更多的资源开销。</p>
<p>加载完类之后，在堆内存中，就产生了一个 Class 类型的对象（一个 类只有一个 Class 对象），这个对象就包含了完整的类的结构信息。 我们可以通过这个对象看到类的结构。</p>
<p>正常方式：<code>引入需要的“包类”名称</code>—&gt;<code>通过new实例化</code>—&gt;<code>取的实例化对象</code></p>
<p>反射方式：<code>实例化对象</code>—&gt;<code>getCLass()方法</code>—&gt;<code>得到完整的“包类”名称</code></p>
<h3 id="Java中为什么需要反射？反射要解决什么问题？"><a href="#Java中为什么需要反射？反射要解决什么问题？" class="headerlink" title="Java中为什么需要反射？反射要解决什么问题？"></a>Java中为什么需要反射？反射要解决什么问题？</h3><p>Java中编译类型有两种：</p>
<ul>
<li><strong>静态编译</strong>：在编译时确定类型，绑定对象即通过。</li>
<li><strong>动态编译</strong>：运行时确定类型，绑定对象。动态编译最大限度地发挥了Java的灵活性，体现了多态的应用，可以减低类之间的耦合性。</li>
</ul>
<p>反射是Java被视为动态（或准动态）语言的关键，反射机制允许程序在执行期借助Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。包括其modifiers（诸如public、static等）、superclass（例如Object）、实现之interfaces（例如Cloneable），也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。</p>
<p>Reflection可以在运行时加载、探知、使用编译期间完全未知的classes。即Java程序可以加载一个运行时才得知名称的class，获取其完整构造，并生成其对象实体、或对其fields设值、或唤起其methods。</p>
<p>反射（reflection）允许静态语言在运行时（runtime）检查、修改程序的结构与行为。<br>在静态语言中，使用一个变量时，必须知道它的类型。在Java中，变量的类型信息在编译时都保存到了class文件中，这样在运行时才能保证准确无误。</p>
<p>实现Java反射机制的类都位于java.lang.reflect包中：</p>
<ol>
<li>Class类：代表一个类</li>
<li>Field类：代表类的成员变量（类的属性）</li>
<li>Method类：代表类的方法</li>
<li>Constructor类：代表类的构造方法</li>
<li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</li>
</ol>
<p><strong>优点</strong> ：可以实现动态创建对象和编译，体现出很大的灵活性</p>
<p><strong>缺点</strong> ：对性能有影响，使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且他满足我们的要求，这类操作总是慢于直接执行相同的操作。</p>
<h3 id="获取Class类的对象"><a href="#获取Class类的对象" class="headerlink" title="获取Class类的对象"></a>获取Class类的对象</h3><p><strong>举例</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-comment">//什么叫反射</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">//通过反射获取类的class对象</span><br>        Class&lt;?&gt; c1 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br>        System.out.println(c1);<br><br>        Class&lt;?&gt; c2 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br>        Class&lt;?&gt; c3 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br>        Class&lt;?&gt; c4 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">//一个类在内存中只有一个class对象</span><br>        <span class="hljs-comment">//一个类被加载后，类的整个结构都会被封装在class对象</span><br>        System.out.println(c2.hashCode());<br>        System.out.println(c3.hashCode());<br>        System.out.println(c4.hashCode());<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//实体类  Pojo</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">class com.bobo.reflection.User   //得到类的全类名</span><br><span class="hljs-comment">789451787</span><br><span class="hljs-comment">789451787</span><br><span class="hljs-comment">789451787</span><br><span class="hljs-comment">//说明一个类在内存中只有一个class对象 ， 因为创建三个对象的hashcode相同</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ol>
<li><p>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高</p>
<p><code>Class c2 = Class.forName(&quot;com.bobo.reflection.Student&quot;);</code></p>
</li>
<li><p>一直某个类的实例，调用该实例的getClass()方法获取Class对象</p>
<p><code>Class c1 = person.getClass();</code></p>
</li>
<li><p>一直一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException异常</p>
<p><code>Class&lt;Student&gt; c3 = Student.class;</code></p>
</li>
<li><p>内置基本数据类型可以直接用<code>类名.Type</code></p>
<p><code>Class&lt;Integer&gt; c4 = Integer.TYPE;</code></p>
</li>
<li><p>还可以利用ClassLoader</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-comment">//测试Class类的创建方式有哪些</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Person person = <span class="hljs-keyword">new</span> Student();<br>        System.out.println(<span class="hljs-string">&quot;这个人是：&quot;</span>+person.name);<br><br>        <span class="hljs-comment">//方式一：通过对象获得</span><br>        Class c1 = person.getClass();<br>        System.out.println(c1.hashCode());<br><br>        <span class="hljs-comment">//方式二：通过forName获得</span><br>        Class c2 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.Student&quot;</span>);<br>        System.out.println(c2.hashCode());<br><br>        <span class="hljs-comment">//方式三：通过类名.class获得</span><br>        Class&lt;Student&gt; c3 = Student.class;<br>        System.out.println(c3.hashCode());<br><br>        <span class="hljs-comment">//方式四：基本内置类型的包装类都有一个Type属性</span><br>        Class&lt;Integer&gt; c4 = Integer.TYPE;<br>        System.out.println(c4);<br><br>        <span class="hljs-comment">//获得父类类型</span><br>        Class c5 = c1.getSuperclass();<br>        System.out.println(c5);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=<span class="hljs-string">&quot;学生&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=<span class="hljs-string">&quot;学生&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">这个人是：学生</span><br><span class="hljs-comment">1950409828</span><br><span class="hljs-comment">1950409828</span><br><span class="hljs-comment">1950409828</span><br><span class="hljs-comment">int</span><br><span class="hljs-comment">class com.bobo.reflection.Person</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>所有类型的class对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><br><span class="hljs-comment">//所有类型的Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class c1 = Object.class;   <span class="hljs-comment">//类</span><br>        Class c2 = Comparable.class;   <span class="hljs-comment">//接口</span><br>        Class c3 = String[].class;   <span class="hljs-comment">//一维数组</span><br>        Class c4 = <span class="hljs-keyword">int</span>[][].class;   <span class="hljs-comment">//二维数组</span><br>        Class c5 = Override.class;   <span class="hljs-comment">//注解</span><br>        Class c6 = ElementType.class;   <span class="hljs-comment">//枚举类型</span><br>        Class c7 = Integer.class;   <span class="hljs-comment">//基本数据类型</span><br>        Class c8 = <span class="hljs-keyword">void</span>.class;    <span class="hljs-comment">//void</span><br>        Class c9 = Class.class;   <span class="hljs-comment">//Class</span><br><br>        System.out.println(c1);<br>        System.out.println(c2);<br>        System.out.println(c3);<br>        System.out.println(c4);<br>        System.out.println(c5);<br>        System.out.println(c6);<br>        System.out.println(c7);<br>        System.out.println(c8);<br>        System.out.println(c9);<br><br><br>        <span class="hljs-comment">//只要是元素类型与维度一样，就是同一个Class</span><br>        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];<br><br>        System.out.println(a.getClass().hashCode());<br>        System.out.println(b.getClass().hashCode());<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">class java.lang.Object</span><br><span class="hljs-comment">interface java.lang.Comparable</span><br><span class="hljs-comment">class [Ljava.lang.String;</span><br><span class="hljs-comment">class [[I</span><br><span class="hljs-comment">interface java.lang.Override</span><br><span class="hljs-comment">class java.lang.annotation.ElementType</span><br><span class="hljs-comment">class java.lang.Integer</span><br><span class="hljs-comment">void</span><br><span class="hljs-comment">class java.lang.Class</span><br><span class="hljs-comment">580220585</span><br><span class="hljs-comment">580220585</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>只要是元素类型与维度一样，就是同一个Class</li>
</ul>
<h3 id="类加载内存分析"><a href="#类加载内存分析" class="headerlink" title="类加载内存分析"></a>类加载内存分析</h3><img src="/article/1621/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84.png" class title="img">
<p>JVM把class文件加载到内存，并对数据进行校验、准备、解析、初始化，最终形成JVM可以直接使用的Java类型的过程。</p>
<ol>
<li><p>加载</p>
<p>将class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量、静态代码块、常量池等），在堆中生成一个Class类对象代表这个类（反射原理），作为方法区类数据的访问入口。</p>
</li>
<li><p>链接</p>
<p>将Java类的二进制代码合并到JVM的运行状态之中(JRE)。</p>
<ul>
<li>验证<br>确保加载的类信息符合JVM规范，没有安全方面的问题。</li>
<li>准备<br>正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成</li>
<li>解析<br>虚拟机常量池内的符号引用替换为直接引用（地址引用）的过程。</li>
</ul>
</li>
<li><p>初始化</p>
<p>初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的<strong>赋值</strong>动作和<strong>静态语句块(static块)</strong>中的语句合并产生的。</clinit></clinit></p>
<ul>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</clinit></li>
</ul>
</li>
</ol>
<p><strong>类的初始化</strong></p>
<p><code>父类</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类被加载&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>子类</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类被加载&quot;</span>);<br>        m = <span class="hljs-number">300</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>主动引用（一定会初始化）</li>
</ol>
<ul>
<li><p>new一个类的对象；</p>
</li>
<li><p>当虚拟启动时，先初始化main方法所在的类；</p>
</li>
<li><p>调用类的静态成员(除了final常量)和静态方法；</p>
</li>
<li><p>使用java.lang.reflect包的方法对类进行反射调用；</p>
</li>
<li><p>当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类</p>
</li>
</ul>
<p><code>实现类</code>new一个类的对象主动引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-comment">//测试类什么时候会初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//主动引用</span><br>        Son son = <span class="hljs-keyword">new</span> Son();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main类被加载</span><br><span class="hljs-comment">父类被加载</span><br><span class="hljs-comment">子类被加载</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><code>实现类</code>反射产生主动引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-comment">//测试类什么时候会初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>      <span class="hljs-comment">//反射产生主动引用</span><br>      Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.Son&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main类被加载</span><br><span class="hljs-comment">父类被加载</span><br><span class="hljs-comment">子类被加载</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li>被动引用</li>
</ol>
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。例如：通过子类引用父类的静态变量，不会导致子类初始化。</li>
<li>通过数组定义类引用，不会触发此类的初始化。</li>
<li>引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）。</li>
</ul>
<p><code>实现类</code>子类引用父类的静态变量，不会导致子类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-comment">//测试类什么时候不会初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//不会产生类的引用的方法</span><br>        <span class="hljs-comment">//子类引用父类的静态变量，不会导致子类的初始化</span><br>        System.out.println(Son.b);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main类被加载</span><br><span class="hljs-comment">父类被加载</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><code>实现类</code>只是为一片内存赋名，不会初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-comment">//测试类什么时候不会初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//只是为一片内存赋名，不会初始化</span><br>        Son[] array = <span class="hljs-keyword">new</span> Son[<span class="hljs-number">5</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main类被加载</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><code>实现类</code>只是为一片内存赋名，不会初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-comment">//测试类什么时候不会初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//引用常量不会触发此类的初始化</span><br>        System.out.println(Son.M);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main类被加载</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="类加载器的原理"><a href="#类加载器的原理" class="headerlink" title="类加载器的原理"></a>类加载器的原理</h3><p><strong>类缓存</strong></p>
<p>标准的Java SE类加载器可以按要求查找类，一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过，JVM垃圾收集器可以回收这些Class对象。</p>
<p><strong>类加载的作用</strong></p>
<p>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</p>
<img src="/article/1621/1516208-20200126152957474-364815257.png" class title="img">
<p><strong>类加载器分类</strong></p>
<img src="/article/1621/376.png" class title="img">
<ul>
<li><p>自底向上检查类是否已装载</p>
</li>
<li><p>自顶向下尝试加载类</p>
</li>
</ul>
<ol>
<li><p>引导类加载器（bootstrap class loader）</p>
<ol>
<li>它用来加载 Java 的核心库(JAVA_HOME/jre/lib/rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自 java.lang.ClassLoader。</li>
<li>加载扩展类和应用程序类加载器。并指定他们的父类加载器。</li>
</ol>
</li>
<li><p>扩展类加载器（extensions class loader）</p>
<ol>
<li>用来加载 Java 的扩展库(JAVA_HOME/jre/ext/*.jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。</li>
<li>由sun.misc.Launcher$ExtClassLoader实现。</li>
</ol>
</li>
<li><p>应用程序类加载器（application class loader）</p>
<ol>
<li>它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。<strong>一般来说，Java 应用的类都是由它来完成加载的。</strong></li>
<li>由sun.misc.Launcher$AppClassLoader实现。</li>
</ol>
</li>
<li><p>自定义类加载器</p>
<ol>
<li>开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test06</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br><br>        <span class="hljs-comment">//获取系统类的加载器</span><br>        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);<br><br>        <span class="hljs-comment">//获取系统类加载起的父类加载器 --&gt; 扩展类加载器</span><br>        ClassLoader parent = systemClassLoader.getParent();<br>        System.out.println(parent);<br><br>        <span class="hljs-comment">//获取扩展类加载起的父类加载器 --&gt; 根类加载器（C/C++）</span><br>        ClassLoader grandparent = parent.getParent();<br>        <span class="hljs-comment">//用来装载核心类库，改加载类无法直接获取</span><br>        System.out.println(grandparent);<br><br>        <span class="hljs-comment">//测试当前类是哪个加载起加载的</span><br>        ClassLoader classLoader = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.Test06&quot;</span>).getClassLoader();<br>        System.out.println(classLoader);<br><br>        <span class="hljs-comment">//测试jdk内置的类是哪个加载起加载的</span><br>        classLoader = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getClassLoader();<br>        System.out.println(classLoader);<br><br>        <span class="hljs-comment">//如何获得系统类加载器可以加载的路径</span><br>        System.out.println(System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">jdk.internal.loader.ClassLoaders$AppClassLoader@55054057</span><br><span class="hljs-comment">jdk.internal.loader.ClassLoaders$PlatformClassLoader@2f0e140b</span><br><span class="hljs-comment">null</span><br><span class="hljs-comment">jdk.internal.loader.ClassLoaders$AppClassLoader@55054057</span><br><span class="hljs-comment">null</span><br><span class="hljs-comment">/Users/renbo/Desktop/研究生/学习笔记/编程/JAVA/狂神/relfection/target/classes</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>使用JDK11编译结果如上</p>
</li>
<li><p>使用JDK8编译结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">sun.misc.Launcher$AppClassLoader@18b4aac2<br>sun.misc.Launcher$ExtClassLoader@1b6d3586<br><span class="hljs-keyword">null</span><br>sun.misc.Launcher$AppClassLoader@18b4aac2<br><span class="hljs-keyword">null</span><br> /Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/charsets.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/deploy.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/cldrdata.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/dnsns.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/jaccess.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/jfxrt.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/localedata.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/nashorn.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/sunec.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/zipfs.ja;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/javaws.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/jce.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/jfr.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/jfxswt.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/jsse.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/management-agent.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/plugin.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/resources.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/rt.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/ant-javafx.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/dt.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/javafx-mx.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/jconsole.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/packager.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/sa-jdi.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/tools.jar;<br>/Users/renbo/Desktop/研究生/学习笔记/编程/JAVA/狂神/relfection/target/classes<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>双亲委派机制</strong></p>
<img src="/article/1621/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E5%9B%BE%E8%A7%A3.png" class title="img">
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的引导类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制</li>
<li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li>
</ol>
<p><strong>优势</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改<ul>
<li>自定义类：java.lang.String (没用)</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li>
</ul>
</li>
</ul>
<h3 id="获得类的运行时结构"><a href="#获得类的运行时结构" class="headerlink" title="获得类的运行时结构"></a>获得类的运行时结构</h3><p>Java中反射获取类的成员时需要调用getFields()、getDeclaredFields()；getMethods()、getDeclaredMethods()；getConstructors()、getDeclaredConstructoers()等方法获取Field、Method、Constructor对象，这几对方法的主要区别如下： </p>
<ol>
<li><p>getFields()与getDeclaredFields()</p>
<p>getFields()返回类中所有public的字段,包括从父类或接口继承的public字段；<br>getDeclaredFields()返回本类中声明的所有字段，包括public、protected、private字段，不包括从父类或接口继承的字段 </p>
</li>
<li><p>getMethods()与getDeclaredMethods()<br> getMethods()返回类中所有public的方法，包括从父类或接口继承的public方法<br> getDeclaredMethods()返回本类中声明的所有方法，包括public、protected、private方法，不包括从父类或接口继承的方法 </p>
</li>
<li><p>getConstructors()与getDeclaredConstructors()<br> getConstructors()返回类中所有public的构造方法；<br> getDeclaredConstructors()返回类中声明的所有构造方法，包括public、protected、private构造方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">//获得类的信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test07</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;<br>        Class c1 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br>        User user = <span class="hljs-keyword">new</span> User();<br>        c1 = user.getClass();<br><br>        <span class="hljs-comment">//获得类的名字</span><br>        System.out.println(c1.getName());    <span class="hljs-comment">//获得包名+类名</span><br>        System.out.println(c1.getSimpleName());   <span class="hljs-comment">//获得类名</span><br><br>        <span class="hljs-comment">//获得类得属性</span><br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        Field[] fields = c1.getFields();  <span class="hljs-comment">//getFields()只能找到public属性</span><br>        fields = c1.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field);<br>        &#125;<br>        Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br><br>        <span class="hljs-comment">//获得类的方法</span><br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        Method[] methods = c1.getMethods();   <span class="hljs-comment">//获得本类及其父类的全部public方法</span><br>        Method[] declaredMethods = c1.getDeclaredMethods();   <span class="hljs-comment">//获得本类的全部方法</span><br><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;正常的：&quot;</span>+method);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Method declaredMethod : declaredMethods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;declaredMethod:&quot;</span>+declaredMethod);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        <span class="hljs-comment">//获得指定方法</span><br>        <span class="hljs-comment">//重载</span><br>        Method getName = c1.getMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-keyword">null</span>);<br>        Method setName = c1.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        System.out.println(getName);<br>        System.out.println(setName);<br><br>        <span class="hljs-comment">//获得指定的构造器</span><br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        Constructor[] constructors = c1.getConstructors();<br>        Constructor[] declaredConstructors = c1.getDeclaredConstructors();<br><br>        <span class="hljs-keyword">for</span> (Constructor constructor : constructors) &#123;<br>            System.out.println(constructor);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Constructor declaredConstructor : declaredConstructors) &#123;<br>            System.out.println(<span class="hljs-string">&quot;#&quot;</span>+declaredConstructor);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        <span class="hljs-comment">//获得指定的构造器</span><br>        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, <span class="hljs-keyword">int</span>.class);<br>        System.out.println(<span class="hljs-string">&quot;指定+&quot;</span>+declaredConstructor);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">com.bobo.reflection.User</span><br><span class="hljs-comment">User</span><br><span class="hljs-comment">====================================</span><br><span class="hljs-comment">private java.lang.String com.bobo.reflection.User.name</span><br><span class="hljs-comment">private int com.bobo.reflection.User.id</span><br><span class="hljs-comment">private int com.bobo.reflection.User.age</span><br><span class="hljs-comment">private java.lang.String com.bobo.reflection.User.name</span><br><span class="hljs-comment">====================================</span><br><span class="hljs-comment">正常的：public java.lang.String com.bobo.reflection.User.getName()</span><br><span class="hljs-comment">正常的：public java.lang.String com.bobo.reflection.User.toString()</span><br><span class="hljs-comment">正常的：public void com.bobo.reflection.User.setName(java.lang.String)</span><br><span class="hljs-comment">正常的：public int com.bobo.reflection.User.getId()</span><br><span class="hljs-comment">正常的：public void com.bobo.reflection.User.setId(int)</span><br><span class="hljs-comment">正常的：public int com.bobo.reflection.User.getAge()</span><br><span class="hljs-comment">正常的：public void com.bobo.reflection.User.setAge(int)</span><br><span class="hljs-comment">正常的：public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="hljs-comment">正常的：public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="hljs-comment">正常的：public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="hljs-comment">正常的：public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="hljs-comment">正常的：public native int java.lang.Object.hashCode()</span><br><span class="hljs-comment">正常的：public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="hljs-comment">正常的：public final native void java.lang.Object.notify()</span><br><span class="hljs-comment">正常的：public final native void java.lang.Object.notifyAll()</span><br><span class="hljs-comment">declaredMethod:public java.lang.String com.bobo.reflection.User.getName()</span><br><span class="hljs-comment">declaredMethod:public java.lang.String com.bobo.reflection.User.toString()</span><br><span class="hljs-comment">declaredMethod:public void com.bobo.reflection.User.setName(java.lang.String)</span><br><span class="hljs-comment">declaredMethod:public int com.bobo.reflection.User.getId()</span><br><span class="hljs-comment">declaredMethod:public void com.bobo.reflection.User.setId(int)</span><br><span class="hljs-comment">declaredMethod:public int com.bobo.reflection.User.getAge()</span><br><span class="hljs-comment">declaredMethod:public void com.bobo.reflection.User.setAge(int)</span><br><span class="hljs-comment">====================================</span><br><span class="hljs-comment">public java.lang.String com.bobo.reflection.User.getName()</span><br><span class="hljs-comment">public void com.bobo.reflection.User.setName(java.lang.String)</span><br><span class="hljs-comment">====================================</span><br><span class="hljs-comment">public com.bobo.reflection.User()</span><br><span class="hljs-comment">public com.bobo.reflection.User(java.lang.String,int,int)</span><br><span class="hljs-comment">#public com.bobo.reflection.User()</span><br><span class="hljs-comment">#public com.bobo.reflection.User(java.lang.String,int,int)</span><br><span class="hljs-comment">====================================</span><br><span class="hljs-comment">指定+public com.bobo.reflection.User(java.lang.String,int,int)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>invoke()方法：用于调用指定的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj,Object... args)</span></span><br></code></pre></td></tr></table></figure>
<ul>
<li>第一个Object对应原方法的返回值，若原方法无返回值则返回null</li>
<li>括号里的第一个Object代表调用这个方法的对象</li>
<li>若原方法形参列表为空，Object[] args为null</li>
<li>如果原方法声明为private，需要在调用invoke()之前调用setAccessible()方法</li>
</ul>
<p><strong>setAccessible()方法：用于启动和禁止访问安全检查的开关</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAccessible</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span></span><br></code></pre></td></tr></table></figure>
<p>参数为false表示反射的对象应该实施访问检查，参数为true则关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">//动态的创建对象，通过反射</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test08</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException </span>&#123;<br>        <span class="hljs-comment">//获得Class对象</span><br>        Class c1 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">//构造一个对象</span><br>        <span class="hljs-comment">//User user = (User) c1.newInstance();   //本质是调用了类无参构造器</span><br>        <span class="hljs-comment">//System.out.println(user);</span><br>        Constructor constructor = (Constructor) c1.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, <span class="hljs-keyword">int</span>.class);<br>        User user2 = (User) constructor.newInstance(<span class="hljs-string">&quot;bobo&quot;</span>, <span class="hljs-number">001</span>, <span class="hljs-number">18</span>);<br>        System.out.println(user2);<br><br>        <span class="hljs-comment">//通过反射调用普通方法</span><br>        User user3 = (User) c1.newInstance();<br>        <span class="hljs-comment">//通过反射获取一个方法</span><br>        Method setName = c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        <span class="hljs-comment">//invoke() 激活</span><br>        <span class="hljs-comment">//(对象，&quot;方法的值&quot;)</span><br>        setName.invoke(user3,<span class="hljs-string">&quot;bobo&quot;</span>);<br>        System.out.println(user3.getName());<br><br>        <span class="hljs-comment">//通过反射操作属性</span><br>        System.out.println(<span class="hljs-string">&quot;================================&quot;</span>);<br>        User user4 = (User) c1.newInstance();<br>        Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">//不能直接操作私有属性，我们需要关闭程序的安全检测   属性或者方法的 setAccessible(true)</span><br>        name.setAccessible(<span class="hljs-keyword">true</span>);<br>        name.set(user4,<span class="hljs-string">&quot;bobo2&quot;</span>);<br>        System.out.println(user4.getName());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">User&#123;name=&#x27;bobo&#x27;, id=1, age=18&#125;</span><br><span class="hljs-comment">bobo</span><br><span class="hljs-comment">================================</span><br><span class="hljs-comment">bobo2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="性能对比分析"><a href="#性能对比分析" class="headerlink" title="性能对比分析"></a>性能对比分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">//分析性能问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test09</span> </span>&#123;<br><br>    <span class="hljs-comment">//普通方式调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        <span class="hljs-comment">//获取开始时间</span><br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            user.getName();<br>        &#125;<br>        <span class="hljs-comment">//获取结束时间</span><br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;普通方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//反射方式调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        Class c1 = user.getClass();<br>        Method getName = c1.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//获取开始时间</span><br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            getName.invoke(user, <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-comment">//获取结束时间</span><br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;反射方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//反射方式调用  关闭检测</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        Class c1 = user.getClass();<br>        Method getName = c1.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-keyword">null</span>);<br>        getName.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//获取开始时间</span><br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            getName.invoke(user, <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-comment">//获取结束时间</span><br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;关闭检测，反射方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, NoSuchMethodException, IllegalAccessException </span>&#123;<br>        test01();<br>        test02();<br>        test03();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">普通方式执行<span class="hljs-number">10</span>亿次：5ms<br>反射方式执行<span class="hljs-number">10</span>亿次：2470ms<br>关闭检测，反射方式执行<span class="hljs-number">10</span>亿次：1169ms<br></code></pre></td></tr></table></figure>
<p><strong>反射操作泛型</strong></p>
<p>Java采用泛型擦除机制来引入泛型。Java中的泛型仅仅是给编译器Javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是编译一旦完成，所有和泛型有关的类型全部被擦除。</p>
<p>为了通过反射操作这些类型以迎合实际开发的需要，Java新增了ParameterizedType,GenericArrayType,TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。 </p>
<ul>
<li><code>ParameterizedType</code>:表示一种参数化的类型，比如<code>Collection&lt;String&gt;</code></li>
<li><code>GenericArrayType</code>:表示一种元素类型是参数化类型或者类型变量的数组类型</li>
<li><code>TypeVariable</code>:是各种类型变量的公共父接口</li>
<li><code>WildcardType</code>:代表一种通配符类型表达式，比如<code>？</code>、<code>？ extends Number</code>、<code>？ super Integer</code>。（wildcard是一个单词：就是”通配符“）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Parameter;<br><span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<br><span class="hljs-keyword">import</span> java.lang.reflect.Type;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">//通过反射获取泛型</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test01&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String ,User&gt; <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test02&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;<br>        <span class="hljs-comment">//参数是泛型</span><br>        Method method = Test.class.getMethod(<span class="hljs-string">&quot;test01&quot;</span>, Map.class, List.class);<br>        Type[] genericParameterTypes = method.getGenericParameterTypes();<br>        <span class="hljs-keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;<br>          System.out.println(<span class="hljs-string">&quot;genericParameterType:&quot;</span>+genericParameterType);<br>            <span class="hljs-keyword">if</span> (genericParameterType <span class="hljs-keyword">instanceof</span> ParameterizedType)&#123;<br>                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();<br>                <span class="hljs-keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;<br>                    System.out.println(actualTypeArgument);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//返回值是泛型</span><br>        method = Test.class.getMethod(<span class="hljs-string">&quot;test02&quot;</span>, <span class="hljs-keyword">null</span>);<br>        Type genericReturnType = method.getGenericReturnType();<br>        <span class="hljs-keyword">if</span> (genericReturnType <span class="hljs-keyword">instanceof</span> ParameterizedType)&#123;<br>            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();<br>            <span class="hljs-keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;<br>                System.out.println(actualTypeArgument);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">返回结果：<br>genericParameterType:java.util.Map&lt;java.lang.String,com.bobo.reflection.User&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span></span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">bobo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span></span><br><span class="hljs-class"><span class="hljs-title">genericParameterType</span>:<span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">List</span>&lt;<span class="hljs-title">com</span>.<span class="hljs-title">bobo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">bobo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span></span><br><span class="hljs-class">  </span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span></span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">bobo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span></span><br></code></pre></td></tr></table></figure>
<h2 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h2><p><strong>获取注解的方法：</strong></p>
<ul>
<li>Class.getAnnotations() 获取所有的注解，包括自己声明的以及继承的</li>
<li>Class.getAnnotation(Class&lt; A &gt; annotationClass) 获取指定的注解，该注解可以是自己声明的，也可以是继承的</li>
<li>Class.getDeclaredAnnotations() 获取自己声明的注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-comment">//练习反射操作注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test11</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;<br>        Class c1 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.Students&quot;</span>);<br><br>        <span class="hljs-comment">//通过反射获取注解</span><br>        Annotation[] annotations = c1.getAnnotations();<br>        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>            System.out.println(annotation);<br>        &#125;<br><br>        <span class="hljs-comment">//获得注解的value的值</span><br>        Tablebobo tablebobo = (Tablebobo) c1.getAnnotation(Tablebobo.class);<br>        String value = tablebobo.value();<br>        System.out.println(value);<br><br>        <span class="hljs-comment">//获得类指定的注解</span><br>        Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        Filebobo annotation = name.getAnnotation(Filebobo.class);<br>        System.out.println(annotation.columnName());<br>        System.out.println(annotation.type());<br>        System.out.println(annotation.length());<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Tablebobo(&quot;db_students&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span>&#123;<br>    <span class="hljs-meta">@Filebobo(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-meta">@Filebobo(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-meta">@Filebobo(columnName = &quot;db_name&quot;,type = &quot;varcher&quot;,length = 3)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Students</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Students</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Students&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//@Target  注解作用域</span><br><span class="hljs-comment">//@Rtention  在什么级别可以获取</span><br><span class="hljs-comment">//类名的注解</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> Tablebobo&#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//属性的注解</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> Filebobo&#123;<br>    <span class="hljs-function">String <span class="hljs-title">columnName</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">type</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">运行结果：<br><span class="hljs-meta">@com</span>.bobo.reflection.Tablebobo(<span class="hljs-string">&quot;db_students&quot;</span>)<br>db_students<br>db_name<br>varcher<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>注解与反射</category>
      </categories>
      <tags>
        <tag>Java,注解与反射</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/article/52560.html</url>
    <content><![CDATA[<p>　　　　　　　　　　</p>
<blockquote>
<p>The world rushes on over the strings of the lingering heart making<br>the music of sadness.</p>
<p>世界在踌躇之心的琴弦上跑过去，奏出忧郁的乐声。</p>
</blockquote>
<h2 id="Java-网络编程"><a href="#Java-网络编程" class="headerlink" title="Java 网络编程"></a>Java 网络编程</h2><p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。</p>
<p>java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p>
<p>java.net 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><strong>TCP</strong>：TCP（英语：Transmission Control Protocol，传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP 层是位于 IP 层之上，应用层之下的中间层。TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。</li>
<li><strong>UDP</strong>：UDP （英语：User Datagram Protocol，用户数据报协议），位于 OSI 模型的传输层。一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。</li>
</ul>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>为了便于寻址以及层次化构造网络，每个IP地址包括两个标识码（ID），即<strong>网络ID和主机ID</strong>。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。Internet委员会定义了5种IP地址类型以适合不同容量的网络，即A类~E类。</p>
<img src="/article/52560/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.jpg" class title="IP地址分类">
<h3 id="IPV4与IPV6"><a href="#IPV4与IPV6" class="headerlink" title="IPV4与IPV6"></a>IPV4与IPV6</h3><table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:left">IPv4</th>
<th style="text-align:left">IPv6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>地址</strong></td>
<td style="text-align:left">长度为 32 位（4 个字节）。地址由网络和主机部分组成，这取决于地址类。根据地址的前几位，可定义各种地址类：A、B、C、D 或 E。IPv4 地址的总数为 4 294 967 296。IPv4 地址的文本格式为 nnn.nnn.nnn.nnn，其中 0&lt;=nnn&lt;=255，而每个 n 都是十进制数。可省略前导零。最大打印字符数为 15 个，不计掩码。</td>
<td style="text-align:left">长度为 128 位（16 个字节）。基本体系结构的网络数字为 64 位，主机数字为 64 位。通常，IPv6 地址（或其部分）的主机部分将派生自 MAC 地址或其他接口标识。根据子网前缀，IPv6 的体系结构比 IPv4 的体系结构更复杂。IPv6 地址的数目比 IPv4 地址的数目大 1028（79 228 162 514 264 337 593 543 950 336）倍。IPv6 地址的文本格式为xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx，其中每个 x 都是十六进制数，表示 4 位。可省略前导零。可在地址的文本格式中使用一次双冒号（::），用于指定任意数目的 0 位。例如，::ffff:10.120.78.40 表示 IPv4 映射的 IPv6 地址。</td>
</tr>
<tr>
<td style="text-align:left"><strong>地址分配</strong></td>
<td style="text-align:left">最初，按网络类分配地址。随着地址空间的消耗，使用“无类域间路由”（CIDR）进行更小的分配。没有在机构和国家或地区之间平均分配地址。</td>
<td style="text-align:left">分配尚处于早期阶段。“因特网工程任务组织”（IETF ）和“因特网体系结构委员会”（IAB）建议基本上为每个组织、家庭或实体分配一个 /48 子网前缀长度。它将保留 16 位供组织进行子网划分。地址空间是足够大的，可为世界上每个人提供一个其自己的 /48 子网前缀长度。</td>
</tr>
</tbody>
</table>
<h3 id="公网IP与私网IP"><a href="#公网IP与私网IP" class="headerlink" title="公网IP与私网IP"></a>公网IP与私网IP</h3><ul>
<li>Public IP : 公共 IP ，经由 INTERNIC 所统一规划的 IP，有这种 IP 才可以连上 Internet ；</li>
<li>Private IP : 私有 IP 或保留 IP，不能直接连上 Internet 的 IP ，主要用于局域网络内的主机联机规划。</li>
</ul>
<p>公网IP在全球内是唯一的。也就是说在同一时间一个IP(除了一些特别的IP，如:154.0.0.0等)只代表一能设备，所以通只要找得到IP，也就可以找到特定的设备了。如果A是公网IP，且没有防火墙等Ban连接的话，那么B电脑上的EM就可以找并连接上A了。私网IP是专门给一些局域网内用的。也就是说在网络上是不唯一-的， 公网上是不能通这个私有IP来找到对应的设备的。</p>
<p>以下范围内的IP地址属于内网保留地址，即不是公网IP，而是属于私有IP:</p>
<ul>
<li>10.0.0.0 - 10.255.255.255</li>
<li>172.16.0.0 - 172.31.255.255</li>
<li>192.168.0.0 - 192. 168.255.255</li>
</ul>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>TCP/IP的<code>传输层</code>用一个16位端口号来标志一个端口（port）。</p>
<p>虽然通信的终点是应用程序，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作（即最后交付的进程）就由TCP或UDP来完成。</p>
<p>TCP和UDP的首部格式中，它们都有<code>源端口</code>和<code>目的端口</code>这两个重要字段。当<code>传输层</code>收到<code>网络层</code>交上来的<code>传输层报文</code>时，就能够根据其首部中的<code>目的端口号</code>把数据交付应用层的<code>目的应用进程</code>。</p>
<p>两个计算机中的进程要互相通信，不仅必须知道对方的IP地址，而且要知道对方的<code>端口号</code>（为了找到对方计算机中的应用程序）。互联网上的计算机通信是采用<code>客户端-服务器</code>方式。客户端在发起通信请求时，必须先知道对方的服务器的<code>IP地址</code>和<code>端口号</code>。</p>
<p>因此传输层的端口号分为下面的两大类：</p>
<p><strong><code>服务器端</code>使用的端口号:</strong></p>
<p>熟知端口号或系统端口号：数值为<code>0 ~ 1023</code>。</p>
<p>UDP 知名端口：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">协议</th>
<th style="text-align:center">数值端口号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center"><strong>ECHO（回声协议）</strong></td>
<td style="text-align:center"><strong>7</strong></td>
<td style="text-align:center"><strong>将收到的数据包会送给发送端</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"><strong>DNS</strong></td>
<td style="text-align:center"><strong>53</strong></td>
<td style="text-align:center"><strong>域名服务</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>3</strong></td>
<td style="text-align:center"><strong>DHCP</strong></td>
<td style="text-align:center"><strong>67</strong></td>
<td style="text-align:center"><strong>动态 主机 设置 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>4</strong></td>
<td style="text-align:center"><strong>TFTP</strong></td>
<td style="text-align:center"><strong>69</strong></td>
<td style="text-align:center"><strong>简单 文件 传输 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>5</strong></td>
<td style="text-align:center"><strong>SNMP</strong></td>
<td style="text-align:center"><strong>161，162</strong></td>
<td style="text-align:center"><strong>简单 网络 管理 协议</strong></td>
</tr>
</tbody>
</table>
<p>TCP 知名端口：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">应用程序</th>
<th style="text-align:center">数值端口号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center"><strong>ECHO（回声协议）</strong></td>
<td style="text-align:center"><strong>7</strong></td>
<td style="text-align:center"><strong>将收到的数据包会送给发送端</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"><strong>FTP</strong></td>
<td style="text-align:center"><strong>20，21</strong></td>
<td style="text-align:center"><strong>20端口 用于 数据传输 21端口 用于 控制信令的传输 控制信息 和 数据 能够同时传输，这是FTP的特殊之处</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>3</strong></td>
<td style="text-align:center"><strong>SSH</strong></td>
<td style="text-align:center"><strong>22</strong></td>
<td style="text-align:center"><strong>安全 外壳 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>4</strong></td>
<td style="text-align:center"><strong>TELNET</strong></td>
<td style="text-align:center"><strong>23</strong></td>
<td style="text-align:center"><strong>远程 终端 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>5</strong></td>
<td style="text-align:center"><strong>SMTP</strong></td>
<td style="text-align:center"><strong>25</strong></td>
<td style="text-align:center"><strong>简单 邮件 传输 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>6</strong></td>
<td style="text-align:center"><strong>DNS</strong></td>
<td style="text-align:center"><strong>53</strong></td>
<td style="text-align:center"><strong>域名服务</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>7</strong></td>
<td style="text-align:center"><strong>HTTP</strong></td>
<td style="text-align:center"><strong>80</strong></td>
<td style="text-align:center"><strong>超文本传送协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>8</strong></td>
<td style="text-align:center"><strong>HTTPS</strong></td>
<td style="text-align:center"><strong>443</strong></td>
<td style="text-align:center"><strong>超文本 传输 安全 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>9</strong></td>
<td style="text-align:center"><strong>POP3</strong></td>
<td style="text-align:center"><strong>110</strong></td>
<td style="text-align:center"><strong>邮件传送协议</strong></td>
</tr>
</tbody>
</table>
<p><strong><code>客户端</code>使用的端口号：</strong></p>
<p>数值为<code>49152 ~ 65535</code></p>
<p>由于这类端口号仅在客户进程运行时才动态选择，因此又叫做<code>短暂端口号</code>。这类端口号留给客户进程选择暂时使用。</p>
<p>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的<code>端口号</code>，因而可以把数据发送给客户进程。</p>
<p>通信结束后，刚才已使用过的客户端口号就不存在了，这个端口号就可以供其他客户进程使用。</p>
<p><strong>常见端口号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">21端口：FTP 文件传输服务<br>22端口：SSH 端口<br>23端口：TELNET 终端仿真服务<br>25端口：SMTP 简单邮件传输服务<br>53端口：DNS 域名解析服务<br>80端口：HTTP 超文本传输服务<br>110端口：POP3 “邮6局协议版本3”使用的端口<br>443端口：HTTPS 加密的超文本传输服务<br>8080端口：Tomcat<br>3306端口：Mysql<br>1521端口: Oracle<br></code></pre></td></tr></table></figure>
<h2 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h2><p>端口号与IP地址的组合，得出一个网络套接字：Socket，所以说一些网络编程也被称为Socket编程</p>
<p>套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。</p>
<p>当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。</p>
<p>java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。</p>
<p>以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：</p>
<ul>
<li>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</li>
<li>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li>
<li>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</li>
<li>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</li>
<li>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</li>
</ul>
<p>连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。</p>
<p>TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送</p>
<p><strong>ServerSocket 类的方法</strong></p>
<p>服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。</p>
<p>ServerSocket 类有四个构造方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>序号</strong></th>
<th style="text-align:left"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left"><strong>public ServerSocket(int port) throws IOException</strong> 创建绑定到特定端口的服务器套接字。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left"><strong>public ServerSocket(int port, int backlog) throws IOException</strong> 利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left"><strong>public ServerSocket(int port, int backlog, InetAddress address) throws IOException</strong> 使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left"><strong>public ServerSocket() throws IOException</strong> 创建非绑定服务器套接字。</td>
</tr>
</tbody>
</table>
<p>创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。</p>
<p>这里有一些 ServerSocket 类的常用方法：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public int getLocalPort()</strong>  返回此套接字在其上侦听的端口。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public Socket accept() throws IOException</strong> 侦听并接受到此套接字的连接。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public void setSoTimeout(int timeout)</strong>  通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public void bind(SocketAddress host, int backlog)</strong> 将 ServerSocket 绑定到特定地址（IP 地址和端口号）。</td>
</tr>
</tbody>
</table>
<p><strong>Socket 类的方法</strong></p>
<p>java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。</p>
<p>Socket 类有五个构造方法.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>序号</strong></th>
<th style="text-align:left"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left"><strong>public Socket(String host, int port) throws UnknownHostException, IOException.</strong> 创建一个流套接字并将其连接到指定主机上的指定端口号。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left"><strong>public Socket(InetAddress host, int port) throws IOException</strong> 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left"><strong>public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.</strong> 创建一个套接字并将其连接到指定远程主机上的指定远程端口。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left"><strong>public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException.</strong> 创建一个套接字并将其连接到指定远程地址上的指定远程端口。</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left"><strong>public Socket()</strong> 通过系统默认类型的 SocketImpl 创建未连接套接字</td>
</tr>
</tbody>
</table>
<p>当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。</p>
<p>下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td><strong>public void connect(SocketAddress host, int timeout) throws IOException</strong> 将此套接字连接到服务器，并指定一个超时值。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td><strong>public InetAddress getInetAddress()</strong>  返回套接字连接的地址。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td><strong>public int getPort()</strong> 返回此套接字连接到的远程端口。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td><strong>public int getLocalPort()</strong> 返回此套接字绑定到的本地端口。</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td><strong>public SocketAddress getRemoteSocketAddress()</strong> 返回此套接字连接的端点的地址，如果未连接则返回 null。</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td><strong>public InputStream getInputStream() throws IOException</strong> 返回此套接字的输入流。</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td><strong>public OutputStream getOutputStream() throws IOException</strong> 返回此套接字的输出流。</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td><strong>public void close() throws IOException</strong> 关闭此套接字。</td>
</tr>
</tbody>
</table>
<p><strong>InetAddress 类的方法</strong></p>
<p>这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>序号</strong></th>
<th style="text-align:left"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left"><strong>static InetAddress getByAddress(byte[] addr)</strong> 在给定原始 IP 地址的情况下，返回 InetAddress 对象。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left"><strong>static InetAddress getByAddress(String host, byte[] addr)</strong> 根据提供的主机名和 IP 地址创建 InetAddress。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left"><strong>static InetAddress getByName(String host)</strong> 在给定主机名的情况下确定主机的 IP 地址。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left"><strong>String getHostAddress()</strong>  返回 IP 地址字符串（以文本表现形式）。</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left"><strong>String getHostName()</strong>   获取此 IP 地址的主机名。</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left"><strong>static InetAddress getLocalHost()</strong> 返回本地主机。</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:left"><strong>String toString()</strong> 将此 IP 地址转换为 String。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.InetAddress; <br><span class="hljs-keyword">import</span> java.net.UnknownHostException; <br><span class="hljs-comment">//IP 这个东西，怎么用Java对象表示 </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InetAddressTest</span> </span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//获得IP地址 </span><br>    InetAddress inetAddresses1 = InetAddress.getByName(<span class="hljs-string">&quot;192.168.8.123&quot;</span>); <br>    System.out.println(inetAddresses1); <br>    InetAddress inetAddresses2 = InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>); <br>    System.out.println(inetAddresses2); <br>    <span class="hljs-comment">//获取本地IP </span><br>    InetAddress inetAddresses3 = InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>); <br>    System.out.println(inetAddresses3); <br>    InetAddress inetAddresses4 = InetAddress.getByName(<span class="hljs-string">&quot;localhost&quot;</span>); <br>    System.out.println(inetAddresses4); <br>    InetAddress inetAddresses5 = InetAddress.getLocalHost(); <br>    System.out.println(inetAddresses5); <br>    <span class="hljs-comment">//getHostName </span><br>    System.out.println(inetAddresses2.getHostName()); <br>    <span class="hljs-comment">//getHostAddress </span><br>    System.out.println(inetAddresses2.getHostAddress()); <br>    <span class="hljs-comment">//Canonical : 规范的 S</span><br>    ystem.out.println(inetAddresses2.getCanonicalHostName()); <br>    &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123; <br>    e.printStackTrace(); <br>    &#125; <br>  &#125; <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">/192.168.8.123</span><br><span class="hljs-comment">www.baidu.com/182.61.200.6</span><br><span class="hljs-comment">/127.0.0.1</span><br><span class="hljs-comment">localhost/127.0.0.1</span><br><span class="hljs-comment">GMagic-Pro.local/127.0.0.1</span><br><span class="hljs-comment">www.baidu.com</span><br><span class="hljs-comment">182.61.200.6</span><br><span class="hljs-comment">182.61.200.6</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>InetSocketAddress类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.InetSocketAddress; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InetSocketAddressTest</span> </span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>    InetSocketAddress socketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">8080</span>);<br>    InetSocketAddress socketAddress2 = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">9000</span>); 		<br>    System.out.println(socketAddress.getHostName()); <br>    System.out.println(socketAddress.getAddress()); <br>    System.out.println(socketAddress.getPort()); <br>    System.out.println(socketAddress2.getHostName()); <br>    System.out.println(socketAddress2.getAddress()); <span class="hljs-comment">//返回地址 </span><br>    System.out.println(socketAddress2.getPort()); <span class="hljs-comment">//返回端口 </span><br>  &#125; <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">返回结果：</span><br><span class="hljs-comment">localhost</span><br><span class="hljs-comment">localhost/127.0.0.1</span><br><span class="hljs-comment">8080</span><br><span class="hljs-comment">localhost</span><br><span class="hljs-comment">localhost/127.0.0.1</span><br><span class="hljs-comment">9000</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>Socket 客户端实例</strong></p>
<p>如下的 GreetingClient 是一个客户端程序，该程序通过 socket 连接到服务器并发送一个请求，然后等待一个响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件名 GreetingClient.java</span><br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingClient</span></span><br><span class="hljs-class"></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span></span><br><span class="hljs-function">   </span>&#123;<br>      String serverName = args[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">1</span>]);<br>      <span class="hljs-keyword">try</span><br>      &#123;<br>         System.out.println(<span class="hljs-string">&quot;连接到主机：&quot;</span> + serverName + <span class="hljs-string">&quot; ，端口号：&quot;</span> + port);<br>         Socket client = <span class="hljs-keyword">new</span> Socket(serverName, port);<br>         System.out.println(<span class="hljs-string">&quot;远程主机地址：&quot;</span> + client.getRemoteSocketAddress());<br>         OutputStream outToServer = client.getOutputStream();<br>         DataOutputStream out = <span class="hljs-keyword">new</span> DataOutputStream(outToServer);<br> <br>         out.writeUTF(<span class="hljs-string">&quot;Hello from &quot;</span> + client.getLocalSocketAddress());<br>         InputStream inFromServer = client.getInputStream();<br>         DataInputStream in = <span class="hljs-keyword">new</span> DataInputStream(inFromServer);<br>         System.out.println(<span class="hljs-string">&quot;服务器响应： &quot;</span> + in.readUTF());<br>         client.close();<br>      &#125;<span class="hljs-keyword">catch</span>(IOException e)<br>      &#123;<br>         e.printStackTrace();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Socket 服务端实例</strong></p>
<p>如下的GreetingServer 程序是一个服务器端应用程序，使用 Socket 来监听一个指定的端口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件名 GreetingServer.java</span><br> <br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span><br><span class="hljs-class"></span>&#123;<br>   <span class="hljs-keyword">private</span> ServerSocket serverSocket;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GreetingServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function">   </span>&#123;<br>      serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port);<br>      serverSocket.setSoTimeout(<span class="hljs-number">10000</span>);<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)<br>      &#123;<br>         <span class="hljs-keyword">try</span><br>         &#123;<br>            System.out.println(<span class="hljs-string">&quot;等待远程连接，端口号为：&quot;</span> + serverSocket.getLocalPort() + <span class="hljs-string">&quot;...&quot;</span>);<br>            Socket server = serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;远程主机地址：&quot;</span> + server.getRemoteSocketAddress());<br>            DataInputStream in = <span class="hljs-keyword">new</span> DataInputStream(server.getInputStream());<br>            System.out.println(in.readUTF());<br>            DataOutputStream out = <span class="hljs-keyword">new</span> DataOutputStream(server.getOutputStream());<br>            out.writeUTF(<span class="hljs-string">&quot;谢谢连接我：&quot;</span> + server.getLocalSocketAddress() + <span class="hljs-string">&quot;\nGoodbye!&quot;</span>);<br>            server.close();<br>         &#125;<span class="hljs-keyword">catch</span>(SocketTimeoutException s)<br>         &#123;<br>            System.out.println(<span class="hljs-string">&quot;Socket timed out!&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         &#125;<span class="hljs-keyword">catch</span>(IOException e)<br>         &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">break</span>;<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span></span><br><span class="hljs-function">   </span>&#123;<br>      <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);<br>      <span class="hljs-keyword">try</span><br>      &#123;<br>         Thread t = <span class="hljs-keyword">new</span> GreetingServer(port);<br>         t.run();<br>      &#125;<span class="hljs-keyword">catch</span>(IOException e)<br>      &#123;<br>         e.printStackTrace();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先启动服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">$ javac GreetingServer.java <br>$ java GreetingServer <span class="hljs-number">6066</span><br>等待远程连接，端口号为：<span class="hljs-number">6066.</span>..<br></code></pre></td></tr></table></figure>
<p>在启动服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">$ javac GreetingClient.java <br>$ java GreetingClient localhost <span class="hljs-number">6066</span><br>连接到主机：localhost ，端口号：<span class="hljs-number">6066</span><br>远程主机地址：localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6066</span><br>服务器响应： 谢谢连接我：/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6066</span><br>Goodbye!<br></code></pre></td></tr></table></figure>
<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a><strong>网络通信协议</strong></h2><p><strong>网络通信协议：</strong></p>
<p>网络通信协议是一种网络通用语言，为连接不同操作系统和不同硬件体系结构的互联网络引提供通信支持，是一种网络通用语言。</p>
<p><strong>通信协议分层的思想</strong></p>
<p>在制定协议时，把复杂成份分解成一些简单的成份，再将他们复合起来。最常用的复合方式是层次方</p>
<p>式，即同层间可以通信，上一层调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开</p>
<p>发和扩展。</p>
<p><strong>网络通信协议由三要素</strong></p>
<ul>
<li>语义，解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</li>
<li>语法，用户数据与控制信息的结构与格式，以及数据出现的顺序。</li>
<li>时序，对事件发生顺序的详细说明。</li>
</ul>
<p><strong>TCP/IP协议簇</strong></p>
<p>传输层协议中有两个非常重要的协议：</p>
<ul>
<li>用户传输协议 TCP （Transmission Control Protocol）</li>
<li>用户数据报协议UDP（User Datagram Protocol） </li>
</ul>
<p>Tcp/IP 以其两个主要协议：</p>
<ul>
<li>传输控制协议：TCP</li>
<li>网络互联协议：IP</li>
</ul>
<p>实际上是一组协议，包括多个具有不同功能且互为关联的协议。</p>
<p>IP（Internet Protocol）协议是网络层的主要协议，支持网间互联的数据通信。</p>
<p>TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层，IP层，传输层和应用层。</p>
<h3 id="UPD与TCP区别"><a href="#UPD与TCP区别" class="headerlink" title="UPD与TCP区别"></a>UPD与TCP区别</h3><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><strong>UDP</strong></h4><p><strong>特点</strong></p>
<ol>
<li><p>面向无连接首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<ol start="2">
<li><p>有单播，多播，广播的功能</p>
<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
</li>
</ol>
</li>
<li><p>UDP是面向报文的</p>
<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
</li>
<li><p>不可靠性</p>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
</li>
</ol>
<blockquote>
<img src="/article/52560/UDP%E5%8C%85%E5%A4%B4.jpg" class title="UDP 包头">
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
</blockquote>
<ul>
<li>沟通简单，不需要大量的数据结构，处理逻辑和包头字段</li>
<li>轻信他人。它不会建立连接，但是会监听这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以同时传给多个人数据。</li>
<li>愣头青，做事不懂变通。不会根据网络的情况进行拥塞控制，无论是否丢包，它该怎么发还是怎么发</li>
</ul>
<p><strong>主要应用场景</strong></p>
<ul>
<li>需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。</li>
<li>不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。</li>
<li>需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候</li>
</ul>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p><strong>特点</strong></p>
<ol>
<li><p>面向连接</p>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
</li>
<li><p>仅支持单播传输</p>
<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
</li>
<li><p>面向字节流</p>
<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
</li>
<li><p>可靠传输</p>
<p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
</li>
<li><p>提供拥塞控制</p>
<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p>
</li>
<li><p>TCP提供全双工通信</p>
<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
</li>
</ol>
<blockquote>
<img src="/article/52560/a795461effcce686a43f48e094c9adbf.jpg" class title="TCP 包头">
<ul>
<li>首先，源端口和目标端口是不可少的；</li>
<li>接下来是包的序号。主要是为了解决乱序问题；</li>
<li>确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题；</li>
<li>状态位。SYN 是发起一个链接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更；</li>
<li>窗口大小，TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。</li>
</ul>
</blockquote>
<p><strong>TCP 的三次握手</strong></p>
<img src="/article/52560/666d7d20aa907d8317af3770411f5aa2.jpg" class title="状态变化时序图">
<p><strong>TCP 四次挥手</strong></p>
<img src="/article/52560/1f6a5e17b34f00d28722428b7b8ccb11.jpg" class title="断开连接状态时序图">
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">UDP</th>
<th style="text-align:center">TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">是否连接</td>
<td style="text-align:center">无连接</td>
<td style="text-align:center">面向连接</td>
</tr>
<tr>
<td style="text-align:center">是否可靠</td>
<td style="text-align:center">不可靠传输，不使用流量控制和拥塞控制</td>
<td style="text-align:center">可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td style="text-align:center">连接对象个数</td>
<td style="text-align:center">支持一对一，一对多，多对一和多对多交互通信</td>
<td style="text-align:center">只能是一对一通信</td>
</tr>
<tr>
<td style="text-align:center">传输方式</td>
<td style="text-align:center">面向报文</td>
<td style="text-align:center">面向字节流</td>
</tr>
<tr>
<td style="text-align:center">首部开销</td>
<td style="text-align:center">首部开销小，仅8字节</td>
<td style="text-align:center">首部最小20字节，最大60字节</td>
</tr>
<tr>
<td style="text-align:center">适用场景</td>
<td style="text-align:center">适用于实时应用（IP电话、视频会议、直播等）</td>
<td style="text-align:center">适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者消费者问题</title>
    <url>/article/19877.html</url>
    <content><![CDATA[<blockquote>
<p>The world puts off its mask of vastness to its lover.</p>
<p>世界对着它的爱人，把它浩翰的面具揭下了。　　</p>
<p>It becomes small as one song, as one kiss of the eternal.</p>
<p>它变小了，小如一首歌，小如一回永恒的接吻。　　　　　　　　　　　</p>
</blockquote>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
<p>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。</p>
<p><strong>该问题需要注意的几点：</strong></p>
<ul>
<li>在缓冲区为空时，消费者不能再进行消费</li>
<li>在缓冲区为满时，生产者不能再进行生产</li>
<li>在一个线程进行生产或消费时，其余线程不能再进行生产或消费等操作，即保持线程间的同步</li>
<li>注意条件变量与互斥锁的顺序</li>
</ul>
<p>由于前两点原因，因此需要保持线程间的同步，即一个线程消费（或生产）完，其他线程才能进行竞争CPU，获得消费（或生产）的机会。对于这一点，可以使用条件变量进行线程间的同步：生产者线程在product之前，需要wait直至获取自己所需的信号量之后，才会进行product的操作；同样，对于消费者线程，在consume之前需要wait直到没有线程在访问共享区（缓冲区），再进行consume的操作，之后再解锁并唤醒其他可用阻塞线程。<br>在访问共享区资源时，为避免多个线程同时访问资源造成混乱，需要对共享资源加锁，从而保证某一时刻只有一个线程在访问共享资源。</p>
<h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试：生产者消费者模型---&gt;利用缓冲区解决：管程法</span><br><span class="hljs-comment">//生产者，消费者，产品，缓冲区</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPC</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		SynContainer container = <span class="hljs-keyword">new</span> SynContainer();<br>		<span class="hljs-keyword">new</span> Productor(container).start();<br>		<span class="hljs-keyword">new</span> Consumer(container).start();<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//生产者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Productor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>	SynContainer container;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Productor</span><span class="hljs-params">(SynContainer container)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.container = container;<br>	&#125;<br><br>	<span class="hljs-comment">// 生产</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>			container.push(<span class="hljs-keyword">new</span> Chicken(i));<br>			System.out.println(<span class="hljs-string">&quot;生产了&quot;</span> + i + <span class="hljs-string">&quot;只鸡&quot;</span>);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//消费者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>	SynContainer container;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(SynContainer container)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.container = container;<br>	&#125;<br><br>	<span class="hljs-comment">// 消费</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>			System.out.println(<span class="hljs-string">&quot;消费了--&gt;&quot;</span> + container.pop().id + <span class="hljs-string">&quot;只鸡&quot;</span>);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chicken</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> id;<span class="hljs-comment">// 产品编号</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chicken</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.id = id;<br>	&#125;<br><br>&#125;<br><br><span class="hljs-comment">//缓冲区</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynContainer</span> </span>&#123;<br><br>	<span class="hljs-comment">// 需要一个容器大小</span><br>	Chicken[] chickens = <span class="hljs-keyword">new</span> Chicken[<span class="hljs-number">10</span>];<br>	<span class="hljs-comment">// 容器计数器</span><br>	<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">// 生产者放入产品</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Chicken chicken)</span> </span>&#123;<br>		<span class="hljs-comment">// 如果容器满了，就需要等待消费者消费</span><br>		<span class="hljs-keyword">if</span> (count == chickens.length) &#123;<br>			<span class="hljs-comment">// 通知消费者消费，生产者等待</span><br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-keyword">this</span>.wait();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				<span class="hljs-comment">// TODO Auto-generated catch block</span><br>				e.printStackTrace();<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">// 如果没有满，我们就放入产品</span><br>		chickens[count] = chicken;<br>		count++;<br>		<span class="hljs-comment">//通知消费者消费了</span><br>		<span class="hljs-keyword">this</span>.notifyAll();<br>	&#125;<br><br>	<span class="hljs-comment">// 消费者消费产品</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Chicken <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 判断是否能消费</span><br>		<span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">// 等待生产者生产，消费者等待</span><br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-keyword">this</span>.wait();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				<span class="hljs-comment">// TODO Auto-generated catch block</span><br>				e.printStackTrace();<br>			&#125;<br><br>		&#125; <span class="hljs-comment">// 如果可以消费</span><br>		count--;<br>		Chicken chicken = chickens[count];<br>		<span class="hljs-comment">// 吃完了，通知生产者生产</span><br>		<span class="hljs-keyword">this</span>.notifyAll();<br>		<span class="hljs-keyword">return</span> chicken;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h3><p>通过标志位解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.Thread;<br><span class="hljs-comment">//解决生产者消费者问题方法2：信号灯法</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPC2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TV tv =<span class="hljs-keyword">new</span> TV();<br>        <span class="hljs-keyword">new</span> Player(tv).start();<br>        <span class="hljs-keyword">new</span> Watcher(tv).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//生产者：演员</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    TV tv;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Player</span><span class="hljs-params">(TV tv)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tv = tv;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">this</span>.tv.play(<span class="hljs-string">&quot;快乐大本营&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">this</span>.tv.play(<span class="hljs-string">&quot;斗鱼&quot;</span>);<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//消费者：观众</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    TV tv;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Watcher</span><span class="hljs-params">(TV tv)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tv = tv;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            tv.watch();<br><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//产品：电视节目</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TV</span></span>&#123;<br>    <span class="hljs-comment">//演员表演，观众等待 T</span><br>    <span class="hljs-comment">//观众观看，演员等待 F</span><br>    String voice;<br>    <span class="hljs-keyword">boolean</span> flag =<span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String voice)</span></span>&#123;<br>        <span class="hljs-comment">//观众观看，演员等待</span><br>        <span class="hljs-keyword">if</span> (!flag)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//若观众没看，演员表演</span><br>        System.out.println(<span class="hljs-string">&quot;演员表演了&quot;</span>+voice);<br>        <span class="hljs-comment">//通知观众看</span><br>        <span class="hljs-keyword">this</span>.notifyAll();<br>        <span class="hljs-keyword">this</span>.voice=voice;<br>        <span class="hljs-keyword">this</span>.flag=!<span class="hljs-keyword">this</span>.flag;<br><br>    &#125;<br>    <span class="hljs-comment">//观看方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">watch</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//演员表演观众等待</span><br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;观看了：&quot;</span>+voice);<br>        <span class="hljs-comment">//通知演员表演</span><br>        <span class="hljs-keyword">this</span>.notifyAll();<br>        <span class="hljs-keyword">this</span>.flag=!<span class="hljs-keyword">this</span>.flag;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
        <category>多线程</category>
        <category>生产者消费者问题</category>
      </categories>
      <tags>
        <tag>Java,多线程,操作系统,生产者消费者问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java函数式接口</title>
    <url>/article/49002.html</url>
    <content><![CDATA[<blockquote>
<p> The world rushes on over the strings of the lingering heart making  the music of sadness. </p>
<p>世界在踌躇之心的琴弦上跑过去，奏出忧郁的乐声。 </p>
</blockquote>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>
<p>函数式接口可以被隐式转换为<a href="/article/4774.html" title="Java-Lambda表达式">Java-Lambda表达式</a>。</p>
<p>Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。</p>
<p>如定义了一个函数式接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingService</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayMessage</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么就可以使用<a href="/article/4774.html" title="Java-Lambda表达式">Java-Lambda表达式</a>来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">GreetingService greetService1 = message -&gt; System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);<br></code></pre></td></tr></table></figure>
<p><strong>函数式接口实例</strong></p>
<p>Predicate <T> 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。</T></p>
<p>该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。</p>
<p>该接口用于测试对象是 true 或 false。</p>
<p>我们可以通过以下实例（Java8Tester.java）来了解函数式接口 Predicate <T> 的使用：</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Java8Tester</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>        <br>      <span class="hljs-comment">// Predicate&lt;Integer&gt; predicate = n -&gt; true</span><br>      <span class="hljs-comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span><br>      <span class="hljs-comment">// n 如果存在则 test 方法返回 true</span><br>        <br>      System.out.println(<span class="hljs-string">&quot;输出所有数据:&quot;</span>);<br>        <br>      <span class="hljs-comment">// 传递参数 n</span><br>      eval(list, n-&gt;<span class="hljs-keyword">true</span>);<br>        <br>      <span class="hljs-comment">// Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0</span><br>      <span class="hljs-comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span><br>      <span class="hljs-comment">// 如果 n%2 为 0 test 方法返回 true</span><br>        <br>      System.out.println(<span class="hljs-string">&quot;输出所有偶数:&quot;</span>);<br>      eval(list, n-&gt; n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> );<br>        <br>      <span class="hljs-comment">// Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3</span><br>      <span class="hljs-comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span><br>      <span class="hljs-comment">// 如果 n 大于 3 test 方法返回 true</span><br>        <br>      System.out.println(<span class="hljs-string">&quot;输出大于 3 的所有数字:&quot;</span>);<br>      eval(list, n-&gt; n &gt; <span class="hljs-number">3</span> );<br>   &#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;<br>      <span class="hljs-keyword">for</span>(Integer n: list) &#123;<br>        <br>         <span class="hljs-keyword">if</span>(predicate.test(n)) &#123;<br>            System.out.println(n + <span class="hljs-string">&quot; &quot;</span>);<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$ javac Java8Tester.java </span><br><span class="hljs-comment">$ java Java8Tester</span><br><span class="hljs-comment">输出所有数据:</span><br><span class="hljs-comment">1 </span><br><span class="hljs-comment">2 </span><br><span class="hljs-comment">3 </span><br><span class="hljs-comment">4 </span><br><span class="hljs-comment">5 </span><br><span class="hljs-comment">6 </span><br><span class="hljs-comment">7 </span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment">9 </span><br><span class="hljs-comment">输出所有偶数:</span><br><span class="hljs-comment">2 </span><br><span class="hljs-comment">4 </span><br><span class="hljs-comment">6 </span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment">输出大于 3 的所有数字:</span><br><span class="hljs-comment">4 </span><br><span class="hljs-comment">5 </span><br><span class="hljs-comment">6 </span><br><span class="hljs-comment">7 </span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment">9 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>函数式接口</category>
      </categories>
      <tags>
        <tag>Java,函数式接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Lambda表达式</title>
    <url>/article/4774.html</url>
    <content><![CDATA[<blockquote>
<p>You smiled and talked to me of nothing and I felt that for this  I had been waiting long. </p>
<p>你微微地笑着，不同我说什么话。而我觉得，为了这个，我已等待得久了。  </p>
</blockquote>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>理解Functional Interface（<a href="/article/49002.html" title="函数式接口">函数式接口</a>）是学习Java8 Lambda表达式的关键所在。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<p>使用 Lambda 表达式可以</p>
<ul>
<li>使代码变的更加简洁紧凑。</li>
<li>避免匿名内部类定义过多</li>
<li>只有核心逻辑，没有无用代码</li>
</ul>
<p><strong>语法</strong></p>
<p>lambda 表达式的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">(parameters) -&gt; expression<br><span class="hljs-comment">//或</span><br>(parameters) -&gt;&#123; statements; &#125;<br></code></pre></td></tr></table></figure>
<p>以下是lambda表达式的重要特征:</p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值；</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号；</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号；</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 不需要参数,返回值为 5  </span><br>() -&gt; <span class="hljs-number">5</span>  <br><span class="hljs-comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span><br>x -&gt; <span class="hljs-number">2</span> * x  <br><span class="hljs-comment">// 3. 接受2个参数(数字),并返回他们的差值  </span><br>(x, y) -&gt; x – y  <br><span class="hljs-comment">// 4. 接收2个int型整数,返回他们的和  </span><br>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) -&gt; x + y  <br><span class="hljs-comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span><br>(String s) -&gt; System.out.print(s)<br></code></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Java8Tester</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>      Java8Tester tester = <span class="hljs-keyword">new</span> Java8Tester();<br>        <br>      <span class="hljs-comment">// 类型声明</span><br>      MathOperation addition = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; a + b;<br>        <br>      <span class="hljs-comment">// 不用类型声明</span><br>      MathOperation subtraction = (a, b) -&gt; a - b;<br>        <br>      <span class="hljs-comment">// 大括号中的返回语句</span><br>      MathOperation multiplication = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; &#123; <span class="hljs-keyword">return</span> a * b; &#125;;<br>        <br>      <span class="hljs-comment">// 没有大括号及返回语句</span><br>      MathOperation division = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; a / b;<br>        <br>      System.out.println(<span class="hljs-string">&quot;10 + 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, addition));<br>      System.out.println(<span class="hljs-string">&quot;10 - 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, subtraction));<br>      System.out.println(<span class="hljs-string">&quot;10 x 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, multiplication));<br>      System.out.println(<span class="hljs-string">&quot;10 / 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, division));<br>        <br>      <span class="hljs-comment">// 不用括号</span><br>      GreetingService greetService1 = message -&gt;<br>      System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);<br>        <br>      <span class="hljs-comment">// 用括号</span><br>      GreetingService greetService2 = (message) -&gt;<br>      System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);<br>        <br>      greetService1.sayMessage(<span class="hljs-string">&quot;Bobo&quot;</span>);<br>      greetService2.sayMessage(<span class="hljs-string">&quot;Google&quot;</span>);<br>   &#125;<br>    <br>   <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MathOperation</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br>   &#125;<br>    <span class="hljs-comment">//定义一个函数式接口</span><br>   <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingService</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayMessage</span><span class="hljs-params">(String message)</span></span>;<br>   &#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">operate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, MathOperation mathOperation)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> mathOperation.operation(a, b);<br>   &#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">$ javac Java8Tester.java </span><br><span class="hljs-comment">$ java Java8Tester</span><br><span class="hljs-comment">10 + 5 = 15</span><br><span class="hljs-comment">10 - 5 = 5</span><br><span class="hljs-comment">10 x 5 = 50</span><br><span class="hljs-comment">10 / 5 = 2</span><br><span class="hljs-comment">Hello Bobo</span><br><span class="hljs-comment">Hello Google</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</li>
<li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Java8Tester</span> </span>&#123;<br> <br>   <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String salutation = <span class="hljs-string">&quot;Hello! &quot;</span>;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>      GreetingService greetService1 = message -&gt; <br>      System.out.println(salutation + message);<br>      greetService1.sayMessage(<span class="hljs-string">&quot;Bobo&quot;</span>);<br>   &#125;<br>    <br>   <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingService</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayMessage</span><span class="hljs-params">(String message)</span></span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">$ javac Java8Tester.java </span><br><span class="hljs-comment">$ java Java8Tester</span><br><span class="hljs-comment">Hello! Bobo</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>我们也可以直接在 lambda 表达式中访问外层的局部变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Java8Tester</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>        Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));<br>        s.convert(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 输出结果为 3</span><br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt; </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <br>Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));<br>s.convert(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//不可以在后面篡改 num</span><br>num = <span class="hljs-number">5</span>;  <br><span class="hljs-comment">//报错信息：Local variable num defined in an enclosing scope must be final or effectively </span><br> <span class="hljs-keyword">final</span><br></code></pre></td></tr></table></figure>
<ul>
<li>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String first = <span class="hljs-string">&quot;&quot;</span>;  <br>Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  <span class="hljs-comment">//编译会出错</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Lambda表达式</category>
      </categories>
      <tags>
        <tag>Java,Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理模式</title>
    <url>/article/21345.html</url>
    <content><![CDATA[<blockquote>
<p>The trees, like the longings of the earth, stand atiptoe to peep  at the heaven.  </p>
<p>群树如表示大地的愿望似的，踮起脚来向天空窥望。</p>
</blockquote>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假设现在有一个人（person接口），他的名字叫A（class A implement person），小A 40岁了必须要找对象，但是呢自己比较害羞不好意思开口，这样就需要一个媒婆来帮他找对象（MeiPo 代理类），至此就是静态代理模式，下面我们用代理来实现下：</p>
<p><code>Class Person</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findLove</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Class A</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findLove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//个人条件</span><br>		System.out.println(<span class="hljs-string">&quot;高富帅&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;有房有车的&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Class Meipo</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meipo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> XiaoA xiaoA;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Meipo2</span><span class="hljs-params">(XiaoA xa)</span> </span>&#123;<br>		<span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>		<span class="hljs-keyword">this</span>.xiaoA = xa;<br>	&#125;<br>	<br>	 <span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findLove</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		System.out.println(<span class="hljs-string">&quot;我是媒婆，要帮小A找对象，小A的条件为：&quot;</span>);<br>		xiaoA.findLove();<br>		System.out.println(<span class="hljs-string">&quot;寻找中...&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;寻找到仙女一枚！&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Main</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFindLove</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Meipo2 meipo2 = <span class="hljs-keyword">new</span> Meipo2(<span class="hljs-keyword">new</span> XiaoA());<br>		meipo2.findLove();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/21345/20190508103432666.png" class title="img">
<p> 静态代理模式总结 </p>
<ul>
<li>真实对象和代理对象都要实现同一接口 </li>
<li>代理对象要代理真实角色 </li>
</ul>
<p>好处：</p>
<ol>
<li>代理对象可以做很多真实对象做不了的事情 、</li>
<li>真实对象可以专注做自己的事情</li>
</ol>
<p>缺点：</p>
<p>一个真实角色会产生一个代理角色</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="实现代理对象的步骤"><a href="#实现代理对象的步骤" class="headerlink" title="实现代理对象的步骤"></a>实现代理对象的步骤</h3><ol>
<li>创建接口，定义目标类要完成的功能</li>
<li>创建目标类，实现接口</li>
<li>创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能<ol>
<li>调用目标方法</li>
<li>增强功能</li>
</ol>
</li>
<li>使用Proxy类的静态方法，创建代理对象，并把返回值转为接口类型</li>
</ol>
<ul>
<li>动态代理角色和静态代理角色一样</li>
<li>动态代理的代理类时动态生成的，不是我们直接写好的</li>
<li>分为两类<ul>
<li>基于接口的动态的代理：<strong>基于JDK的动态代理</strong></li>
<li>基于类的动态代理：cglib</li>
<li>java字节码实现：javasist</li>
</ul>
</li>
</ul>
<p><strong>基于JDK的动态代理</strong></p>
<p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合</p>
<ol>
<li>Proxy：代理</li>
<li>InvocationHandler：调用处理程序</li>
</ol>
<p><strong>例</strong></p>
<p>上面的静态代理是每来一个人就创建一个媒婆代理他，这样的话工作过于繁琐，这时我们为何我开一个媒婆公司呢？将找对象的人交给媒婆公司，让媒婆公司创建媒婆代理他传宗接代的任务！</p>
<p><code>Class B</code></p>
<p><strong>目标接口的实现类</strong>，也就是接下来的目标类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findLove</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;矮穷矬&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;屌丝一枚&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>findLove</code>目标类中目标方法</p>
<p>媒婆 改为 媒婆公司：<code>Class MeipoCompany</code></p>
<p><strong>代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MeipoCompany</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> Person target; <span class="hljs-comment">//被代理对象的引用作为一个成员变量保存下来了</span><br>  <span class="hljs-comment">//传入对象</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.target = target;<br>  &#125;<br>  <br>	<span class="hljs-comment">//获取被代理人的个人资料</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getInstance</span><span class="hljs-params">(Person target)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>		<span class="hljs-keyword">this</span>.target = target;<br>		Class clazz = target.getClass();<br>		System.out.println(<span class="hljs-string">&quot;被代理对象的class是:&quot;</span>+clazz);<br>		<span class="hljs-keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), <span class="hljs-keyword">this</span>);<br>	&#125;<br>	<br> <br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>		<br>		System.out.println(<span class="hljs-string">&quot;我是媒婆公司：&quot;</span> + <span class="hljs-string">&quot;得给你找个异性才行&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;说下你的条件：&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>		<span class="hljs-comment">//反射调用方法</span><br>		method.invoke(target, args);<br>		System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;开始进行海选...&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;找到啦&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>在invoke()方法中，我们没有创建对象，所以，我们使用<code>method.invoke</code></strong></p>
<p>两个参数：</p>
<ol>
<li>对象，这个对象是动态的，不是固定的，所以我们需要传入进来，可以通过调用该类的构造方法<code>setTarget()</code>进行传入</li>
<li>参数，调用方法的参数，即args</li>
</ol>
<p><code>Main</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFindLove</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br> 			Person handler = (Person)<span class="hljs-keyword">new</span> MeipoCompany().getInstance(<span class="hljs-keyword">new</span> XiaoA());<br> 			System.out.println(<span class="hljs-string">&quot;代理类：&quot;</span>+A.getClass());<br> 			handler.findLove();<br>      System.out.println(<span class="hljs-string">&quot;************************&quot;</span>);<br>      <span class="hljs-comment">//1. 创建目标对象</span><br>      Person B = <span class="hljs-keyword">new</span> XiaoB();<br>      <span class="hljs-comment">//2. 创建 InvocationHandler 对象</span><br>      InvocationHandler handler1 = <span class="hljs-keyword">new</span> MeipoCompany(B);<br>      <span class="hljs-comment">//3.创建代理对象</span><br>      Person proxy = (Person)Proxy.newProxyInstance(B.getClassLoader(), B.getInterfaces(), handler1)<br> 			System.out.println(<span class="hljs-string">&quot;代理类：&quot;</span>+B.getClass());<br>      <span class="hljs-comment">//4.通过代理执行方法</span><br> 			B.findLove();<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 创建目标对象</span><br>Person B = <span class="hljs-keyword">new</span> XiaoB();<br><span class="hljs-comment">//2. 创建 InvocationHandler 对象</span><br>InvocationHandler handler1 = <span class="hljs-keyword">new</span> MeipoCompany(B);<br><span class="hljs-comment">//3.创建代理对象</span><br>Person proxy = hander.getInstance(handler);<br>Person proxy = (Person)Proxy.newProxyInstance(B.getClassLoader(), B.getInterfaces(), handler1)<br>System.out.println(<span class="hljs-string">&quot;代理类：&quot;</span>+B.getClass());<br><span class="hljs-comment">//4.通过代理执行方法</span><br>proxy.findLove();<br></code></pre></td></tr></table></figure>
<p>这段代码中不需要<code>MeipoCompany</code>中有<code>getInstance</code>方法，直接在main类中实现，等价于A的动态代理</p>
</blockquote>
<p>这里调用方法时，就会自动跳转到invoke方法，将方法名与参数传递给invoke中的method.invoke方法</p>
<h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><p><strong>实现InvocationHandler，重写invoke方法</strong></p>
<p>处理代理实例，并且返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;	<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong><code>invoke</code>表示代理对象要执行的功能代码，代理类要完成的功能就写在invoke中。</strong></p>
<ol>
<li><p><strong>调用目标方法，执行目标方法的功能</strong></p>
</li>
<li><p><strong>功能增强，在目标方法调用时，增加功能</strong></p>
</li>
<li><p><strong>参数</strong></p>
<blockquote>
<ol>
<li><p>Object proxy</p>
<p>jdk创建的代理对象，无需赋值</p>
</li>
<li><p>Method method</p>
<p>目标类中的方法，jdk提供，无需赋值</p>
</li>
<li><p>Object[] args</p>
<p>目标类中方法的参数，jdk提供，无需赋值</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<hr>
<p><code>Method类</code>：表示方法的类，确切的说就目标类中的方法</p>
<p><strong>作用</strong>：通过Method可以执行某个目标类的方法，<code>method.invoke()</code></p>
<p>method.invoke(目标对象，方法的参数)</p>
<h3 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h3><p>核心对象，创建代理对象</p>
<p>之前的创建对象都是new类的构造方法，现在我们是使用Proxy类的对象，代替new的使用.</p>
<p>静态方法<code>newProxyInstance</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      InvocationHandler h)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>作用：创建代理对象，等同于静态代理中的new</strong></p>
<p><strong>参数</strong></p>
<blockquote>
<ol>
<li><p>ClassLoader loader</p>
<p>类加载器，负责向内存中加载对象，使用反射获取对象的ClassLoader</p>
<p><strong>是目标对象的类加载器</strong></p>
</li>
<li><p>Class&lt;?&gt;[] interfaces</p>
<p>是接口，目标对象所实现的接口，也是反射获取的</p>
</li>
<li><p>InvocationHandler h</p>
<p>是我们自己写的，代理类要完成的功能</p>
</li>
</ol>
</blockquote>
<p><strong>返回值</strong>：就是目标对象的代理对象</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>代理模式</category>
      </categories>
      <tags>
        <tag>Java,代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/article/58846.html</url>
    <content><![CDATA[<blockquote>
<p>  I cannot tell why this heart languishes in silence.</p>
<p>我说不出这心为什么那样默默地颓丧着。   </p>
<p> It is for small needs it never asks, or knows or remembers.  </p>
<p>是为了它那不曾要求，不曾知道，不曾记得的小小的需要。</p>
</blockquote>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<img src="/article/58846/1629488-20190622115300479-2129397443.png" class title="进程">
<h2 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h2><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p>
<img src="/article/58846/java-thread.jpg" class title="java-thread">
<p><strong>线程五大状态</strong></p>
<ul>
<li><p>新建状态:</p>
<p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
</li>
<li><p>就绪状态:</p>
<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
</li>
<li><p>运行状态:</p>
<p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</li>
<li><p>阻塞状态:</p>
<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： </p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
</li>
<li><p>死亡状态: </p>
<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态，<strong>无法再起启动</strong>。</p>
</li>
</ul>
<img src="/article/58846/2.png" class title="img">
<h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><ul>
<li>线程就是独立的执行路径；</li>
<li>在程序运行时，即使没有自己创建线程，后台也会有很多个线程；</li>
<li><code>main()</code>称之为主线程，为系统的入口，用于执行整个程序；</li>
<li>在一个进程中，如果开辟了多个线程，线程的运行是由调度器安排调度，调度器与操作系统是紧密相关的，先后顺序是不能人为干预的；</li>
<li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；</li>
<li>线程会带来额外的开销；</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。</li>
</ul>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>Java 提供了三种创建线程的方法：</p>
<ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<p><strong>通过继承Thread来创建线程</strong></p>
<p>创建一个线程的第一种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。</p>
<p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。</p>
<p>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.demo01;<br><span class="hljs-comment">//创建线程方式一：继承Thread类，重写run()方法，调用star开启线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在看代码---&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建一个线程对象</span><br>        TestThread1 testThread1 = <span class="hljs-keyword">new</span> TestThread1();<br>        <span class="hljs-comment">//调用start方法,开启线程</span><br>        testThread1.start();<br>        <span class="hljs-comment">//main线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程---&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">截取部分输出结果：</span><br><span class="hljs-comment">我在学习多线程---49</span><br><span class="hljs-comment">我在看代码---71</span><br><span class="hljs-comment">我在看代码---72</span><br><span class="hljs-comment">我在学习多线程---50</span><br><span class="hljs-comment">我在看代码---73</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>序号</strong></th>
<th style="text-align:center"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center"><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center"><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center"><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:center"><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:center"><strong>public void interrupt()</strong> 中断线程。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:center"><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td>
</tr>
</tbody>
</table>
<p>上述方法是被 Thread 对象调用的，下面表格的方法是 Thread 类的静态方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>序号</strong></th>
<th style="text-align:center"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center"><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center"><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center"><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td>
</tr>
</tbody>
</table>
<p><strong>线程停止：</strong>（stop）</p>
<ul>
<li>不推荐JDK提供的stop()\destory()方法；</li>
<li>建议使用表示为进行终止变量。</li>
</ul>
<p><strong>线程休眠：</strong>(sleep)</p>
<ul>
<li>sleep（时间）指定当前线程阻塞的毫秒数；</li>
<li>sleep存在异常 InterruptedException；</li>
<li>sleep时间达到后线程进入就绪状态；</li>
<li>色了可以模拟网络延时，倒计时等；</li>
<li>每一个对象都有一个锁，sleep不会释放锁。</li>
</ul>
<p><strong>线程礼让：</strong>(yield)</p>
<ul>
<li>让当前正在执行的线程暂停，但不阻塞；</li>
<li>让线程从运行状态转为就绪状态；</li>
<li>让CPU重新调度。礼让不一定成功。</li>
</ul>
<p><strong>线程强制执行：</strong>(join)</p>
<ul>
<li>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</li>
</ul>
<p><strong>线程优先级：</strong> </p>
<ul>
<li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行；</li>
<li>线程优先级用数字表示，范围1～10；</li>
<li>使用<code>getPriority()</code> <code>setPriority(int xxx)</code>改变或获取优先级；</li>
<li><strong>优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看cpu的调度。</strong></li>
</ul>
<p><strong>守护（daemon）线程</strong></p>
<ul>
<li>线程分为<strong>用户线程</strong>和<strong>守护线程；</strong></li>
<li>虚拟机必须确保用户线程（比如main）执行完毕；</li>
<li>虚拟机不用等待守护线程（比如gcc）执行完毕。</li>
</ul>
<p><strong>通过实现 Runnable 接口来创建线程</strong></p>
<p>创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。</p>
<p>为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：<code>public void run()</code></p>
<p>在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.demo01;<br><span class="hljs-comment">//创建线程方式二 实现runnable接口 重写run方法，执行线程需要丢入runnable接口实现类，调用start方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在看代码---&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建runnable接口的实现对象</span><br>        TestThread3 testThread3 = <span class="hljs-keyword">new</span> TestThread3();<br>        <span class="hljs-comment">//创建线程对象，通过线程对象来开启线程</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(testThread3);<br>        thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程---&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">截取部分输出结果：</span><br><span class="hljs-comment">我在看代码---122</span><br><span class="hljs-comment">我在学习多线程---189</span><br><span class="hljs-comment">我在看代码---123</span><br><span class="hljs-comment">我在学习多线程---190</span><br><span class="hljs-comment">我在看代码---124</span><br><span class="hljs-comment">我在学习多线程---191</span><br><span class="hljs-comment">我在看代码---125</span><br><span class="hljs-comment">我在看代码---126</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>通过 Callable 和 Future 创建线程</strong></p>
<ul>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableThreadTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        CallableThreadTest ctt = <span class="hljs-keyword">new</span> CallableThreadTest();  <br>        FutureTask&lt;Integer&gt; ft = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(ctt);  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">100</span>;i++)  <br>        &#123;  <br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 的循环变量i的值&quot;</span>+i);  <br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">20</span>)  <br>            &#123;  <br>                <span class="hljs-keyword">new</span> Thread(ft,<span class="hljs-string">&quot;有返回值的线程&quot;</span>).start();  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">try</span>  <br>        &#123;  <br>            System.out.println(<span class="hljs-string">&quot;子线程的返回值：&quot;</span>+ft.get());  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)  <br>        &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e)  <br>        &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>  <br>    &#125;<br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception  </span><br><span class="hljs-function">    </span>&#123;  <br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">100</span>;i++)  <br>        &#123;  <br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> i;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><a href="/article/21345.html" title="点击跳转静态代理">点击跳转静态代理</a>
<p>静态代理即线程底部实现原理</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>多个线程操作同一个资源</p>
<p><strong>锁机制</strong></p>
<p>由于同一进程的多个线程共享同一快存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问的正确性，在访问时加入锁机制(synchronized)，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起；</li>
<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题；</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。</li>
</ul>
<p>synchronized有两种用法，synchronized方法与synchronized块。</p>
<p><strong>synchronized方法</strong></p>
<p>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的进程才能获得这个锁，继续执行。</p>
<p>有一个<strong>缺陷：</strong>若将一个大的方法声明为synchronized将会影响效率</p>
<ul>
<li>方法里面需要修改的内容才需要锁，锁的太多，浪费资源</li>
</ul>
<p><strong>synchronized同步块</strong></p>
<p><code>synchronized(obj)&#123;&#125;</code></p>
<p>obj称为<strong>同步监视器</strong></p>
<ul>
<li>obj可以是任何对象，但是推荐使用共享资源作为同步监视器；</li>
<li>同步方法中无需指定同步监视器，因为同步方法中的同步监视器就是 this，就是这个对象本身</li>
<li>同步监视器的执行过程<ol>
<li>第一个线程访问，锁定同步监视器，执行其中代码；</li>
<li>第二个线程访问，发现同步监视器被锁定，无法访问；</li>
<li>第一个线程访问完毕，解锁同步监视器；</li>
<li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问。</li>
</ol>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p>死锁的规范定义：</p>
<blockquote>
<p> 集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。</p>
</blockquote>
<p>死锁的发生必须具备以下四个必要条件:</p>
<p><strong>1）互斥条件：</strong>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p>
<p><strong>2）请求和保持条件：</strong>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
<p><strong>3）不剥夺条件：</strong>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>
<p><strong>4）环路等待条件：</strong>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>从JDK 5.0之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock，通过显示定义同步锁对象来实现同步，同步锁使用Lock对象充当。</p>
<p>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应该先获得Lock对象。</p>
<p>ReentrantLock 类实现了Lock，拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Lock lock = ...;<br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//处理任务</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br>     <br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    lock.unlock();   <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>synchronized与Lock对比：</p>
<ul>
<li>Lock是显式锁（手动开启和关闭锁），synchronized是隐式锁，除了作用域自动释放；</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁；</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多的子类）；</li>
<li>优先使用顺序：<ul>
<li>Lock &gt; 同步代码块（已经进入了方法题，分配了相应资源）&gt; 同步方法（在方法体之外）</li>
</ul>
</li>
</ul>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>Java提供了几个方法解决线程之间的通信问题</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait()</td>
<td>表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</td>
</tr>
<tr>
<td>wait(long timeout)</td>
<td>指定等待的毫秒数</td>
</tr>
<tr>
<td>notify()</td>
<td>唤醒一个处于等待状态的线程</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td>
</tr>
</tbody>
</table>
<p>均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IIIegalMonitorStateException</p>
<h2 id="线程实例"><a href="#线程实例" class="headerlink" title="线程实例"></a>线程实例</h2><a href="/article/19877.html" title="生产者消费者问题">生产者消费者问题</a>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在一个应用程序中，我们需要多次使用线程，也就意味着，我们需要多次创建并销毁线程。而创建并销毁线程的过程势必会消耗内存。而在Java中，内存资源是及其宝贵的，所以，我们就提出了线程池的概念。</p>
<img src="/article/58846/937.png" class title="img">
<p><strong>线程池</strong></p>
<p>Java中开辟出了一种管理线程的概念，这个概念叫做线程池，从概念以及应用场景中，我们可以看出，线程池的好处，就是可以方便的管理线程，也可以减少内存的消耗。</p>
<p><strong>线程池的优势</strong></p>
<ol>
<li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li>
<li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</li>
<li>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。</li>
<li>提供更强大的功能，延时定时线程池。</li>
</ol>
<p><strong>线程池的主要参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>1、corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</p>
<p>2、maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</p>
<p>3、keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</p>
<p>4、workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。</p>
<p>5、threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</p>
<p>5、handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。</p>
</blockquote>
<p>假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。</p>
<p>如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。</p>
<p>一个线程池包括以下四个基本组成部分：</p>
<pre><code>1. 线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
1. 工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
1. 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
1. 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。
</code></pre><p>线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</p>
<p>线程池不仅调整T1,T3产生的时间段，而且它还显著减少了创建线程的数目，看一个例子：</p>
<blockquote>
<p>假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为50000。一般线程池大小是远小于50000。所以利用线程池的服务器程序不会为了创建50000而在处理请求时浪费时间，从而提高效率。</p>
</blockquote>
<p><strong>比较重要的几个类</strong></p>
<table>
<thead>
<tr>
<th>ExecutorService</th>
<th>真正的线程池接口。</th>
</tr>
</thead>
<tbody>
<tr>
<td>ScheduledExecutorService</td>
<td>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td>
</tr>
<tr>
<td>ThreadPoolExecutor</td>
<td>ExecutorService的默认实现。</td>
</tr>
<tr>
<td>ScheduledThreadPoolExecutor</td>
<td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td>
</tr>
</tbody>
</table>
<p><strong>java中提供的线程池</strong></p>
<img src="/article/58846/1200.png" class title="img">
<p>1、newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）</p>
<p>2、newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）</p>
<p>3、newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。</p>
<p>4、newScheduledThreadPool：适用于执行延时或者周期性任务。</p>
<p><strong>execute()和submit()方法</strong></p>
<p>1、execute()，执行一个任务，没有返回值。</p>
<p>2、submit()，提交一个线程任务，有返回值。</p>
<p>submit(Callable<T> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。一般使用FutureTask+Callable配合使用（IntentService中有体现）。</T></p>
<p>submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值。<br>submit(Runnable task)则是没有返回值的，就算获取它的返回值也是null。</p>
<p>Future.get方法会使取结果的线程进入阻塞状态，知道线程执行完成之后，唤醒取结果的线程，然后返回结果。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java,多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java引用类型</title>
    <url>/article/40363.html</url>
    <content><![CDATA[<blockquote>
<p>The mystery of creation is like the darkness of night–it is great. </p>
<p>创造的神秘，有如夜间的黑暗－－是伟大的。</p>
<p>Delusions of knowledge are like the fog of the morning. </p>
<p>而知识的幻影却不过如晨间 之雾。 </p>
</blockquote>
<p>java中的4种引用类型，它们从强到弱分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:center">引用类型</th>
<th style="text-align:center">对象是否可引用</th>
<th style="text-align:center">回收时间</th>
<th style="text-align:center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强引用</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">从不回收</td>
<td style="text-align:center">普遍对象的状态</td>
</tr>
<tr>
<td style="text-align:center">软引用</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">内存不足时</td>
<td style="text-align:center">内存敏感的高速缓存</td>
</tr>
<tr>
<td style="text-align:center">弱引用</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">下一次GC</td>
<td style="text-align:center">对象缓存</td>
</tr>
<tr>
<td style="text-align:center">虚引用</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">下一次GC，不影响对象生命周期</td>
<td style="text-align:center">必须和引用队列(ReferenceQueue)一起使用，一般用于追踪垃圾收集器的回收动作。相比对象的finalize方法，虚引用的方式更加灵活和安全。</td>
</tr>
</tbody>
</table>
<h2 id="对象可达性判断"><a href="#对象可达性判断" class="headerlink" title="对象可达性判断"></a>对象可达性判断</h2><p>目前，大多数JVM都是使用可达性分析算法来判断对象的是否可达。可达性分析算法以GC Roots对象作为起始点进行搜索。当一个对象与GC Roots对象没有任何引用链相连时(也即引用有向图中从GC Roots对象到这个对象是不连通的)，则表明该对象是不可用的（不可用的对象不一定被判定为可以回收的对象）。当对象与GC Roots对象有引用链相连时，则需要根据引用链的类型来判断对象是否可达。</p>
<blockquote>
<p>不可用的对象不一定被判定为可以回收的对象：判定对象为”死亡”至少需要经历两次标记的过程。第一次标记：对象可达性分析，如果发现对象没有与GC Roots相连接的引用链，且对象需要执行finalize方法，将会被加入F-Queue队列中。第二次标记：由一个优先级低的Finalizer线程去取F-Queue队列的对象，“尝试执行”对象的finalize方法。<br>JVM会保证触发满足条件的对象的finalize方法，但是并不承诺会等待方法执行结束。finalize方法是对象逃脱死亡命运的最后一次机会。</p>
</blockquote>
<h2 id="GC-Roots对象"><a href="#GC-Roots对象" class="headerlink" title="GC Roots对象"></a>GC Roots对象</h2><p>GC Roots对象包含以下四类：</p>
<ul>
<li>虚拟机栈(栈桢中的本地变量表)中的引用的对象；</li>
<li>方法区中的类静态属性引用的对象；</li>
<li>方法区中的常量引用的对象；</li>
<li>本地方法栈中JNI（Native方法）引用的对象；</li>
</ul>
<h2 id="可达性判断"><a href="#可达性判断" class="headerlink" title="可达性判断"></a>可达性判断</h2><h3 id="可达性状态类型"><a href="#可达性状态类型" class="headerlink" title="可达性状态类型"></a>可达性状态类型</h3><p>Java有5种类型的可达性状态：</p>
<ul>
<li>强可达(Strongly Reachable)：与GC Roots对象之间有强引用相连通，则为强可达的；</li>
<li>软可达(Soft Reachable)：与GC Roots对象之间没有强引用相连通，但有软引用相连通，则为软可达的；</li>
<li>弱可达(Weak Reachable)：与GC Roots对象之间没有强引用或软引用相连通，但有弱引用相连通，则为弱可达的；</li>
<li>虚可达(Phantom Reachable)：与GC Roots对象之间没有强引用、软引用或弱引用相连通，然后该对象finalize方法已执行，并且有虚引用相连通，则为虚可达的；</li>
<li>不可达(Unreachable)：如果对象finalize方法已执行并且没有任何引用相连通，则对象是不可达的，可以被回收。</li>
</ul>
<h3 id="可达性判断规则"><a href="#可达性判断规则" class="headerlink" title="可达性判断规则"></a>可达性判断规则</h3><p>从GC Roots对象到一个对象的引用链可能存在多条，那么此时会依据两个原则来判断对象的可达性：</p>
<ul>
<li>单个引用链中，以最弱的引用类型为准；</li>
<li>多引用链联合看时，以最强的引用类型为准；</li>
</ul>
<img src="/article/40363/%E5%8F%AF%E8%BE%BE%E6%80%A7%E8%A7%84%E5%88%99%E5%88%A4%E6%96%AD.jpeg" class title="可达性判断">
<p>首先，单个引用链中，以最弱的引用类型为准：则GC Roots-&gt;Obj1-&gt;Obj4是软引用连通的，GC Roots-&gt;Obj2-&gt;Obj4是弱引用连通的，GC Roots-&gt;Obj3-&gt;Obj5是弱引用连通的。然后多引用链联合看时，以最强的引用类型为准：则GC Roots到Obj4对象的引用联合来看是弱引用连通的。</p>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>对象可达性状态是随着程序运行而不断变化的，对象可达性状态转换图可参考下图。</p>
<ul>
<li>对象创建后一般是强可达的。</li>
<li>当GC Roots对象到该对象的强引用被清除后：如果剩余引用链最高为软引用，则状态转换为软可达的；反之如果最高为弱引用，则状态转换为弱可达的，反之则把对象标记为可执行finalize方法状态。</li>
<li>当软可达对象重新被强引用连接时，则转换为强可达状态；当软可达对象的软引用被清除后，如果剩余引用链最高为弱引用，则状态转换为弱可达；反之则把对象标记为可执行finalize方法状态。</li>
<li>当弱可达对象重新被强引用或者软引用连接时，则可转换为强可达或者软可达；当弱可达对象的弱引用被清除后，则把对象标记为可执行finalize方法状态。</li>
<li>可对象被标记为可执行finalize方法状态，如果对象finalize从未被执行，则执行finalize方法，并标记对象的finalize方法已经被执行（在finalize方法可能会重新生成强/软/弱引用等，对象状态会重新转换为强/软/弱可达，不过并不推荐这么做，因为可能会导致对象状态紊乱，无法被正常回收）；反之当对象有虚引用连接时，则转换为虚可达状态，否则转换为不可达状态。</li>
<li>虚可达对象在垃圾回收后状态转换为不可达（不能通过虚引用获取对象引用，所以对象状态不会再转换为强/软/弱可达）；</li>
</ul>
<img src="/article/40363/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpeg" class title="可达性状态转换图">
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Reference类是所有引用类型的基类，定义了reference对象的通用操作，用来保存对象引用及引用的内部状态。Reference抽象类初始化时，会启动一个ReferenceHandler线程。Reference的referent被回收前，垃圾回收器会把reference添加到pending这个链表里（如果注册了ReferenceQueue），然后ReferenceHandler线程不断的读取pending中的reference，把它加入到对应的ReferenceQueue中（如果Reference是Cleaner类的实例，即虚引用对象，则调用其注册的预处理钩子方法）。</p>
<blockquote>
<p>ReferenceQueue提供了两个静态字段NULL，ENQUEUED。这两个字段的主要功能：NULL是当我们构造Reference实例时queue传入null时，会默认使用NULL，这样在enqueue时判断queue是否为NULL,如果为NULL直接返回，入队失败。ENQUEUED的作用是防止重复入队，reference后会把其queue字段赋值为ENQUEUED,当再次入队时会直接返回失败。</p>
</blockquote>
<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>Reference对象的基类。该类定义了reference对象的通用操作。因为reference对象是和垃圾回收器密切配合实现的，因此该类不能直接进行子类化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>	<span class="hljs-comment">// 用于保存对象的引用，GC会特别对待该变量</span><br>    <span class="hljs-keyword">private</span> T referent; <br>	<span class="hljs-comment">// 如果注册了ReferenceQueue（需要通知机制），用来保存对象引用的队列，</span><br>    <span class="hljs-keyword">volatile</span> ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; queue;<br><br>  <span class="hljs-comment">// 保存需要由ReferenceHandler处理的引用</span><br>    <span class="hljs-keyword">volatile</span> Reference next;<br><br>	<span class="hljs-comment">// 被JVM使用，保存需要被JVM处理的下一个引用</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">private</span> Reference&lt;T&gt; discovered;<br><br>    <span class="hljs-comment">// 同步锁，用于同步pending队列的进队和出队</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Lock lock = <span class="hljs-keyword">new</span> Lock();<br><br>    <span class="hljs-comment">// 一个PENDING队列，配合上述next一起使用，实现类单向循环链表的操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Reference&lt;Object&gt; pending = <span class="hljs-keyword">null</span>;<br><br>	<span class="hljs-comment">// 高优先级线程，用于将pending队列里面的Reference实例依次添加到不同的ReferenceQueue中</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;...&#125;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h2><p>一个对象引用有四种内部状态:</p>
<ul>
<li><p>Active: 新创建的实例的状态，当对象引用被垃圾回收器回收前：如果Reference注册了ReferenceQueue，则会切换为Pending，并且Reference会加入pending链表中，如果没有注册ReferenceQueue，会切换为Inactive。</p>
</li>
<li><p>Pending: 在pending链表中的Reference的状态，这些Reference等待被ReferenceHandler内部线程加入ReferenceQueue中。</p>
</li>
<li><p>Enqueued: 在ReferenceQueue队列中的Reference的状态，如果Reference从队列中移除，会进入Inactive状态。未注册ReferenceQueue的实例不会到达该状态。</p>
</li>
<li><p>Inactive: Reference的最终状态，该状态不会再改变。</p>
</li>
</ul>
<p>  其状态转换图如下：<br>  <img src="/article/40363/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.jpeg" class title="img"></p>
<h2 id="四种引用类型实现"><a href="#四种引用类型实现" class="headerlink" title="四种引用类型实现"></a>四种引用类型实现</h2><img src="/article/40363/%E4%B8%8D%E5%90%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84UML%E7%B1%BB%E5%9B%BE.jpeg" class title="Reference UML类图">
<h3 id="强引用FinalReference"><a href="#强引用FinalReference" class="headerlink" title="强引用FinalReference"></a>强引用FinalReference</h3><p>对象新建后默认为强引用类型的，是普遍对象引用的类型。查看FinalReference在JDK中的源码发现其只有一个空实现，这也说明强引用是“默认引用类型”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Final references, used to implement finalization</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FinalReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(referent, q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a>软引用SoftReference</h3><p>软引用是用来描述一些“还有用但是非必须”的对象。软引用的回收策略在不同的JVM实现会略有不同，JVM不仅仅只会考虑当前内存情况，还会考虑软引用所指向的referent最近的使用情况和创建时间来综合决定是否回收该referent。软引用保存了两个变量：</p>
<ul>
<li>timestamp：每次调用get方法都会更新时间戳。JVM可以利用该字段来选择要清除的软引用，但不是必须要这样做。</li>
<li>clock：时间锁，由垃圾收集器更新。    </li>
</ul>
<p>因此，任何GC都可以使用这些字段并定义清除软引用的策略，例如：最后清除最近创建的或最近使用的软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 软引用对象由垃圾收集器根据内存需要决定是否清除。软引用经常用于实现内存敏感的缓存。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 假如垃圾收集器在某个时间确定对象是软可达的，此时它可以选择原地清除</span><br><span class="hljs-comment"> * 指向该对象的所有软引用，以及从该对象通过强引用链连接的其他软可达对象的所有软引用。</span><br><span class="hljs-comment"> * 与时同时或者之后的某个时间，它会将注册了reference queues的新清除的软引用加入队列。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在虚拟机抛出OutOfMemoryError异常之前，将保证清除对软可达对象的所有软引用。</span><br><span class="hljs-comment"> * 不过，并没有对清除软引用的时间以及清除顺序施加强制约束。</span><br><span class="hljs-comment"> * 但是，鼓励虚拟机实现偏向不清除最近创建或最近使用的软引用。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 该类的直接实例可用于实现简单的缓存。</span><br><span class="hljs-comment"> * 该类或其派生子类也可用于更大的数据结构以实现更复杂的高速缓存。</span><br><span class="hljs-comment"> * 只要软引用的引用对象还是强可达的，即还在实际使用中，软引用就不会被清除。</span><br><span class="hljs-comment"> * 因此，复杂的高速缓存可以通过持有对最近使用缓存对象的强引用来防止其被清除，</span><br><span class="hljs-comment"> * 而不常使用的剩余缓存对象由垃圾收集器决定是否清除。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SoftReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>	<span class="hljs-comment">// 时间锁，由垃圾收集器更新。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> clock;<br><br>	<span class="hljs-comment">// 每次调用get方法都会更新该时间戳。JVM可能会在选择要清除的软引用时使用该字段，</span><br>	<span class="hljs-comment">// 但这不是强制必须的。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timestamp;<br>	<br>	<span class="hljs-comment">// 返回对象的引用。如果该引用对象已经被程序或者垃圾收集器清除，则返回null。</span><br>	<span class="hljs-comment">// 把最近一次垃圾回收时间赋值给timestamp</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        T o = <span class="hljs-keyword">super</span>.get();<br>        <span class="hljs-keyword">if</span> (o != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.timestamp != clock)<br>            <span class="hljs-keyword">this</span>.timestamp = clock;<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="弱引用WeakReference"><a href="#弱引用WeakReference" class="headerlink" title="弱引用WeakReference"></a>弱引用WeakReference</h3><p>当一个对象没有被强引用或者软引用连接，但被弱引用连接时，则处于弱可达状态。只要发生GC，弱可达的对象就会被清除，同时会把弱引用加入到注册的引用队列中(如果存在的话)。弱引用对GC几乎是没有影响的，它不影响对应的referent被终结(finalized)和回收(reclaimed)。因此，弱引用最常用于实现规范化映射(canonicalizing mappings)，例如哈希表，如果它们在程序中未被引用，则其键和值将从映射中删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 弱引用对象不能阻止自身的引用被回收。</span><br><span class="hljs-comment"> * 弱引用常用于实现规范化映射(对象实例可以在程序的多个地方同时使用)。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 假如垃圾收集器在某个时间点确定对象是弱可达的。那时它将原子地清除对该对象的所有弱引用</span><br><span class="hljs-comment"> * 以及该引用通过强引用或者软引用连接的所有其他弱可达对象的所有弱引用。</span><br><span class="hljs-comment"> * 同时，它将表明前面所指的所有弱可达对象都可以执行finalize方法。</span><br><span class="hljs-comment"> * 与此同时或之后某一个时间，它将注册了reference queues的那些新清除弱引用加入队列。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>	<span class="hljs-comment">// 创建没有注册ReferenceQueue的弱引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeakReference</span><span class="hljs-params">(T referent)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(referent);<br>    &#125;<br><br>	<span class="hljs-comment">// 创建注册了ReferenceQueue的弱引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeakReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(referent, q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="虚引用PhantomReference"><a href="#虚引用PhantomReference" class="headerlink" title="虚引用PhantomReference"></a>虚引用PhantomReference</h3><p>虚引用是所有引用类型中最弱的一种。一个对象是否关联到虚引用，完全不会影响该对象的生命周期，也无法通过虚引用来获取一个对象的实例。为对象设置一个虚引用的唯一目的是：能在此对象被垃圾收集器回收的时候收到一个系统通知，它就是利用ReferenceQueue实现的。当referent被gc回收时，JVM自动把虚引用对象本身加入到ReferenceQueue中，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，可以通过这个来做额外的清理工作。可以用虚引用代替对象finalize方法来实现资源释放，这样更加灵活和安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虚引用对象在被垃圾收集器检查到后加入reference queues队列，否则会被回收。</span><br><span class="hljs-comment"> * 虚引用最常用于实现比Java finalization机制更灵活的安排额外的清理工作。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 如果垃圾收集器在某个时间点确定虚引用对象是虚可达的，那么在那个时间或之后某个时间它会将引用加入reference queues队列。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 为了确保可回收对象保持不变，虚引用的引用无法使用：虚引用对象的get方法始终返回null。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 与软引用和弱引用不同，当虚引用加入reference queues队列后垃圾收集器不会被自动清除。</span><br><span class="hljs-comment"> * 只通过虚引用可达的对象将保持不变，直到所有此类引用都被清除或自已变为不可达。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhantomReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 由于不能通过虚引用访问对象，因此此方法始终返回null。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>  <span class="hljs-comment">// 使用空ReferenceQueue队列创建一个虚引用没有意义：它的get方法总是返回null，</span><br>	<span class="hljs-comment">// 并且由于它没有注册队列，所以也不会被加入队列有任何清理前的预处理操作。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhantomReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(referent, q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>引用类型</category>
      </categories>
      <tags>
        <tag>Java,引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈循环不变量</title>
    <url>/article/41380.html</url>
    <content><![CDATA[<h2 id="循环不变量（loop-invariant）"><a href="#循环不变量（loop-invariant）" class="headerlink" title="循环不变量（loop invariant）"></a>循环不变量（loop invariant）</h2><p>在使用循环的算法里，可以通过循环不变量证明其正确性。</p>
<p>所谓循环不变量是指一种在整个循环过程中保持不变的性质，它必须在以下3种情况下均保持不变，且该性质在循环终止后能证明算法的正确性。</p>
<ol>
<li>初始化（循环初始化后，循环条件测试前）</li>
<li>迭代（第 n 次迭代后，第 n+1 次迭代前）</li>
<li>结束（循环终止即循环条件判断为 false 时）</li>
</ol>
<h3 id="二分法理解循环不变量"><a href="#二分法理解循环不变量" class="headerlink" title="二分法理解循环不变量"></a>二分法理解循环不变量</h3><p>题目：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。<br><br>示例 1:<br>输入: nums = [1,3,5,6], target = 5<br>输出: 2<br><br>示例 2:<br>输入: nums = [1,3,5,6], target = 2<br>输出: 1<br><br>示例 3:<br>输入: nums = [1,3,5,6], target = 7<br>输出: 4<br><br>示例 4:<br>输入: nums = [1,3,5,6], target = 0<br>输出: 0<br><br>示例 5:<br>输入: nums = [1], target = 0<br>输出: 0<br><br>提示:<br>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 为无重复元素的升序排列数组<br>-104 &lt;= target &lt;= 104<br><br>Related Topics<br>数组<br>二分查找<br></code></pre></td></tr></table></figure>
<p>我自己的理解：使用二分法一直盯着right，保持循环不变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>      	<span class="hljs-comment">//定义target在左闭右闭合的区间范围里。</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//由于target在一个闭合区间里，那么left=right的时候式子也成立，当left&gt;right的时候式子不成立，则可以推出，while()循环条件是</span><br>        <span class="hljs-comment">//left&lt;=right（取补集）。注意这里很容易错，一定要注意推到。</span><br>        <span class="hljs-comment">//就是循环不变式满足：如果在循环的每一步，这个式子都是正确的，那么循环结束后，这个式子也正确。</span><br>        <span class="hljs-comment">//此问题中初始化时定义区间为[0,nums.length - 1],那么根据循环不变量原理则在循环的整个过程中这种模式是不变的</span><br>        <span class="hljs-comment">//都是闭区间的模式。我们可以根据此检验代码的正确性。</span><br>        <span class="hljs-comment">//因为left，right是闭合区间，所以left和right是可以取到的</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">int</span> middle = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &gt;nums[middle] )&#123;<br>                <span class="hljs-comment">//如果要找的数比中间值大，说明在区间右边。根据循环不变式，那么当改变left指针的时候，其也是左边闭合的</span><br>                <span class="hljs-comment">//此时left的值应该能被取到，因此left=middle+1</span><br>                left=middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(target &lt; nums[middle] )&#123;<br>                right=middle-<span class="hljs-number">1</span>;<span class="hljs-comment">//同理，right的值也能被取到</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(target == nums[middle] )&#123;<br>                <span class="hljs-keyword">return</span>  middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  right+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length;<span class="hljs-comment">//注意此处定义的右边为数组的长度，因此其右端点的值是取不到的</span><br>        <span class="hljs-comment">//也就是左闭右开区间[left,right)，因此left!=right，当left大于等于right的时候循环结束</span><br>        <span class="hljs-comment">//循环中的条件为left&lt;right</span><br>        <span class="hljs-keyword">while</span>(left &lt;right)&#123;<br>            <span class="hljs-keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(target &gt;nums[middle] )&#123;<br>                <span class="hljs-comment">//如果要找的数比中间值大，说明在区间右边。根据循环不变式，那么当改变left指针的时候，其也是左边闭合的</span><br>                <span class="hljs-comment">//此时left的值应该能被取到，因此left=middle+1</span><br>                left=middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(target &lt; nums[middle] )&#123;<br>                <span class="hljs-comment">//当要找的值比中间值小的时候，说明区间在左边，由于是左闭右开的区间，所以右端点</span><br>                <span class="hljs-comment">//不能被取到，如果当right=middle-1时候，值是有可能取到的，当right=middle时候</span><br>                <span class="hljs-comment">//由于要找的值是比middle小的，所以是不能被取到的，根据循环不变量原理区间是[0,right)</span><br>                <span class="hljs-comment">//right为middle时候取不到</span><br>                right=middle;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(target == nums[middle] )&#123;<br>                <span class="hljs-keyword">return</span>  middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//注意此时返回的是right</span><br>        <span class="hljs-keyword">return</span>  right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>循环不变量</category>
      </categories>
      <tags>
        <tag>循环不变量</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/article/34455.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java异常处理</title>
    <url>/article/28277.html</url>
    <content><![CDATA[<blockquote>
<p>My wishes are fools, they shout across thy song, my Master. </p>
<p>神呀，我的那些愿望真是愚傻呀，它们杂在你的歌声中喧叫着呢。 </p>
<p>Let me but listen. </p>
<p>让我只是静听着吧。</p>
</blockquote>
<h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><p>异常发生的原因有很多，通常包含以下几大类：</p>
<ul>
<li>用户输入了非法数据；</li>
<li>要打开的文件不存在；</li>
<li>网络通信时连接中断，或者JVM内存溢出。</li>
</ul>
<p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p>
<ul>
<li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的；</li>
<li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略；</li>
<li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。</li>
</ul>
<img src="/article/28277/exception-hierarchy.png" class title="exception-hierarchy">
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作<strong>无关</strong></p>
<p>Java虚拟机运行错误（Virtual MachineError），当JVM不再继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机一般会选择线程终止。</p>
<p>还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为他们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</p>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p>
<p>这些已成一般是由于程序逻辑错误引起的，程序应该从逻辑的角度尽可能避免这些类异常的发生。</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>Mac快捷键：<code>Command + option + T</code></p>
<p><strong>try-catch</strong></p>
<ul>
<li>使用 try 和 catch 关键字可以捕获异常；</li>
<li>try-catch 代码块放在异常可能发生的地方。</li>
</ul>
<p>try-catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>   <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 异常的变量名<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">//Catch 块</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">2</span> 异常的变量名<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-comment">//Catch 块</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">3</span> 异常的变量名<span class="hljs-number">3</span>)&#123;<br>  <span class="hljs-comment">//Catch 块</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p>
<p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p>
<p>捕获<strong>多个异常</strong>时，顺序要由小到大！</p>
<p><strong>finally</strong></p>
<ul>
<li>finally 关键字用来创建在 try 代码块后面执行的代码块；</li>
<li><strong>无论是否发生异常，finally 代码块中的代码总会被执行；</strong><ul>
<li>有一种特殊情况finally不执行：当程序没进入try就报错的情况下不执行；</li>
</ul>
</li>
<li>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</li>
<li>finally 代码块出现在 catch 代码块最后，语法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 异常的变量名<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">2</span> 异常的变量名<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>catch 不能独立于 try 存在；</li>
<li>在 try-catch 后面添加 finally 块并非强制性要求的；</li>
<li>try 代码后不能既没 catch 块也没 finally 块；</li>
<li>try, catch, finally 块之间不能添加任何代码。</li>
</ul>
<p><strong>throws/throw </strong></p>
<p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p>
<p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p>
<p>下面方法的声明抛出一个 RemoteException 异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">className</span></span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span> <span class="hljs-keyword">throws</span> RemoteException</span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// Method implementation</span><br>    <span class="hljs-comment">//主动抛出异常，一般在方法中使用</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemoteException();<br>  &#125;<br>  <span class="hljs-comment">//Remainder of class definition</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点：</p>
<ul>
<li>所有异常都必须是 Throwable 的子类；</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。只继承Exception 类来创建的异常类是检查性异常类;</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="通用异常"><a href="#通用异常" class="headerlink" title="通用异常"></a>通用异常</h2><p>在Java中定义了两种类型的异常和错误。</p>
<ul>
<li><strong>JVM(Java虚拟机)</strong> <strong>异常：</strong>由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</li>
<li><strong>程序级异常：</strong>由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</li>
</ul>
<h2 id="Java异常合集"><a href="#Java异常合集" class="headerlink" title="Java异常合集"></a>Java异常合集</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>Java, 异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 排序算法</title>
    <url>/article/50722.html</url>
    <content><![CDATA[<blockquote>
<p>The mystery of creation is like the darkness of night–it is great.</p>
<p>Delusions of knowledge are like the fog of the morning.</p>
</blockquote>
<p><a href="https://www.cnblogs.com/l199616j/p/10742603.html#_label0_0">https://www.cnblogs.com/l199616j/p/10742603.html#_label0_0</a></p>
<img src="/article/50722/sort.png" class title="sort">
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们的位置；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<img src="/article/50722/bubbleSort.gif" class title="bubbleSort">
<h3 id="Java算法实现"><a href="#Java算法实现" class="headerlink" title="Java算法实现"></a>Java算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] bubbleSort(<span class="hljs-keyword">int</span>[] array)&#123;<br>  <span class="hljs-comment">//外层循环 判断循环走多少次</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length - <span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-comment">//比较相邻的元素。如果第一个比第二个大，就交换他们的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span> - i; j++)&#123;<br>      <span class="hljs-keyword">if</span>(array[j+<span class="hljs-number">1</span>] &lt; array[j])&#123;<br>        <span class="hljs-keyword">int</span> temp = array[j];<br>        array[j] = array[j+<span class="hljs-number">1</span>];<br>        array[j+<span class="hljs-number">1</span>] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="算法增加标志位改进"><a href="#算法增加标志位改进" class="headerlink" title="算法增加标志位改进"></a>算法增加标志位改进</h4><ul>
<li>增加标志位，减少没有意义的比较</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] bubbleSort(<span class="hljs-keyword">int</span>[] array)&#123;<br>  <span class="hljs-comment">//外层循环 判断循环走多少次</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length - <span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-comment">//设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成</span><br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">//比较相邻的元素。如果第一个比第二个大，就交换他们的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span> - i; j++)&#123;<br>      <span class="hljs-keyword">if</span>(array[j+<span class="hljs-number">1</span>] &lt; array[j])&#123;<br>        <span class="hljs-keyword">int</span> temp = array[j];<br>        array[j] = array[j+<span class="hljs-number">1</span>];<br>        array[j+<span class="hljs-number">1</span>] = temp;<br>        <span class="hljs-comment">//相邻数字排序完成后，置为true</span><br>        flag = <span class="hljs-keyword">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果其中一轮完全没有进入第二次循环中的置换顺序，说明没有需要置换的相邻元素，那么说明已经不需要再次进行排序，flag为true，可以直接跳出循环</span><br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  reyurn array;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li><p>第一个跟后面的所有数相比较，如果小于（或等于）第一个数的时候，暂存较小数的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）</p>
</li>
<li><p>下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数</p>
</li>
<li>重复以上步骤，直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。</li>
</ol>
<img src="/article/50722/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" class title="img">
<h3 id="Java算法实现-1"><a href="#Java算法实现-1" class="headerlink" title="Java算法实现"></a>Java算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] n = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">33</span>,<span class="hljs-number">27</span>,<span class="hljs-number">66</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">88</span>&#125;;<br>    <span class="hljs-keyword">int</span> temp,index = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n.length-<span class="hljs-number">1</span>; i++) &#123;<br>      index=i;<br>      <span class="hljs-comment">//如果大于，暂存较小的数的下标</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt;n.length; j++) &#123;<br>        <span class="hljs-keyword">if</span>(n[index]&gt;n[j])&#123;<br>          index = j;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">////将一趟下来求出的最小数，与这个数交换</span><br>      <span class="hljs-keyword">if</span>(index&gt;<span class="hljs-number">0</span>)&#123;<br>        temp = n[i];<br>        n[i] = n[index];<br>        n[index] = temp;<br>      &#125;<br>      System.out.println(Arrays.toString(n));<br>    &#125;<br>    System.out.println(Arrays.toString(n));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img src="/article/50722/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" class title="img">
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><img src="/article/50722/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" class title="img">
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><img src="/article/50722/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" class title="img">
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><img src="/article/50722/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.jpg" class title="img">
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><img src="/article/50722/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" class title="img">
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><img src="/article/50722/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" class title="img">
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><img src="/article/50722/1c950a7b02087bf4562d34cf54939c2410dfcf98.jpeg" class title="img">
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><img src="/article/50722/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" class title="img">
]]></content>
      <categories>
        <category>Java</category>
        <category>语言</category>
        <category>Java</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存</title>
    <url>/article/33962.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>语言</category>
        <category>Java</category>
        <category>内存</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：梦开始的地方</title>
    <url>/article/33685.html</url>
    <content><![CDATA[<blockquote>
<p>What language is thine, o sea?</p>
<p>The language of eternal question.</p>
<p>What language is thy answer, o sky?</p>
<p>The language of eternal silence.</p>
</blockquote>
<blockquote>
<p>记性越来越差！能怎么办！</p>
<p>做个博客记录记录吧～</p>
<p>虽然整个java相关都快学完了，但总是觉得看了后面忘了前面，所以决定写个博客，正好感觉之前基础学的感觉不扎实，那就把容易忘记的东西复习一遍吧，准备明年的实习，在实习之前把所有的java相关再来一次～</p>
<p>永不放弃！</p>
</blockquote>
<img src="/article/33685/image-20211210124950047-9111795.png" class="slug">
<h2 id="编译型语言和解释型语言的区别"><a href="#编译型语言和解释型语言的区别" class="headerlink" title="编译型语言和解释型语言的区别"></a>编译型语言和解释型语言的区别</h2><img src="/article/33685/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class="slug">
<h3 id="解释性语言和编译型语言的优缺点"><a href="#解释性语言和编译型语言的优缺点" class="headerlink" title="解释性语言和编译型语言的优缺点"></a><strong>解释性语言和编译型语言</strong>的优缺点</h3><p><a href="https://blog.csdn.net/xwx_100/article/details/83212067">原文链接</a> <a href="本文为CSDN博主「xwx_100」的原创文章，遵循CC4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。">版权声明</a></p>
<p><strong>编译型语言</strong></p>
<ul>
<li>编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%；</li>
<li>编译型程序比解释型程序消耗的内存更少；</li>
<li>不利的一面——编译器比解释器要难写得多；</li>
<li>编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置；</li>
<li>可执行的编译型代码要比相同的解释型代码大许多。例如C/C++的.exe文件要比同样功能的Java的.class文件大很多；</li>
<li>编译型程序是面向特定平台的因而是平台依赖的；</li>
<li>编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的）；</li>
<li>由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。</li>
</ul>
<p><strong>解释型语言</strong></p>
<ul>
<li>解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的；</li>
<li>另一个优势是解释器比编译器容易实现；</li>
<li>解释型语言最大的优势之一是其平台独立性</li>
<li>解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的；</li>
<li>中间语言代码的大小比编译型可执行代码小很多；</li>
<li>平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素；</li>
<li>解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存；</li>
<li>由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多；</li>
<li>解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>类型</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>编译型语言</td>
<td>通过专门的编译器，将所有源代码一次性转换成特定平台（Windows、Linux 等）执行的机器码（以可执行文件的形式存在）。</td>
<td>编译一次后，脱离了编译器也可以运行，并且运行效率高。</td>
<td>可移植性差，不够灵活。</td>
</tr>
<tr>
<td>解释型语言</td>
<td>由专门的解释器，根据需要将部分源代码临时转换成特定平台的机器码。</td>
<td>跨平台性好，通过不同的解释器，将相同的源代码解释成不同平台下的机器码。</td>
<td>一边执行一边转换，效率很低。</td>
</tr>
</tbody>
</table>
<h2 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h2><ol>
<li><p>单行注释</p>
<p>以双斜杠“//”标识，只能注释一行内容，用在注释信息内容少的地方；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是单行注释</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>多行注释</p>
<p>包含在“/<em>”和“</em>/”之间，能注释很多行的内容。为了可读性比较好，一般首行和尾行不写注释信息（这样也比较美观好看）；</p>
<ul>
<li>多行注释可以嵌套单行注释，但是不能嵌套多行注释和文档注释。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">这是多行注释</span><br><span class="hljs-comment">这里也是</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>文档注释</p>
<p>包含在“/*<em>”和“</em>/”之间，也能注释多行内容，一般用在类、方法和变量上面，用来描述其作用；</p>
<p>注释后，鼠标放在类和变量上面会自动显示出我们注释的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*这是文档注释</span><br><span class="hljs-comment">*<span class="hljs-doctag">@Description</span> HelloWorld</span><br><span class="hljs-comment">*这是有功能的注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Java命名规范"><a href="#Java命名规范" class="headerlink" title="Java命名规范"></a>Java命名规范</h2><ul>
<li><p><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</p>
</li>
<li><p><strong>常量：</strong>大写字母和下划线组成。例如<strong>MAX_VALUE</strong></p>
</li>
<li><p><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong>。</p>
</li>
<li><p><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。例如 <strong>myFirstJavaMethod</strong>。</p>
<p><strong>类成员变量、局部变量</strong>同样遵守这个规则</p>
<p><strong>方法名</strong>不使用连接符,但下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如 <code>testPop_emptyStack</code></p>
</li>
<li><p><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</p>
</li>
<li><p><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</p>
</li>
<li><p><strong>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符：</strong></p>
<ul>
<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>
<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
<li>合法标识符举例：age、$salary、_value、__1_value</li>
<li>非法标识符举例：123abc、-salary</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><a href="https://www.runoob.com/java/java-tutorial.html">部分内容引用菜鸟教程</a></p>
<blockquote>
<p>程序员就要知道CV ， CV完了千万记得理解呀！！！</p>
</blockquote>
<p>Java是一种强类型语言</p>
<ul>
<li>要求变量的使用要严格符合规定，所有变量都必须先定义以后才能使用</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>byte：</strong></p>
<ul>
<li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是 <strong>-128（-2^7）</strong>；</li>
<li>最大值是 <strong>127（2^7-1）</strong>；</li>
<li>默认值是 <strong>0</strong>；</li>
<li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li>
</ul>
<p><strong>short：</strong></p>
<ul>
<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 <strong>-32768（-2^15）</strong>；</li>
<li>最大值是 <strong>32767（2^15 - 1）</strong>；</li>
<li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
<li>默认值是 <strong>0</strong>；</li>
</ul>
<p><strong>int：</strong></p>
<ul>
<li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li>
<li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li>
<li>一般地整型变量默认为 int 类型；</li>
<li>默认值是 <strong>0</strong> ；</li>
</ul>
<p><strong>long：</strong></p>
<ul>
<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li>
<li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是 <strong>0L</strong>；</li>
<li>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li>
</ul>
<p><strong>float：</strong></p>
<ul>
<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
<li>float 在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是 <strong>0.0f</strong>；</li>
<li>浮点数不能用来表示精确的值，如货币；</li>
<li>最好完全避免使用浮点数进行比较；</li>
</ul>
<p><strong>double：</strong></p>
<ul>
<li><p>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；</p>
</li>
<li><p>浮点数的默认类型为 double 类型；</p>
</li>
<li><p>double类型同样不能表示精确的值，如货币；</p>
</li>
<li><p>默认值是 <strong>0.0d</strong>；</p>
</li>
<li><p>最好完全避免使用浮点数进行比较；</p>
</li>
<li><p>例子：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">double</span>   d<span class="hljs-number">1</span>  = <span class="hljs-number">7</span>D ;<br><span class="hljs-attribute">double</span>   d<span class="hljs-number">2</span>  = <span class="hljs-number">7</span>.; <br><span class="hljs-attribute">double</span>   d<span class="hljs-number">3</span>  =  <span class="hljs-number">8</span>.<span class="hljs-number">0</span>; <br><span class="hljs-attribute">double</span>   d<span class="hljs-number">4</span>  =  <span class="hljs-number">8</span>.D; <br><span class="hljs-attribute">double</span>   d<span class="hljs-number">5</span>  =  <span class="hljs-number">12</span>.<span class="hljs-number">9867</span>; <br></code></pre></td></tr></table></figure>
<p>7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。</p>
</li>
</ul>
<p><strong>boolean：</strong></p>
<ul>
<li>boolean数据类型表示一位的信息；</li>
<li>只有两个取值：true 和 false；</li>
<li>这种类型只作为一种标志来记录 true/false 情况；</li>
<li>默认值是 <strong>false</strong>；</li>
</ul>
<p><strong>char：</strong></p>
<ul>
<li>char 类型是一个单一的 16 位 Unicode 字符；</li>
<li>最小值是 <strong>\u0000</strong>（十进制等效值为 0）；</li>
<li>最大值是 <strong>\uffff</strong>（即为 65535）；</li>
<li>char 数据类型可以储存任何字符；</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><strong>自动类型转换：整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">低  ------------------------------------&gt;  高<br><br><span class="hljs-keyword">byte</span>,<span class="hljs-keyword">short</span>,<span class="hljs-keyword">char</span>—&gt; <span class="hljs-keyword">int</span> —&gt; <span class="hljs-keyword">long</span>—&gt; <span class="hljs-keyword">float</span> —&gt; <span class="hljs-keyword">double</span> <br></code></pre></td></tr></table></figure>
<p>数据类型转换必须满足如下规则：</p>
<ul>
<li>不能对boolean类型进行类型转换</li>
<li>不能把对象类型转换成不相关类的对象</li>
<li>在把容量大的类型转换为容量小的类型时必须使用<strong>强制类型转换</strong></li>
<li>转换过程中可能导致溢出或损失精度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZiDongLeiZhuan</span></span>&#123;<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    		<span class="hljs-keyword">char</span> c1=<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//定义一个char类型</span><br>        <span class="hljs-keyword">int</span> i1 = c1;<span class="hljs-comment">//char自动类型转换为int</span><br>        System.out.println(<span class="hljs-string">&quot;char自动类型转换为int后的值等于&quot;</span>+i1);<br>        <span class="hljs-keyword">char</span> c2 = <span class="hljs-string">&#x27;A&#x27;</span>;<span class="hljs-comment">//定义一个char类型</span><br>        <span class="hljs-keyword">int</span> i2 = c2+<span class="hljs-number">1</span>;<span class="hljs-comment">//char 类型和 int 类型计算</span><br>        System.out.println(<span class="hljs-string">&quot;char类型和int计算后的值等于&quot;</span>+i2);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">char自动类型转换为int后的值等于97</span><br><span class="hljs-comment">char类型和int计算后的值等于66</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>强制类型转换：</strong></p>
<ul>
<li>条件是转换的数据类型必须是兼容的</li>
<li>格式：(type)value type是要强制类型转换后的数据类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QiangZhiZhuanHuan</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">123</span>;<br>        <span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>)i1;<span class="hljs-comment">//强制类型转换为byte</span><br>        System.out.println(<span class="hljs-string">&quot;int强制类型转换为byte后的值等于&quot;</span>+b);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">int强制类型转换为byte后的值等于123</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>隐含强制类型转换：</strong></p>
<ul>
<li>整数的默认类型是 int</li>
<li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f</li>
</ul>
<hr>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul>
<li>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时候被指定为一个特定的类型，声明之后不能改变。</li>
<li>引用数据类型包括：类（对象）、接口、数组</li>
<li>所有引用类型默认值都是null.</li>
<li>一个引用变量可以用于引用任何与之兼容的类型。</li>
</ul>
<img src="/article/33685/%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98.png" class title="引用数据类型内存">
<hr>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上</li>
<li>引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。</li>
</ul>
<h2 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h2><p><strong>Java语言支持的变量类型有：</strong></p>
<ul>
<li>类变量：独立于方法之外的变量，用 static 修饰。</li>
<li>实例变量：独立于方法之外的变量，不过没有 static 修饰。 </li>
<li>局部变量：类的方法中的变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Variable</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> allClicks=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 类变量</span><br>    String str=<span class="hljs-string">&quot;hello world&quot;</span>;  <span class="hljs-comment">// 实例变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;  <span class="hljs-comment">// 局部变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul>
<li>局部变量声明在方法、构造方法或者语句块中</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，<strong>当它们执行完成后，变量将会被销毁</strong></li>
<li>访问修饰符不能用于局部变量(<strong>default</strong> <strong>private</strong>  <strong>public</strong> <strong>protected</strong>)</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见</li>
<li>局部变量是在<strong>栈</strong>上分配的</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123; <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pupAge</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>;<br>      age = age + <span class="hljs-number">7</span>;<br>      System.out.println(<span class="hljs-string">&quot;小狗的年龄是: &quot;</span> + age);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      Test test = <span class="hljs-keyword">new</span> Test();<br>      test.pupAge();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">小狗的年龄是: 7</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁</li>
<li>实例变量的值应该<strong>至少</strong>被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息</li>
<li>实例变量可以声明在使用前或者使用后</li>
<li>访问修饰符可以修饰实例变量(<strong>default</strong> <strong>private</strong>  <strong>public</strong> <strong>protected</strong>)</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见</li>
<li>实例变量具有默认值。<strong>数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。</strong>变量的值可以在声明时指定，也可以在构造方法中指定</li>
<li><strong>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;<br>   <span class="hljs-comment">// 这个实例变量对子类可见</span><br>   <span class="hljs-keyword">public</span> String name;<br>   <span class="hljs-comment">// 私有变量，仅在该类可见</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<br>   <span class="hljs-comment">//在构造器中对name赋值</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span> <span class="hljs-params">(String empName)</span></span>&#123;<br>      name = empName;<br>   &#125;<br>   <span class="hljs-comment">//设定salary的值</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> empSal)</span></span>&#123;<br>      salary = empSal;<br>   &#125;  <br>   <span class="hljs-comment">// 打印信息</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEmp</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;名字 : &quot;</span> + name );<br>      System.out.println(<span class="hljs-string">&quot;薪水 : &quot;</span> + salary);<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      Employee empOne = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;BOBO&quot;</span>);<br>      empOne.setSalary(<span class="hljs-number">1000.0</span>);<br>      empOne.printEmp();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">$ javac Employee.java </span><br><span class="hljs-comment">$ java Employee</span><br><span class="hljs-comment">名字 : BOBO</span><br><span class="hljs-comment">薪水 : 1000.0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p><a href="#静态变量"><code>点击跳转静态变量</code></a></p>
<ul>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外</li>
<li>无论一个类创建了多少个对象，<strong>类只拥有类变量的一份拷贝</strong></li>
<li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li>
<li><strong>静态变量在第一次被访问时创建，在程序结束时销毁</strong></li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型</li>
<li>默认值和实例变量相似。<strong>数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。</strong>变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化</li>
<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问</li>
<li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-comment">//salary是静态的私有变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> salary;<br>    <span class="hljs-comment">// DEPARTMENT是一个常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEPARTMENT = <span class="hljs-string">&quot;开发人员&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    salary = <span class="hljs-number">10000</span>;<br>        System.out.println(DEPARTMENT+<span class="hljs-string">&quot;平均工资:&quot;</span>+salary);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">开发人员平均工资:10000.0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h2><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>
<p>方法的可变参数的声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">typeName... parameterName<br></code></pre></td></tr></table></figure>
<p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p>
<p>一个方法中只能指定一个可变参数，它<strong>必须是方法的最后一个参数</strong>。任何普通的参数必须在它之前声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VarargsDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-comment">// 调用可变参数的方法</span><br>        printMax(<span class="hljs-number">34</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">56.5</span>);<br>        printMax(<span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMax</span><span class="hljs-params">( <span class="hljs-keyword">double</span>... numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (numbers.length == <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;No argument passed&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">double</span> result = numbers[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;  numbers.length; i++)&#123;<br>            <span class="hljs-keyword">if</span> (numbers[i] &gt;  result) &#123;<br>                result = numbers[i];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;The max value is &quot;</span> + result);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">The max value is 56.5</span><br><span class="hljs-comment">The max value is 3.0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>构造方法也称为构造器</li>
<li><strong>当一个对象被创建时候，构造方法用来初始化该对象</strong></li>
<li><strong>构造方法和它所在类的名字相同</strong>，但构造方法没有返回值，也不能写void</li>
<li>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象</li>
<li>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)</li>
<li>一旦你定义了自己的构造方法，默认构造方法就会失效</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个简单的构造函数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> x;<br> <br>  <span class="hljs-comment">// 以下是构造函数</span><br>  MyClass() &#123;<br>    x = <span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Java-静态类、静态方法和静态变量"><a href="#Java-静态类、静态方法和静态变量" class="headerlink" title="Java 静态类、静态方法和静态变量"></a>Java 静态类、静态方法和静态变量</h2><p><strong>static</strong> 是Java中的一个关键字，我们不能声明普通外层类或者包为静态的</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p><a href="#类变量"><code>点击跳转类变量</code></a></p>
<p>静态变量即类变量，静态变量是属于类的，而不是属于类创建的对象或实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态变量的例子</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String str;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DB_USER = <span class="hljs-string">&quot;myuser&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>类似于静态变量</li>
<li>静态方法也属于类，不属于实例</li>
<li>静态方法只能访问类的静态变量，或调用类的静态方法</li>
<li>通常静态方法作为工具方法，被其它类使用，而不需要创建类的实例</li>
<li>通常java程序的开始就是一个<code>main()</code>方法，它就是个静态方法</li>
<li>静态方法只会在第一次执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态方法的例子</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)<br>    StaticExample.count = count;<br>&#125;<br><br><span class="hljs-comment">//静态工具方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addInts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>...js)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : js) sum+=x;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="静态块"><a href="#静态块" class="headerlink" title="静态块"></a>静态块</h3><ul>
<li>静态块就是类加载器加载对象时，要执行的一组语句</li>
<li>用于初始化静态变量</li>
<li>通常用于类加载的时候创建静态资源</li>
<li>我们在静态块中不能访问非静态变量</li>
<li>我们可以在一个类中有多个静态块，尽管这么做没什么意义</li>
<li>静态块只会在类加载到内存中的时候执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br>    <span class="hljs-comment">//在类被加载的时候用于初始化资源</span><br>    System.out.println(<span class="hljs-string">&quot;StaticExample static block&quot;</span>);<br>    <span class="hljs-comment">//仅能访问静态变量和静态方法</span><br>    str=<span class="hljs-string">&quot;Test&quot;</span>;<br>    setCount(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><p><a href="#内部类"><code>点击跳转内部类</code></a></p>
<ul>
<li>我们对嵌套类使用static关键字</li>
<li>static不能用于最外层的类</li>
<li>静态的嵌套类和其它外层的类别无二致，嵌套只是为了方便打包</li>
</ul>
<h3 id="静态导入包"><a href="#静态导入包" class="headerlink" title="静态导入包"></a>静态导入包</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.random;<br></code></pre></td></tr></table></figure>
<p>可以在类中直接使用random方法</p>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><p>数组是<strong>相同类型数据</strong>的<strong>有序集合</strong></p>
<ul>
<li>长度确定，一旦被创建，大小就不可以被改变</li>
<li>其元素必须是相同类型，不允许出现混合类型</li>
<li>数组中的元素可以是任何数据类型</li>
<li>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量</li>
</ul>
<p>初始化数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 首选的方法</span><br>dataType[] arrayRefVar;  <br><span class="hljs-comment">//或</span><br><span class="hljs-comment">// 效果相同，但不是首选方法 </span><br><span class="hljs-comment">// 来自 C/C++ 语言 </span><br>dataType arrayRefVar[];  <br></code></pre></td></tr></table></figure>
<p>初始化多维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接为每一维分配空间</span><br><span class="hljs-comment">//type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数</span><br>type[][] typeName = <span class="hljs-keyword">new</span> type[typeLength1][typeLength2];<br><span class="hljs-comment">//或</span><br><span class="hljs-comment">//为最高维分配引用空间</span><br><span class="hljs-comment">//再为其每个数组元素单独分配空间</span><br>String[][] s = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>][];<br>s[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>];<br>s[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>];<br>s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Good&quot;</span>);<br>s[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Luck&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;to&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;you&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;!&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>稀疏矩阵（英语：sparse matrix）指的是在数值分析中绝大多数数值为零的矩阵。反之，如果大部分元素都非零，则这个矩阵是稠密的(Dense)。</p>
<img src="/article/33685/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%A8%A0%E5%AF%86%E7%9F%A9%E9%98%B5.png" class title="稀疏矩阵与稠密矩阵">
<blockquote>
<p> 上图中左边就是一个稀疏矩阵，可以看到包含了很多 0 元素，右边是稠密的矩阵，大部分元素不是 0</p>
</blockquote>
<p>转化为稀疏数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] sparseMatrix(<span class="hljs-keyword">int</span>[][] array)&#123;<br>  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; array.length; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; array[i].length)&#123;<br>      <span class="hljs-keyword">if</span>(array[i][j] != <span class="hljs-number">0</span>)<br>        sum++;<br>    &#125;<br>  &#125;<br>  System.out.println(<span class="hljs-string">&quot;有效值的个数：&quot;</span> + sum);<br>  <br>  <span class="hljs-comment">//创建一个稀疏数组</span><br>  <span class="hljs-keyword">int</span>[][] sparse = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>  sparse[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = array.length;<br>  sparse[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = array[<span class="hljs-number">0</span>].length;<br>  sparse[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = sum;<br>  <br>  <span class="hljs-comment">//遍历二维数组，将非零的值，存放数组中</span><br>  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; array.length ; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; array[<span class="hljs-number">0</span>].length ; j++)&#123;<br>      <span class="hljs-keyword">if</span>(array[i][j] != <span class="hljs-number">0</span>)&#123;<br>        count++;<br>        sparse[count][<span class="hljs-number">0</span>] = i;<br>        sparse[count][<span class="hljs-number">1</span>] = j;<br>        sparse[count][<span class="hljs-number">2</span>] = array[i][j];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sparse;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Java类"><a href="#Java类" class="headerlink" title="Java类"></a>Java类</h2><h3 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Scanner s = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure>
<p>通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据.</p>
<p><strong>next方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner; <br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScannerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">// 从键盘接收数据</span><br> <br>        <span class="hljs-comment">// next方式接收字符串</span><br>        System.out.println(<span class="hljs-string">&quot;next方式接收：&quot;</span>);<br>        <span class="hljs-comment">// 判断是否还有输入</span><br>        <span class="hljs-keyword">if</span> (scan.hasNext()) &#123;<br>            String str1 = scan.next();<br>            System.out.println(<span class="hljs-string">&quot;输入的数据为：&quot;</span> + str1);<br>        &#125;<br>        scan.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">$ javac ScannerDemo.java</span><br><span class="hljs-comment">$ java ScannerDemo</span><br><span class="hljs-comment">next方式接收：</span><br><span class="hljs-comment">bobo com</span><br><span class="hljs-comment">输入的数据为：bobo</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>nextLine 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScannerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">// 从键盘接收数据</span><br> <br>        <span class="hljs-comment">// nextLine方式接收字符串</span><br>        System.out.println(<span class="hljs-string">&quot;nextLine方式接收：&quot;</span>);<br>        <span class="hljs-comment">// 判断是否还有输入</span><br>        <span class="hljs-keyword">if</span> (scan.hasNextLine()) &#123;<br>            String str2 = scan.nextLine();<br>            System.out.println(<span class="hljs-string">&quot;输入的数据为：&quot;</span> + str2);<br>        &#125;<br>        scan.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">$ javac ScannerDemo.java</span><br><span class="hljs-comment">$ java ScannerDemo</span><br><span class="hljs-comment">nextLine方式接收：</span><br><span class="hljs-comment">bobo com</span><br><span class="hljs-comment">输入的数据为：bobo com</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>next() 与 nextLine() 区别</strong></p>
<p>next():</p>
<ul>
<li>一定要读取到有效字符后才可以结束输入。</li>
<li>对输入有效字符之前遇到的空白，next() 方法会自动将其去。</li>
<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 </li>
<li>next() 不能得到带有空格的字符串。</li>
</ul>
<p>nextLine()： </p>
<ul>
<li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 </li>
<li>可以获得空白。</li>
</ul>
<blockquote>
<p><strong>相较于 hasnext()</strong>，针对int、float等其他基本数据类型，还有scan.hasNextInt()、hasNextFloat()等方法，返回布尔值；</p>
</blockquote>
<blockquote>
<p> <strong>相较于 nextLine()</strong>，针对int、float等其他基本数据类型，还有、scan.nextInt()、scan.nextFloat()等方法，返回输出类型值；</p>
</blockquote>
<h3 id="Java-Arrays-类"><a href="#Java-Arrays-类" class="headerlink" title="Java Arrays 类"></a>Java Arrays 类</h3><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法 ,将指定的值分配给数组的每个元素</li>
<li>对数组排序：通过 sort 方法,按升序</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p>
<p><strong>成员内部类</strong></p>
<p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> radius = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.radius = radius;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Draw</span> </span>&#123;     <span class="hljs-comment">//内部类</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawSahpe</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;drawshape&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以<strong>无条件访问外部类的所有成员属性和成员方法</strong>（包括private成员和静态成员）。</p>
<hr>
<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">外部类.<span class="hljs-keyword">this</span>.成员变量<br>外部类.<span class="hljs-keyword">this</span>.成员方法<br></code></pre></td></tr></table></figure>
<hr>
<p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.radius = radius;<br>        getDrawInstance().drawSahpe();   <span class="hljs-comment">//必须先创建成员内部类的对象，再进行访问</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Draw <span class="hljs-title">getDrawInstance</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//创建成员内部类的对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Draw();<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Draw</span> </span>&#123;     <span class="hljs-comment">//内部类</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawSahpe</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(radius);  <span class="hljs-comment">//外部类的private成员</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        <span class="hljs-comment">//第一种方式：</span><br>        Outter outter = <span class="hljs-keyword">new</span> Outter();<br>        Outter.Inner inner = outter.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//必须通过Outter对象来创建</span><br>         <br>        <span class="hljs-comment">//第二种方式：</span><br>        Outter.Inner inner1 = outter.getInnerInstance();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Inner inner = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Outter</span><span class="hljs-params">()</span> </span>&#123;<br>         <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Inner <span class="hljs-title">getInnerInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inner == <span class="hljs-keyword">null</span>)<br>            inner = <span class="hljs-keyword">new</span> Inner();<br>        <span class="hljs-keyword">return</span> inner;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Inner</span><span class="hljs-params">()</span> </span>&#123;    <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。</p>
<hr>
<p><strong>局部内部类</strong></p>
<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Man</span><span class="hljs-params">()</span></span>&#123;    <br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> People <span class="hljs-title">getWoman</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">People</span></span>&#123;   <span class="hljs-comment">//局部内部类</span><br>            <span class="hljs-keyword">int</span> age =<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Woman();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意</strong>: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p>
<hr>
<p><strong>匿名内部类</strong></p>
<p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。</p>
<p>下面是一段匿名内部类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面这段代码是一段 Android 事件监听代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">scan_bt.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;);<br> <br>history_bt.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>     <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>这就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。</p>
<hr>
<p><strong>静态内部类</strong></p>
<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</p>
<p>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        Outter.Inner inner = <span class="hljs-keyword">new</span> Outter.Inner();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Outter</span><span class="hljs-params">()</span> </span>&#123;<br>         <br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Inner</span><span class="hljs-params">()</span> </span>&#123;<br>             <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p><strong>静态内部类与内部类的区别</strong></p>
<p><strong>内部类</strong></p>
<ul>
<li>内部类拥有普通类的所有特性，也拥有类成员变量的特性 </li>
<li>内部类可以访问其外部类的成员变量，属性，方法，其它内部类</li>
</ul>
<p><strong>静态内部类</strong></p>
<ul>
<li>只有内部类才能声明为static，也可以说是静态内部类 </li>
<li>只有静态内部类才能拥有静态成员，普通内部类只能定义普通成员 </li>
<li>静态类跟静态方法一样，只能访问其外部类的静态成员 </li>
<li>如果在外部类的静态方法中访问内部类，这时候只能访问静态内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 外部类，不能声明为 static</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ab = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sab = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NormalInnerClass</span> </span>&#123;<br>        <span class="hljs-comment">// private static int age = 22;</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">22</span>; <span class="hljs-comment">// 不能声明为static</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NormalInnerClass</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 可以访问外部类静态与非静态成员</span><br>            System.out.println(ab);<br>            System.out.println(sab);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 静态内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> </span>&#123;<br>        <span class="hljs-comment">// 定义静态与非静态成员都是可以的</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">22</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age2 = <span class="hljs-number">22</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">echo</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// System.out.println(ab);</span><br>            System.out.println(sab);<span class="hljs-comment">// 只能访问外部类的静态成员</span><br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>
<hr>
<p><strong>练习</strong></p>
<p>1.根据注释填写(1)，(2)，(3)处的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>           <span class="hljs-comment">// 初始化Bean1</span><br>           (<span class="hljs-number">1</span>)<br>           bean1.I++;<br>           <span class="hljs-comment">// 初始化Bean2</span><br>           (<span class="hljs-number">2</span>)<br>           bean2.J++;<br>           <span class="hljs-comment">//初始化Bean3</span><br>           (<span class="hljs-number">3</span>)<br>           bean3.k++;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bean1</span></span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> I = <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bean2</span></span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> J = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bean</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bean3</span></span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>
<p>创建静态内部类对象的一般形式为：<code>外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</code></p>
<p>创建成员内部类对象的一般形式为： <code>外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</code></p>
<p>因此，（1），（2），（3）处的代码分别为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Test test = <span class="hljs-keyword">new</span> Test();    <br>Test.Bean1 bean1 = test.n<span class="hljs-function">ew <span class="hljs-title">Bean1</span><span class="hljs-params">()</span></span>;<br>---------------------------------------<br>Test.Bean2 b2 = <span class="hljs-keyword">new</span> Test.Bean2();<br>Bean bean = <span class="hljs-keyword">new</span> Bean();     <br>---------------------------------------<br>Bean.Bean3 bean3 =  bean.n<span class="hljs-function">ew <span class="hljs-title">Bean3</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p>2.下面这段代码的输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        Outter outter = <span class="hljs-keyword">new</span> Outter();<br>        outter.n<span class="hljs-function">ew <span class="hljs-title">Inner</span><span class="hljs-params">()</span>.<span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br> <br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outter</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br>            System.out.println(<span class="hljs-string">&quot;局部变量：&quot;</span> + a);<br>            System.out.println(<span class="hljs-string">&quot;内部类变量：&quot;</span> + <span class="hljs-keyword">this</span>.a);<br>            System.out.println(<span class="hljs-string">&quot;外部类变量：&quot;</span> + Outter.<span class="hljs-keyword">this</span>.a);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">局部变量：3</span><br><span class="hljs-comment">内部类变量：2</span><br><span class="hljs-comment">外部类变量：1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<hr>
<p>关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>
<ul>
<li>成员内部类的引用方式必须为 Outter.Inner </li>
<li>构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithInner</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br>         <br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritInner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WithInner</span>.<span class="hljs-title">Inner</span> </span>&#123;<br>      <br>    <span class="hljs-comment">// InheritInner() 是不能通过编译的，一定要加上形参</span><br>    InheritInner(WithInner wi) &#123;<br>        wi.<span class="hljs-keyword">super</span>(); <span class="hljs-comment">//必须有这句调用</span><br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        WithInner wi = <span class="hljs-keyword">new</span> WithInner();<br>        InheritInner obj = <span class="hljs-keyword">new</span> InheritInner(wi);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样</p>
</li>
<li><p>抽象方法必须在抽象类中</p>
<ul>
<li><p>如果一个类包含抽象方法，那么该类必须是抽象类</p>
</li>
<li><p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类</p>
</li>
</ul>
</li>
<li><p>由于抽象类不能实例化对象，所以<strong>抽象类必须被继承</strong>，才能被使用</p>
</li>
<li><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法</p>
</li>
<li><p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而<strong>一个类却可以实现多个<a href="#接口"><code>接口</code></a></strong>,接口可以多继承</p>
</li>
<li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p>
</li>
<li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能</p>
</li>
<li><p><strong>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</strong></p>
</li>
<li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</p>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范（抽象方法）都有</li>
<li>接口：只有规范！</li>
</ul>
<ol>
<li>是抽象方法的集合，接口通常以interface来声明；</li>
<li>一个类通过继承接口的方式，从而来继承接口的抽象方法；</li>
<li>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法；</li>
<li>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法；</li>
<li>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类；</li>
<li>在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或<strong>是被绑定在一个以此接口实现的对象</strong>。</li>
</ol>
<p><strong>接口与类相似点</strong></p>
<ul>
<li>一个接口可以有多个方法；</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名；</li>
<li>接口的字节码文件保存在 .class 结尾的文件中；</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<p><strong>接口与类的区别</strong></p>
<ul>
<li>接口不能用于实例化对象；</li>
<li>接口没有构造方法；</li>
<li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法；</li>
<li>接口不能包含成员变量，除了 static 和 final 变量；</li>
<li>接口不是被类继承了，而是要被类实现；</li>
<li>接口支持多继承。</li>
</ul>
<p><strong>接口特性</strong></p>
<ul>
<li>接口与接口中的每一个方法都是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）；</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）；</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法；</li>
<li>接口中的方法都是公有的。</li>
</ul>
<p><strong>抽象类和接口的区别</strong></p>
<ul>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的；</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名称 [<span class="hljs-keyword">extends</span> 其他的接口名] </span>&#123;<br>  <span class="hljs-comment">// 声明变量</span><br>  <span class="hljs-comment">// 抽象方法</span><br>&#125;<br><br>...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...<br></code></pre></td></tr></table></figure>
<p><strong>重写接口中声明的方法时，需要注意以下规则</strong></p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常；</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型；</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法；</li>
</ul>
<p><strong>在实现接口的时候，也要注意一些规则</strong></p>
<ul>
<li>一个类可以同时实现多个接口；</li>
<li>一个类只能继承一个类，但是能实现多个接口；</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<p><strong>标记接口</strong></p>
<ul>
<li>最常用的继承接口是没有包含任何方法的接口；</li>
<li>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情；</li>
<li>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</li>
</ul>
<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EventListener</span></span><br><span class="hljs-class"></span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>
<ul>
<li><p>建立一个公共的父接口：</p>
<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li><p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>
</li>
</ul>
<h2 id="值传递-引用传递"><a href="#值传递-引用传递" class="headerlink" title="值传递-引用传递"></a>值传递-引用传递</h2><p><strong>值传递</strong></p>
<p>实参传递给形参的是值 形参和实参在内存上是两个<strong>独立</strong>的变量,对<strong>形参做任何修改不会影响实参</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> b =<span class="hljs-number">20</span>;<br>        change(b);<span class="hljs-comment">// 实参 实际上的参数</span><br>        System.out.println(b);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<span class="hljs-comment">//形参 形式上的参数</span><br>        a=<span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>引用传递</strong></p>
<p>实参传递给形参的是参数对于堆内存上的引用地址，实参和形参在内存上指向了同一块区域，对<strong>形参的修改会影响实参</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> [] a=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.println(a[<span class="hljs-number">0</span>]);<br>        change(a);<br>        System.out.println(a[<span class="hljs-number">0</span>]);<br>    &#125;<br>   <span class="hljs-comment">//实参和形参在内存上指向了同一块区域</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a )</span></span>&#123;<br>        a[<span class="hljs-number">0</span>]=<span class="hljs-number">100</span>;  <span class="hljs-comment">//形参的修改会影响实参</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote>
<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法;</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制;</p>
</blockquote>
<p><strong>优点</strong></p>
<ul>
<li>良好的封装能够减少耦合；</li>
<li>类内部的结构可以自由修改；</li>
<li>可以对成员变量进行更精确的控制；</li>
<li>隐藏信息，实现细节。</li>
</ul>
<p><strong>实现步骤</strong></p>
<ol>
<li>修改属性的可见性来限制对属性的访问（一般限制为private）</li>
<li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问（get、set方法）</li>
<li>采用 <strong>this</strong> 关键字是为了解决实例变量和局部变量之间发生的同名的冲突</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类;</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类的继承格式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> 父类 </span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> 子类 <span class="hljs-keyword">extends</span> 父类 </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/33685/java-extends.png" class title="java-extends">
<p><strong>特性</strong></p>
<ul>
<li>子类拥有父类<strong>非 private </strong>的属性、方法；</li>
<li>final修饰的类，不能被继承；</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展；</li>
<li>子类可以用自己的方式实现父类的方法；</li>
<li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li>
<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li>
</ul>
<p><strong>关键字</strong></p>
<p><strong>super 与 this 关键字</strong></p>
<p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类</p>
<p>this关键字：指向自己的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;animal : eat&quot;</span>);<br>  &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;dog : eat&quot;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eatTest</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.eat();   <span class="hljs-comment">// this 调用自己的方法</span><br>    <span class="hljs-keyword">super</span>.eat();  <span class="hljs-comment">// super 调用父类方法</span><br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Animal a = <span class="hljs-keyword">new</span> Animal();<br>    a.eat();<br>    Dog d = <span class="hljs-keyword">new</span> Dog();<br>    d.eatTest();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果为：</span><br><span class="hljs-comment">animal : eat</span><br><span class="hljs-comment">dog : eat</span><br><span class="hljs-comment">animal : eat</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>super调用父类的构造方法，必须在构造方法的第一个</li>
<li>super必须只能出现在子类的方法或者构造方法中</li>
<li>super和this不能同时调用构造方法</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote>
<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作.</p>
</blockquote>
<p><strong>注意</strong></p>
<ul>
<li>对象能执行哪些方法，主要看左边的类型，和右边关系不大</li>
<li>父类可以指向子类，但是不能调用子类<strong>独有</strong>的方法</li>
<li></li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ul>
<p><strong>多态存在的三个必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写 <a href="#Java重写与重载"><code>点击跳转重写与重载</code></a></li>
<li>父类引用指向子类对象：<strong>Parent p = new Child();</strong></li>
</ul>
<img src="/article/33685/Java%E5%A4%9A%E6%80%81.jpg" class title="Java多态">
<p><em>简单的多态实例</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      show(<span class="hljs-keyword">new</span> Cat());  <span class="hljs-comment">// 以 Cat 对象调用 show 方法</span><br>      show(<span class="hljs-keyword">new</span> Dog());  <span class="hljs-comment">// 以 Dog 对象调用 show 方法</span><br>                <br>      Animal a = <span class="hljs-keyword">new</span> Cat();  <span class="hljs-comment">// 向上转型  </span><br>      a.eat();               <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br>      Cat c = (Cat)a;        <span class="hljs-comment">// 向下转型  </span><br>      c.work();        <span class="hljs-comment">// 调用的是 Cat 的 work</span><br>  &#125;  <br>            <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Animal a)</span>  </span>&#123;<br>      a.eat();  <br>        <span class="hljs-comment">// 类型判断</span><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)  &#123;  <span class="hljs-comment">// 猫做的事情 </span><br>            Cat c = (Cat)a;  <br>            c.work();  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Dog) &#123; <span class="hljs-comment">// 狗做的事情 </span><br>            Dog c = (Dog)a;  <br>            c.work();  <br>        &#125;  <br>    &#125;  <br>&#125;<br> <br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;  <br>&#125;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;看家&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>稍微复杂的多态</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> String address;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, String address, <span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Employee 构造函数&quot;</span>);<br>      <span class="hljs-keyword">this</span>.name = name;<br>      <span class="hljs-keyword">this</span>.address = address;<br>      <span class="hljs-keyword">this</span>.number = number;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailCheck</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;邮寄支票给： &quot;</span> + <span class="hljs-keyword">this</span>.name<br>       + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.address);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot; &quot;</span> + address + <span class="hljs-string">&quot; &quot;</span> + number;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> name;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> address;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String newAddress)</span> </span>&#123;<br>      address = newAddress;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> number;<br>   &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span><br><span class="hljs-class"></span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary; <span class="hljs-comment">// 全年工资</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Salary</span><span class="hljs-params">(String name, String address, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">double</span> salary)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>(name, address, number);<br>       setSalary(salary);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailCheck</span><span class="hljs-params">()</span> </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Salary 类的 mailCheck 方法 &quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;邮寄支票给：&quot;</span> + getName()<br>       + <span class="hljs-string">&quot; ，工资为：&quot;</span> + salary);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> salary;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newSalary)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(newSalary &gt;= <span class="hljs-number">0.0</span>) &#123;<br>          salary = newSalary;<br>       &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">computePay</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;计算工资，付给：&quot;</span> + getName());<br>      <span class="hljs-keyword">return</span> salary/<span class="hljs-number">52</span>;<br>   &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualDemo</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span> </span>&#123;<br>      Salary s = <span class="hljs-keyword">new</span> Salary(<span class="hljs-string">&quot;员工 A&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3600.00</span>);<br>      Employee e = <span class="hljs-keyword">new</span> Salary(<span class="hljs-string">&quot;员工 B&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2400.00</span>);<br>      System.out.println(<span class="hljs-string">&quot;使用 Salary 的引用调用 mailCheck -- &quot;</span>);<br>      s.mailCheck();<br>      System.out.println(<span class="hljs-string">&quot;\n使用 Employee 的引用调用 mailCheck--&quot;</span>);<br>      e.mailCheck();<br>    &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Employee 构造函数</span><br><span class="hljs-comment">Employee 构造函数</span><br><span class="hljs-comment">使用 Salary 的引用调用 mailCheck -- </span><br><span class="hljs-comment">Salary 类的 mailCheck 方法 </span><br><span class="hljs-comment">邮寄支票给：员工 A ，工资为：3600.0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">使用 Employee 的引用调用 mailCheck--</span><br><span class="hljs-comment">Salary 类的 mailCheck 方法 </span><br><span class="hljs-comment">邮寄支票给：员工 B ，工资为：2400.0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>理解：</p>
<ol>
<li>主函数初始化<code>new Salary</code>时，因为继承关系，所以执行父类构造方法，初始化两次，执行了两次</li>
<li><code>s.mailCheck();</code>正常调用类Salary中的方法</li>
<li><code>e.mailCheck();</code> 父类的引用指向了子类的对象，因为类Salary重写了父类的方法，所以，调用类Salary中的方法</li>
</ol>
<h2 id="Java重写与重载"><a href="#Java重写与重载" class="headerlink" title="Java重写与重载"></a>Java重写与重载</h2><h2 id="⚠️⚠️⚠️注意细节⚠️⚠️⚠️"><a href="#⚠️⚠️⚠️注意细节⚠️⚠️⚠️" class="headerlink" title="⚠️⚠️⚠️注意细节⚠️⚠️⚠️"></a>⚠️⚠️⚠️注意细节⚠️⚠️⚠️</h2><h3 id="类中方法加载顺序"><a href="#类中方法加载顺序" class="headerlink" title="类中方法加载顺序"></a>类中方法加载顺序</h3><p>静态代码块——匿名代码块——构造方法</p>
<h3 id="字符输出问题"><a href="#字符输出问题" class="headerlink" title="字符输出问题"></a>字符输出问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZiDongLeiZhuan</span></span>&#123;<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    		<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>      	<span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br>      	System.out.println(<span class="hljs-string">&quot;&quot;</span> + a + b);<br>      	System.out.println(a + b + <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">1020</span><br><span class="hljs-comment">30</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>如果<code>&quot;&quot;</code>在前 则字符串拼接！如果<code>&quot;&quot;</code>在后 则为数学相加！</p>
<h3 id="关于调用静态方法与非静态方法的区别"><a href="#关于调用静态方法与非静态方法的区别" class="headerlink" title="关于调用静态方法与非静态方法的区别"></a><strong>关于调用静态方法与非静态方法的区别</strong></h3><p><strong>例子</strong>：注意看 输出是不同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主启动类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-comment">//调用静态方法时 方法的调用只和  左边  定义的数据类型有关</span><br>    A a = <span class="hljs-keyword">new</span> A();<br>    a.test();<br>    <span class="hljs-comment">//父类的引用指向了子类</span><br>    B b = <span class="hljs-keyword">new</span> A();  <span class="hljs-comment">//子类重写了父类的方法  只和非静态方法有关</span><br>    b.test()<br>  &#125;<br>&#125;  <br><br>---非静态方法---<br><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;B=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;A=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">A=&gt;test()</span><br><span class="hljs-comment">A=&gt;test()</span><br><span class="hljs-comment">*/</span><br>---静态方法---<br><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;B=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;A=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">A=&gt;test()</span><br><span class="hljs-comment">B=&gt;test()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>理解</strong>：</p>
<p>静态方法属于类的方法，非静态方法属于对象的方法</p>
<p>调用静态方法时，b调用了B类的方法，因为b是B类定义的，只和 <code>**左边**</code>  定义的数据类型有关</p>
<p>调用非静态方法时，b调用的是对象的方法，而b这个对象是用A类new的，所以调用A的方法</p>
<h3 id="Java程序初始化顺序"><a href="#Java程序初始化顺序" class="headerlink" title="Java程序初始化顺序"></a>Java程序初始化顺序</h3><ol>
<li>父类的静态变量</li>
<li>父类的静态代码块</li>
<li>子类的静态变量</li>
<li>子类的静态代码块</li>
<li>父类的非静态变量</li>
<li>父类的非静态代码块</li>
<li>父类的构造方法</li>
<li>子类的非静态变量</li>
<li>子类的非静态代码块</li>
<li>子类的构造方法</li>
</ol>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/article/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo server<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
