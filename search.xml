<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Typora-markdown 操作详解</title>
    <url>/article/44103.html</url>
    <content><![CDATA[<blockquote>
<p> Stray birds of summer come to my window to sing and fly away.</p>
<p>And yellow leaves of autumn, which have no songs, flutter and fallthere with a sign.</p>
</blockquote>
<h1 id="一、markdown-的简介"><a href="#一、markdown-的简介" class="headerlink" title="一、markdown 的简介"></a>一、markdown 的简介</h1><blockquote>
<p>markdown是一种轻量级的标记语言</p>
<p>理念：markdown致力于让创作或者阅读文档变得更加的容易</p>
<p>hyper text markup language（html）超文本标记性语言</p>
</blockquote>
<blockquote>
<blockquote>
<p>（&lt; + 空格 – 引用）</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">导入文章顶部目录<br>代码：[TOC]<br></code></pre></td></tr></table></figure>
<h1 id="二、标题"><a href="#二、标题" class="headerlink" title="二、标题"></a>二、标题</h1><h2 id="markdown的标题"><a href="#markdown的标题" class="headerlink" title="markdown的标题"></a>markdown的标题</h2><blockquote>
<p>语法：</p>
<!--#（一级标题）  ##（二级标题） ###（三级标题（四级标题） #####（五级标题）-->
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">#（一级标题）<br>##（二级标题）<br>###（三级标题）<br>####（四级标题）<br>#####（五级标题）<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3></blockquote>
<blockquote>
<p>快捷键：</p>
<ul>
<li>command + 数字 1-5   可以快速将选中文字转换为对应级别的标题</li>
<li>command + 加号/减号   可以对标题级别进行加减</li>
</ul>
</blockquote>
<h1 id="三、段落"><a href="#三、段落" class="headerlink" title="三、段落"></a>三、段落</h1><h2 id="1、段落"><a href="#1、段落" class="headerlink" title="1、段落"></a>1、段落</h2><blockquote>
<p>语法：直接进行文字的编辑，如需新建下一段落，可以直接换行</p>
<p>或者在段落的末尾加两个空格回车</p>
</blockquote>
<h2 id="2、字体"><a href="#2、字体" class="headerlink" title="2、字体"></a>2、字体</h2><blockquote>
<p>语法：</p>
<ol>
<li>粗体   用一对 双星号 （**）包裹  </li>
<li>删除线  用一对 波浪线 （~~）包裹</li>
<li>下划线  用一对  u 标签（<u></u>）包裹</li>
<li>斜体  用一对 单星号 （*）包裹</li>
<li>斜粗体 用一对 三星号（***）包裹</li>
</ol>
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">**这是粗体**<br>~~这是删除线~~<br>&lt;u&gt;这是下划线&lt;/u&gt;<br>*这是斜体*<br>***这是斜粗体***<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<p><strong>这是粗体</strong></p>
<p><del>这是删除线</del></p>
<p><u>这是下划线</u></p>
<p><em>这是斜体</em></p>
<p><strong><em>这是斜粗体</em></strong></p>
</blockquote>
<blockquote>
<p>快捷键：</p>
<ul>
<li>command + B   粗体</li>
<li>shift + control + `  删除线</li>
<li>command + U   下划线</li>
<li>command + I   斜体 </li>
</ul>
</blockquote>
<h2 id="3-分隔符"><a href="#3-分隔符" class="headerlink" title="3.分隔符"></a>3.分隔符</h2><blockquote>
<p>语法：</p>
<p>分割线：三个 — 或 三个 ***</p>
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">---<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<hr>
</blockquote>
<h2 id="4-脚注"><a href="#4-脚注" class="headerlink" title="4.脚注"></a>4.脚注</h2><blockquote>
<p>说明：脚注作用是对文本进行补充说明的</p>
<p>为此文本添加脚注[^键入文本]</p>
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">[^键入文本]<br>[^键入文本]:<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<p>为此文本添加脚注[^键入文本]</p>
</blockquote>
<h1 id="四、列表"><a href="#四、列表" class="headerlink" title="四、列表"></a>四、列表</h1><h2 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h2><blockquote>
<p>语法：星号 + 空格</p>
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">&gt;* <br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<p>1、只有同一级别</p>
<ul>
<li></li>
<li></li>
</ul>
<p>2、有子分类</p>
<ul>
<li>一级分类</li>
<li>二级分类<ul>
<li>三级分类</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h2><blockquote>
<p>语法：数字 + . + 空格</p>
</blockquote>
<blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">&gt;1. <br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<ol>
<li>这是第一个标题</li>
<li>这是第二个标题</li>
<li>这是第三个标题<ul>
<li>这是嵌套内容</li>
<li>这也是嵌套内容</li>
</ul>
<ol>
<li>这是新的嵌套</li>
<li>欧吼，又来一个嵌套</li>
</ol>
</li>
</ol>
</blockquote>
<h1 id="五、区块显示"><a href="#五、区块显示" class="headerlink" title="五、区块显示"></a>五、区块显示</h1><blockquote>
<p>代码：</p>
</blockquote>
<blockquote>
<p>效果：</p>
<blockquote>
<p>这是最外层的区块</p>
<blockquote>
<p>这是第二层区块</p>
<blockquote>
<p>这是第三层区块</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li><p>spring boot 技术</p>
<blockquote>
<p>spring boot 技术</p>
</blockquote>
</li>
<li><p>spring cloub技术</p>
<blockquote>
<p>spring cloub 技术</p>
</blockquote>
</li>
</ul>
<h1 id="六、代码块"><a href="#六、代码块" class="headerlink" title="六、代码块"></a>六、代码块</h1><blockquote>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;``` js /java/text<br>&gt;``` js<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">这就是代码块<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs c#">public class Text()&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h1 id="七、链接"><a href="#七、链接" class="headerlink" title="七、链接"></a>七、链接</h1><blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">www.baidu.com<br>[百度一下](https://www.baidu.com)<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果；</p>
<p><a href="http://www.baidu.com">www.baidu.com</a></p>
<p><a href="https://www.baidu.com">百度一下</a></p>
</blockquote>
<h1 id="八、图片插入"><a href="#八、图片插入" class="headerlink" title="八、图片插入"></a>八、图片插入</h1><blockquote>
<p>代码；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs tect">![自定义图片名称](图片路径)<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<p><img src="/Users/pro/Downloads/文件名"><span class="image-caption">This is picture!</span></p>
</blockquote>
<h1 id="九、表格"><a href="#九、表格" class="headerlink" title="九、表格"></a>九、表格</h1><blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">|表头|表中|表尾|<br>|----|----:|:----:|<br>|1|2|3|<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>表头</th>
<th style="text-align:right">表中</th>
<th style="text-align:center">表尾</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:right">2</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</blockquote>
<blockquote>
<p>快捷键：</p>
<ul>
<li>插入表格：command + alt + T</li>
</ul>
</blockquote>
<h1 id="十、其他操作"><a href="#十、其他操作" class="headerlink" title="十、其他操作"></a>十、其他操作</h1><blockquote>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs text">&lt;kbd&gt;&lt;/kbd&gt;<br>`内容`<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>效果：</p>
<p><kbd>Control</kbd></p>
<p><code>control</code></p>
</blockquote>
]]></content>
      <categories>
        <category>技巧</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>技巧，markdown，typora</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM</title>
    <url>/article/16813.html</url>
    <content><![CDATA[<p>1111</p>
]]></content>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/article/33708.html</url>
    <content><![CDATA[<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。</p>
<p><strong>AMQP</strong>（Advanced Message Queuing Protocol）高级消息队列协议，一个提供统一消息服务的应用层标准协议，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP是一个进程间传递异步消息的网络协议。</p>
<img src="/article/33708/AMQP%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90.png" class title="AMQP核心组成">
<blockquote>
<p><strong>Producer(生产者)</strong>:生产消息</p>
<p><strong>ConnectionFactory(连接工厂)</strong>:生产Connection的的工厂</p>
<p><strong>Connection(连接)</strong>:连接，应用程序与Broker的网络连接TCP/IP/三次握手和四次挥手。</p>
<p>AMQP连接通常是长连接。AMQP是一个使用 TCP提供可靠投递的应用层协议。AMQP 使用认证机制并且提供 TLS（SSL）保护。当一个应用不再需要连接到 AMQP 代理的时候，需要优雅的释放掉 AMQP 连接，而不是直接将 TCP 连接关闭。</p>
<p><strong>Channel(信道)</strong>:网络信道，是建立在Connection连接之上的一种轻量级的连接。几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立多各Channel，每个Channel代表一个会话任务。</p>
<p>大部分的业务操作是在Channel这个接口中完成的，包括:</p>
<p>队列的声明queueDeclare<br>交换机的声明exchangeDeclare<br>队列的绑定queueBind<br>发布消息basicPublish<br>消费消息basicConsume等。<br>Broker(中间件)</p>
<p><strong>VirtualHost(虚拟主机)</strong>:虚拟主机，用于进行逻辑隔离，一个虚拟主机理由可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名字的Exchange。</p>
<p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP 提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟 Web servers虚拟主机概念非常相似，这为 AMQP 实体提供了完全隔离的环境。当连接被建立的时候，AMQP 客户端来指定使用哪个虚拟主机。</p>
<p><strong>Exchange(交换机)</strong>:交换机，接受消息，根据路由键发送消息到绑定的队列（不具备消息存储的能力）。</p>
<p>交换机是用来发送消息的 AMQP 实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。</p>
<p><strong>Consumer(消费者)</strong>:消费者消费消息。在AMQP中，消费者获取待消费消息的途径有两种：</p>
<ul>
<li>消息中间件将消息投递给消费者（push API）</li>
<li>消费者主动获取消息 (pull API)</li>
</ul>
<p><strong>需要注意：多个消费者监听同一个队列时，队列中的消息只会被其中一个消费者消费（并不会每个消费者都消费一次）</strong></p>
<p><strong>Message(消息)</strong>:消息，服务与应用程序之间传送的数据，由Properties（属性）和body（主体）组成。属性是对消息进行修饰，比如消息的优先级，延迟等高级特性，主体则就是消息体的内容。</p>
</blockquote>
<p>优点：</p>
<ol>
<li>应用耦合</li>
<li>异步处理</li>
<li>流量削峰</li>
</ol>
<h3 id="RabbitMQ优势"><a href="#RabbitMQ优势" class="headerlink" title="RabbitMQ优势"></a><strong>RabbitMQ优势</strong></h3><ol>
<li>基于AMQP协议</li>
<li>高并发（是一个容量的概念，服务器可以接受的最大任务数量）</li>
<li>高性能（是一个速度的概念，单位时间内服务器可以处理的任务数）</li>
<li>高可用（是一个持久的概念，单位时间内服务器可以正常工作的时间比例）</li>
<li>强大的社区支持</li>
<li>支持插件</li>
<li>支持多语言</li>
</ol>
<h3 id="RabbitMQ界面"><a href="#RabbitMQ界面" class="headerlink" title="RabbitMQ界面"></a><strong>RabbitMQ界面</strong></h3><ol>
<li><p>概要</p>
<img src="/article/33708/%E6%A6%82%E8%A6%81.png" class title="概要">
</li>
<li><p>连接</p>
<img src="/article/33708/%E8%BF%9E%E6%8E%A5.png" class title="连接">
</li>
<li><p>通道</p>
<img src="/article/33708/%E9%80%9A%E9%81%93.png" class title="通道">
<ol>
<li>一个连接可以创建多个通道</li>
<li>一个应用或者一个线程，都是一个通道</li>
<li>在通道中创建队列，生产者的通道一般立马关闭，消费者是一只在监听，通道一直存在</li>
</ol>
</li>
<li><p>交换机</p>
<img src="/article/33708/%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" class title="交换机">
<p>| Type              | 解释                                                         |<br>| —————– | ———————————————————— |<br>| direct            | 它会把消息路由到那些 binding key 与 routing key 完全匹配的 Queue 中 |<br>| fanout            | 它会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中 |<br>| headers           | headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。（headers 类型的交换器性能差，不实用，基本不会使用。） |<br>| topic             | 与direct模型相比，多了个可以使用通配符                       |<br>| x-delayed-message | 延迟交换机，可以延迟接收消息                                 |</p>
<p>| <strong>Features</strong> | <strong>解释</strong>                                                     |<br>| ———— | ———————————————————— |<br>| D            | d 是 durable 的缩写，代表这个队列中的消息支持持久化          |<br>| AD           | ad 是 autoDelete 的缩写。代表当前队列的最后一个消费者退订时被自动删除。注意：此时不管队列中是否还存在消息，队列都会删除。 |<br>| excl         | 是 exclusive 的缩写。代表这是一个排他队列。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点：其一，排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一个连接创建的排他队列的。其二，“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同。其三，即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的。这种队列适用于只限于一个客户端发送读取消息的应用场景。 |<br>| Args         | 是 arguments 的缩写。代表该队列配置了 arguments 参数。       |<br>| TTL          | 是 x-message-ttl 的缩写。设置队列中的所有消息的生存周期(统一为整个队列的所有消息设置生命周期), 也可以在发布消息的时候单独为某个消息指定剩余生存时间，单位毫秒。 |<br>| Exp          | Auto Expire，是 x-expires 配置的缩写。当队列在指定的时间没有被访问(consume, basicGet, queueDeclare…)就会被删除，Features=Exp。注意这里是删除队列，不是队列中的消息。 |<br>| Lim          | 说明该队列配置了 x-max-length。限定队列的消息的最大值长度，超过指定长度将会把最早的几条删除掉。 |<br>| Lim B        | 说明队列配置了 x-max-length-bytes。限定队列最大占用的空间大小， 一般受限于内存、磁盘的大小。 |<br>| DLX          | 说明该队列配置了 x-dead-letter-exchange。当队列消息长度大于最大长度、或者过期的等，将从队列中删除的消息推送到指定的交换机中去而不是丢弃掉。 |<br>| DLK          | x-dead-letter-routing-key 的缩写，将删除的消息推送到指定交换机的指定路由键的队列中去。 |<br>| Pri          | x-max-priority 的缩写，优先级队列。表明该队列支持优先级，先定义最大优先级值(定义最大值一般不要太大)，在发布消息的时候指定该消息的优先级， 优先级更高（数值更大的）的消息先被消费。 |<br>| Ovfl         | x-overflow 的缩写。队列中的消息溢出时，如何处理这些消息。要么丢弃队列头部的消息，要么拒绝接收后面生产者发送过来的所有消息。有两个配置项：drop-head，代表丢弃队列头部的消息，默认行为；reject-publish 设置队列中的消息溢出后,该队列的行为:”拒绝接收”(所有消息)。 |<br>| ha-all       | 镜像队列。all 表示镜像到集群上的所有节点，ha-params 参数忽略。 |</p>
</li>
</ol>
<h3 id="七大示例"><a href="#七大示例" class="headerlink" title="七大示例"></a>七大示例</h3><ol>
<li><p>Hello World</p>
</li>
<li><p>工作队列</p>
<p>假如一共20条消息，A处理时间1s，B处理时间2s</p>
<ol>
<li><p>轮询</p>
<p>A，B同时拿到各自的10条消息，然后再处理，所以A经过10s处理完，B要经过20s才能处理完</p>
</li>
<li><p>公平</p>
<p>A和B不能直接拿到所有消息，设置<strong>int prefetchCount = 1</strong>表示消费者每次只能接收一条消息，只有处理完这条消息，才能处理下一条</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.basicQos(prefetchCount);<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<pre><code>这样A处理的快，所以A可以不断从信道中得到消息，B处理的比A慢，间隔2s才可以获得一条消息

**没有资源浪费**
</code></pre><ol start="3">
<li><p>发布订阅（使用交换机，使用广播模式<strong>fanout</strong>）</p>
<ol>
<li>生产者绑定交换机，将消息发送至交换机</li>
<li>交换机生成<strong>排他队列</strong>，然后将交换机与队列进行绑定</li>
<li>消费者监听对应队列的消息</li>
</ol>
<p>交换机将消息转发至队列，消费者可以收到生产发布的消息。 </p>
</li>
<li><p>路由队列（使用交换机，使用路由模式<strong>direct</strong>）</p>
<ol>
<li>生产者绑定交换机，并且定义不同的<strong>routingKey</strong>，生产者将携带不同<strong>routingKey</strong>的消息发送至交换机</li>
<li>交换机生成<strong>排他队列</strong>，同时将队列与交换机进行绑定，此时不同的队列绑定不同的<strong>routingKey</strong></li>
<li>消费者监听对应队列的消息</li>
</ol>
<p>交换机将携带不同的<strong>routingKey</strong>的消息转发至对应<strong>routingKey</strong>的队列，消费者可以收到生产发布的消息</p>
</li>
<li><p>主题队列（使用交换机，使用主题模式<strong>topic</strong>）</p>
<p>* 匹配一个字符串</p>
<p># 匹配0个或多个</p>
<p><strong>队列和交换机绑定才可以使用通配符，发送消息时必须使用具体的路由名称</strong></p>
</li>
<li><p>PRC模式</p>
<p>客户端同时是生产者和消费者，服务端者同时是生产者和消费者</p>
<p>客户端发送请求携带 <strong>reply_to</strong> 表示服务端收到消息后转发的队列名 以及 <strong>correlation_id</strong> 表示该消息的唯一id</p>
</li>
</ol>
<h3 id="RabbitMQ消息的事务机制"><a href="#RabbitMQ消息的事务机制" class="headerlink" title="RabbitMQ消息的事务机制"></a>RabbitMQ消息的事务机制</h3><ol>
<li>通过AMQP事务机制实现；</li>
<li>通过将channel设置成confirm模式来实现</li>
</ol>
<p><strong>两种事务控制形式不能同时开启</strong></p>
<h4 id="通过AMQP事务机制实现"><a href="#通过AMQP事务机制实现" class="headerlink" title="通过AMQP事务机制实现"></a>通过AMQP事务机制实现</h4><ol>
<li>txSelect() 将当前channel设置成transaction模式，即开启事务</li>
<li>txCommit() 提交事务</li>
<li>txRollback() 回滚事务</li>
</ol>
<p>在通过 txSelect() 开启事务之后，便可以发布消息给 broker 代理服务器了，如果 txCommit() 提交成功了，则消息一定到达了 broker 了,如果在 txCommit() 执行之前 broker 异常崩溃或者由于其他原因抛出异常，这个时候便可以捕获异常通过 txRollback() 回滚事务。</p>
<p><strong>缺点：降低RabbitMQ的性能</strong></p>
<h4 id="confirm确认模式"><a href="#confirm确认模式" class="headerlink" title="confirm确认模式"></a>confirm确认模式</h4><p>生产者将信道设置成 <strong>confirm</strong> 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个<strong>唯一的ID(从1开始)</strong>，<strong>一旦消息被投递到所有匹配的队列之后</strong>，broker 就会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了；</p>
<p>如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basicAck 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p>confirm模式最大的好处在于它是可以 异步 的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。</p>
<p>在 channel 被设置成 confirm 模式之后，所有被 publish 的后续消息都将被 confirm（即 ack）或者 nack 一次，但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm 又被 nack。</p>
<p><strong>实现方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开启确认发布</span><br>channel.confirmSelect();<br></code></pre></td></tr></table></figure>
<ol>
<li><p>普通 confirm 模式</p>
<p>这是一种简单的确认方式，它是一种 <strong>同步</strong> 确认发布的方式，也就是发布一个消息之后，只有收到了确认发布，后续的消息才能继续发布，waitForConfirms() 这个方法在消息被确认的时候返回true，如果在指定时间范围内，这个消息没有被确认那么它将返回false。</p>
<p>waitForConfirmsOrDie() 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内，这个消息没有被确认那么它将抛出异常。</p>
<p>这种确认方式有一个最大的缺点就是：发布速度特别的慢，因为如果没有收到确认发布的消息，就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。</p>
</li>
<li><p>批量 confirm 模式</p>
<p>先发布一批消息，然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：<strong>当发生故障导致发布出现问题时，不知道是哪个消息出现问题了</strong>，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是 同步的，也一样阻塞消息的发布。</p>
</li>
<li><p>异步 confirm 模式</p>
<p>channel 利用回调函数 ConfirmListener() 来达到消息可靠性传递的，这个回调函数只包含 deliveryTag(当前Channel发出的消息序号) ，需要自己手动维护一个 unconfirm 的消息序号集合，每发布一条消息，集合中元素+1 ， 每回调一次 <code>handleAck</code> 方法，unconfirm集合删除相应的一条或多条记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//信道添加监听回调函数</span><br>channel.addConfirmListener(<span class="hljs-keyword">new</span> ConfirmListener()&#123;<br>  <span class="hljs-comment">//重写 handleAck 回调方法</span><br>  <span class="hljs-comment">//deliveryTag 消息发送序号</span><br>  <span class="hljs-comment">//multiple 是否是多条</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleAck</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deliveryTag , <span class="hljs-keyword">boolean</span> multiple)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>    处理逻辑<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h2><p>Spring AMQP 是对 Spring 基于 AMQP 的消息收发解决方案，它是一个抽象层，不依赖于特定的 AMQP Broker 实现和客户端的抽象，所以可以很方便地替换。</p>
<h2 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h2><p><strong>邮箱中开启SMTP服务</strong></p>
<blockquote>
<p><strong>依赖</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;<br>  &lt;dependency&gt;<br> 		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  	&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br>  	&lt;version&gt;<span class="hljs-number">2.6</span><span class="hljs-number">.4</span>&lt;/version&gt;<br>  &lt;/dependency&gt;<br>  &lt;dependency&gt;<br>  	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  	&lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;<br>  	&lt;version&gt;<span class="hljs-number">2.6</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>  &lt;/dependency&gt;<br>  &lt;dependency&gt;<br>  	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  	&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;<br>  	&lt;version&gt;<span class="hljs-number">2.6</span><span class="hljs-number">.4</span>&lt;/version&gt;<br>  &lt;/dependency&gt;<br>  &lt;dependency&gt;<br>  	&lt;groupId&gt;com.boyolo&lt;/groupId&gt;<br>  	&lt;artifactId&gt;yeb-server&lt;/artifactId&gt;<br>  	&lt;version&gt;<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-SNAPSHOT&lt;/version&gt;<br>  &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>application.yml</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">server:<br>  #端口<br>  port: <span class="hljs-number">8082</span><br>spring:<br>  #邮件配置<br>  mail:<br>    #邮件服务器地址<br>    host: smtp<span class="hljs-number">.163</span>.com<br>    #协议<br>    protocol: smtp<br>    #编码格式<br>    <span class="hljs-keyword">default</span>-encoding: utf-<span class="hljs-number">8</span><br>    #授权码（在邮箱开通服务时获取）<br>    password: NBFXNQFSTKVDEBTN<br>    #发送者邮箱地址<br>    username: beau_renbo@<span class="hljs-number">163.</span>com<br>    #端口（不同邮箱端口号不同）<br>    port: <span class="hljs-number">25</span><br><br>  #rabbitmq配置<br>  rabbitmq:<br>    #用户名<br>    username: guest<br>    #密码<br>    password: guest<br>    #服务器地址<br>    host: localhost<br>    #端口<br>    port: <span class="hljs-number">5672</span><br>    listener:<br>      simple:<br>        #开启手动确认<br>        acknowledge-mode: manual<br><br>  redis:<br>    #超时时间<br>    timeout: 10000ms<br>    #服务器地址<br>    host: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>    #服务器端口<br>    port: <span class="hljs-number">6379</span><br>    #数据库<br>    database: <span class="hljs-number">0</span><br>    password: buzhidao<br>    lettuce:<br>      pool:<br>        #最大连接数<br>        max-active: <span class="hljs-number">1024</span><br>        #最大连接阻塞等待时间<br>        max-wait: 10000ms<br>        #最大空闲连接<br>        max-idle: <span class="hljs-number">200</span><br>        #最小空闲连接<br>        min-idle: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>设置邮件发送常量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.pojo;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailConstants</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息投递中</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer DELIVERING = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息投递成功</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer SUCCESS = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息投递失败</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer FAILURE = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最大尝试次数</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer MAX_TRY_COUNT = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息超时时间</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer MSG_TIMEOUT = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对列</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAIL_QUEUE_NAME = <span class="hljs-string">&quot;mail.queue&quot;</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换机</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAIL_EXCHANGE_NAME = <span class="hljs-string">&quot;mail.exchange&quot;</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 路由键</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAIL_ROUTING_KEY_NAME = <span class="hljs-string">&quot;mail.routing.key&quot;</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>邮件接收</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.mail;<br><br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.Employee;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.MailConstants;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.amqp.support.AmqpHeaders;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.mail.MailProperties;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.HashOperations;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.mail.javamail.JavaMailSender;<br><span class="hljs-keyword">import</span> org.springframework.mail.javamail.MimeMessageHelper;<br><span class="hljs-keyword">import</span> org.springframework.messaging.Message;<br><span class="hljs-keyword">import</span> org.springframework.messaging.MessageHeaders;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.thymeleaf.TemplateEngine;<br><span class="hljs-keyword">import</span> org.thymeleaf.context.Context;<br><span class="hljs-keyword">import</span> javax.mail.internet.MimeMessage;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailReceiver</span> </span>&#123;<br>  <span class="hljs-comment">//日志</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MailReceiver.class);<br>	<br>  <span class="hljs-comment">//邮件发送</span><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> JavaMailSender javaMailSender;<br>  <span class="hljs-comment">//邮件配置</span><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> MailProperties mailProperties;<br>  <span class="hljs-comment">//模版引擎 负责把对象数据呈现成文本数据</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1. 指令简单 - 内置不超过10个常用的指令.</span><br><span class="hljs-comment">	2. 基于XPath - 直接使用XPath查找对象,并且可以使用XPath强大的语法和函数.</span><br><span class="hljs-comment">	3. 容易扩展 - 无论是指令还是XPath函数都可以自定义.</span><br><span class="hljs-comment">	4. 解析超快 - 基于其语法特点,解析模板结构非常快.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> TemplateEngine templateEngine;<br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>  <span class="hljs-meta">@RabbitListener(queues = MailConstants.MAIL_QUEUE_NAME)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Message message, Channel channel)</span> </span>&#123;<br>    Employee employee = (Employee) message.getPayload();<br>    MessageHeaders headers = message.getHeaders();<br>    <span class="hljs-comment">//消息序号</span><br>    <span class="hljs-keyword">long</span> tag = (<span class="hljs-keyword">long</span>) headers.get(AmqpHeaders.DELIVERY_TAG);<br>    String msgId = (String) headers.get(<span class="hljs-string">&quot;spring_returned_message_correlation&quot;</span>);<br>    HashOperations hashOperations = redisTemplate.opsForHash();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (hashOperations.entries(<span class="hljs-string">&quot;mail_log&quot;</span>).containsKey(msgId)) &#123;<br>        LOGGER.error(<span class="hljs-string">&quot;消息已经被消费==========&gt;&#123;&#125;&quot;</span>, msgId);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 手动确认消息</span><br><span class="hljs-comment">                 * tag：消息序号</span><br><span class="hljs-comment">                 * multiple:是否确认多条</span><br><span class="hljs-comment">                 */</span><br>        channel.basicAck(tag, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <br>      MimeMessage msg = javaMailSender.createMimeMessage();<br>      MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(msg);<br>      <span class="hljs-comment">//发件人</span><br>      helper.setFrom(mailProperties.getUsername());<br>      <span class="hljs-comment">//收件人</span><br>      helper.setTo(employee.getEmail());<br>      <span class="hljs-comment">//主题</span><br>      helper.setSubject(<span class="hljs-string">&quot;入职欢迎邮件&quot;</span>);<br>      <span class="hljs-comment">//发送日期</span><br>      helper.setSentDate(<span class="hljs-keyword">new</span> Date());<br>      <br>      <span class="hljs-comment">//邮件内容</span><br>      Context context = <span class="hljs-keyword">new</span> Context();<br>      context.setVariable(<span class="hljs-string">&quot;name&quot;</span>, employee.getName());<br>      context.setVariable(<span class="hljs-string">&quot;posName&quot;</span>, employee.getPosition().getName());<br>      context.setVariable(<span class="hljs-string">&quot;jobLevelName&quot;</span>, employee.getJoblevel().getName());<br>      context.setVariable(<span class="hljs-string">&quot;departmentName&quot;</span>, employee.getDepartment().getName());<br><br>      String mail = templateEngine.process(<span class="hljs-string">&quot;mail&quot;</span>, context);<br>      helper.setText(mail, <span class="hljs-keyword">true</span>);<br><br>      javaMailSender.send(msg);<br>      LOGGER.info(<span class="hljs-string">&quot;邮件发送成功&quot;</span>);<br>      <span class="hljs-comment">//将消息Id存入redis</span><br>      hashOperations.put(<span class="hljs-string">&quot;mail_log&quot;</span>, msgId, <span class="hljs-string">&quot;OK&quot;</span>);<br>      <span class="hljs-comment">//手动确认消息</span><br>      channel.basicAck(tag, <span class="hljs-keyword">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 手动确认消息</span><br><span class="hljs-comment">                 * tag：消息序号</span><br><span class="hljs-comment">                 * multiple:是否确认多条</span><br><span class="hljs-comment">                 * requeue:是否退回队列</span><br><span class="hljs-comment">                 */</span><br>        channel.basicNack(tag, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (IOException ioException) &#123;<br>        LOGGER.error(<span class="hljs-string">&quot;邮件发送失败========&gt;&#123;&#125;&quot;</span>, e.getMessage());<br>      &#125;<br>      LOGGER.error(<span class="hljs-string">&quot;邮件发送失败========&gt;&#123;&#125;&quot;</span>, e.getMessage());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>EmployeeServiceImpl.java</strong> 添加员工发送消息时消息可靠性–消息落库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == employeeMapper.insert(employee)) &#123;<br><br>  Employee emp = employeeMapper.getEmployee(employee.getId()).get(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">//数据库记录发送的消息</span><br>  String msgId = UUID.randomUUID().toString();<br>  <span class="hljs-comment">//            String msgId = &quot;123456&quot;;</span><br>  MailLog mailLog = <span class="hljs-keyword">new</span> MailLog();<br>  mailLog.setMsgId(msgId);<br>  mailLog.setEid(employee.getId());<br>  mailLog.setStatus(<span class="hljs-number">0</span>);<br>  mailLog.setRouteKey(MailConstants.MAIL_ROUTING_KEY_NAME);<br>  mailLog.setExchange(MailConstants.MAIL_EXCHANGE_NAME);<br>  mailLog.setCount(<span class="hljs-number">0</span>);<br>  mailLog.setTryTime(LocalDateTime.now().plusMinutes(MailConstants.MSG_TIMEOUT));<br>  mailLog.setCreateTime(LocalDateTime.now());<br>  mailLog.setUpdateTime(LocalDateTime.now());<br>  mailLogMapper.insert(mailLog);<br><br>  <span class="hljs-comment">//发送信息</span><br>  rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME, MailConstants.MAIL_ROUTING_KEY_NAME, emp, <span class="hljs-keyword">new</span> CorrelationData(msgId));<br><br>  <span class="hljs-keyword">return</span> RespBean.success(<span class="hljs-string">&quot;添加成功！&quot;</span>);<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>RabbitMQ配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.config;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.MailConstants;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.MailLog;<br><span class="hljs-keyword">import</span> com.boyolo.server.service.IMailLogService;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Binding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.BindingBuilder;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.DirectExchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.connection.CachingConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RabbitMq 配置类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMqConfig</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(RabbitMqConfig.class);<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> CachingConnectionFactory cachingConnectionFactory;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> IMailLogService mailLogService;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> RabbitTemplate <span class="hljs-title">rabbitTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>    RabbitTemplate rabbitTemplate = <span class="hljs-keyword">new</span> RabbitTemplate(cachingConnectionFactory);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消息确认回调，确认消息是否到达broker</span><br><span class="hljs-comment">         * data:消息唯一标识</span><br><span class="hljs-comment">         * ack：确认结果</span><br><span class="hljs-comment">         * cause：失败原因</span><br><span class="hljs-comment">         */</span><br>    rabbitTemplate.setConfirmCallback((data, ack, cause) -&gt; &#123;<br>      String msgId = data.getId();<br>      <span class="hljs-keyword">if</span> (ack) &#123;<br>        LOGGER.info(<span class="hljs-string">&quot;&#123;&#125;========&gt;消息发送成功&quot;</span>, msgId);<br>        mailLogService.update(<span class="hljs-keyword">new</span> UpdateWrapper&lt;MailLog&gt;().set(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">1</span>).eq(<span class="hljs-string">&quot;msgID&quot;</span>, msgId));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        LOGGER.error(<span class="hljs-string">&quot;&#123;&#125;========&gt;消息发送失败&quot;</span>, msgId);<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消息失败回调  比如route不到queue</span><br><span class="hljs-comment">         * smg：消息主题</span><br><span class="hljs-comment">         * repCode：响应码</span><br><span class="hljs-comment">         * repTExt：响应，描述</span><br><span class="hljs-comment">         * exchange：交换机</span><br><span class="hljs-comment">         * routingkey：路由键</span><br><span class="hljs-comment">         */</span><br><br>    <span class="hljs-comment">//        rabbitTemplate.setReturnCallback((msg, repCode, repText, exchange, routingkey)</span><br>    rabbitTemplate.setReturnsCallback((msg) -&gt; &#123;<br>      LOGGER.error(<span class="hljs-string">&quot;&#123;&#125;========&gt;消息发送queue时失败&quot;</span>,msg.getMessage().getBody());<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> rabbitTemplate;<br>  &#125;<br><br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(MailConstants.MAIL_QUEUE_NAME);<br>  &#125;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(MailConstants.MAIL_EXCHANGE_NAME);<br>  &#125;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">binding</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(queue()).to(directExchange()).with(MailConstants.MAIL_ROUTING_KEY_NAME);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>邮件发送定时任务–失败重传</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.task;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.Employee;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.MailConstants;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.MailLog;<br><span class="hljs-keyword">import</span> com.boyolo.server.service.IEmployeeService;<br><span class="hljs-keyword">import</span> com.boyolo.server.service.IMailLogService;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Scheduled;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 邮件发送定时任务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailTask</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> IMailLogService mailLogService;<br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> IEmployeeService employeeService;<br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮件发送定时任务</span><br><span class="hljs-comment">     * 10s一次</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-meta">@Scheduled(cron = &quot;0/10 * * * * ?&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailTask</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;MailLog&gt; list = mailLogService.list(<span class="hljs-keyword">new</span> QueryWrapper&lt;MailLog&gt;().eq(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">0</span>).lt(<span class="hljs-string">&quot;tryTime&quot;</span>, LocalDateTime.now()));<br>    list.forEach(mailLog -&gt; &#123;<br>      <span class="hljs-comment">//如果重试次数超过三次，更新状态为投递失败，不再重试</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> &lt;= mailLog.getCount())&#123;<br>        mailLogService.update(<span class="hljs-keyword">new</span> UpdateWrapper&lt;MailLog&gt;().set(<span class="hljs-string">&quot;status&quot;</span>,<span class="hljs-number">2</span>).eq(<span class="hljs-string">&quot;msgId&quot;</span>,mailLog.getMsgId()));<br>      &#125;<br>      mailLogService.update(<span class="hljs-keyword">new</span> UpdateWrapper&lt;MailLog&gt;().set(<span class="hljs-string">&quot;count&quot;</span>,mailLog.getCount()+<span class="hljs-number">1</span>).set(<span class="hljs-string">&quot;updateTime&quot;</span>,LocalDateTime.now()).set(<span class="hljs-string">&quot;tryTime&quot;</span>,LocalDateTime.now().plusMinutes(MailConstants.MSG_TIMEOUT)).eq(<span class="hljs-string">&quot;msgId&quot;</span>,mailLog.getMsgId()));<br>      Employee employee = employeeService.getEmployee(mailLog.getEid()).get(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">//重新发送消息</span><br>      rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME,MailConstants.MAIL_ROUTING_KEY_NAME,employee,<span class="hljs-keyword">new</span> CorrelationData(mailLog.getMsgId()));<br><br>    &#125;);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="RabbitMQ消息可靠性"><a href="#RabbitMQ消息可靠性" class="headerlink" title="RabbitMQ消息可靠性"></a>RabbitMQ消息可靠性</h2><p>保证消息百分百发送到消息队列中去</p>
<ul>
<li>保证mq节点成功接受消息</li>
<li>消息发送端需要接受到mq服务端接受到消息的确认应答</li>
<li>完善的消息补偿机制，发送失败的消息可以再感知并⼆次处理</li>
</ul>
<img src="/article/33708/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%83%85%E5%86%B5.png" class title="消息丢失可能的情况">
<ol>
<li><p>确保生产者发送的消息被rabbitmq接收了；</p>
<p><a href="#RabbitMQ消息的事务机制">RabbitMQ事务</a></p>
</li>
<li><p>确保队列中的消息能够持久化；</p>
<ol>
<li><p>创建 queue 的时候将其设置为持久化</p>
<p>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</p>
</li>
<li><p>第二个是发送消息的时候将消息的 deliveryMode 设置为 2</p>
<p>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</p>
</li>
</ol>
<p><strong>必须要同时设置这两个持久化才行</strong></p>
</li>
<li><p>确保消费者已经把消息处理完了。</p>
<p>RabbitMQ提供了<strong>消息确认机制</strong></p>
<p>消费者在订阅队列时，可以指定autoAck参数，</p>
<ol>
<li><p>当autoAck等于false时，RabbitMQ 会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。</p>
</li>
<li><p>当autoAck等于true时，RabbitMQ会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正的消费到了这些消息。</p>
</li>
<li><p>RabbitMQ不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开，这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring集成谷歌验证码</title>
    <url>/article/54334.html</url>
    <content><![CDATA[<blockquote>
<p><strong>添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- google kaptcha依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.axet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kaptcha<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>配置类 CaptchaConfig.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.config;<br><br><span class="hljs-keyword">import</span> com.google.code.kaptcha.impl.DefaultKaptcha;<br><span class="hljs-keyword">import</span> com.google.code.kaptcha.util.Config;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaptchaConfig</span> </span>&#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultKaptcha <span class="hljs-title">defaultKaptcha</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//验证码生成器</span><br>    DefaultKaptcha defaultKaptcha = <span class="hljs-keyword">new</span> DefaultKaptcha();<br>    <span class="hljs-comment">//配置</span><br>    Properties properties = <span class="hljs-keyword">new</span> Properties();<br>    <span class="hljs-comment">//是否有边框</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.border&quot;</span>, <span class="hljs-string">&quot;yes&quot;</span>);<br>    <span class="hljs-comment">//设置边框颜色</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.border.color&quot;</span>, <span class="hljs-string">&quot;105,179,90&quot;</span>);<br>    <span class="hljs-comment">//边框粗细度，默认为1</span><br>    <span class="hljs-comment">// properties.setProperty(&quot;kaptcha.border.thickness&quot;,&quot;1&quot;);</span><br>    <span class="hljs-comment">//验证码</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.session.key&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>);<br>    <span class="hljs-comment">//验证码文本字符颜色 默认为黑色</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.color&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>);<br>    <span class="hljs-comment">//设置字体样式</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.names&quot;</span>, <span class="hljs-string">&quot;宋体,楷体,微软雅黑&quot;</span>);<br>    <span class="hljs-comment">//字体大小，默认40</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.size&quot;</span>, <span class="hljs-string">&quot;30&quot;</span>);<br>    <span class="hljs-comment">//验证码文本字符内容范围 默认为abced2345678gfynmnpwx</span><br>    <span class="hljs-comment">// properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;&quot;);</span><br>    <span class="hljs-comment">//字符长度，默认为5</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);<br>    <span class="hljs-comment">//字符间距 默认为2</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.char.space&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);<br>    <span class="hljs-comment">//验证码图片宽度 默认为200</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.image.width&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>    <span class="hljs-comment">//验证码图片高度 默认为40</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.image.height&quot;</span>, <span class="hljs-string">&quot;40&quot;</span>);<br>    Config config = <span class="hljs-keyword">new</span> Config(properties);<br>    defaultKaptcha.setConfig(config);<br>    <span class="hljs-keyword">return</span> defaultKaptcha;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>CaptchaController</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.controller;<br><span class="hljs-keyword">import</span> com.google.code.kaptcha.impl.DefaultKaptcha;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaptchaController</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> DefaultKaptcha defaultKaptcha;<br><br>  <span class="hljs-meta">@ApiOperation(value = &quot;验证码&quot;)</span><br>  <span class="hljs-meta">@GetMapping(value = &quot;/captcha&quot;, produces = &quot;image/jpeg&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">captcha</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    <span class="hljs-comment">// 定义response输出类型为image/jpeg类型</span><br>    response.setDateHeader(<span class="hljs-string">&quot;Expires&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// Set standard HTTP/1.1 no-cache headers.</span><br>    response.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-store, no-cache, must-revalidate&quot;</span>);<br>    <span class="hljs-comment">// Set IE extended HTTP/1.1 no-cache headers (use addHeader).</span><br>    response.addHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;post-check=0, pre-check=0&quot;</span>);<br>    <span class="hljs-comment">// Set standard HTTP/1.0 no-cache header.</span><br>    response.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);<br>    <span class="hljs-comment">// return a jpeg</span><br>    response.setContentType(<span class="hljs-string">&quot;image/jpeg&quot;</span>);<br>    <span class="hljs-comment">//-------------------生成验证码 begin ------------------------</span><br>    <span class="hljs-comment">//获取验证码文本内容</span><br>    String text = defaultKaptcha.createText();<br>    System.out.println(<span class="hljs-string">&quot;验证码内容：&quot;</span> + text);<br>    <span class="hljs-comment">//将验证码放入session中</span><br>    request.getSession().setAttribute(<span class="hljs-string">&quot;captcha&quot;</span>, text);<br>    <span class="hljs-comment">//根据文本内容创建图形验证码</span><br>    BufferedImage image = defaultKaptcha.createImage(text);<br>    ServletOutputStream outputStream = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      outputStream = response.getOutputStream();<br>      <span class="hljs-comment">//输出流输出图片，格式jpg</span><br>      ImageIO.write(image, <span class="hljs-string">&quot;jpg&quot;</span>, outputStream);<br>      outputStream.flush();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != outputStream) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          outputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//-------------------生成验证码 end --------------------------</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>验证码</category>
      </categories>
      <tags>
        <tag>Java,Spring,验证码</tag>
      </tags>
  </entry>
  <entry>
    <title>位图</title>
    <url>/article/9386.html</url>
    <content><![CDATA[<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>位图是通过将数组下标与应用中的一些值关联映射，数组中该下标所指定的位置上的元素可以用来标识应用中值的情况（是否存在或者数目 或者计数等），位图数组中每个元素在内存中占用1位，所以可以节省存储空间。位图是一种非常简洁快速的数据结构，它能同时使存储空间和速度最优化。</p>
<blockquote>
<p>有 1 千万个整数，整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？</p>
</blockquote>
<blockquote>
<p>可以使用一种比较“特殊”的散列表，那就是位图。</p>
<p>申请一个大小为 1 亿、数据类型为布尔类型（true 或者 false）的数组。<br>将这 1 千万个整数作为数组下标，将对应的数组值设置成 true。比如，整数 5 对应下标为 5 的数组值设置为 true，也就是 array[5]=true。</p>
<p>查询某个整数 K 是否在这 1 千万个整数中的时候，只需要将对应的数组值 array[K]取出来，看是否等于 true。如果等于 true，那说明 1 千万整数中包含这个整数 K；相反，就表示不包含这个整数 K。</p>
</blockquote>
<p>很多语言中提供的布尔类型，大小是 1 个字节的，并不能节省太多内存空间。实际上，表示 true 和 false 两个值，只需要用一个二进制位（bit）就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitMap</span> </span>&#123; <span class="hljs-comment">// Java中char类型占16bit，也即是2个字节</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] bytes;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> nbits;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BitMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nbits)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.nbits = nbits;<br>    <span class="hljs-keyword">this</span>.bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[nbits/<span class="hljs-number">16</span>+<span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k &gt; nbits) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> byteIndex = k / <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">int</span> bitIndex = k % <span class="hljs-number">16</span>;<br>    bytes[byteIndex] |= (<span class="hljs-number">1</span> &lt;&lt; bitIndex);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k &gt; nbits) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> byteIndex = k / <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">int</span> bitIndex = k % <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (bytes[byteIndex] &amp; (<span class="hljs-number">1</span> &lt;&lt; bitIndex)) != <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>散列表是存储已有数据，而位图存储的是范围</p>
<blockquote>
<p>比如有1、1000、1000000 ，散列表只需要存储三次，而位图首先需要1000000位才可以存储</p>
<p><strong>问题：</strong></p>
<p>如果数字的范围很大，数字范围不是 1 到 1 亿，而是 1 到 10 亿，那位图的大小就是 10 亿个二进制位，消耗内存就很大</p>
<p><strong>解决方法：布隆过滤器</strong></p>
</blockquote>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>对位图这种数据结构的一种改进</p>
<blockquote>
<p>数据个数是 1 千万，数据的范围是 1 到 10 亿</p>
<p><strong>布隆过滤器</strong>的做法是，仍然使用一个 1 亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这 1 到 1 亿范围内。</p>
<p>比如把哈希函数设计成 f(x)=x%n。其中，x 表示数字，n 表示位图的大小（1 亿），也就是，对数字跟位图的大小进行取模求余。</p>
<p><strong>问题：</strong>哈希函数会存在冲突</p>
</blockquote>
<p>一个哈希函数可能会存在冲突，用多个哈希函数一块儿定位一个数据</p>
<p><strong>布隆过滤器</strong></p>
<ol>
<li>使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值分别记作 X<sub>1</sub>，X<sub>2</sub>，X<sub>3</sub>，…，X<sub>k</sub></li>
<li>把这 K 个数字作为位图中的下标，将对应的 BitMap[X<sub>1</sub>]，BitMap[X<sub>2</sub>]，BitMap[X<sub>3</sub>]，…，BitMap[X<sub>k</sub>]都设置成 true</li>
<li>用 K 个二进制位，来表示一个数字的存在。当查询某个数字是否存在的时候，用同样的 K 个哈希函数，对这个数字求哈希值，分别得到 Y<sub>1</sub>，Y<sub>2</sub>，Y<sub>3</sub>，…，Y<sub>k</sub>。</li>
<li>看这 K 个哈希值，对应位图中的数值是否都为 true，如果都是 true，则说明，这个数字存在，如果有其中任意一个不为 true，那就说明这个数字不存在。</li>
</ol>
<blockquote>
<p><strong>问题：容易误判</strong></p>
<img src="/article/9386/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AF%E5%88%A4%E6%83%85%E5%86%B5.jpg" class title="布隆过滤器误判情况">
</blockquote>
<p>尽管布隆过滤器会存在误判，但是，这并不影响它发挥大作用。</p>
<blockquote>
<p><strong>布隆过滤器与散列表</strong></p>
<p>布隆过滤器用多个哈希函数对同一个网页链接进行处理，CPU 只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是 CPU 密集型的。而在散列表的处理方式中，需要读取散列值相同（散列冲突）的多个网页链接，分别跟待判重的网页链接，进行字符串匹配。这个操作涉及很多内存数据的读取，所以是内存密集型的。</p>
<p>CPU 计算可能是要比内存访问更快速的，所以，理论上讲，布隆过滤器的判重方式，更加快速。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>位图</category>
      </categories>
      <tags>
        <tag>数据结构与算法,位图</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/article/55046.html</url>
    <content><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划比较适合用来求解最优问题</p>
<p>动态规划解决问题的思路:</p>
<p>把问题分解为多个阶段，每个阶段对应一个决策。记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。</p>
<h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><blockquote>
<p>对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回溯算法实现。注意：我把输入的变量都定义成了成员变量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">// 结果放到maxW中</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] weight = &#123;<span class="hljs-number">2</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 物品重量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// 物品个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">9</span>; <span class="hljs-comment">// 背包承受的最大重量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw)</span> </span>&#123; <span class="hljs-comment">// 调用f(0, 0)</span><br>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w表示装满了，i==n表示物品都考察完了</span><br>    <span class="hljs-keyword">if</span> (cw &gt; maxW) maxW = cw;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  f(i+<span class="hljs-number">1</span>, cw); <span class="hljs-comment">// 选择不装第i个物品</span><br>  <span class="hljs-keyword">if</span> (cw + weight[i] &lt;= w) &#123;<br>    f(i+<span class="hljs-number">1</span>,cw + weight[i]); <span class="hljs-comment">// 选择装第i个物品</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/55046/%E5%9B%9E%E6%BA%AF%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.jpg" class title="回溯求解过程">
<p>递归树中的每个节点表示一种状态，用（i, cw）来表示。其中，i （从0开始）表示将要决策第几个物品是否装入背包，cw 表示当前背包中物品的总重量。比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。</p>
<p>有些子问题的求解是重复的，记录已经计算好的 f(i, cw)，当再次计算到重复的 f(i, cw) 的时候，可以直接从备忘录中取出来用，就不用再递归计算了，这样就可以避免冗余计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">// 结果放到maxW中</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] weight = &#123;<span class="hljs-number">2</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 物品重量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// 物品个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">9</span>; <span class="hljs-comment">// 背包承受的最大重量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[][] mem = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">5</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// 备忘录，默认值false</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw)</span> </span>&#123; <span class="hljs-comment">// 调用f(0, 0)</span><br>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w表示装满了，i==n表示物品都考察完了</span><br>    <span class="hljs-keyword">if</span> (cw &gt; maxW) maxW = cw;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (mem[i][cw]) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 重复状态</span><br>  mem[i][cw] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 记录(i, cw)这个状态</span><br>  f(i+<span class="hljs-number">1</span>, cw); <span class="hljs-comment">// 选择不装第i个物品</span><br>  <span class="hljs-keyword">if</span> (cw + weight[i] &lt;= w) &#123;<br>    f(i+<span class="hljs-number">1</span>,cw + weight[i]); <span class="hljs-comment">// 选择装第i个物品</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>动态规划</strong></p>
<p>把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。</p>
<p>把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量），就成功避免了每层状态个数的指数级增长。</p>
<p>用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。</p>
<blockquote>
<p>第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态。</p>
<p>第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。用 states[1][0]=true，states[1][2]=true，states[1][4]=true 来表示这三种状态。</p>
<p>以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。图中 0 表示 false，1 表示 true。只需要在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。</p>
<img src="/article/55046/0-1%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E5%9B%BE1.jpg" class title="0-1背包动态规划状态图1">
<img src="/article/55046/0-1%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E5%9B%BE2.jpg" class title="0-1背包动态规划状态图2">
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//weight:物品重量，n:物品个数，w:背包可承载重量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] weight, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>  <span class="hljs-keyword">boolean</span>[][] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][w+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 默认值false</span><br>  states[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span><br>  <span class="hljs-keyword">if</span> (weight[<span class="hljs-number">0</span>] &lt;= w) &#123;<br>    states[<span class="hljs-number">0</span>][weight[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 动态规划状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w; ++j) &#123;<span class="hljs-comment">// 不把第i个物品放入背包</span><br>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j] == <span class="hljs-keyword">true</span>) states[i][j] = states[i-<span class="hljs-number">1</span>][j];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w-weight[i]; ++j) &#123;<span class="hljs-comment">//把第i个物品放入背包</span><br>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j]==<span class="hljs-keyword">true</span>) states[i][j+weight[i]] = <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = w; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (states[n-<span class="hljs-number">1</span>][i] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span> i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度:耗时最多的部分就是代码中的两层 for 循环，所以时间复杂度是 <strong>O(n*w)</strong>。n 表示物品个数，w 表示背包可以承载的总重量。</p>
<p><strong>动态规划优化</strong></p>
<p>需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。需要一个大小为 w+1 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] items, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>  <span class="hljs-keyword">boolean</span>[] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[w+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 默认值false</span><br>  states[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span><br>  <span class="hljs-keyword">if</span> (items[<span class="hljs-number">0</span>] &lt;= w) &#123;<br>    states[items[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 动态规划</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = w-items[i]; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<span class="hljs-comment">//把第i个物品放入背包</span><br>      <span class="hljs-keyword">if</span> (states[j]==<span class="hljs-keyword">true</span>) states[j+items[i]] = <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = w; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (states[i] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span> i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="0-1-背包问题升级版"><a href="#0-1-背包问题升级版" class="headerlink" title="0-1 背包问题升级版"></a>0-1 背包问题升级版</h3><p>引入物品价值这一变量</p>
<blockquote>
<p>对于一组不同重量、不同价值、不可分割的物品，选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p>
</blockquote>
<blockquote>
<p><strong>回溯算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxV = Integer.MIN_VALUE; <span class="hljs-comment">// 结果放到maxV中</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] items = &#123;<span class="hljs-number">2</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 物品的重量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] value = &#123;<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">8</span>，<span class="hljs-number">9</span>，<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">// 物品的价值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// 物品个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">9</span>; <span class="hljs-comment">// 背包承受的最大重量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw, <span class="hljs-keyword">int</span> cv)</span> </span>&#123; <span class="hljs-comment">// 调用f(0, 0, 0)</span><br>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w表示装满了，i==n表示物品都考察完了</span><br>    <span class="hljs-keyword">if</span> (cv &gt; maxV) maxV = cv;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  f(i+<span class="hljs-number">1</span>, cw, cv); <span class="hljs-comment">// 选择不装第i个物品</span><br>  <span class="hljs-keyword">if</span> (cw + weight[i] &lt;= w) &#123;<br>    f(i+<span class="hljs-number">1</span>,cw+weight[i], cv+value[i]); <span class="hljs-comment">// 选择装第i个物品</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/55046/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8D%87%E7%BA%A7%E7%89%88%E5%9B%9E%E6%BA%AF%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="背包问题升级版回溯递归树">
<p>在递归树中，每个节点表示一个状态。现在需要 3 个变量（i, cw, cv）来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值。</p>
<p>在递归树中，有几个节点的 i 和 cw 是完全相同的，比如 f(2,2,4) 和 f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。</p>
<p><strong>对于 (i, cw) 相同的不同状态，只需要保留 cv 值最大的那个，继续递归处理，其他状态不予考虑。</strong></p>
</blockquote>
<p><strong>动态规划</strong></p>
<p>把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。</p>
<p>用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] weight, <span class="hljs-keyword">int</span>[] value, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[][] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][w+<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 初始化states</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; w+<span class="hljs-number">1</span>; ++j) &#123;<br>      states[i][j] = -<span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  states[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (weight[<span class="hljs-number">0</span>] &lt;= w) &#123;<br>    states[<span class="hljs-number">0</span>][weight[<span class="hljs-number">0</span>]] = value[<span class="hljs-number">0</span>];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">//动态规划，状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w; ++j) &#123; <span class="hljs-comment">// 不选择第i个物品</span><br>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j] &gt;= <span class="hljs-number">0</span>) states[i][j] = states[i-<span class="hljs-number">1</span>][j];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w-weight[i]; ++j) &#123; <span class="hljs-comment">// 选择第i个物品</span><br>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> v = states[i-<span class="hljs-number">1</span>][j] + value[i];<br>        <span class="hljs-keyword">if</span> (v &gt; states[i][j+weight[i]]) &#123;<br>          states[i][j+weight[i]] = v;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 找出最大值</span><br>  <span class="hljs-keyword">int</span> maxvalue = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w; ++j) &#123;<br>    <span class="hljs-keyword">if</span> (states[n-<span class="hljs-number">1</span>][j] &gt; maxvalue) maxvalue = states[n-<span class="hljs-number">1</span>][j];<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxvalue;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="动态规划：一个模型三个特征"><a href="#动态规划：一个模型三个特征" class="headerlink" title="动态规划：一个模型三个特征"></a>动态规划：一个模型三个特征</h3><ol>
<li><p>多阶段决策最优解模型</p>
<p>一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p>
</li>
<li><p>最优子结构特征</p>
<p>最优子结构指的是，问题的最优解包含子问题的最优解。</p>
<p>可以通过子问题的最优解，推导出问题的最优解。后面阶段的状态可以通过前面阶段的状态推导出来。</p>
</li>
<li><p>无后效性特征</p>
<ol>
<li>在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的</li>
<li>某阶段状态一旦确定，就不受之后阶段的决策影响</li>
</ol>
</li>
<li><p>重复子问题</p>
<p>不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态</p>
</li>
</ol>
<h4 id="“一个模型三个特征”实例剖析"><a href="#“一个模型三个特征”实例剖析" class="headerlink" title="“一个模型三个特征”实例剖析"></a>“一个模型三个特征”实例剖析</h4><blockquote>
<p>假设有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p>
<img src="/article/55046/%E6%A3%8B%E5%AD%90%E5%AE%9E%E4%BE%8B.jpg" class title="棋子实例">
</blockquote>
<ol>
<li><p>一个模型</p>
<p>从 (0, 0) 走到 (n-1, n-1)，总共要走 2*(n-1) 步，也就对应着 2*(n-1) 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。</p>
<p>把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动态规划的模型。</p>
<img src="/article/55046/%E6%A3%8B%E5%AD%90%E5%AE%9E%E4%BE%8B%E5%A4%9A%E9%98%B6%E6%AE%B5%E5%86%B3%E7%AD%96%E6%9C%80%E4%BC%98%E8%A7%A3%E6%A8%A1%E5%9E%8B.jpg" class title="棋子实例多阶段决策最优解模型">
</li>
<li><p>三个特征</p>
<p>如果我们走到 (i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动，也就是说，想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“无后效性”这一特征。</p>
<p>定义状态的时候，从起始位置 (0, 0) 到 (i, j) 的最小路径，记作 min_dist(i, j)。只有可能从 (i, j-1) 或者 (i-1, j) 两个位置到达 (i, j)。也就是说，到达 (i, j) 的最短路径要么经过 (i, j-1)，要么经过 (i-1, j)，而且到达 (i, j) 的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist(i, j) 可以通过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来。这就说明，这个问题符合“最优子结构”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">min_dist(i, j) = w[i][j] + min(min_dist(i, j-<span class="hljs-number">1</span>), min_dist(i-<span class="hljs-number">1</span>, j))<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h3><h4 id="状态转移表法"><a href="#状态转移表法" class="headerlink" title="状态转移表法"></a>状态转移表法</h4><p>状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p>
<blockquote>
<p>矩阵最短路径问题</p>
<p>画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。</p>
<img src="/article/55046/%E7%9F%A9%E9%98%B5%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%981.jpg" class title="矩阵最短路径问题1">
<img src="/article/55046/%E7%9F%A9%E9%98%B5%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%982.jpg" class title="矩阵最短路径问题2">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistDP</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[][] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123; <span class="hljs-comment">// 初始化states的第一行数据</span><br>    sum += matrix[<span class="hljs-number">0</span>][j];<br>    states[<span class="hljs-number">0</span>][j] = sum;<br>  &#125;<br>  sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 初始化states的第一列数据</span><br>    sum += matrix[i][<span class="hljs-number">0</span>];<br>    states[i][<span class="hljs-number">0</span>] = sum;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>      states[i][j] = <br>            matrix[i][j] + Math.min(states[i][j-<span class="hljs-number">1</span>], states[i-<span class="hljs-number">1</span>][j]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> states[n-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="状态转移方程法"><a href="#状态转移方程法" class="headerlink" title="状态转移方程法"></a>状态转移方程法</h4><p>状态转移方程法有点类似递归的解题思路。需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。</p>
<blockquote>
<p>矩阵最短路径问题</p>
<p>状态转移方程:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>状态转移方程是解决动态规划的关键</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] matrix = <br>         &#123;&#123;<span class="hljs-number">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">5</span>，<span class="hljs-number">9</span>&#125;, &#123;<span class="hljs-number">2</span>，<span class="hljs-number">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>&#125;，&#123;<span class="hljs-number">5</span>，<span class="hljs-number">2</span>，<span class="hljs-number">6</span>，<span class="hljs-number">7</span>&#125;，&#123;<span class="hljs-number">6</span>，<span class="hljs-number">8</span>，<span class="hljs-number">4</span>，<span class="hljs-number">3</span>&#125;&#125;;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mem = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDist</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123; <span class="hljs-comment">// 调用minDist(n-1, n-1);</span><br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">if</span> (mem[i][j] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> mem[i][j];<br>  <span class="hljs-keyword">int</span> minLeft = Integer.MAX_VALUE;<br>  <span class="hljs-keyword">if</span> (j-<span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>    minLeft = minDist(i, j-<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">int</span> minUp = Integer.MAX_VALUE;<br>  <span class="hljs-keyword">if</span> (i-<span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>    minUp = minDist(i-<span class="hljs-number">1</span>, j);<br>  &#125;<br>  <br>  <span class="hljs-keyword">int</span> currMinDist = matrix[i][j] + Math.min(minLeft, minUp);<br>  mem[i][j] = currMinDist;<br>  <span class="hljs-keyword">return</span> currMinDist;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="动态规划实战"><a href="#动态规划实战" class="headerlink" title="动态规划实战"></a>动态规划实战</h3><blockquote>
<p>如何实现搜索引擎中的拼写纠错功能？</p>
<p>在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出拼写错误，并且用对应的正确单词来进行搜索</p>
</blockquote>
<h4 id="量化两个字符串的相似度"><a href="#量化两个字符串的相似度" class="headerlink" title="量化两个字符串的相似度"></a>量化两个字符串的相似度</h4><p><strong>编辑距离（Edit Distance）</strong></p>
<p>编辑距离指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。</p>
<p>编辑距离有多种不同的计算方式，比较著名的有莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）。</p>
<p>其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，莱文斯坦距离的大小，表示两个字符串差异的大小；最长公共子串长度只允许增加、删除字符这两个编辑操作，最长公共子串的大小，表示两个字符串相似程度的大小。</p>
<img src="/article/55046/%E8%8E%B1%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6.jpg" class title="莱文斯坦距离与最长公共子串长度">
<h4 id="计算莱文斯坦距离"><a href="#计算莱文斯坦距离" class="headerlink" title="计算莱文斯坦距离"></a><strong>计算莱文斯坦距离</strong></h4><blockquote>
<p><strong>回溯</strong></p>
<p>回溯是一个递归处理的过程。如果 a[i]与 b[j]匹配，递归考察 a[i+1]和 b[j+1]。如果 a[i]与 b[j]不匹配：</p>
<ol>
<li>可以删除 a[i]，然后递归考察 a[i+1]和 b[j]；</li>
<li>可以删除 b[j]，然后递归考察 a[i]和 b[j+1]；</li>
<li>可以在 a[i]前面添加一个跟 b[j]相同的字符，然后递归考察 a[i]和 b[j+1];</li>
<li>可以在 b[j]前面添加一个跟 a[i]相同的字符，然后递归考察 a[i+1]和 b[j]；</li>
<li>可以将 a[i]替换成 b[j]，或者将 b[j]替换成 a[i]，然后递归考察 a[i+1]和 b[j+1]。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] a = <span class="hljs-string">&quot;mitcmu&quot;</span>.toCharArray();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] b = <span class="hljs-string">&quot;mtacnu&quot;</span>.toCharArray();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> minDist = Integer.MAX_VALUE; <span class="hljs-comment">// 存储结果</span><br><span class="hljs-comment">// 调用方式 lwstBT(0, 0, 0);</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">lwstBT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> edist)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (i == n || j == m) &#123;<br>    <span class="hljs-keyword">if</span> (i &lt; n) edist += (n-i);<br>    <span class="hljs-keyword">if</span> (j &lt; m) edist += (m - j);<br>    <span class="hljs-keyword">if</span> (edist &lt; minDist) minDist = edist;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123; <span class="hljs-comment">// 两个字符匹配</span><br>    lwstBT(i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>, edist);<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 两个字符不匹配</span><br>    lwstBT(i + <span class="hljs-number">1</span>, j, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除a[i]或者b[j]前添加一个字符</span><br>    lwstBT(i, j + <span class="hljs-number">1</span>, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除b[j]或者a[i]前添加一个字符</span><br>    lwstBT(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 将a[i]和b[j]替换为相同字符</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] a = <span class="hljs-string">&quot;mitcmu&quot;</span>.toCharArray();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] b = <span class="hljs-string">&quot;mtacnu&quot;</span>.toCharArray();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> minDist = Integer.MAX_VALUE; <span class="hljs-comment">// 存储结果</span><br><span class="hljs-comment">// 调用方式 lwstBT(0, 0, 0);</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">lwstBT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> edist)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (i == n || j == m) &#123;<br>    <span class="hljs-keyword">if</span> (i &lt; n) edist += (n-i);<br>    <span class="hljs-keyword">if</span> (j &lt; m) edist += (m - j);<br>    <span class="hljs-keyword">if</span> (edist &lt; minDist) minDist = edist;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123; <span class="hljs-comment">// 两个字符匹配</span><br>    lwstBT(i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>, edist);<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 两个字符不匹配</span><br>    lwstBT(i + <span class="hljs-number">1</span>, j, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除a[i]或者b[j]前添加一个字符</span><br>    lwstBT(i, j + <span class="hljs-number">1</span>, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除b[j]或者a[i]前添加一个字符</span><br>    lwstBT(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 将a[i]和b[j]替换为相同字符</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/55046/%E8%8E%B1%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E7%A6%BB%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="莱文斯坦距离回溯算法递归树">
<p>在递归树中，每个节点代表一个状态，状态包含三个变量 (i, j, edist)，其中，edist 表示处理到 a[i]和 b[j]时，已经执行的编辑操作的次数。</p>
<p>在递归树中，(i, j) 两个变量重复的节点很多。对于 (i, j) 相同的节点，只需要保留 edist 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i]和 b[j]，已经执行的最少编辑次数。</p>
<img src="/article/55046/%E8%8E%B1%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E7%A6%BB%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" class title="莱文斯坦距离状态转移的过程">
</blockquote>
<p><strong>动态规划</strong></p>
<p><strong>状态转移方程</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：<br>min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)<br><br>如果：a[i]==b[j]，那么：min_edist(i, j)就等于：<br>min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))<br><br>其中，min表示求三数中的最小值。     <br></code></pre></td></tr></table></figure>
<img src="/article/55046/%E8%8E%B1%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E7%A6%BB%E7%8A%B6%E6%80%81%E8%A1%A8.jpg" class title="莱文斯坦距离状态表">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lwstDP</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[][] minDist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123; <span class="hljs-comment">// 初始化第0行:a[0..0]与b[0..j]的编辑距离</span><br>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[j]) minDist[<span class="hljs-number">0</span>][j] = j;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) minDist[<span class="hljs-number">0</span>][j] = minDist[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> minDist[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 初始化第0列:a[0..i]与b[0..0]的编辑距离</span><br>    <span class="hljs-keyword">if</span> (a[i] == b[<span class="hljs-number">0</span>]) minDist[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) minDist[i][<span class="hljs-number">0</span>] = minDist[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> minDist[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 按行填表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (a[i] == b[j]) minDist[i][j] = min(<br>          minDist[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>, minDist[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>, minDist[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]);<br>      <span class="hljs-keyword">else</span> minDist[i][j] = min(<br>          minDist[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>, minDist[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>, minDist[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> minDist[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> minv = Integer.MAX_VALUE;<br>  <span class="hljs-keyword">if</span> (x &lt; minv) minv = x;<br>  <span class="hljs-keyword">if</span> (y &lt; minv) minv = y;<br>  <span class="hljs-keyword">if</span> (z &lt; minv) minv = z;<br>  <span class="hljs-keyword">return</span> minv;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="计算最长公共子串长度"><a href="#计算最长公共子串长度" class="headerlink" title="计算最长公共子串长度"></a>计算最长公共子串长度</h4><p><strong>动态规划</strong></p>
<p><strong>状态转移方程</strong></p>
<p>每个状态包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i]和 b[0…j]的最长公共子串长度。</p>
<ol>
<li>如果 a[i]与 b[j]互相匹配，将最大公共子串长度加一，并且继续考察 a[i+1]和 b[j+1]。</li>
<li>如果 a[i]与 b[j]不匹配，最长公共子串长度不变<ol>
<li>删除 a[i]，或者在 b[j]前面加上一个字符 a[i]，然后继续考察 a[i+1]和 b[j]；</li>
<li>删除 b[j]，或者在 a[i]前面加上一个字符 b[j]，然后继续考察 a[i]和 b[j+1]。</li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：<br>max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；<br><br>如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：<br>max(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))；<br><br>其中max表示求三数中的最大值。<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lcs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[][] maxlcs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<span class="hljs-comment">//初始化第0行：a[0..0]与b[0..j]的maxlcs</span><br>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[j]) maxlcs[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) maxlcs[<span class="hljs-number">0</span>][j] = maxlcs[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">else</span> maxlcs[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<span class="hljs-comment">//初始化第0列：a[0..i]与b[0..0]的maxlcs</span><br>    <span class="hljs-keyword">if</span> (a[i] == b[<span class="hljs-number">0</span>]) maxlcs[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) maxlcs[i][<span class="hljs-number">0</span>] = maxlcs[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">else</span> maxlcs[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 填表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (a[i] == b[j]) maxlcs[i][j] = max(<br>          maxlcs[i-<span class="hljs-number">1</span>][j], maxlcs[i][j-<span class="hljs-number">1</span>], maxlcs[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">else</span> maxlcs[i][j] = max(<br>          maxlcs[i-<span class="hljs-number">1</span>][j], maxlcs[i][j-<span class="hljs-number">1</span>], maxlcs[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxlcs[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> maxv = Integer.MIN_VALUE;<br>  <span class="hljs-keyword">if</span> (x &gt; maxv) maxv = x;<br>  <span class="hljs-keyword">if</span> (y &gt; maxv) maxv = y;<br>  <span class="hljs-keyword">if</span> (z &gt; maxv) maxv = z;<br>  <span class="hljs-keyword">return</span> maxv;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="背包问题总结"></a>背包问题总结</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><blockquote>
<p><strong>dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少?</strong></p>
</blockquote>
<p><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</p>
<p><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</p>
<p> <strong>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</strong></p>
<hr>
<blockquote>
<p><strong>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]</strong></p>
</blockquote>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p><strong>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</strong></p>
<hr>
<blockquote>
<ol>
<li><p>当动态规划数组为二维数组时–先遍历物品 再遍历背包无所谓</p>
</li>
<li><p>当动态规划数组为一维数组时–先遍历物品再遍历背包，并且逆序遍历背包</p>
</li>
</ol>
</blockquote>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>对于完全背包，不论动态规划数组为一维还是二维，对物品遍历与背包遍历的顺序都是无所谓的</p>
<h3 id="背包问题排列组合问题"><a href="#背包问题排列组合问题" class="headerlink" title="背包问题排列组合问题"></a>背包问题排列组合问题</h3><p>之前的遍历顺序不受凑成总和的元素的元素的顺序影响，而排列组合问题不同,求的是凑成总和的方法种类</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>数据结构与算法,动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/article/60033.html</url>
    <content><![CDATA[<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h4><blockquote>
<p>有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。</p>
<p>第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p>
<img src="/article/60033/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.jpg" class title="八皇后问题">
</blockquote>
<p>把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>];<span class="hljs-comment">//全局或成员变量,下标表示行,值表示queen存储在哪一列</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cal8queens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row)</span> </span>&#123; <span class="hljs-comment">// 调用方式：cal8queens(0);</span><br>  <span class="hljs-keyword">if</span> (row == <span class="hljs-number">8</span>) &#123; <span class="hljs-comment">// 8个棋子都放置好了，打印结果</span><br>    printQueens(result);<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = <span class="hljs-number">0</span>; column &lt; <span class="hljs-number">8</span>; ++column) &#123; <span class="hljs-comment">// 每一行都有8中放法</span><br>    <span class="hljs-keyword">if</span> (isOk(row, column)) &#123; <span class="hljs-comment">// 有些放法不满足要求</span><br>      result[row] = column; <span class="hljs-comment">// 第row行的棋子放到了column列</span><br>      cal8queens(row+<span class="hljs-number">1</span>); <span class="hljs-comment">// 考察下一行</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column)</span> </span>&#123;<span class="hljs-comment">//判断row行column列放置是否合适</span><br>  <span class="hljs-keyword">int</span> leftup = column - <span class="hljs-number">1</span>, rightup = column + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 逐行往上考察每一行</span><br>    <span class="hljs-keyword">if</span> (result[i] == column) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 第i行的column列有棋子吗？</span><br>    <span class="hljs-keyword">if</span> (leftup &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 考察左上对角线：第i行leftup列有棋子吗？</span><br>      <span class="hljs-keyword">if</span> (result[i] == leftup) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rightup &lt; <span class="hljs-number">8</span>) &#123; <span class="hljs-comment">// 考察右上对角线：第i行rightup列有棋子吗？</span><br>      <span class="hljs-keyword">if</span> (result[i] == rightup) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    --leftup; ++rightup;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] result)</span> </span>&#123; <span class="hljs-comment">// 打印出一个二维矩阵</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">8</span>; ++row) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = <span class="hljs-number">0</span>; column &lt; <span class="hljs-number">8</span>; ++column) &#123;<br>      <span class="hljs-keyword">if</span> (result[row] == column) System.out.print(<span class="hljs-string">&quot;Q &quot;</span>);<br>      <span class="hljs-keyword">else</span> System.out.print(<span class="hljs-string">&quot;* &quot;</span>);<br>    &#125;<br>    System.out.println();<br>  &#125;<br>  System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h4><blockquote>
<p>有一个背包，背包总的承载重量是 Wkg。现在有 n 个物品，每个物品的重量不等，并且不可分割。现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>
</blockquote>
<p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2^n 种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。</p>
<p>可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">//存储背包中物品总重量的最大值</span><br><span class="hljs-comment">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span><br><span class="hljs-comment">// w背包重量；items表示每个物品的重量；n表示物品个数</span><br><span class="hljs-comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span><br><span class="hljs-comment">// f(0, 0, a, 10, 100)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw, <span class="hljs-keyword">int</span>[] items, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span><br>    <span class="hljs-keyword">if</span> (cw &gt; maxW) maxW = cw;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  f(i+<span class="hljs-number">1</span>, cw, items, n, w);<span class="hljs-comment">//当前物品不装进背包</span><br>  <span class="hljs-keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="hljs-comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span><br>    f(i+<span class="hljs-number">1</span>,cw + items[i], items, n, w);<span class="hljs-comment">// 当前物品装进背包</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><blockquote>
<p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。</p>
<p>假设正则表达式中只包含“*”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。</p>
<p>如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p>
</blockquote>
<p>依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</p>
<p>如果遇到特殊字符的时候，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pattern</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> matched = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] pattern; <span class="hljs-comment">// 正则表达式</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> plen; <span class="hljs-comment">// 正则表达式长度</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pattern</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] pattern, <span class="hljs-keyword">int</span> plen)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.pattern = pattern;<br>    <span class="hljs-keyword">this</span>.plen = plen;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text, <span class="hljs-keyword">int</span> tlen)</span> </span>&#123; <span class="hljs-comment">// 文本串及长度</span><br>    matched = <span class="hljs-keyword">false</span>;<br>    rmatch(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, text, tlen);<br>    <span class="hljs-keyword">return</span> matched;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rmatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ti, <span class="hljs-keyword">int</span> pj, <span class="hljs-keyword">char</span>[] text, <span class="hljs-keyword">int</span> tlen)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matched) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果已经匹配了，就不要继续递归了</span><br>    <span class="hljs-keyword">if</span> (pj == plen) &#123; <span class="hljs-comment">// 正则表达式到结尾了</span><br>      <span class="hljs-keyword">if</span> (ti == tlen) matched = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 文本串也到结尾了</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pattern[pj] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123; <span class="hljs-comment">// *匹配任意个字符</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= tlen-ti; ++k) &#123;<br>        rmatch(ti+k, pj+<span class="hljs-number">1</span>, text, tlen);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pattern[pj] == <span class="hljs-string">&#x27;?&#x27;</span>) &#123; <span class="hljs-comment">// ?匹配0个或者1个字符</span><br>      rmatch(ti, pj+<span class="hljs-number">1</span>, text, tlen);<br>      rmatch(ti+<span class="hljs-number">1</span>, pj+<span class="hljs-number">1</span>, text, tlen);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="hljs-comment">// 纯字符匹配才行</span><br>      rmatch(ti+<span class="hljs-number">1</span>, pj+<span class="hljs-number">1</span>, text, tlen);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>回溯算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法,回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/article/46607.html</url>
    <content><![CDATA[<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p><strong>分治算法（divide and conquer）的核心思想</strong>其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p>
<p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong></p>
<p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p>
<ol>
<li>分解：将原问题分解成一系列子问题；</li>
<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li>
<li>合并：将子问题的结果合并成原问题。</li>
</ol>
<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>
<ol>
<li>原问题与分解成的小问题具有相同的模式；</li>
<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li>
<li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li>
<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li>
</ol>
<h3 id="分治算法应用举例"><a href="#分治算法应用举例" class="headerlink" title="分治算法应用举例"></a>分治算法应用举例</h3><blockquote>
<p><strong>如何求出一组数据的有序对个数或者逆序对个数</strong></p>
</blockquote>
<p>有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。</p>
<p>假设有 n 个数据，期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。</p>
<p>用分治的思想来求数组 A 的逆序对个数。可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p>
<p><strong>归并排序</strong>中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，就可以计算这两个小数组的逆序对个数了。每次合并操作，都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p>
<img src="/article/46607/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E4%B8%AA%E6%95%B0.jpg" class title="归并排序求逆序对个数">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 全局变量或者成员变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  num = <span class="hljs-number">0</span>;<br>  mergeSortCounting(a, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> num;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSortCounting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (p &gt;= r) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">int</span> q = (p+r)/<span class="hljs-number">2</span>;<br>  mergeSortCounting(a, p, q);<br>  mergeSortCounting(a, q+<span class="hljs-number">1</span>, r);<br>  merge(a, p, q, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i = p, j = q+<span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r-p+<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;<br>    <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) &#123;<br>      tmp[k++] = a[i++];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      num += (q-i+<span class="hljs-number">1</span>); <span class="hljs-comment">// 统计p-q之间，比a[j]大的元素个数</span><br>      tmp[k++] = a[j++];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (i &lt;= q) &#123; <span class="hljs-comment">// 处理剩下的</span><br>    tmp[k++] = a[i++];<br>  &#125;<br>  <span class="hljs-keyword">while</span> (j &lt;= r) &#123; <span class="hljs-comment">// 处理剩下的</span><br>    tmp[k++] = a[j++];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= r-p; ++i) &#123; <span class="hljs-comment">// 从tmp拷贝回a</span><br>    a[p+i] = tmp[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h3><blockquote>
<p>给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而机器的内存可能只有 2、3GB ，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p>
</blockquote>
<p>利用分治的思想。可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p>
<blockquote>
<p>给 10GB 的订单排序，可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>分治算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法,分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/article/51855.html</url>
    <content><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法解决问题的步骤:</p>
<ol>
<li>针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。<strong>当看到这类问题的时候，首先要联想到贪心算法。</strong></li>
<li>尝试看这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。</li>
<li>第三步，举几个例子看下贪心算法产生的结果是否是最优的。</li>
</ol>
<h3 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h3><ol>
<li><p>分糖果</p>
<blockquote>
<p>有 m 个糖果和 n 个孩子。现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子。</p>
<p>每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。</p>
<p>如何分配糖果，能尽可能满足最多数量的孩子？</p>
</blockquote>
<p><strong>抽象问题：从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。这个问题的限制值就是糖果个数 m。</strong></p>
<p>对于一个孩子来说，如果小的糖果可以满足，就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，可以从需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对期望值的贡献是一样的。</p>
<p>每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p>
</li>
<li><p>钱币找零</p>
<blockquote>
<p>假设有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p>
</blockquote>
<p>先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。</p>
</li>
<li><p>区间覆盖</p>
<blockquote>
<p>假设有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？</p>
<img src="/article/51855/%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96.jpg" class title="区间覆盖">
</blockquote>
<p><strong>解决思路:</strong>假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。</p>
<p>每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</p>
<img src="/article/51855/%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF.jpg" class title="区间覆盖解决思路">
</li>
</ol>
<h3 id="贪心算法实现Huffman压缩编码"><a href="#贪心算法实现Huffman压缩编码" class="headerlink" title="贪心算法实现Huffman压缩编码"></a>贪心算法实现Huffman压缩编码</h3><blockquote>
<p>假设有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p>
<p>假设通过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">a(000)、b(001)、c(010)、d(011)、e(100)、f(101)<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>霍夫曼编码是一种十分有效的编码方法</strong>，广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。</p>
<p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。</p>
<p>如何给不同频率的字符选择不同长度的编码呢？<strong>根据贪心的思想，可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</strong></p>
<blockquote>
<p>对于等长的编码来说，解压缩起来很简单。比如用 3 个 bit 表示一个字符。在解压缩的时候，每次从文本中读取 3 位二进制码，然后翻译成对应的字符。</p>
<p><strong>但是，霍夫曼编码是不等长的，每次应该读取 1 位还是 2 位、3 位等等来解压缩呢？</strong>这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，<strong>霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</strong></p>
</blockquote>
<p><strong>霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</strong></p>
<p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，<strong>在解压缩的时候，每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。</strong></p>
<img src="/article/51855/Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81.jpg" class title="Huffman压缩编码">
<p><strong>根据字符出现频率的不同，给不同的字符进行不同长度的编码</strong></p>
<p>把每个字符看作一个节点，并且附带着把频率放到优先级队列中。从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p>

<p><strong>给每一条边加上画一个权值，指向左子节点的边标记为 0，指向右子节点的边，标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</strong></p>
<img src="/article/51855/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.jpg" class title="霍夫曼编码">
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>贪心算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法,贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配</title>
    <url>/article/41181.html</url>
    <content><![CDATA[<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>在字符串 A 中查找字符串 B，那字符串 A 就是<strong>主串</strong>，字符串 B 就是<strong>模式串</strong>。</p>
<h3 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h3><p>BF 算法中的 BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。</p>
<p><strong>在主串中，检查起始位置分别是 0、1、2….n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。</strong></p>
<p><img src="/article/BF 算法实例.jpg"><span class="image-caption">BF 算法实例</span></p>
<p>最坏情况时间复杂度是 O(n*m)</p>
<h3 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h3><p>RK 算法的全称叫 Rabin-Karp 算法，是 BF 算法的升级版</p>
<h4 id="RK-算法的思路"><a href="#RK-算法的思路" class="headerlink" title="RK 算法的思路"></a>RK 算法的思路</h4><p>通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p>
<img src="/article/41181/%E4%B8%BB%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC.jpg" class title="主串哈希值">
<h4 id="提高哈希算法计算子串哈希值的效率"><a href="#提高哈希算法计算子串哈希值的效率" class="headerlink" title="提高哈希算法计算子串哈希值的效率"></a><strong>提高哈希算法计算子串哈希值的效率</strong></h4><p>假设要匹配的字符串的字符集中只包含 K 个字符，可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p>
<p>相邻两个子串 s[i-1]和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，<strong>可以使用 s[i-1]的哈希值很快的计算出 s[i]的哈希值。</strong></p>
<img src="/article/41181/%E6%8F%90%E9%AB%98%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%AD%90%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC%E7%9A%84%E6%95%88%E7%8E%87.jpg" class title="提高哈希算法计算子串哈希值的效率">
<p>26<sup>(m-1)</sup> 这部分的计算，我们可以通过查表的方法来提高效率。事先计算好 26<sup>0</sup>、26<sup>1</sup>、26<sup>2</sup>、26<sup>3</sup>……26<sup>(m-1)</sup> ，并且<strong>存储在一个长度为 m 的数组中</strong>，公式中的“次方”就对应数组的下标，需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。</p>
<blockquote>
<p><strong>问题：模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？</strong></p>
<p>为了能将哈希值落在整型数据范围内，可以允许哈希冲突</p>
</blockquote>
<h4 id="RK-算法的时间复杂度"><a href="#RK-算法的时间复杂度" class="headerlink" title="RK 算法的时间复杂度"></a><strong>RK 算法的时间复杂度</strong></h4><p>整个 RK 算法包含两部分</p>
<ol>
<li><p>计算子串哈希值和模式串哈希值</p>
<p>通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 <strong>O(n)</strong></p>
</li>
<li><p>子串哈希值之间的比较</p>
<p>时间复杂度是 <strong>O(1)</strong>，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 <strong>O(n)</strong></p>
</li>
</ol>
<p>RK 算法整体的时间复杂度就是 <strong>O(n)</strong></p>
<p>最坏情况时间复杂度<strong>O(n*m)</strong></p>
<h3 id="BF、RK算法实现"><a href="#BF、RK算法实现" class="headerlink" title="BF、RK算法实现"></a>BF、RK算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bF</span><span class="hljs-params">(String a,String b)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> m=a.length(),n=b.length(),k;<br>		<span class="hljs-keyword">char</span>[] a1=a.toCharArray();<br>		<span class="hljs-keyword">char</span>[] b1=b.toCharArray();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m-n;i++) &#123;<br>			k=<span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br>				<span class="hljs-keyword">if</span>(a1[i+j]==b1[j]) &#123;<br>					k++;<br>				&#125;<br>				<span class="hljs-keyword">else</span><br>					<span class="hljs-keyword">break</span>;<br>			&#125;<br>			<span class="hljs-keyword">if</span>(k==n) &#123;<br>				<span class="hljs-keyword">return</span> i;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>	&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rK</span><span class="hljs-params">(String a,String b)</span> </span>&#123;<br>		<span class="hljs-keyword">int</span> m=a.length(),n=b.length(),s,j;<br>		<span class="hljs-keyword">int</span>[] hash=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m-n+<span class="hljs-number">1</span>];<br>		<span class="hljs-keyword">int</span>[] table=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>		<span class="hljs-keyword">char</span>[] a1=a.toCharArray();<br>		<span class="hljs-keyword">char</span>[] b1=b.toCharArray();<br>		s=<span class="hljs-number">1</span>;<br>		<span class="hljs-comment">//将26的次方存储在一个表里，取的时候直接用,虽然溢出，但没啥问题</span><br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;j++) &#123;<br>			table[j]=s;<br>			s*=<span class="hljs-number">26</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m-n;i++) &#123;<br>			s=<span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br>				s+=(a1[i+j]-<span class="hljs-string">&#x27;a&#x27;</span>)*table[n-<span class="hljs-number">1</span>-j];<br>			&#125;<br>			hash[i]=s;<br>		&#125;<br>		s=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br>			s+=(b1[j]-<span class="hljs-string">&#x27;a&#x27;</span>)*table[n-<span class="hljs-number">1</span>-j];<br>		&#125;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m-n+<span class="hljs-number">1</span>;j++) &#123;<br>			<span class="hljs-keyword">if</span>(hash[j]==s) &#123;<br>				<span class="hljs-keyword">return</span> j;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>
<h3 id="BM（Boyer-Moore）算法"><a href="#BM（Boyer-Moore）算法" class="headerlink" title="BM（Boyer-Moore）算法"></a>BM（Boyer-Moore）算法</h3><h4 id="BM-算法的核心思想"><a href="#BM-算法的核心思想" class="headerlink" title="BM 算法的核心思想"></a>BM 算法的核心思想</h4><p>BM 算法包含两部分，分别是<strong>坏字符规则（bad character rule）</strong>和<strong>好后缀规则（good suffix shift）</strong>。</p>
<ol>
<li><p>坏字符规则</p>
<p><img src="/article/BM 算法的匹配顺序实例.jpg"><span class="image-caption">BM 算法的匹配顺序实例</span></p>
<p>BM 算法的匹配顺序是<strong>按照模式串下标从大到小的顺序</strong></p>
<p>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候，把这个没有匹配的字符叫作<strong>坏字符（主串中的字符）</strong>。</p>
<blockquote>
<ol>
<li><p>坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p>
<p><img src="/article/BM 算法的匹配顺序1.jpg"><span class="image-caption">BM 算法的匹配顺序1</span></p>
</li>
<li><p>模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，<strong>不能将模式串往后滑动三位</strong>。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。</p>
<p><img src="/article/BM 算法的匹配顺序2.jpg"><span class="image-caption">BM 算法的匹配顺序2</span></p>
</li>
</ol>
</blockquote>
<p>当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。</p>
<p><img src="/article/BM 算法坏字符规律.jpg"><span class="image-caption">BM 算法坏字符规律</span></p>
<p><strong>如果坏字符在模式串里多处出现，在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</strong></p>
<p><strong>最好情况时间复杂度：</strong>O(n/m)</p>
<p><strong>问题：</strong>根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。</p>
</li>
<li><p>好后缀规则</p>
<img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E5%AE%9E%E4%BE%8B.jpg" class title="好后缀规则实例">
<p><strong>把已经匹配的 bc 叫作好后缀</strong>，记作{u}</p>
<blockquote>
<ol>
<li><p>拿 {u} 在模式串中查找，如果找到了另一个跟 {u} 相匹配的子串 {u*} ，就将模式串滑动到子串{u*}与主串中{u}对齐的位置。</p>
<img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F1.jpg" class title="好后缀规则顺序1">
</li>
<li><p>如果好后缀在模式串中不存在可匹配的子串，在一步一步往后滑动模式串的过程中，只要主串中的 {u} 与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中 {u} 的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。</p>
<img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F2.jpg" class title="好后缀规则顺序2">
<img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D.jpg" class title="好后缀规则前缀后缀部分匹配">
<p>所以，针对这种情况，不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察<strong>好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的</strong>。</p>
<p><strong>从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是 {v} ，然后将模式串滑动到如图所示的位置。</strong></p>
<img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F3.jpg" class title="好后缀规则顺序3">
</li>
</ol>
</blockquote>
</li>
</ol>
<p><strong>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数</strong></p>
<h4 id="BM-算法代码实现"><a href="#BM-算法代码实现" class="headerlink" title="BM 算法代码实现"></a>BM 算法代码实现</h4><blockquote>
<p><strong>如何查找坏字符在模式串中出现的位置?</strong></p>
<p>可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。</p>
<p>假设字符串的字符集不是很大，每个字符长度是 1 字节，用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。</p>
<img src="/article/41181/%E6%9F%A5%E6%89%BE%E5%9D%8F%E5%AD%97%E7%AC%A6%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg" class title="查找坏字符在模式串中出现的位置">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">256</span>; <span class="hljs-comment">// 全局变量或成员变量</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateBC</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] bc)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; ++i) &#123;<br>    bc[i] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化bc</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">int</span> ascii = (<span class="hljs-keyword">int</span>)b[i]; <span class="hljs-comment">// 计算b[i]的ASCII值</span><br>    bc[ascii] = i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>变量 b 是模式串，m 是模式串的长度，bc 表示散列表</p>
</blockquote>
<blockquote>
<p><strong>不考虑好后缀规则，仅用坏字符规则，并且不考虑 si-xi 计算得到的移动位数可能会出现负数的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bm</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[] bc = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE]; <span class="hljs-comment">// 记录模式串中每个字符最后出现的位置</span><br>  generateBC(b, m, bc); <span class="hljs-comment">// 构建坏字符哈希表</span><br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// i表示主串与模式串对齐的第一个字符</span><br>  <span class="hljs-keyword">while</span> (i &lt;= n - m) &#123;<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">for</span> (j = m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123; <span class="hljs-comment">// 模式串从后往前匹配</span><br>      <span class="hljs-keyword">if</span> (a[i+j] != b[j]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 坏字符对应模式串中的下标是j</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br>    &#125;<br>    <span class="hljs-comment">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span><br>    i = i + (j - bc[(<span class="hljs-keyword">int</span>)a[i+j]]); <br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/41181/%E6%9F%A5%E6%89%BE%E5%9D%8F%E5%AD%97%E7%AC%A6%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%B9%B6%E7%A7%BB%E5%8A%A8.jpg" class title="查找坏字符在模式串中出现的位置并移动">
</blockquote>
<blockquote>
<p><strong>好后缀规则</strong></p>
<ol>
<li>在模式串中，查找跟好后缀匹配的另一个子串；</li>
<li>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</li>
</ol>
<p><strong>在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置</strong></p>
<ol>
<li><p>表示模式串中不同的后缀子串</p>
<p>后缀子串的最后一个字符的位置是固定的，下标为 m-1，只需要记录长度就可以了。通过长度，可以确定一个唯一的后缀子串。</p>
<img src="/article/41181/%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84%E5%90%8E%E7%BC%80%E5%AD%90%E4%B8%B2.jpg" class title="表示模式串中不同的后缀子串">
</li>
<li><p><strong>引入关键变量 suffix 数组</strong></p>
<p>suffix 数组的下标 k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀{u}相匹配的子串{u*}的起始下标值</p>
<p><img src="/article/suffix 数组.jpg"><span class="image-caption">suffix 数组</span></p>
</li>
<li><p><strong>引入 boolean 类型的 prefix 数组</strong></p>
<p>记录模式串的后缀子串是否能匹配模式串的前缀子串</p>
<p><img src="/article/prefix 数组.jpg"><span class="image-caption">prefix 数组</span></p>
</li>
</ol>
<p>拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 k，那我们就记录 suffix[k]=j（j 表示公共后缀子串的起始下标）。如果 j 等于 0，也就是说，公共后缀子串也是模式串的前缀子串，我们就记录 prefix[k]=true。</p>
<p><img src="/article/suffix 数组、prefix 数组计算.jpg"><span class="image-caption">suffix 数组、prefix 数组计算</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateGS</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] suffix, <span class="hljs-keyword">boolean</span>[] prefix)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123; <span class="hljs-comment">// 初始化</span><br>    suffix[i] = -<span class="hljs-number">1</span>;<br>    prefix[i] = <span class="hljs-keyword">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; ++i) &#123; <span class="hljs-comment">// b[0, i]</span><br>    <span class="hljs-keyword">int</span> j = i;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; <span class="hljs-comment">// 公共后缀子串长度</span><br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; b[j] == b[m-<span class="hljs-number">1</span>-k]) &#123; <span class="hljs-comment">// 与b[0, m-1]求公共后缀子串</span><br>      --j;<br>      ++k;<br>      suffix[k] = j+<span class="hljs-number">1</span>; <span class="hljs-comment">//j+1表示公共后缀子串在b[0, i]中的起始下标</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span>) prefix[k] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//如果公共后缀子串也是模式串的前缀子串</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</strong></p>
<ol>
<li><p>假设好后缀的长度是 k。先拿好后缀，在 suffix 数组中查找其匹配的子串。如果 suffix[k]不等于 -1（-1 表示不存在匹配的子串），那我们就将模式串往后移动 j-suffix[k]+1 位（j 表示坏字符对应的模式串中的字符下标）。</p>
<img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D1.jpg" class title="好后缀匹配1">
</li>
<li><p>如果 suffix[k]等于 -1，表示模式串中不存在另一个跟好后缀匹配的子串片段</p>
<p>好后缀的后缀子串 b[r, m-1]（其中，r 取值从 j+2 到 m-1）的长度 k=m-r，如果 prefix[k]等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样我们可以把模式串后移 r 位。</p>
<img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D1.jpg" class title="好后缀匹配1">
</li>
<li><p>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，就将整个模式串后移 m 位。</p>
<img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D3.jpg" class title="好后缀匹配3">
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// a,b表示主串和模式串；n，m表示主串和模式串的长度。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bm</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[] bc = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE]; <span class="hljs-comment">// 记录模式串中每个字符最后出现的位置</span><br>  generateBC(b, m, bc); <span class="hljs-comment">// 构建坏字符哈希表</span><br>  <span class="hljs-keyword">int</span>[] suffix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br>  <span class="hljs-keyword">boolean</span>[] prefix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m];<br>  generateGS(b, m, suffix, prefix);<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// j表示主串与模式串匹配的第一个字符</span><br>  <span class="hljs-keyword">while</span> (i &lt;= n - m) &#123;<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">for</span> (j = m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123; <span class="hljs-comment">// 模式串从后往前匹配</span><br>      <span class="hljs-keyword">if</span> (a[i+j] != b[j]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 坏字符对应模式串中的下标是j</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> x = j - bc[(<span class="hljs-keyword">int</span>)a[i+j]];<br>    <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (j &lt; m-<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果有好后缀的话</span><br>      y = moveByGS(j, m, suffix, prefix);<br>    &#125;<br>    i = i + Math.max(x, y);<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">moveByGS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] suffix, <span class="hljs-keyword">boolean</span>[] prefix)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> k = m - <span class="hljs-number">1</span> - j; <span class="hljs-comment">// 好后缀长度</span><br>  <span class="hljs-keyword">if</span> (suffix[k] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> j - suffix[k] +<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = j+<span class="hljs-number">2</span>; r &lt;= m-<span class="hljs-number">1</span>; ++r) &#123;<br>    <span class="hljs-keyword">if</span> (prefix[m-r] == <span class="hljs-keyword">true</span>) &#123;<br>      <span class="hljs-keyword">return</span> r;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="KMP-算法基本原理"><a href="#KMP-算法基本原理" class="headerlink" title="KMP 算法基本原理"></a>KMP 算法基本原理</h3><p>在模式串和主串匹配的过程中，把不能匹配的那个字符叫作坏字符，把已经匹配的那段字符串叫作好前缀。</p>
<img src="/article/41181/%E5%A5%BD%E5%89%8D%E7%BC%80%E4%B8%8E%E5%9D%8F%E5%AD%97%E7%AC%A6.jpg" class title="好前缀与坏字符">
<p>当遇到坏字符的时候，把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。</p>
<img src="/article/41181/%E5%AD%97%E4%B8%B2%E5%AF%B9%E6%AF%94.jpg" class title="字串对比">
<p>只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。</p>
<img src="/article/41181/%E5%AD%97%E4%B8%B2%E5%8C%B9%E9%85%8D.jpg" class title="字串匹配">
<p>好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫作<strong>最长可匹配前缀子串</strong>。</p>
<img src="/article/41181/%E6%9C%80%E9%95%BF%E5%8F%AF%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2.jpg" class title="最长可匹配子串">
<h3 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a>next 数组</h3><p>KMP 算法可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。把这个数组定义为 <strong>next 数组</strong>，也叫失效函数（failure function）。</p>
<p>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。</p>
<p>匹配发生冲突时，查看坏字符前一位的next数组下标</p>
<table>
<thead>
<tr>
<th>模式串</th>
<th>a</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>a</th>
<th>f</th>
</tr>
</thead>
<tbody>
<tr>
<td>前缀表（next数组）</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><strong>next 数组算法实现</strong></p>
<ol>
<li>初始化</li>
<li>前后缀不相同情况</li>
<li>前后缀相同情况</li>
<li>next数组</li>
</ol>
<p>i 表示 后缀末尾位置</p>
<p>j 表示 前缀末尾位置、i之前包括i的字串的的最长相等前后缀的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] next, <span class="hljs-keyword">char</span>[] s)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>  next[] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.size ; i++)&#123;<br>    <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j])&#123;<br>      j = next[ j - <span class="hljs-number">1</span> ];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s[i] == s[j])&#123;<br>      j++;<br>      next[i] = j;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="KMP-算法复杂度分析"><a href="#KMP-算法复杂度分析" class="headerlink" title="KMP 算法复杂度分析"></a>KMP 算法复杂度分析</h3><p>KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以<strong>空间复杂度是 O(m)</strong>，m 表示模式串的长度。</p>
<p>KMP 算法的时间复杂度就是 O(m+n)</p>
<h3 id="KMP算法算法实现"><a href="#KMP算法算法实现" class="headerlink" title="KMP算法算法实现"></a>KMP算法算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种<strong>专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</strong></p>
<blockquote>
<p>有 6 个字符串，它们分别是：how，hi，her，hello，so，see。希望在里面多次查找某个字符串是否存在。</p>
<p>对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。</p>
</blockquote>
<p><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</strong></p>
<blockquote>
<img src="/article/41181/Trie%E6%A0%91%E5%AE%9E%E4%BE%8B.jpg" class title="Trie树实例">
</blockquote>
<p>根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p>
<blockquote>
<p>Trie 树构造的分解过程</p>
<p><img src="/article/Trie 树构造的分解过程1.jpg"><span class="image-caption">img</span></p>
<p><img src="/article/Trie 树构造的分解过程2.jpg"><span class="image-caption">Trie 树构造的分解过程</span></p>
</blockquote>
<h3 id="如何实现一棵-Trie-树？"><a href="#如何实现一棵-Trie-树？" class="headerlink" title="如何实现一棵 Trie 树？"></a>如何实现一棵 Trie 树？</h3><p>Trie 树主要有两个操作</p>
<ol>
<li>一个是将字符串集合构造成 Trie 树。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。</li>
<li>另一个是在 Trie 树中查询一个字符串。</li>
</ol>
<p>借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> data;<br>  TrieNode children[<span class="hljs-number">26</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/41181/%E5%80%9F%E5%8A%A9%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0Trie%E6%A0%91.jpg" class title="借助散列表实现Trie树">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> TrieNode root = <span class="hljs-keyword">new</span> TrieNode(<span class="hljs-string">&#x27;/&#x27;</span>); <span class="hljs-comment">// 存储无意义字符</span><br><br>  <span class="hljs-comment">// 往Trie树中插入一个字符串</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; text.length; ++i) &#123;<br>      <span class="hljs-keyword">int</span> index = text[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-keyword">null</span>) &#123;<br>        TrieNode newNode = <span class="hljs-keyword">new</span> TrieNode(text[i]);<br>        p.children[index] = newNode;<br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    p.isEndingChar = <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 在Trie树中查找一个字符串</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] pattern)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pattern.length; ++i) &#123;<br>      <span class="hljs-keyword">int</span> index = pattern[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在pattern</span><br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p.isEndingChar == <span class="hljs-keyword">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不能完全匹配，只是前缀</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 找到pattern</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> data;<br>    <span class="hljs-keyword">public</span> TrieNode[] children = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEndingChar = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol>
<li><p>时间复杂度</p>
<p>构建 Trie 树的过程，需要扫描所有的字符串，<strong>时间复杂度是 O(n)</strong>（n 表示所有字符串的长度和）</p>
<p>每次查询时，如果要查询的字符串长度是 k，只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的<strong>时间复杂度是 O(k)</strong>，k 表示要查找的字符串的长度。</p>
</li>
<li><p>空间复杂度</p>
<p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组元素要存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>
<p><strong>在某些情况下，Trie 树不一定会节省存储空间。在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存。</strong></p>
</li>
</ol>
<h3 id="Trie-树与散列表、红黑树"><a href="#Trie-树与散列表、红黑树" class="headerlink" title="Trie 树与散列表、红黑树"></a>Trie 树与散列表、红黑树</h3><p>Trie 树对要处理的字符串有极其严苛的要求</p>
<ol>
<li>第一，字符串中包含的字符集不能太大。即便可以优化，但也要付出牺牲查询、插入效率的代价。</li>
<li>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</li>
<li>第三，如果要用 Trie 树解决问题，那就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</li>
<li>第四，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</li>
</ol>
<p>针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树</p>
<h2 id="AC-自动机-Trie-树优化"><a href="#AC-自动机-Trie-树优化" class="headerlink" title="AC 自动机(Trie 树优化)"></a>AC 自动机(Trie 树优化)</h2><p><strong>基于单模式串和 Trie 树实现的敏感词过滤</strong></p>
<p>多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。</p>
<p>只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。</p>
<p><strong>Trie 树就是一种多模式串匹配算法</strong></p>
<p>可以对敏感词字典进行预处理，构建成 Trie 树结构。这个预处理的操作只需要做一次，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，只需要动态更新一下 Trie 树就可以了。</p>
<p>当用户输入一个文本内容后，把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p>
<h3 id="经典的多模式串匹配算法：AC-自动机"><a href="#经典的多模式串匹配算法：AC-自动机" class="headerlink" title="经典的多模式串匹配算法：AC 自动机"></a>经典的多模式串匹配算法：AC 自动机</h3><p>AC 自动机算法，全称是 Aho-Corasick 算法。</p>
<p>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AcNode</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> data; <br>  <span class="hljs-keyword">public</span> AcNode[] children = <span class="hljs-keyword">new</span> AcNode[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 字符集只包含a~z这26个字符</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEndingChar = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 结尾字符为true</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> length = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 当isEndingChar=true时，记录模式串长度</span><br>  <span class="hljs-keyword">public</span> AcNode fail; <span class="hljs-comment">// 失败指针</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AcNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.data = data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>AC 自动机的构建，包含两个操作：</p>
<ol>
<li>将多个模式串构建成 Trie 树；</li>
<li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。</li>
</ol>
<h3 id="构建失败指针"><a href="#构建失败指针" class="headerlink" title="构建失败指针"></a><strong>构建失败指针</strong></h3><p>Trie 树中的每一个节点都有一个失败指针</p>
<blockquote>
<p>有 4 个模式串，分别是 c，bc，bcd，abcd；主串是 abcd。</p>
</blockquote>
<img src="/article/41181/%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg" class title="构建失败指针">
<p>假设沿 Trie 树走到 p 节点，也就是下图中的紫色节点，那 p 的失败指针就是从 root 走到紫色节点形成的字符串 abc，跟所有模式串前缀匹配的最长可匹配后缀子串，就是箭头指的 bc 模式串。</p>
<blockquote>
<p>字符串 abc 的后缀子串有两个 bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，那我们就把这个后缀子串叫作可匹配后缀子串。</p>
</blockquote>
<p>从可匹配后缀子串中，找出最长的一个。将 p 节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是图中紫色箭头指向的节点。</p>
<p><strong>如果把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。</strong></p>
<p><strong>失败指针的构建过程，是一个按层遍历树的过程</strong></p>
<p>首先 root 的失败指针为 NULL，也就是指向自己。</p>
<p>假设节点 p 的失败指针指向节点 q，看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc。</p>
<img src="/article/41181/%E5%AF%BB%E6%89%BE%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg" class title="寻找子节点的失败指针">
<p>如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 q=q-&gt;fail（fail 表示失败指针），继续上面的查找，直到 q 是 root 为止，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构建失败指针</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFailurePointer</span><span class="hljs-params">()</span> </span>&#123;<br>  Queue&lt;AcNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  root.fail = <span class="hljs-keyword">null</span>;<br>  queue.add(root);<br>  <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>    AcNode p = queue.remove();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>      AcNode pc = p.children[i];<br>      <span class="hljs-keyword">if</span> (pc == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (p == root) &#123;<br>        pc.fail = root;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        AcNode q = p.fail;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span>) &#123;<br>          AcNode qc = q.children[pc.data - <span class="hljs-string">&#x27;a&#x27;</span>];<br>          <span class="hljs-keyword">if</span> (qc != <span class="hljs-keyword">null</span>) &#123;<br>            pc.fail = qc;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          q = q.fail;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-keyword">null</span>) &#123;<br>          pc.fail = root;<br>        &#125;<br>      &#125;<br>      queue.add(pc);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/41181/%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg" class title="失败指针">
<h3 id="在-AC-自动机上匹配主串"><a href="#在-AC-自动机上匹配主串" class="headerlink" title="在 AC 自动机上匹配主串"></a>在 AC 自动机上匹配主串</h3><p>在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是 b，主串是 a。</p>
<ol>
<li>如果 p 指向的节点有一个等于 a[i]的子节点 x，我们就更新 p 指向 x，这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。处理完之后，我们将 i 加一，继续这两个过程；</li>
<li>如果 p 指向的节点没有等于 a[i]的子节点，那失败指针就派上用场了，我们让 <code>p=p-&gt;fail</code>，然后继续这 2 个过程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text)</span> </span>&#123; <span class="hljs-comment">// text是主串</span><br>  <span class="hljs-keyword">int</span> n = text.length;<br>  AcNode p = root;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> idx = text[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (p.children[idx] == <span class="hljs-keyword">null</span> &amp;&amp; p != root) &#123;<br>      p = p.fail; <span class="hljs-comment">// 失败指针发挥作用的地方</span><br>    &#125;<br>    p = p.children[idx];<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) p = root; <span class="hljs-comment">// 如果没有匹配的，从root开始重新匹配</span><br>    AcNode tmp = p;<br>    <span class="hljs-keyword">while</span> (tmp != root) &#123; <span class="hljs-comment">// 打印出可以匹配的模式串</span><br>      <span class="hljs-keyword">if</span> (tmp.isEndingChar == <span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">int</span> pos = i-tmp.length+<span class="hljs-number">1</span>;<br>        System.out.println(<span class="hljs-string">&quot;匹配起始下标&quot;</span> + pos + <span class="hljs-string">&quot;; 长度&quot;</span> + tmp.length);<br>      &#125;<br>      tmp = tmp.fail;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Trie 树构建的<strong>时间复杂度是 O(m*len)</strong>，其中 len 表示敏感词的平均长度，m 表示敏感词的个数。</p>
<p>整个失败指针的构建过程<strong>时间复杂度是 O(k*len)</strong>， k 是 Trie 树中总的节点个数，每个节点构建失败指针的时候，最耗时的环节是 while 循环中的 q=q-&gt;fail，每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len，所以每个节点构建失败指针的时间复杂度是 O(len)。</p>
<p>用 AC 自动机做匹配的时间复杂度，for 循环依次遍历主串中的每个字符，for 循环内部最耗时的部分也是 while 循环，而这一部分的时间复杂度也是 O(len)，所以总的匹配的时间复杂度就是 O(n*len)。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，<strong>可能近似于 O(n)</strong>，所以 AC 自动机做敏感词过滤，性能非常高。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>字符串匹配</category>
      </categories>
      <tags>
        <tag>数据结构与算法,字符串匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/article/47098.html</url>
    <content><![CDATA[<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><strong>如何理解“图”？</strong></p>
<p><strong>图（Graph）</strong>和树比起来，这是一种更加复杂的非线性表结构。</p>
<p>图中的元素就叫做<strong>顶点（vertex）</strong>，图中的一个顶点可以与任意其他顶点建立连接关系。这种建立的关系叫做<strong>边（edge）</strong>。跟顶点相连接的边的条数叫做顶点的<strong>度（degree）</strong>。</p>
<p>边有方向的图叫做<strong>“有向图”</strong>。边没有方向的图就叫做<strong>“无向图”</strong>。</p>
<p>在有向图中，我们把度分为<strong>入度（In-degree）和出度（Out-degree）</strong>。</p>
<p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。</p>
<p><strong>带权图（weighted graph）</strong>。在带权图中，每条边都有一个<strong>权重（weight）</strong>。</p>
<h3 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h3><p>图最直观的一种存储方法就是，<strong>邻接矩阵（Adjacency Matrix）</strong>。</p>
<p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重。</p>
<img src="/article/47098/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.webp" class title="邻接矩阵">
<p><strong>优点：</strong></p>
<ol>
<li>邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。</li>
<li>其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><p>对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1</p>
<p>无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。</p>
</li>
<li><p>如果存储的是稀疏图（Sparse Matrix），顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。</p>
</li>
</ol>
<h3 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h3><p><strong>邻接表</strong></p>
<img src="/article/47098/%E9%82%BB%E6%8E%A5%E8%A1%A8.jpg" class title="邻接表">
<p>每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p>
<p>有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点</p>
<p>无向图的邻接表存储方式，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点</p>
<p><strong>图的算法实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123; <span class="hljs-comment">// 无向图</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> v; <span class="hljs-comment">// 顶点的个数</span><br>  <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="hljs-comment">// 邻接表</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.v = v;<br>    adj = <span class="hljs-keyword">new</span> LinkedList[v];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;v; ++i) &#123;<br>      adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 无向图一条边存两次</span><br>    adj[s].add(t);<br>    adj[t].add(s);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>逆邻接表</strong></p>
<p>逆邻接表中，每个顶点的链表中，存储的是指向这个顶点的顶点</p>
<img src="/article/47098/%E9%82%BB%E6%8E%A5%E8%A1%A8%E4%B8%8E%E9%80%86%E9%82%BB%E6%8E%A5%E8%A1%A8.jpg" class title="邻接表与逆邻接表">
<h3 id="“搜索”算法？"><a href="#“搜索”算法？" class="headerlink" title="“搜索”算法？"></a>“搜索”算法？</h3><p>算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。</p>
<ol>
<li><p>广度优先搜索（BFS）</p>
<p>广度优先搜索（Breadth-First-Search，简称 BFS）。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p>
<img src="/article/47098/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89%E7%A4%BA%E4%BE%8B%E5%9B%BE.jpg" class title="广度优先搜索（BFS）示例图">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (s == t) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//visited 是用来记录已经被访问的顶点</span><br>  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[v];<br>  visited[s]=<span class="hljs-keyword">true</span>;<br>  <span class="hljs-comment">//queue 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点</span><br>  Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  queue.add(s);<br>  <span class="hljs-comment">//prev 用来记录搜索路径</span><br>  <span class="hljs-keyword">int</span>[] prev = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[v];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;<br>    prev[i] = -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (queue.size() != <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-keyword">int</span> w = queue.poll();<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[w].size(); ++i) &#123;<br>      <span class="hljs-keyword">int</span> q = adj[w].get(i);<br>      <span class="hljs-keyword">if</span> (!visited[q]) &#123;<br>        prev[q] = w;<br>        <span class="hljs-keyword">if</span> (q == t) &#123;<br>          print(prev, s, t);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        visited[q] = <span class="hljs-keyword">true</span>;<br>        queue.add(q);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prev, <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 递归打印s-&gt;t的路径</span><br>  <span class="hljs-keyword">if</span> (prev[t] != -<span class="hljs-number">1</span> &amp;&amp; t != s) &#123;<br>    print(prev, s, prev[t]);<br>  &#125;<br>  System.out.print(t + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中 s 表示起始顶点，t 表示终止顶点。搜索一条从 s 到 t 的路径。实际上，这样求得的路径就是从 s 到 t 的最短路径。</p>
<p><strong>visited</strong> 是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点 q 被访问，那相应的 visited[q]会被设置为 true。</p>
<p><strong>queue</strong> 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当我们访问到第 k 层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。所以，我们用这个队列来实现记录的功能。</p>
<p><strong>prev</strong> 用来记录搜索路径。当我们从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w]存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 2 的邻接表访问到顶点 3，那 prev[3]就等于 2。为了正向打印出路径，我们需要递归地来打印，你可以看下 print() 函数的实现方式。</p>
<blockquote>
<img src="/article/47098/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E8%A7%A3%E5%9B%BE1.jpg" class title="广度优先搜索的分解图">
<img src="/article/47098/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E8%A7%A3%E5%9B%BE2.jpg" class title="广度优先搜索的分解图">

</blockquote>
<p><strong>最坏情况时间复杂度</strong>：最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，<strong>广度优先搜索的时间复杂度也可以简写为 O(E)。</strong></p>
<p><strong>空间复杂度</strong>：广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，<strong>所以空间复杂度是 O(V)。</strong></p>
</li>
<li><p>深度优先搜索（DFS）</p>
<p>深度优先搜索（Depth-First-Search，简称 DFS）</p>

<p>实线箭头表示遍历，虚线箭头表示回退</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当已经找到终止顶点 t 之后，就不再递归地继续查找了。</span><br><span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 全局变量或者类成员变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>  found = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[v];<br>  <span class="hljs-keyword">int</span>[] prev = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[v];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;<br>    prev[i] = -<span class="hljs-number">1</span>;<br>  &#125;<br>  recurDfs(s, t, visited, prev);<br>  print(prev, s, t);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recurDfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">int</span>[] prev)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (found == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span>;<br>  visited[w] = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">if</span> (w == t) &#123;<br>    found = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[w].size(); ++i) &#123;<br>    <span class="hljs-keyword">int</span> q = adj[w].get(i);<br>    <span class="hljs-keyword">if</span> (!visited[q]) &#123;<br>      prev[q] = w;<br>      recurDfs(q, t, visited, prev);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>时间复杂度：</strong>每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的<strong>时间复杂度是 O(E)</strong>，E 表示边的个数。</p>
<p><strong>空间复杂度</strong>：深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以<strong>总的空间复杂度就是 O(V)</strong>。</p>
</li>
</ol>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><strong>拓扑排序（Topological Sorting</strong>）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：</p>
<ol>
<li>每个顶点出现且只出现一次。</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
</ol>
<p><strong>有向无环图</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> v; <span class="hljs-comment">// 顶点的个数</span><br>  <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="hljs-comment">// 邻接表</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.v = v;<br>    adj = <span class="hljs-keyword">new</span> LinkedList[v];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;v; ++i) &#123;<br>      adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// s先于t，边s-&gt;t</span><br>    adj[s].add(t);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Kahn-算法"><a href="#Kahn-算法" class="headerlink" title="Kahn 算法"></a>Kahn 算法</h4><p>贪心算法思想</p>
<p>定义数据结构的时候，如果 s 需要先于 t 执行，那就添加一条 s 指向 t 的边。</p>
<p>如果某个顶点入度为 0， 也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。</p>
<p>先从图中，找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中，并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 1）。</p>
<p>循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topoSortByKahn</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[] inDegree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[v]; <span class="hljs-comment">// 统计每个顶点的入度</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); ++j) &#123;<br>      <span class="hljs-keyword">int</span> w = adj[i].get(j); <span class="hljs-comment">// i-&gt;w</span><br>      inDegree[w]++;<br>    &#125;<br>  &#125;<br>  LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) queue.add(i);<br>  &#125;<br>  <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>    <span class="hljs-keyword">int</span> i = queue.remove();<br>    System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span> + i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); ++j) &#123;<br>      <span class="hljs-keyword">int</span> k = adj[i].get(j);<br>      inDegree[k]--;<br>      <span class="hljs-keyword">if</span> (inDegree[k] == <span class="hljs-number">0</span>) queue.add(k);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>时间复杂度：</strong></p>
<p>每个顶点被访问了一次，每个边也都被访问了一次，所以，Kahn 算法的时间复杂度就是 O(V+E)（V 表示顶点个数，E 表示边的个数）。</p>
<h4 id="DFS-算法"><a href="#DFS-算法" class="headerlink" title="DFS 算法"></a>DFS 算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topoSortByDFS</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s</span><br>  LinkedList&lt;Integer&gt; inverseAdj[] = <span class="hljs-keyword">new</span> LinkedList[v];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 申请空间</span><br>    inverseAdj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 通过邻接表生成逆邻接表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); ++j) &#123;<br>      <span class="hljs-keyword">int</span> w = adj[i].get(j); <span class="hljs-comment">// i-&gt;w</span><br>      inverseAdj[w].add(i); <span class="hljs-comment">// w-&gt;i</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[v];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 深度优先遍历图</span><br>    <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-keyword">false</span>) &#123;<br>      visited[i] = <span class="hljs-keyword">true</span>;<br>      dfs(i, inverseAdj, visited);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> vertex, LinkedList&lt;Integer&gt; inverseAdj[], <span class="hljs-keyword">boolean</span>[] visited)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inverseAdj[vertex].size(); ++i) &#123;<br>    <span class="hljs-keyword">int</span> w = inverseAdj[vertex].get(i);<br>    <span class="hljs-keyword">if</span> (visited[w] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">continue</span>;<br>    visited[w] = <span class="hljs-keyword">true</span>;<br>    dfs(w, inverseAdj, visited);<br>  &#125; <span class="hljs-comment">// 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</span><br>  System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span> + vertex);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第一部分是通过邻接表构造逆邻接表。</p>
<p>邻接表中，边 s-&gt;t 表示 s 先于 t 执行，也就是 t 要依赖 s。在逆邻接表中，边 s-&gt;t 表示 s 依赖于 t，s 后于 t 执行。</p>
<p>第二部分是递归处理每个顶点。</p>
<p>对于顶点 vertex 来说，先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己。</p>
<p><strong>时间复杂度：</strong></p>
<p>每个顶点被访问两次，每条边都被访问一次，所以时间复杂度也是 O(V+E)。</p>
<h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><blockquote>
<p>将整个地图抽象成一个有向有权图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123; <span class="hljs-comment">// 有向有权图的邻接表表示</span><br>  <span class="hljs-keyword">private</span> LinkedList&lt;Edge&gt; adj[]; <span class="hljs-comment">// 邻接表</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> v; <span class="hljs-comment">// 顶点个数</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.v = v;<br>    <span class="hljs-keyword">this</span>.adj = <span class="hljs-keyword">new</span> LinkedList[v];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;<br>      <span class="hljs-keyword">this</span>.adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> w)</span> </span>&#123; <span class="hljs-comment">// 添加一条边</span><br>    <span class="hljs-keyword">this</span>.adj[s].add(<span class="hljs-keyword">new</span> Edge(s, t, w));<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sid; <span class="hljs-comment">// 边的起始顶点编号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> tid; <span class="hljs-comment">// 边的终止顶点编号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> w; <span class="hljs-comment">// 权重</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid, <span class="hljs-keyword">int</span> tid, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.sid = sid;<br>      <span class="hljs-keyword">this</span>.tid = tid;<br>      <span class="hljs-keyword">this</span>.w = w;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 下面这个类是为了dijkstra实现用的</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// 顶点编号ID</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> dist; <span class="hljs-comment">// 从起始顶点到这个顶点的距离</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vertex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> dist)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.id = id;<br>      <span class="hljs-keyword">this</span>.dist = dist;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>Dijkstra 算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 因为Java提供的优先级队列，没有暴露更新数据的接口，所以我们需要重新实现一个</span><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span> </span>&#123; <span class="hljs-comment">// 根据vertex.dist构建小顶堆</span><br>  <span class="hljs-keyword">private</span> Vertex[] nodes;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.nodes = <span class="hljs-keyword">new</span> Vertex[v+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">this</span>.count = v;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Vertex <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现... &#125;</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Vertex vertex)</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现...&#125;</span><br>  <span class="hljs-comment">// 更新结点的值，并且从下往上堆化，重新符合堆的定义。时间复杂度O(logn)。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Vertex vertex)</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现...&#125; </span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现...&#125;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 从顶点s到顶点t的最短路径</span><br>  <span class="hljs-keyword">int</span>[] predecessor = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.v]; <span class="hljs-comment">// 用来还原最短路径</span><br>  Vertex[] vertexes = <span class="hljs-keyword">new</span> Vertex[<span class="hljs-keyword">this</span>.v];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.v; ++i) &#123;<br>    vertexes[i] = <span class="hljs-keyword">new</span> Vertex(i, Integer.MAX_VALUE);<br>  &#125;<br>  PriorityQueue queue = <span class="hljs-keyword">new</span> PriorityQueue(<span class="hljs-keyword">this</span>.v);<span class="hljs-comment">// 小顶堆</span><br>  <span class="hljs-keyword">boolean</span>[] inqueue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.v]; <span class="hljs-comment">// 标记是否进入过队列</span><br>  vertexes[s].dist = <span class="hljs-number">0</span>;<br>  queue.add(vertexes[s]);<br>  inqueue[s] = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>    Vertex minVertex= queue.poll(); <span class="hljs-comment">// 取堆顶元素并删除</span><br>    <span class="hljs-keyword">if</span> (minVertex.id == t) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 最短路径产生了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[minVertex.id].size(); ++i) &#123;<br>      Edge e = adj[minVertex.id].get(i); <span class="hljs-comment">// 取出一条minVetex相连的边</span><br>      Vertex nextVertex = vertexes[e.tid]; <span class="hljs-comment">// minVertex--&gt;nextVertex</span><br>      <span class="hljs-keyword">if</span> (minVertex.dist + e.w &lt; nextVertex.dist) &#123; <span class="hljs-comment">// 更新next的dist</span><br>        nextVertex.dist = minVertex.dist + e.w;<br>        predecessor[nextVertex.id] = minVertex.id;<br>        <span class="hljs-keyword">if</span> (inqueue[nextVertex.id] == <span class="hljs-keyword">true</span>) &#123;<br>          queue.update(nextVertex); <span class="hljs-comment">// 更新队列中的dist值</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          queue.add(nextVertex);<br>          inqueue[nextVertex.id] = <span class="hljs-keyword">true</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 输出最短路径</span><br>  System.out.print(s);<br>  print(s, t, predecessor);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span>[] predecessor)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (s == t) <span class="hljs-keyword">return</span>;<br>  print(s, predecessor[t], predecessor);<br>  System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span> + t);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>用 vertexes 数组，记录从起始顶点到每个顶点的距离（dist）</p>
<ol>
<li><p>首先将所有顶点的 dist 都初始化为无穷大（Integer.MAX_VALUE），起始顶点的 dist 值初始化为 0，然后将其放到优先级队列中。</p>
</li>
<li><p>从优先级队列中取出 dist 最小的顶点 minVertex，然后考察这个顶点可达的所有顶点（nextVertex）</p>
</li>
<li>如果 minVertex 的 dist 值加上 minVertex 与 nextVertex 之间边的权重 w 小于 nextVertex 当前的 dist 值，也就是说，存在另一条更短的路径，它经过 minVertex 到达 nextVertex。把 nextVertex 的 dist 更新为 minVertex 的 dist 值加上 w。把 nextVertex 加入到优先级队列中。</li>
<li>重复这个过程，直到找到终止顶点 t 或者队列为空。</li>
</ol>
<p>predecessor 数组的作用是为了还原最短路径，它记录每个顶点的前驱顶点。最后，通过递归的方式，将这个路径打印出来。</p>
<p>inqueue 数组是为了避免将一个顶点多次添加到优先级队列中。更新了某个顶点的 dist 值之后，如果这个顶点已经在优先级队列中了，就不要再将它重复添加进去了。</p>
<p><img src="/article/Dijkstra 算法.jpg"><span class="image-caption">Dijkstra 算法</span></p>
<p><strong>时间复杂度</strong></p>
<p>while 循环最多会执行 V 次（V 表示顶点的个数），而内部的 for 循环的执行次数不确定，跟每个顶点的相邻边的个数有关，分别记作 E0，E1，E2，……，E(V-1)。如果把这 V 个顶点的边都加起来，最大也不会超过图中所有边的个数 E（E 表示边的个数）。</p>
<p>for 循环内部的代码涉及从优先级队列取数据、往优先级队列中添加数据、更新优先级队列中的数据，这样三个主要的操作。优先级队列是用堆来实现的，堆中的这几个操作，时间复杂度都是 O(logV)（堆中的元素个数不会超过顶点的个数 V）。</p>
<p>时间复杂度就是 O(E*logV)</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>数据结构与算法,图</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis核心技术与实战</title>
    <url>/article/30584.html</url>
    <content><![CDATA[<p><a href="https://time.geekbang.org/column/article/268247">参考</a></p>
<p><strong>Redis 知识全景图包括“两大维度，三大主线”</strong></p>
<p><img src="/article/Redis 知识全景图.jpg"><span class="image-caption">Redis 知识全景图</span></p>
<p><strong>Redis问题画像</strong></p>
<img src="/article/30584/Redis%E9%97%AE%E9%A2%98%E7%94%BB%E5%83%8F.jpeg" class title="Redis问题画像">
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><blockquote>
<p><strong>Redis 的快，到底是快在哪里呢？</strong></p>
<p><strong>一方面</strong>，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。</p>
<p><strong>另一方面</strong>，这要归功于它的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。</p>
</blockquote>
<p>底层数据结构一共有 6 种，分别是<strong>简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组</strong></p>
<img src="/article/30584/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" class title="底层数据结构">
<p>List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p>
<p><strong>压缩列表</strong>实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 <strong>zlbytes、zltail 和 zllen</strong>，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 <strong>zlend</strong>，表示列表结束。</p>
<img src="/article/30584/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.jpg" class title="压缩列表">
<p><strong>跳表</strong>在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</p>
<img src="/article/30584/%E8%B7%B3%E8%A1%A8.jpg" class title="跳表">
<h3 id="键和值用什么结构组织？"><a href="#键和值用什么结构组织？" class="headerlink" title="键和值用什么结构组织？"></a>键和值用什么结构组织？</h3><p><strong>Redis 使用了一个哈希表来保存所有键值对：</strong>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶，哈希桶中的元素保存的并不是值本身，而是<strong>指向具体值的指针</strong>。</p>
<p>哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值</p>
<img src="/article/30584/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.jpg" class title="全局哈希表">
<p>可以用 <strong>O(1) 的时间复杂度</strong>来快速查找到键值对——只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中</p>
<ol>
<li><p>链式哈希</p>
<p>Redis 解决哈希冲突的方式，就是链式哈希。<strong>指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。</strong></p>
<img src="/article/30584/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg" class title="链表法">
</li>
<li><p>rehash</p>
<p>如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低</p>
<p><strong>Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突</strong></p>
<blockquote>
<p>Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>
<li>释放哈希表 1 的空间。</li>
</ol>
<p>从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用</p>
<p><strong>问题：第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求</strong></p>
</blockquote>
<p><strong>渐进式 rehash</strong></p>
<p>在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：</p>
<p><img src="/article/渐进式 rehash.jpg"><span class="image-caption">渐进式 rehash</span></p>
</li>
</ol>
<h3 id="不同数据结构查找的时间复杂度"><a href="#不同数据结构查找的时间复杂度" class="headerlink" title="不同数据结构查找的时间复杂度"></a>不同数据结构查找的时间复杂度</h3><img src="/article/30584/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" class title="时间复杂度">
<ol>
<li>单元素操作，是指每一种集合类型对单个数据实现的增删改查操作，复杂度都是 O(1)</li>
<li>范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。</li>
<li>统计操作，是指集合类型对集合中所有元素个数的记录。这类操作复杂度只有 O(1)。</li>
<li>例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</li>
</ol>
<h3 id="String-类型数据结构"><a href="#String-类型数据结构" class="headerlink" title="String 类型数据结构"></a>String 类型数据结构</h3><p>String 类型提供的“一个键对应一个值的数据”</p>
<p>String 类型并不是适用于所有场合的，它有一个明显的短板，就是它<strong>保存数据时所消耗的内存空间较多。</strong></p>
<h4 id="为什么-String-类型内存开销大？"><a href="#为什么-String-类型内存开销大？" class="headerlink" title="为什么 String 类型内存开销大？"></a>为什么 String 类型内存开销大？</h4><hr>
<p>元数据 + 实际数据</p>
<p>除了<strong>记录实际数据</strong>，String 类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作<strong>元数据</strong>。</p>
<p>当你保存 64 位<strong>有符号整数</strong>时，String 类型会把它保存为一个 8 字节的 Long 类型整数，这种保存方式通常也叫作 int 编码方式。</p>
<p>但是，当你保存的数据中<strong>包含字符</strong>时，String 类型就会用简单动态字符串（Simple Dynamic String，SDS）结构体来保存，如下图所示：</p>
<img src="/article/30584/SDS%E7%BB%93%E6%9E%84%E4%BD%93.jpg" class title="SDS结构体">
<ol>
<li>buf：字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个“\0”，这就会额外占用 1 个字节的开销。</li>
<li>len：占 4 个字节，表示 buf 的已用长度。</li>
<li>alloc：也占个 4 字节，表示 buf 的实际分配长度，一般大于 len。</li>
</ol>
<p>在 SDS 中，buf 保存实际数据，而 len 和 alloc 本身其实是 SDS 结构体的额外开销。</p>
<hr>
<p>对于 String 类型来说，除了 SDS 的额外开销，还有一个来自于 <strong>RedisObject</strong> 结构体的开销。</p>
<p>因为 Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。</p>
<p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在。</p>
<img src="/article/30584/RedisObject%E7%BB%93%E6%9E%84%E4%BD%93.jpg" class title="RedisObject结构体">
<hr>
<p>为了节省内存空间，Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计。</p>
<ol>
<li>当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。</li>
<li>当保存的是字符串数据，并且字符串<strong>小于等于 44 字节</strong>时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。</li>
<li>当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 <strong>raw 编码模式</strong>。</li>
</ol>
<p><img src="/article/int、embstr 和 raw 三种编码模式.jpg"><span class="image-caption">int、embstr 和 raw 三种编码模式</span></p>
<hr>
<p>Redis 使用的内存分配库 jemalloc</p>
<p>jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。</p>
<hr>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>Redis 有一种底层数据结构，叫压缩列表（ziplist），这是一种非常节省内存的结构。</p>
<p>压缩列表的构成：表头有三个字段 <strong>zlbytes、zltail 和 zllen</strong>，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表尾还有一个 <strong>zlend</strong>，表示列表结束。</p>
<img src="/article/30584/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90.jpg" class title="压缩列表的构成">
<p>压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分。</p>
<ol>
<li><strong>prev_len</strong>，表示前一个 entry 的长度。prev_len 有两种取值情况：<strong>1 字节或 5 字节</strong>。取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255 表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。</li>
<li>len：表示自身长度，4 字节；</li>
<li>encoding：表示编码方式，1 字节；</li>
<li>content：保存实际数据。</li>
</ol>
<p>这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。</p>
<p>Redis 基于压缩列表实现了 <strong>List、Hash 和 Sorted Set</strong> 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。</p>
<h4 id="如何用集合类型保存单值的键值对？"><a href="#如何用集合类型保存单值的键值对？" class="headerlink" title="如何用集合类型保存单值的键值对？"></a>如何用集合类型保存单值的键值对？</h4><p>在保存单值的键值对时，可以采用基于 Hash 类型的二级编码方法。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value。</p>
<blockquote>
<p>以图片 ID 1101000060 和图片存储对象 ID 3302000080 为例</p>
<p>可以把图片 ID 的前 7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象 ID 分别作为 Hash 类型值中的 key 和 value。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; info memory<br><span class="hljs-meta">#</span><span class="bash"> Memory</span><br>used_memory:1039120<br>127.0.0.1:6379&gt; hset 1101000 060 3302000080<br>(integer) 1<br>127.0.0.1:6379&gt; info memory<br><span class="hljs-meta">#</span><span class="bash"> Memory</span><br>used_memory:1039136<br></code></pre></td></tr></table></figure>
<p>增加一条记录后，内存占用只增加了 16 字节</p>
</blockquote>
<p><strong>二级编码方法中采用的 ID 长度</strong></p>
<p>hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。</p>
<p>这两个阈值分别对应以下两个配置项：</p>
<ol>
<li><code>hash-max-ziplist-entries</code>：表示用压缩列表保存时哈希集合中的最大元素个数。</li>
<li><code>hash-max-ziplist-value</code>：表示用压缩列表保存时哈希集合中单个元素的最大长度。</li>
</ol>
<p>如果 Hash 集合中写入的元素个数超过了 <code>hash-max-ziplist-entries</code>并且写入的单个元素大小超过了 <code>hash-max-ziplist-value</code>，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表。</p>
<p>一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。</p>
<p><strong>为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash 集合中的元素个数。</strong></p>
<blockquote>
<p>所以，在二级编码中，只用图片 ID <strong>最后 3 位作为 Hash 集合的 key</strong>，也就<strong>保证了 Hash 集合的元素个数不超过 1000</strong>，同时，我们把 <code>hash-max-ziplist-entries</code>设置为 1000，这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了。</p>
</blockquote>
<h3 id="集合统计模式"><a href="#集合统计模式" class="headerlink" title="集合统计模式"></a>集合统计模式</h3><p>常见的四种统计模式，包括<strong>聚合统计、排序统计、二值状态统计和基数统计</strong></p>
<img src="/article/30584/%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg" class title="集合统计模式">
<h4 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h4><blockquote>
<p>在移动应用中，需要统计每天的新增用户数和第二天的留存用户数；</p>
</blockquote>
<p>所谓的<strong>聚合统计</strong>，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。</p>
<blockquote>
<p>可以用一个集合记录所有登录过 App 的用户 ID，同时，用另一个集合记录每一天登录过 App 的用户 ID。然后，再对这两个集合做聚合统计。</p>
<p>记录所有登录过 App 的用户 ID 可以直接使用 Set 类型</p>
<ol>
<li>key 是 user:id 以及当天日期；</li>
<li>value 是 Set 集合，记录当天登录的用户 ID。</li>
</ol>
<p>这个 Set 叫作每日用户 Set，如下图所示：</p>
<img src="/article/30584/%E6%AF%8F%E6%97%A5%E7%94%A8%E6%88%B7set.jpg" class title="每日用户set">
<ol>
<li><p>在统计每天的新增用户时，我们只用计算每日用户 Set 和累计用户 Set 的差集就行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">SDIFFSTORE  user:new  user:id:20200804 user:id  <br></code></pre></td></tr></table></figure>
<p><code>SDIFFSTORE</code> 命令计算累计用户 Set 和 20200804 Set 的差集，结果保存在 key 为 user:new 的 Set 中</p>
</li>
<li><p>计算 8 月 4 日的留存用户</p>
<p>计算 20200803 和 20200804 两个 Set 的交集，就可以得到同时在这两个集合中的用户 ID</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SINTERSTORE user:id:rem user:id:20200803 user:id:20200804<br></code></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p><strong>Set 的差集、并集和交集的计算复杂度较高</strong>，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。</p>
<p>所以，可以从主从集群中选择一个从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了。</p>
<p><strong>注意：</strong></p>
<ol>
<li><p><strong>“Set数据类型，使用 <code>SUNIONSTORE</code>、<code>SDIFFSTORE</code>、<code>SINTERSTORE</code> 做并集、差集、交集时，选择一个从库进行聚合计算”。这3个命令都会在Redis中生成一个新key，而从库默认是readonly不可写的，所以这些命令只能在主库使用。想在从库上操作，可以使用 <code>SUNION</code>、<code>SDIFF</code>、<code>SINTER</code> ，这些命令可以计算出结果，但不会生成新key。</strong></p>
</li>
<li><p><strong>如果是在集群模式使用多个key聚合计算的命令，一定要注意，因为这些key可能分布在不同的实例上，多个实例之间是无法做聚合运算的，这样操作可能会直接报错或者得到的结果是错误的！</strong></p>
</li>
</ol>
<h4 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h4><blockquote>
<p>在电商网站的商品评论中，需要统计评论列表中的最新评论；</p>
</blockquote>
<p>要求集合类型能对元素保序，也就是说，集合中的元素可以按序排列，这种对元素保序的集合类型叫作有序集合。</p>
<p>在 Redis 常用的 4 个集合类型中（List、Hash、Set、Sorted Set），<strong>List 和 Sorted Set</strong> 就属于有序集合。</p>
<p><strong>List 是按照元素进入 List 的顺序进行排序的，而 Sorted Set 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。</strong></p>
<p><strong>使用List</strong></p>
<blockquote>
<p>每个商品对应一个 List，这个 List 包含了对这个商品的所有评论，而且会按照评论时间保存这些评论，每来一个新评论，就用 LPUSH 命令把它插入 List 的队头。</p>
<p>在只有一页评论的时候，我们可以很清晰地看到最新的评论，但是，在实际应用中，网站一般会分页显示最新的评论列表，一旦涉及到分页操作，List 就可能会出现问题了。</p>
<blockquote>
<p>假设当前的评论 List 是{A, B, C, D, E, F}（其中，A 是最新的评论，以此类推，F 是最早的评论），在展示第一页的 3 个评论时，可以用下面的命令，得到最新的三条评论 A、B、C：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">LRANGE product1 0 2<br>1) &quot;A&quot;<br>2) &quot;B&quot;<br>3) &quot;C&quot;<br></code></pre></td></tr></table></figure>
<p>但是，如果在展示第二页前，又产生了一个新评论 G，评论 G 就会被 LPUSH 命令插入到评论 List 的队头，评论 List 就变成了{G, A, B, C, D, E, F}。此时，再用刚才的命令获取第二页评论时，就会发现，评论 C 又被展示出来了，也就是 C、D、E。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">LRANGE product1 3 5<br>1) <span class="hljs-string">&quot;C&quot;</span><br>2) <span class="hljs-string">&quot;D&quot;</span><br>3) <span class="hljs-string">&quot;E&quot;</span><br></code></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>List 是通过元素在 List 中的位置来排序的，当有一个新元素插入时，原先的元素在 List 中的位置都后移了一位，比如说原来在第 1 位的元素现在排在了第 2 位。</p>
<blockquote>
<p>所以，对比新元素插入前后，List 相同位置上的元素就会发生变化，用 <code>LRANGE</code> 读取时，就会读到旧元素。</p>
</blockquote>
<p><strong>使用 Sorted Set</strong></p>
<p>Sorted Set是根据元素的实际权重来排序和获取数据的</p>
<blockquote>
<p>按评论时间的先后给每条评论设置一个权重值，然后再把评论保存到 Sorted Set 中。Sorted Set 的 <code>ZRANGEBYSCORE</code> 命令就可以按权重排序后返回元素。这样的话，即使集合中的元素频繁更新，Sorted Set 也能通过 <code>ZRANGEBYSCORE</code> 命令准确地获取到按序排列的数据。</p>
<p>假设越新的评论权重越大，目前最新评论的权重是 N，我们执行下面的命令时，就可以获得最新的 10 条评论：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">ZRANGEBYSCORE comments N-9 N<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h4><blockquote>
<p>用户在手机 App 上的签到打卡信息：一天对应一系列用户的签到记录</p>
</blockquote>
<p>二值状态就是指集合元素的取值就<strong>只有 0 和 1 两种</strong></p>
<blockquote>
<p>在签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。这个时候，我们就可以选择 <strong>Bitmap</strong>。这是 Redis 提供的扩展数据类型。</p>
</blockquote>
<p>Bitmap 本身是<strong>用 String 类型作为底层数据结构</strong>实现的一种统计二值状态的数据类型。String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态。可以把 Bitmap 看作是一个 bit 数组。</p>
<p>Bitmap 提供了 <code>GETBIT/SETBIT</code> 操作，使用一个偏移值 <strong>offset</strong> 对 bit 数组的某一个 bit 位进行读和写。</p>
<p>Bitmap 的偏移量是从 0 开始算的，也就是说 offset 的最小值是 0。当使用 <code>SETBIT</code> 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。Bitmap 还提供了 <code>BITCOUNT</code> 操作，用来统计这个 bit 数组中所有“1”的个数。</p>
<blockquote>
<p>统计 ID 3000 的用户在 2020 年 8 月份的签到情况</p>
<ol>
<li><p>执行命令，记录该用户 8 月 3 号已签到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SETBIT uid:sign:3000:202008 2 1 <br></code></pre></td></tr></table></figure>
<p>offset = 2 (从0开始 0、1、2)</p>
</li>
<li><p>检查该用户 8 月 3 日是否签到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">GETBIT uid:sign:3000:202008 2 <br></code></pre></td></tr></table></figure>
</li>
<li><p>统计该用户在 8 月份的签到次数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">BITCOUNT uid:sign:3000:202008<br></code></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<p>如果记录了 1 亿个用户 10 天的签到情况，统计出这 10 天连续签到的用户总数吗？</p>
</blockquote>
<p>Bitmap 支持用 <code>BITOP</code> 命令对多个 Bitmap 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 Bitmap 中</p>
<blockquote>
<p>对应 bit 位做“与”操作，结果保存到了一个新的 Bitmap 中</p>
<ol>
<li>在统计 1 亿个用户连续 10 天的签到情况时，把每天的日期作为 key，每个 key 对应一个 1 亿位的 Bitmap，每一个 bit 对应一个用户当天的签到情况</li>
<li>对 10 个 Bitmap 做“与”操作，得到的结果也是一个 Bitmap。在这个 Bitmap 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。</li>
<li>最后，我们可以用 <code>BITCOUNT</code> 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。</li>
</ol>
</blockquote>
<h4 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h4><blockquote>
<p>在网页访问记录中，需要统计独立访客（Unique Visitor，UV）量</p>
</blockquote>
<p>基数统计就是指统计一个集合中不重复的元素个数</p>
<blockquote>
<p>网页 UV 的统计有个独特的地方，就是需要去重，一个用户一天内的多次访问只能算作一次。</p>
</blockquote>
<p><strong>使用 set</strong></p>
<blockquote>
<p>有一个用户 user1 访问 page1 时，把这个信息加到 Set 中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SADD page1:uv user1<br></code></pre></td></tr></table></figure>
<p>用户 1 再来访问时，Set 的去重功能就保证了不会重复记录用户 1 的访问次数，这样，用户 1 就算是一个独立访客。当需要统计 UV 时，可以直接用 <code>SCARD</code> 命令，这个命令会返回一个集合中的元素个数。</p>
<p>但是，如果 page1 非常火爆，UV 达到了千万，这个时候，一个 Set 就要记录千万个用户 ID。对于一个搞大促的电商网站而言，这样的页面可能有成千上万个，如果每个页面都用这样的一个 Set，就会<strong>消耗很大的内存空间</strong>。</p>
</blockquote>
<p><strong>使用 Hash</strong></p>
<blockquote>
<p>可以把用户 ID 作为 Hash 集合的 key，当用户访问页面时，就用 <code>HSET</code> 命令（用于设置 Hash 集合元素的值），对这个用户 ID 记录一个值“1”，表示一个独立访客，用户 1 访问 page1 后，我们就记录为 1 个独立访客，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">HSET page1:uv user1 1<br></code></pre></td></tr></table></figure>
<p>即使用户 1 多次访问页面，重复执行这个 HSET 命令，也只会把 user1 的值设置为 1，仍然只记为 1 个独立访客。当要统计 UV 时，我们可以用 <code>HLEN</code> 命令统计 Hash 集合中的所有元素个数。</p>
<p>当页面很多时，Hash 类型也会<strong>消耗很大的内存空间</strong></p>
</blockquote>
<p><strong>使用 HyperLogLog</strong></p>
<p><strong>HyperLogLog 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。</strong></p>
<p>在 Redis 中，每个 HyperLogLog 只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数。</p>
<blockquote>
<p>可以用 <code>PFADD</code> 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">PFADD page1:uv user1 user2 user3 user4 user5<br></code></pre></td></tr></table></figure>
<p>接下来，就可以用 <code>PFCOUNT</code> 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">PFCOUNT page1:uv<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的</strong>，标准误算率是 0.81%</p>
<h3 id="GEO数据类型"><a href="#GEO数据类型" class="headerlink" title="GEO数据类型"></a>GEO数据类型</h3><p><strong>GEO 的底层结构</strong>:GEO 类型的底层数据结构就是用 Sorted Set 来实现的</p>
<p><strong>GeoHash 的编码方法</strong></p>
<p>为了能高效地对经纬度进行比较，Redis 采用了业界广泛使用的 GeoHash 编码方法，这个方法的基本原理就是“二分区间，区间编码”。</p>
<p>要对一组经纬度进行 GeoHash 编码时，要先对经度和纬度分别编码，然后再把经纬度各自的编码组合成一个最终编码。</p>
<p>对于一个地理位置信息来说，它的经度范围是[-180,180]。GeoHash 编码会把一个经度值编码成一个 N 位的二进制值，我们来对经度范围[-180,180]做 N 次的二分区操作，其中 N 可以自定义。<br>在进行第一次二分区时，经度范围[-180,180]会被分成两个子区间：[-180,0) 和[0,180]（称之为左、右分区）。此时，可以查看一下要编码的经度值落在了左分区还是右分区。如果是落在左分区，我们就用 0 表示；如果落在右分区，就用 1 表示。这样一来，每做完一次二分区，就可以得到 1 位编码值。<br>然后，再对经度值所属的分区再做一次二分区，同时再次查看经度值落在了二分区后的左分区还是右分区，按照刚才的规则再做 1 位编码。当做完 N 次的二分区后，经度值就可以用一个 N bit 的数来表示了。</p>
<blockquote>
<p>对（116.37，39.86）进行编码</p>
<img src="/article/30584/%E7%BB%8F%E5%BA%A6%E7%BC%96%E7%A0%81.jpg" class title="经度编码">
<img src="/article/30584/%E7%BA%AC%E5%BA%A6%E7%BC%96%E7%A0%81.jpg" class title="纬度编码">
<p>当一组经纬度值都编完码后，再把它们的各自编码值组合在一起，组合的规则是：最终编码值的<strong>偶数位上依次是经度的编码值，奇数位上依次是纬度的编码值</strong>，其中，偶数位从 0 开始，奇数位从 1 开始。</p>
<img src="/article/30584/%E6%9C%80%E7%BB%88%E7%BC%96%E7%A0%81%E5%80%BC.jpg" class title="最终编码值">
</blockquote>
<p>使用 GeoHash 编码后，相当于把整个地理空间划分成了一个个方格，每个方格对应了 GeoHash 中的一个分区。</p>
<p>每个方格覆盖了一定范围内的经纬度值，分区越多，每个方格能覆盖到的地理空间就越小，也就越精准。</p>
<p><img src="/article/4 个方格.jpg"><span class="image-caption">4 个方格</span></p>
<p>有的编码值虽然在大小上接近，但实际对应的方格却距离比较远</p>
<blockquote>
<p><img src="/article/16 个方格.jpg"><span class="image-caption">16 个方格</span></p>
</blockquote>
<p>为了避免查询不准确问题，可以同时查询给定经纬度所在的方格周围的 4 个或 8 个方格。</p>
<h4 id="操作-GEO-类型"><a href="#操作-GEO-类型" class="headerlink" title="操作 GEO 类型"></a>操作 GEO 类型</h4><ol>
<li><code>GEOADD</code> 命令：用于把一组经纬度信息和相对应的一个 ID 记录到 GEO 类型集合中；</li>
<li><code>GEORADIUS</code> 命令：会根据输入的经纬度位置，查找以这个经纬度为中心的一定范围内的其他元素。当然，我们可以自己定义这个范围。</li>
</ol>
<blockquote>
<p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">GEOADD cars:locations 116.034579 39.030452 33<br></code></pre></td></tr></table></figure>
<p>LBS 位置信息服务（Location-Based Service，LBS）应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。可以修改“5”这个参数，来返回更大或更小范围内的车辆信息。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h3><p><strong>Redis 键值对中的每一个值都是用 RedisObject 保存的</strong></p>
<p>RedisObject 包括元数据和指针。其中，元数据的一个功能就是用来区分不同的数据类型，指针用来指向具体的数据类型的值。</p>
<h4 id="Redis-的基本对象结构"><a href="#Redis-的基本对象结构" class="headerlink" title="Redis 的基本对象结构"></a>Redis 的基本对象结构</h4><p>RedisObject 的内部组成包括了 type、encoding、lru 和 refcount 4 个元数据，以及 1 个 *ptr 指针。</p>
<ol>
<li>type：表示值的类型，涵盖五大基本类型；</li>
<li>encoding：是值的编码方式，用来表示 Redis 中实现各个基本类型的底层数据结构，例如 SDS、压缩列表、哈希表、跳表等；</li>
<li>lru：记录了这个对象最后一次被访问的时间，用于淘汰过期的键值对；</li>
<li>refcount：记录了对象的引用计数；</li>
<li>*ptr：是指向数据的指针。</li>
</ol>
<p><img src="/article/Redis 的基本对象结构.jpg"><span class="image-caption">Redis 的基本对象结构</span></p>
<p>RedisObject 结构借助 *ptr 指针，就可以指向不同的数据类型</p>
<h4 id="开发一个新的数据类型"><a href="#开发一个新的数据类型" class="headerlink" title="开发一个新的数据类型"></a>开发一个新的数据类型</h4><p>首先，需要为新数据类型定义好它的底层结构、type 和 encoding 属性值，然后再实现新数据类型的创建、释放函数和基本命令。</p>
<img src="/article/30584/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpg" class title="开发一个新的数据类型">
<ol>
<li><p>定义新数据类型的底层结构</p>
<p>用 newtype.h 文件来保存这个新类型的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewTypeObject</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewTypeNode</span> *<span class="hljs-title">head</span>;</span> <br>    <span class="hljs-keyword">size_t</span> len; <br>&#125;NewTypeObject; <br></code></pre></td></tr></table></figure>
<p>其中，NewTypeNode 结构就是我们自定义的新类型的底层结构。为底层结构设计两个成员变量：一个是 Long 类型的 value 值，用来保存实际数据；一个是*next指针，指向下一个 NewTypeNode 结构。</p>
</li>
<li><p>在 RedisObject 的 type 属性中，增加这个新类型的定义</p>
<p>在 Redis 的 server.h 文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_STRING 0    <span class="hljs-comment">/* String object. */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_LIST 1      <span class="hljs-comment">/* List object. */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_SET 2       <span class="hljs-comment">/* Set object. */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ZSET 3      <span class="hljs-comment">/* Sorted set object. */</span></span><br>…<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_NEWTYPE 7</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>开发新类型的创建和释放函数</p>
<p>Redis 把数据类型的创建和释放函数都定义在了 object.c 文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">robj *<span class="hljs-title">createNewTypeObject</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>   NewTypeObject *h = newtypeNew(); <br>   robj *o = createObject(OBJ_NEWTYPE,h);<br>   <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>newtypeNew 函数,它是用来为新数据类型初始化内存结构的。这个初始化过程主要是用 zmalloc 做底层结构分配空间，以便写入数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">NewTypeObject *<span class="hljs-title">newtypeNew</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    NewTypeObject *n = zmalloc(<span class="hljs-keyword">sizeof</span>(*n));<br>    n-&gt;head = <span class="hljs-literal">NULL</span>;<br>    n-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>newtypeNew 函数涉及到新数据类型的具体创建，而 Redis 默认会为每个数据类型定义一个单独文件，实现这个类型的创建和命令操作。按照 Redis 的惯例，把 newtypeNew 函数定义在名为 t_newtype.c 的文件中。</p>
<p>createObject 是 Redis 本身提供的 RedisObject 创建函数，它的参数是数据类型的 type 和指向数据类型实现的指针*ptr。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function">robj *<span class="hljs-title">createObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;<br>    robj *o = zmalloc(<span class="hljs-keyword">sizeof</span>(*o));<br>    o-&gt;type = type;<br>    o-&gt;ptr = ptr;<br>    ...<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于释放函数来说，它是创建函数的反过程，是用 zfree 命令把新结构的内存空间释放掉。</p>
</li>
<li><p>开发新类型的命令操作</p>
<ol>
<li><p>在 t_newtype.c 文件中增加命令操作的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ntinsertCommand</span><span class="hljs-params">(client *c)</span></span>&#123;<br>  <span class="hljs-comment">//基于客户端传递的参数，实现在NewTypeObject链表头插入元素</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>在 server.h 文件中，声明我们已经实现的命令，以便在 server.c 文件引用这个命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ntinsertCommand</span><span class="hljs-params">(client *c)</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在 server.c 文件中的 redisCommandTable 里面，把新增命令和实现函数关联起来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisCommand</span> <span class="hljs-title">redisCommandTable</span>[] =</span> &#123; <br>...<br>&#123;<span class="hljs-string">&quot;ntinsert&quot;</span>,ntinsertCommand,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;m&quot;</span>,...&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="时间序列数据"><a href="#时间序列数据" class="headerlink" title="时间序列数据"></a>时间序列数据</h3><p><strong>时间序列数据的读写特点</strong></p>
<ol>
<li><p>写</p>
<p>时间序列数据通常是持续高并发写入的。</p>
<p>这种数据的写入特点很简单，就是插入数据快，这就要求选择的数据类型，在进行数据插入时，复杂度要低，尽量不要阻塞。</p>
</li>
<li><p>读</p>
<p>时间序列数据的“读”，查询模式多，比如范围查询、聚合查询等</p>
</li>
</ol>
<h4 id="基于-Hash-和-Sorted-Set-保存时间序列数据"><a href="#基于-Hash-和-Sorted-Set-保存时间序列数据" class="headerlink" title="基于 Hash 和 Sorted Set 保存时间序列数据"></a>基于 Hash 和 Sorted Set 保存时间序列数据</h4><p><strong>好处：</strong>是 Redis 内在的数据类型，代码成熟和性能稳定。所以，基于这两个数据类型保存时间序列数据，系统稳定性是可以预期的。</p>
<p>用 Hash 类型来实现单键的查询很简单。但是，Hash 类型有个短板：它并不支持对数据进行范围查询。</p>
<blockquote>
<p>虽然时间序列数据是按时间递增顺序插入 Hash 集合中的，但 Hash 类型的底层结构是哈希表，并没有对数据进行有序索引。所以，如果要对 Hash 类型进行范围查询的话，就需要扫描 Hash 集合中的所有数据，再把这些数据取回到客户端进行排序，然后，才能在客户端得到所查询范围内的数据。显然，查询效率很低。</p>
</blockquote>
<p>为了能同时支持按时间戳范围的查询，可以用 Sorted Set 来保存时间序列数据，因为它能够根据元素的权重分数来排序。可以把时间戳作为 Sorted Set 集合的元素分数，把时间点上记录的数据作为元素本身。</p>
<p><strong>保证写入 Hash 和 Sorted Set 是一个原子性的操作</strong></p>
<p>涉及到了 Redis 用来实现简单的事务的 <code>MULTI</code> 和 <code>EXEC</code> 命令。当多个命令及其参数本身无误时，<code>MULTI</code> 和 <code>EXEC</code> 命令可以保证执行这些命令时的原子性。</p>
<ol>
<li><code>MULTI</code> 命令：表示一系列原子性操作的开始。收到这个命令后，Redis 就知道，接下来再收到的命令需要放到一个内部队列中，后续一起执行，保证原子性。</li>
<li><code>EXEC</code> 命令：表示一系列原子性操作的结束。一旦 Redis 收到了这个命令，就表示所有要保证原子性的命令操作都已经发送完成了。此时，Redis 开始执行刚才放到内部队列中的所有命令操作。</li>
</ol>
<blockquote>
<img src="/article/30584/%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C.jpg" class title="原子性的操作">
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; MULTI<br>OK<br><br>127.0.0.1:6379&gt; HSET device:temperature 202008030911 26.8<br>QUEUED<br><br>127.0.0.1:6379&gt; ZADD device:temperature 202008030911 26.8<br>QUEUED<br><br>127.0.0.1:6379&gt; EXEC<br>1) (<span class="hljs-built_in">integer</span>) 1<br>2) (<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>对时间序列数据进行聚合计算</strong></p>
<blockquote>
<p>Sorted Set 只支持范围查询，无法直接进行聚合计算，所以，只能先把时间范围内的数据取回到客户端，然后在客户端自行完成聚合计算。这个方法虽然能完成聚合计算但是会带来一定的潜在风险，也就是大量数据在 Redis 实例和客户端间频繁传输，这会和其他操作命令竞争网络资源，导致其他操作变慢。</p>
</blockquote>
<p>为了避免客户端和 Redis 实例间频繁的大量数据传输，<strong>使用 RedisTimeSeries 来保存时间序列数据。</strong></p>
<p>RedisTimeSeries 支持直接在 Redis 实例上进行聚合计算。</p>
<h4 id="基于-RedisTimeSeries-模块保存时间序列数据"><a href="#基于-RedisTimeSeries-模块保存时间序列数据" class="headerlink" title="基于 RedisTimeSeries 模块保存时间序列数据"></a>基于 RedisTimeSeries 模块保存时间序列数据</h4><p><strong>RedisTimeSeries</strong> 是 Redis 的一个扩展模块。它专门面向时间序列数据提供了数据类型和访问接口，并且支持在 Redis 实例上直接对数据进行按时间范围的聚合计算以及按标签属性过滤查询数据集合。</p>
<blockquote>
<p>因为 RedisTimeSeries 不属于 Redis 的内建功能模块，在使用时，需要先把它的源码单独编译成动态链接库 redistimeseries.so，再使用 loadmodule 命令进行加载，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">loadmodule redistimeseries.so<br></code></pre></td></tr></table></figure>
</blockquote>
<p>RedisTimeSeries 的底层数据结构使用了链表，它的范围查询的复杂度是 O(N) 级别的，同时，它的 <code>TS.GET</code> 查询只能返回最新的数据，没有办法像 Hash 类型一样，可以返回任一时间点的数据。</p>
<p>当用于时间序列数据存取时，RedisTimeSeries 的操作主要有 5 个：</p>
<ol>
<li><p>用 <code>TS.CREATE</code> 命令创建时间序列数据集合；</p>
<p>需要设置时间序列数据集合的 key 和数据的过期时间（以毫秒为单位）。此外，还可以为数据集合设置标签，来表示数据集合的属性。</p>
<blockquote>
<p>创建一个 key 为 device:temperature、数据有效期为 600s 的时间序列数据集合。也就是说，这个集合中的数据创建了 600s 后，就会被自动删除。最后，给这个集合设置了一个标签属性{device_id:1}，表明这个数据集合中记录的是属于设备 ID 号为 1 的数据。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">TS.CREATE device:temperature RETENTION 600000 LABELS device_id 1<br>OK<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>用 <code>TS.ADD</code> 命令插入数据；</p>
<p><code>TS.ADD</code> 命令往时间序列集合中插入数据，包括时间戳和具体的数值</p>
<blockquote>
<p>往 device:temperature 集合中插入了一条数据，记录的是设备在 2020 年 8 月 3 日 9 时 5 分的设备温度</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">TS.ADD device:temperature 1596416700 25.1<br>1596416700<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>用 <code>TS.GET</code> 命令读取最新数据；</p>
<p>使用 <code>TS.GET</code> 命令读取数据集合中的最新一条数据</p>
<blockquote>
<p>把刚刚插入的最新数据读取出来\</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">TS.GET device:temperature<br>25.1<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>用 <code>TS.MGET</code> 命令按标签过滤查询数据集合；</p>
<p>使用 <code>TS.MGET</code> 命令，按照标签查询部分集合中的最新数据</p>
<p>在使用 <code>TS.CREATE</code> 创建数据集合时，可以给集合设置标签属性。进行查询时，就可以在查询条件中对集合标签属性进行匹配，最后的查询结果里只返回匹配上的集合中的最新数据。</p>
<blockquote>
<p>一共用 4 个集合为 4 个设备保存时间序列数据，设备的 ID 号是 1、2、3、4，在创建数据集合时，把 device_id 设置为每个集合的标签。此时，就可以使用下列 <code>TS.MGET</code> 命令，以及 FILTER 设置（这个配置项用来设置集合标签的过滤条件），查询 device_id 不等于 2 的所有其他设备的数据集合，并返回各自集合中的最新的一条数据。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">TS.MGET FILTER device_id!=2 <br>1) 1) <span class="hljs-string">&quot;device:temperature:1&quot;</span><br>   2) (empty list or <span class="hljs-built_in">set</span>)<br>   3) 1) (<span class="hljs-built_in">integer</span>) 1596417000<br>      2) <span class="hljs-string">&quot;25.3&quot;</span><br>2) 1) <span class="hljs-string">&quot;device:temperature:3&quot;</span><br>   2) (empty list or <span class="hljs-built_in">set</span>)<br>   3) 1) (<span class="hljs-built_in">integer</span>) 1596417000<br>      2) <span class="hljs-string">&quot;29.5&quot;</span><br>3) 1) <span class="hljs-string">&quot;device:temperature:4&quot;</span><br>   2) (empty list or <span class="hljs-built_in">set</span>)<br>   3) 1) (<span class="hljs-built_in">integer</span>) 1596417000<br>      2) <span class="hljs-string">&quot;30.1&quot;</span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>用 <code>TS.RANGE</code> 支持聚合计算的范围查询。</p>
<p>在对时间序列数据进行聚合计算时，可以使用 <code>TS.RANGE</code> 命令指定要查询的数据的时间范围，同时用 <code>AGGREGATION</code> 参数指定要执行的聚合计算类型。</p>
<blockquote>
<p>按照每 180s 的时间窗口，对 2020 年 8 月 3 日 9 时 5 分和 2020 年 8 月 3 日 9 时 12 分这段时间内的数据进行均值计算</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">TS.RANGE device:temperature 1596416700 1596417120 AGGREGATION avg 180000<br>1) 1) (<span class="hljs-built_in">integer</span>) 1596416700<br>   2) <span class="hljs-string">&quot;25.6&quot;</span><br>2) 1) (<span class="hljs-built_in">integer</span>) 1596416880<br>   2) <span class="hljs-string">&quot;25.8&quot;</span><br>3) 1) (<span class="hljs-built_in">integer</span>) 1596417060<br>   2) <span class="hljs-string">&quot;26.1&quot;</span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h2 id="Redis：高性能IO模型"><a href="#Redis：高性能IO模型" class="headerlink" title="Redis：高性能IO模型"></a>Redis：高性能IO模型</h2><p><strong>Redis 是单线程，主要是指 Redis 的<u>网络 IO 和键值对读写</u>是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。</strong></p>
<p><strong>采用单线程的一个核心原因是避免多线程开发的并发控制问题</strong></p>
<p>一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，这是它实现高性能的一个重要原因。</p>
<p>另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p>
<h3 id="Socket-网络模型的非阻塞模式"><a href="#Socket-网络模型的非阻塞模式" class="headerlink" title="Socket 网络模型的非阻塞模式"></a>Socket 网络模型的非阻塞模式</h3><blockquote>
<p>以 Get 请求为例，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。</p>
<img src="/article/30584/Redis%E5%9F%BA%E6%9C%ACIO%E6%A8%A1%E5%9E%8B.jpg" class title="Redis基本IO模型">
<p>但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。</p>
</blockquote>
<p>在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。</p>
<img src="/article/30584/Redis%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AE%BE%E7%BD%AE.jpg" class title="Redis套接字类型与非阻塞设置">
<p>针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 accept() 时，已经存在监听套接字了。</p>
<blockquote>
<p>要有机制继续监听监听套接字或已连接套接字，并在有数据达到时通知 Redis。</p>
</blockquote>
<h3 id="基于多路复用的高性能-I-O-模型"><a href="#基于多路复用的高性能-I-O-模型" class="headerlink" title="基于多路复用的高性能 I/O 模型"></a>基于多路复用的高性能 I/O 模型</h3><p>Linux 中的 IO 多路复用机制是指<strong>一个线程处理多个 IO 流</strong>，就是select/epoll 机制。</p>
<p>在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>
<img src="/article/30584/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B.webp" class title="基于多路复用的Redis高性能IO模型">
<p>图中的多个 FD 就是多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。</p>
<p><strong>回调机制</strong></p>
<p>为了在请求到达时能通知到 Redis 线程，<strong>select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数</strong>。</p>
<p>select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。</p>
<h2 id="Redis-的持久化（AOF）"><a href="#Redis-的持久化（AOF）" class="headerlink" title="Redis 的持久化（AOF）"></a>Redis 的持久化（AOF）</h2><h3 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h3><p>AOF（Append Only File） 日志是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志，如下图所示：</p>
<p><img src="/article/Redis AOF操作过程.jpg"><span class="image-caption">Redis AOF操作过程</span></p>
<p>AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。</p>
<p><strong>优点：</strong></p>
<ol>
<li><strong>写后日志</strong>这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。</li>
<li>它是在命令执行后才记录日志，所以不会阻塞当前的写操作。</li>
</ol>
<p><strong>风险：</strong></p>
<ol>
<li>首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</li>
<li>其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</li>
</ol>
<p><strong>AOF 文件过大带来的性能问题：</strong></p>
<ol>
<li>一是，文件系统本身对文件大小有限制，无法保存过大的文件；</li>
<li>二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；</li>
<li>三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用</li>
</ol>
<h3 id="AOF-三种写回策略"><a href="#AOF-三种写回策略" class="headerlink" title="AOF 三种写回策略"></a>AOF 三种写回策略</h3><p>AOF 配置项 <code>appendfsync</code> 三个可选值</p>
<ol>
<li><p>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p>
<p>“同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；</p>
</li>
<li><p>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p>
<p>“每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。</p>
</li>
<li><p>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p>
<p>虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；</p>
</li>
</ol>
<img src="/article/30584/%E4%B8%89%E7%A7%8D%E7%AD%96%E7%95%A5%E7%9A%84%E5%86%99%E5%9B%9E%E6%97%B6%E6%9C%BA%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9.jpg" class title="三种策略的写回时机，以及优缺点">
<h3 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h3><p>AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。</p>
<p>旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。</p>
<blockquote>
<img src="/article/30584/AOF%E9%87%8D%E5%86%99%E5%87%8F%E5%B0%91%E6%97%A5%E5%BF%97%E5%A4%A7%E5%B0%8F.jpg" class title="AOF重写减少日志大小">
</blockquote>
<p>有两个配置项在控制AOF重写的<strong>触发时机</strong>：</p>
<ol>
<li><code>auto-aof-rewrite-min-size</code>: 表示运行AOF重写时文件的最小大小，默认为64MB</li>
<li><code>auto-aof-rewrite-percentage</code>: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。 </li>
</ol>
<p>AOF文件大小同时超出上面这两个配置项时，会触发AOF重写。</p>
<p>和 AOF 日志由主线程写回不同，<strong>重写过程是由后台子进程 <em>bgrewriteaof</em> 来完成的</strong>，这也是为了避免阻塞主线程，导致数据库性能下降。</p>
<p><strong>一个拷贝，两处日志</strong></p>
<ol>
<li><p>“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 <strong>bgrewriteaof</strong> 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p>
<p>fork采用操作系统提供的<strong>写时复制(Copy On Write)机制</strong>，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题</p>
<p>fork子进程时，子进程是会拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据了，此时，类似于有了父进程的所有内存数据。</p>
</li>
<li><p>“两处日志”</p>
<ol>
<li>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。</li>
<li>新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，就可以用新的 AOF 文件替代旧文件了。</li>
</ol>
</li>
</ol>
<img src="/article/30584/AOF%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B.jpg" class title="AOF非阻塞的重写过程">
<h2 id="Redis宕机快速恢复（RDB）"><a href="#Redis宕机快速恢复（RDB）" class="headerlink" title="Redis宕机快速恢复（RDB）"></a>Redis宕机快速恢复（RDB）</h2><p><strong>内存快照</strong>。所谓内存快照，就是指内存中的数据在某一个时刻的状态记录</p>
<p>对 Redis 来说，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 <strong>RDB 文件</strong>，其中，RDB 就是 Redis DataBase 的缩写。</p>
<p>和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，可以直接把 RDB 文件读入内存，很快地完成恢复。</p>
<p>Redis 提供了两个命令来生成 RDB 文件：</p>
<ol>
<li>save：在主线程中执行，会导致阻塞；</li>
<li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的认配置。</li>
</ol>
<p><strong>关键问题：</strong></p>
<ol>
<li><p>对哪些数据做快照？这关系到快照的执行效率问题</p>
<p>Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是<strong>全量快照</strong>，也就是说，把内存中的所有数据都记录到磁盘中。</p>
</li>
<li><p>做快照时，数据还能被增删改吗？这关系到 Redis 是否被阻塞，能否同时正常处理请求。</p>
<p><strong>避免阻塞和正常处理写操作并不是一回事</strong>。主线程没有阻塞，可以正常接收请求，但是，为了保证快照完整性，它只能处理读操作，因为不能修改正在执行快照的数据。</p>
<p>Redis 就会借助操作系统提供的<strong>写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</strong></p>
<blockquote>
<p>bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</p>
<p>如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据写入 RDB 文件。</p>
<img src="/article/30584/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6%E4%BF%9D%E8%AF%81%E5%BF%AB%E7%85%A7%E6%9C%9F%E9%97%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BF%AE%E6%94%B9.jpg" class title="写时复制机制保证快照期间数据可修改">
</blockquote>
<p>既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。</p>
</li>
<li><p>多久做一次快照？</p>
<p>虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销。</p>
<ol>
<li>频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li>
<li>bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，<strong>fork 这个创建过程本身会阻塞主线程</strong>，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了（所以，在 Redis 中如果有一个 bgsave 在运行，就不会再启动第二个 bgsave 子进程）</li>
</ol>
</li>
</ol>
<p><strong>增量快照</strong>：做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。<strong>需要记住哪些数据被修改了</strong>，需要使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。</p>
<p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。</p>
<p>简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>
<p><strong>AOF 和 RDB 的选择问题：</strong></p>
<ol>
<li>数据不能丢失时，选择内存快照和 AOF 的混合使用；</li>
<li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li>
<li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li>
</ol>
<h2 id="Redis数据同步"><a href="#Redis数据同步" class="headerlink" title="Redis数据同步"></a><a href="https://juejin.cn/post/6981744631000072205">Redis数据同步</a></h2><p>Redis 具有高可靠性：</p>
<ol>
<li><p>一是数据尽量少丢失</p>
<p>AOF 和 RDB 保证</p>
</li>
<li><p>二是服务尽量少中断</p>
<p>增加副本冗余量，将一份数据同时保存在多个实例上。即使有一个实例出现了故障，需要过一段时间才能恢复，其他实例也可以对外提供服务，不会影响业务使用。</p>
</li>
</ol>
<p>Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式</p>
<ol>
<li>读操作：主库、从库都可以接收；</li>
<li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li>
</ol>
<img src="/article/30584/Redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.jpg" class title="Redis主从库和读写分离">
<h3 id="主从库间进行第一次同步"><a href="#主从库间进行第一次同步" class="headerlink" title="主从库间进行第一次同步"></a>主从库间进行第一次同步</h3><p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 <code>replicaof</code>（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p>
<blockquote>
<p>实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5），在实例 2 上执行以下这个命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">replicaof  172.16.19.3  6379<br></code></pre></td></tr></table></figure>
</blockquote>
<img src="/article/30584/%E4%B8%BB%E4%BB%8E%E5%BA%93%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5%E7%9A%84%E6%B5%81%E7%A8%8B.jpg" class title="主从库第一次同步的流程">
<ol>
<li><p>第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p>
<p>从库给主库发送 <code>psync</code> 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。<code>psync</code> 命令包含了主库的 <code>runID</code> 和复制进度 <code>offset</code> 两个参数。</p>
<ol>
<li>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。</li>
<li>offset，此时设为 -1，表示第一次复制。</li>
</ol>
<p>主库收到 <code>psync</code> 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 <code>runID</code>和主库目前的复制进度 <code>offset</code>，返回给从库。从库收到响应后，会记录下这两个参数。</p>
<p><strong>FULLRESYNC 响应表示第一次复制采用的全量复制</strong>，也就是说，主库会把当前所有的数据都复制给从库。</p>
</li>
<li><p>在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p>
<p>主库执行 <code>bgsave</code> 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 <code>replicaof</code> 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。</p>
<p>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 <strong>replication buffer</strong>，记录 RDB 文件生成后收到的所有写操作。</p>
</li>
<li><p>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 <strong>replication buffer</strong> 中的修改操作发给从库，从库再重新执行这些操作。</p>
</li>
</ol>
<h3 id="主从级联模式分担全量复制时的主库压力"><a href="#主从级联模式分担全量复制时的主库压力" class="headerlink" title="主从级联模式分担全量复制时的主库压力"></a>主从级联模式分担全量复制时的主库压力</h3><blockquote>
<p><strong>问题：</strong>一次全量复制中，对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。<u>fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢</u>。<u>此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力</u>。</p>
</blockquote>
<p>通过<strong>“主 - 从 - 从”</strong>模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。</p>
<p>在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">replicaof  所选从库的IP 6379<br></code></pre></td></tr></table></figure>
<p>在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力</p>
<img src="/article/30584/%E7%BA%A7%E8%81%94%E7%9A%84%E2%80%9C%E4%B8%BB-%E4%BB%8E-%E4%BB%8E%E2%80%9D%E6%A8%A1%E5%BC%8F.jpg" class title="级联的“主-从-从”模式">
<h3 id="主从库间网络中断"><a href="#主从库间网络中断" class="headerlink" title="主从库间网络中断"></a>主从库间网络中断</h3><blockquote>
<p>在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。</p>
</blockquote>
<p>从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步，只会把主从库网络断连期间主库收到的命令，同步给从库。</p>
<p>当主从库断连后，主库会把断连期间收到的写操作命令，写入 <strong>replication buffer</strong>，同时也会把这些操作命令也写入 <strong>repl_backlog_buffer</strong>这个缓冲区。</p>
<p>只要有从库存在，这个 <strong>repl_backlog_buffer</strong> 就会存在。主库的所有写命令除了传播给从库之外，都会在这个 <strong>repl_backlog_buffer</strong> 中记录一份，缓存起来，只有预先缓存了这些命令，当从库断连后，从库重新发送 <code>psync <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.049ex" height="2.509ex" style="vertical-align: -0.671ex;" viewbox="0 -791.3 5618.3 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">master_runid </title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
<path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-6D" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="878" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="1408" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="1877" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="2239" y="0"/>
<g transform="translate(2705,0)">
 <use xlink:href="#E1-MJMATHI-72" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-72" x="638" y="-213"/>
</g>
 <use xlink:href="#E1-MJMATHI-75" x="3576" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="4148" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="4749" y="0"/>
 <use xlink:href="#E1-MJMATHI-64" x="5094" y="0"/>
</g>
</svg>offset</code>，主库才能通过 <code><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="65.473ex" height="3.343ex" style="vertical-align: -1.171ex;" viewbox="0 -934.9 28189.8 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">offset` 在 **repl_backlog_buffer** 中找到从库断开的位置，只发送`</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
<path stroke-width="1" id="E1-MJMATHI-66" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMAIN-2018" d="M64 494Q64 548 86 597T131 670T160 694Q163 694 172 685T182 672Q182 669 170 656T144 625T116 573T101 501Q101 489 102 489T107 491T120 497T138 500Q163 500 180 483T198 440T181 397T139 379Q110 379 87 405T64 494Z"/>
<path stroke-width="1" id="E1-MJMAIN-2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/>
<path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMATHI-6C" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/>
<path stroke-width="1" id="E1-MJMATHI-62" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-63" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/>
<path stroke-width="1" id="E1-MJMATHI-6B" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/>
<path stroke-width="1" id="E1-MJMATHI-67" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-6F" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="485" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="1036" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="1586" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="2056" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="2522" y="0"/>
 <use xlink:href="#E1-MJMAIN-2018" x="2884" y="0"/>
<g transform="translate(3162,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">在</text>
</g>
 <use xlink:href="#E1-MJMAIN-2217" x="4317" y="0"/>
 <use xlink:href="#E1-MJMAIN-2217" x="5040" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="5540" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="5992" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="6458" y="0"/>
<g transform="translate(6962,0)">
 <use xlink:href="#E1-MJMATHI-6C" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-62" x="422" y="-213"/>
</g>
 <use xlink:href="#E1-MJMATHI-61" x="7664" y="0"/>
 <use xlink:href="#E1-MJMATHI-63" x="8194" y="0"/>
 <use xlink:href="#E1-MJMATHI-6B" x="8627" y="0"/>
 <use xlink:href="#E1-MJMATHI-6C" x="9149" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="9447" y="0"/>
<g transform="translate(9933,0)">
 <use xlink:href="#E1-MJMATHI-67" x="0" y="0"/>
 <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-62" x="675" y="-213"/>
</g>
 <use xlink:href="#E1-MJMATHI-75" x="10814" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="11386" y="0"/>
 <use xlink:href="#E1-MJMATHI-66" x="11937" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="12487" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="12954" y="0"/>
 <use xlink:href="#E1-MJMAIN-2217" x="13627" y="0"/>
 <use xlink:href="#E1-MJMAIN-2217" x="14350" y="0"/>
<g transform="translate(14851,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">中</text>
</g>
<g transform="translate(15784,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">找</text>
</g>
<g transform="translate(16716,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">到</text>
</g>
<g transform="translate(17649,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">从</text>
</g>
<g transform="translate(18582,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">库</text>
</g>
<g transform="translate(19515,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">断</text>
</g>
<g transform="translate(20448,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">开</text>
</g>
<g transform="translate(21381,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">的</text>
</g>
<g transform="translate(22314,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">位</text>
</g>
<g transform="translate(23246,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">置</text>
</g>
<g transform="translate(24179,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">，</text>
</g>
<g transform="translate(25112,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">只</text>
</g>
<g transform="translate(26045,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">发</text>
</g>
<g transform="translate(26978,0)">
<text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">送</text>
</g>
 <use xlink:href="#E1-MJMAIN-2018" x="27911" y="0"/>
</g>
</svg>offset</code> 之后的增量数据给从库即可。</p>
<p><strong>注意连接没有断开的时候，这两个缓冲区是同时存在，如果连接断开，那么对应Slave的replication buffer缓冲区就会被删除</strong>。</p>
<p><strong>repl_backlog_buffer</strong> 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。</p>
<ol>
<li>开始时，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，通常用<strong>偏移量</strong>来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是 <code>master_repl_offset</code>。主库接收的新写操作越多，这个值就会越大。</li>
<li>同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 <code>slave_repl_offset</code> 也在不断增加。正常情况下，这两个偏移量基本相等。</li>
<li>主从库的连接恢复之后，从库首先会给主库发送 <code>psync</code> 命令，并把自己当前的 <code>slave_repl_offset</code> 发给主库，主库会判断自己的 <code>master_repl_offset</code> 和 <code>slave_repl_offset</code> 之间的差距。 </li>
</ol>
<blockquote>
<ol>
<li><p><strong>repl_backlog_buffer</strong>：是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量同步带来的性能开销。如果从库断开时间太久， <strong>repl_backlog_buffer</strong> 环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量同步，所以 <strong>repl_backlog_buffer</strong> 配置尽量大一些，可以降低主从断开后全量同步的概率。</p>
</li>
<li><p><strong>replication buffer</strong>：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个内存 buffer 进行数据交互，客户端是一个 client，从库也是一个 client，我们每个 client 连上 Redis 后，Redis 都会分配一个 <strong>client buffer</strong>，所有数据交互都是通过这个 buffer 进行的：Redis先把数据写到这个buffer中，然后再把 buffer 中的数据发到 client socket 中再通过网络发送出去，这样就完成了数据交互。</p>
<p>所以主从在增量同步时，从库作为一个 client，也会分配一个 buffer，只不过这个 buffer 专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做 replication buffer</p>
</li>
<li><p>既然有这个内存 buffer 存在，那么这个 buffer 有没有限制呢？</p>
<p>如果主从在传播命令时，因为某些原因从库处理得非常慢，那么主库上的这个 buffer 就会持续增长，消耗大量的内存资源，甚至 OOM。所以Redis提供了<code>client-output-buffer-limit</code>参数限制这个 buffer 的大小，如果超过限制，主库会强制断开这个client的连接，也就是说从库处理慢导致主库内存buffer 的积压达到限制后，主库会强制断开从库的连接，此时主从复制会中断，中断后如果从库再次发起复制请求，那么此时可能会导致恶性循环，引发复制风暴，这种情况需要格外注意。</p>
</li>
</ol>
</blockquote>
<p>因为 <strong>repl_backlog_buffer</strong> 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。</p>
<p>可以调整 <code>repl_backlog_size</code> 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：<strong>缓冲空间大小 = 主库写入命令速度 <em> 操作大小 - 主从库间网络传输命令速度 </em> 操作大小</strong>。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 <strong>repl_backlog_size = 缓冲空间大小 * 2</strong>，这也就是 <code>repl_backlog_size</code> 的最终值。</p>
<blockquote>
<p>如果主库每秒写入 2000 个操作，每个操作的大小为 2KB，网络每秒能传输 1000 个操作，那么，有 1000 个操作需要缓冲起来，这就至少需要 2MB 的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，我们最终把 repl_backlog_size 设为 4MB。</p>
</blockquote>
<h2 id="Redis哨兵机制"><a href="#Redis哨兵机制" class="headerlink" title="Redis哨兵机制"></a>Redis哨兵机制</h2><img src="/article/30584/%E4%B8%BB%E5%BA%93%E6%95%85%E9%9A%9C%E5%90%8E%E4%BB%8E%E5%BA%93%E6%97%A0%E6%B3%95%E6%9C%8D%E5%8A%A1%E5%86%99%E6%93%8D%E4%BD%9C.jpg" class title="主库故障后从库无法服务写操作">
<h3 id="哨兵机制的基本流程"><a href="#哨兵机制的基本流程" class="headerlink" title="哨兵机制的基本流程"></a>哨兵机制的基本流程</h3><p>哨兵主要负责的就是三个任务：<strong>监控、选择主库和通知</strong></p>
<ol>
<li>监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</li>
<li>选择主库是主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。</li>
<li>通知是指哨兵会把新主库的连接信息发给其他从库，让它们执行 <code>replicaof</code> 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</li>
</ol>
<img src="/article/30584/%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%89%E9%A1%B9%E4%BB%BB%E5%8A%A1%E4%B8%8E%E7%9B%AE%E6%A0%87.jpg" class title="哨兵机制的三项任务与目标">
<p><strong>主观下线和客观下线</strong></p>
<ol>
<li><p>主观下线</p>
<p>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“<strong>主观下线</strong>”。</p>
<ol>
<li>如果检测的是从库，那么，哨兵简单地把它标记为“主观下线”</li>
<li>如果检测的是主库，那么，哨兵还不能简单地把它标记为“主观下线”，开启主从切换。因为很有可能存在这么一个情况：那就是哨兵误判了，其实主库并没有故障。可是，一旦启动了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销。</li>
</ol>
</li>
</ol>
<p>哨兵机制通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<ol start="2">
<li><p>客观下线</p>
<p>在判断主库是否下线时，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”，这个叫法也是表明主库下线成为一个客观事实了。这个判断原则就是：少数服从多数。</p>
<p>“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。</p>
</li>
</ol>
<p><strong>选定新主库</strong></p>
<p>筛选 + 打分</p>
<img src="/article/30584/%E6%96%B0%E4%B8%BB%E5%BA%93%E7%9A%84%E9%80%89%E6%8B%A9%E8%BF%87%E7%A8%8B.jpg" class title="新主库的选择过程">
<ol>
<li><p>筛选的条件</p>
<ol>
<li><p>检查从库的当前在线状态</p>
</li>
<li><p>判断它之前的网络连接状态</p>
<blockquote>
<p>使用配置项 <code>down-after-milliseconds * 10</code>。其中，down-after-milliseconds 是认定主从库断连的最大连接超时时间。</p>
<p>如果在 <code>down-after-milliseconds</code> 毫秒内，主从节点都没有通过网络联系上，就可以认为主从节点断连了。</p>
<p>如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>从库打分</p>
<p>分别按照三个规则依次进行三轮打分，这三个规则分别是从库优先级、从库复制进度以及从库 ID 号。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。</p>
<ol>
<li><p>第一轮：优先级最高的从库得分高</p>
<blockquote>
<p>用户可以通过 <code>slave-priority</code> 配置项，给不同的从库设置不同优先级。</p>
</blockquote>
</li>
<li><p>第二轮：和旧主库同步程度最接近的从库得分高</p>
<blockquote>
<p>有从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库</p>
</blockquote>
</li>
<li><p>第三轮：ID 号小的从库得分高</p>
<blockquote>
<p>每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号。目前，Redis 在选主库时，有一个默认的规定：在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h3><p>一旦多个实例组成了<strong>哨兵集群</strong>，即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作，包括判定主库是不是处于下线状态，选择新主库，以及通知从库和客户端。</p>
<h4 id="基于-pub-sub-机制的哨兵集群组成"><a href="#基于-pub-sub-机制的哨兵集群组成" class="headerlink" title="基于 pub/sub 机制的哨兵集群组成"></a>基于 pub/sub 机制的哨兵集群组成</h4><p>哨兵实例之间可以相互发现，要归功于 Redis 提供的 <strong>pub/sub 机制</strong>，也就是发布 / 订阅机制。</p>
<p>哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。</p>
<p>只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换。</p>
<img src="/article/30584/%E5%93%A8%E5%85%B5%E4%B9%8B%E9%97%B4%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.jpg" class title="哨兵之间建立连接">
<h4 id="哨兵获取从库的-IP-地址和端口"><a href="#哨兵获取从库的-IP-地址和端口" class="headerlink" title="哨兵获取从库的 IP 地址和端口"></a>哨兵获取从库的 IP 地址和端口</h4><p><strong>哨兵向主库发送 <code>INFO</code> 命令来获取从库的 IP 地址和端口</strong></p>
<p><img src="/article/哨兵获取从库的 IP 地址和端口.jpg"><span class="image-caption">哨兵获取从库的 IP 地址和端口</span></p>
<p>哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。</p>
<h4 id="基于-pub-sub-机制的客户端事件通知"><a href="#基于-pub-sub-机制的客户端事件通知" class="headerlink" title="基于 pub/sub 机制的客户端事件通知"></a>基于 pub/sub 机制的客户端事件通知</h4><p>从本质上说，哨兵就是一个运行在特定模式下的 Redis 实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。</p>
<img src="/article/30584/%E5%85%B3%E9%94%AE%E4%BA%8B%E4%BB%B6.jpg" class title="关键事件">
<p>客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。</p>
<blockquote>
<p>订阅“所有实例进入客观下线状态的事件”：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">SUBSCRIBE +odown<br></code></pre></td></tr></table></figure>
<p>订阅所有的事件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">PSUBSCRIBE  *<br></code></pre></td></tr></table></figure>
</blockquote>
<p>当哨兵把新主库选择出来后，客户端就会看到下面的 switch-master 事件。这个事件表示主库已经切换了，新主库的 IP 地址和端口信息已经有了。这个时候，客户端就可以用这里面的新主库地址和端口进行通信了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">switch-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;<br></code></pre></td></tr></table></figure>
<h4 id="由哪个哨兵执行主从切换？"><a href="#由哪个哨兵执行主从切换？" class="headerlink" title="由哪个哨兵执行主从切换？"></a>由哪个哨兵执行主从切换？</h4><p>哨兵集群要判定主库“客观下线”，需要有一定数量的实例都认为该主库已经“主观下线”了。</p>
<p>任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 <code>is-master-down-by-addr</code> 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。</p>
<img src="/article/30584/%E5%8F%91%E9%80%81%E4%B8%8B%E7%BA%BF%E6%8A%95%E7%A5%A8.jpg" class title="发送下线投票">
<p>一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。这个所需的赞成票数是通过哨兵配置文件中的 <strong>quorum 配置</strong>项设定的。</p>
<p>此时，这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为<strong>“Leader 选举”</strong>。因为最终执行主从切换的哨兵称为 Leader，投票过程就是确定 Leader。</p>
<p>在投票过程中，任何一个想成为 Leader 的哨兵，要满足两个条件：</p>
<ol>
<li>第一，<strong>拿到半数以上的赞成票；</strong></li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 <strong>quorum 值</strong>。</li>
</ol>
<blockquote>
<p>需要注意的是，如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得 2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，<strong>通常至少会配置 3 个哨兵实例</strong>。</p>
</blockquote>
<h2 id="Redis切片集群"><a href="#Redis切片集群" class="headerlink" title="Redis切片集群"></a>Redis切片集群</h2><p><strong>切片集群，也叫分片集群</strong>，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。</p>
<p>采用多个实例保存数据切片后，我们既能保存大量数据，又避免了 fork 子进程阻塞主线程而导致的响应突然变慢。</p>
<p>Redis 应对数据量增多的两种方案：纵向扩展（scale up）和横向扩展（scale out）。</p>
<ol>
<li><p>纵向扩展：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。</p>
<blockquote>
<p>优点：实施起来简单、直接</p>
<p>缺点：</p>
<ol>
<li>当使用 RDB 对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程 fork 子进程时就可能会阻塞</li>
<li>纵向扩展会受到硬件和成本的限制</li>
</ol>
</blockquote>
</li>
<li><p>横向扩展：横向增加当前 Redis 实例的个数。</p>
</li>
</ol>
<img src="/article/30584/%E7%BA%B5%E5%90%91%E6%89%A9%E5%B1%95%E5%92%8C%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95.jpg" class title="纵向扩展和横向扩展">
<h3 id="数据切片和实例的对应分布关系（Redis-Cluster）"><a href="#数据切片和实例的对应分布关系（Redis-Cluster）" class="headerlink" title="数据切片和实例的对应分布关系（Redis Cluster）"></a>数据切片和实例的对应分布关系（Redis Cluster）</h3><p>切片集群是一种保存大量数据的通用机制，从 Redis 3.0 开始，官方提供了一个名为 <strong>Redis Cluster</strong> 的方案，用于实现切片集群。</p>
<p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和实例之间的映射关系。</p>
<p>在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</p>
<p>具体的映射过程：</p>
<ol>
<li>首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；</li>
<li>然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li>
</ol>
<p>哈希槽如何被映射到具体的 Redis 实例：</p>
<ol>
<li><p>在部署 Redis Cluster 方案时，可以使用 <code>cluster create</code> 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。</p>
</li>
<li><p>也可以使用 <code>cluster meet</code> 命令手动建立实例间的连接，形成集群，再使用 <code>cluster addslots</code> 命令，指定每个实例上的哈希槽个数。</p>
<blockquote>
<img src="/article/30584/%E6%89%8B%E5%8A%A8%E5%88%86%E9%85%8D%E5%93%88%E5%B8%8C%E6%A7%BD.jpg" class title="手动分配哈希槽">
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1<br>redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3<br>redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</strong></p>
</li>
</ol>
<h3 id="客户端定位数据"><a href="#客户端定位数据" class="headerlink" title="客户端定位数据"></a>客户端定位数据</h3><p>在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，要进一步定位到实例，还需要知道哈希槽分布在哪个实例上。</p>
<p>一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。<strong>Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。</strong></p>
<p>客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p>
<p><strong>实例和哈希槽的对应关系会发生变化：</strong></p>
<ol>
<li>在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；</li>
<li>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</li>
</ol>
<blockquote>
<p><strong>问题：实例和哈希槽的对应关系会发生变化后，实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是，客户端是无法主动感知这些变化的。这就会导致，它缓存的分配信息和最新的分配信息就不一致了</strong></p>
<p><strong>Redis Cluster</strong> 方案提供了一种<strong>重定向机制</strong>，所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。</p>
<p>当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 <strong>MOVED 命令响应结果</strong>，这个结果中就包含了新实例的访问地址。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">GET hello:key<br>(error) MOVED 13320 172.16.19.5:6379<br></code></pre></td></tr></table></figure>
<p>其中，MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 这个实例上。通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。</p>
<img src="/article/30584/%E5%AE%A2%E6%88%B7%E7%AB%AFMOVED%E9%87%8D%E5%AE%9A%E5%90%91%E5%91%BD%E4%BB%A4.jpg" class title="客户端MOVED重定向命令">
<blockquote>
<p><strong>问题：如果 Slot 2 中的数据比较多，就可能会出现一种情况：客户端向实例 2 发送请求，但此时，Slot 2 中的数据只有一部分迁移到了实例 3，还有部分数据没有迁移</strong></p>
<p>在这种迁移部分完成的情况下，客户端就会收到一条 <strong>ASK 报错信息</strong>，如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">GET hello:key<br>(error) ASK 13320 172.16.19.5:6379<br></code></pre></td></tr></table></figure>
<p>这个结果中的 ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但是这个哈希槽正在迁移。此时，客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送 GET 命令，以读取数据。</p>
<img src="/article/30584/%E5%AE%A2%E6%88%B7%E7%AB%AFASK%E9%87%8D%E5%AE%9A%E5%90%91%E5%91%BD%E4%BB%A4.jpg" class title="客户端ASK重定向命令">
<p><strong>ASK 命令表示两层含义</strong>：第一，表明 Slot 数据还在迁移中；第二，ASK 命令把客户端所请求数据的最新实例地址返回给客户端</p>
<p><strong>和 MOVED 命令不同，ASK 命令并不会更新客户端缓存的哈希槽分配信息。</strong></p>
<p>如果客户端再次请求 Slot 2 中的数据，它还是会给实例 2 发送请求。这也就是说，<strong>ASK 命令的作用只是让客户端能给新实例发送一次请求</strong>，而不像 <strong>MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。</strong></p>
</blockquote>
</blockquote>
<h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><p>在分布式系统中，当两个组件要基于消息队列进行通信时，一个组件会把要处理的数据以消息的形式传递给消息队列，然后，这个组件就可以继续执行其他操作了；远端的另一个组件从消息队列中把消息读取出来，再在本地进行处理。</p>
<p><strong>消息队列在存取消息时，必须要满足三个需求：</strong></p>
<ol>
<li>消息保序</li>
<li>处理重复的消息</li>
<li>保证消息可靠性</li>
</ol>
<p><img src="/article/List 和 Streams 实现消息队列的特点和区别.jpg"><span class="image-caption">List 和 Streams 实现消息队列的特点和区别</span></p>
<h3 id="基于-List-的消息队列解决方案"><a href="#基于-List-的消息队列解决方案" class="headerlink" title="基于 List 的消息队列解决方案"></a>基于 List 的消息队列解决方案</h3><p><strong>顺序读取</strong></p>
<p>List 本身就是按先进先出的顺序对数据进行存取的</p>
<p>生产者可以使用 <code>LPUSH</code> 命令把要发送的消息依次写入 List，而消费者则可以使用 <code>RPOP</code> 命令，从 List 的另一端按照消息的写入顺序，依次读取消息并进行处理。</p>
<blockquote>
<p><strong>性能风险:</strong></p>
<p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code> 命令（比如使用一个 while(1) 循环）。如果有新消息写入，<code>RPOP</code> 命令就会返回结果，否则，<code>RPOP</code> 命令返回空值，再继续循环。</p>
<p>所以，即使没有新消息写入 List，消费者也要不停地调用 <code>RPOP</code> 命令，这就会导致消费者程序的 CPU 一直消耗在执行 <code>RPOP</code> 命令上，带来不必要的性能损失。</p>
</blockquote>
<p>Redis 提供了 <code>BRPOP</code> 命令。<code>BRPOP</code> 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。</p>
<p><strong>重复消息判断</strong></p>
<ol>
<li><p>消息队列要能给每一个消息提供全局唯一的 ID 号</p>
</li>
<li><p>消费者程序要把已经处理过的消息的 ID 号记录下来</p>
<p>幂等性就是指，对于同一条消息，消费者收到一次的处理结果和收到多次的处理结果是一致的。</p>
</li>
</ol>
<blockquote>
<p>List 本身是不会为每个消息生成 ID 号的，所以，消息的全局唯一 ID 号就需要生产者程序在发送消息前自行生成。生成之后，用 <code>LPUSH</code> 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p>
</blockquote>
<p><strong>消息可靠性</strong></p>
<p>List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p>
<p><img src="/article/List 类型BRPOPLPUSH命令.jpg"><span class="image-caption">List 类型BRPOPLPUSH命令</span></p>
<blockquote>
<p><strong>问题：</strong>生产者消息发送很快，而消费者处理消息的速度比较慢，这就导致 List 中的消息越积越多，给 Redis 的内存带来很大压力。</p>
</blockquote>
<h3 id="基于-Streams-的消息队列解决方案"><a href="#基于-Streams-的消息队列解决方案" class="headerlink" title="基于 Streams 的消息队列解决方案"></a>基于 Streams 的消息队列解决方案</h3><p>Streams 是 Redis 专门为消息队列设计的数据类型</p>
<ol>
<li><p><code>XADD</code>：插入消息，保证有序，可以自动生成全局唯一 ID；</p>
<p>消息的格式是<strong>键 - 值</strong>对形式。对于插入的每一条消息，Streams 可以自动为其生成一个全局唯一的 ID。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">XADD mqstream * repo 5<br><span class="hljs-string">&quot;1599203861727-0&quot;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>消息队列名称后面的*，表示让 Redis 为插入的数据自动生成一个全局唯一的 ID</strong></p>
<blockquote>
<p>消息的全局唯一 ID 由两部分组成</p>
<p>第一部分“1599203861727”是数据插入时，以毫秒为单位计算的当前服务器时间</p>
<p>第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1599203861727-0”就表示在“1599203861727”毫秒内的第 1 条消息。</p>
</blockquote>
</li>
<li><p><code>XREAD</code>：用于读取消息，可以按 ID 读取数据；</p>
<p>读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">XREAD BLOCK 100 STREAMS  mqstream 1599203861727-0<br>1) 1) <span class="hljs-string">&quot;mqstream&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1599274912765-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;3&quot;</span><br>      2) 1) <span class="hljs-string">&quot;1599274925823-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;2&quot;</span><br>      3) 1) <span class="hljs-string">&quot;1599274927910-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure>
<p>从 ID 号为 1599203861727-0 的消息开始，读取后续的所有消息</p>
</blockquote>
<p>在调用 <code>XRAED</code> 时设定 block 配置项，实现类似于 <code>BRPOP</code> 的阻塞读取操作。当消息队列中没有消息时，一旦设置了 block 配置项，<code>XREAD</code> 就会阻塞，阻塞的时长可以在 block 配置项进行设置。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">XREAD block 10000 streams mqstream $<br>(nil)<br>(10.00s)<br></code></pre></td></tr></table></figure>
<p>设置了 block 10000 的配置项，10000 的单位是毫秒，表明 <code>XREAD</code> 在读取最新消息时，如果没有消息到来，<code>XREAD</code> 将阻塞 10000 毫秒（即 10 秒），然后再返回</p>
</blockquote>
<p>命令最后的“$”符号表示读取最新的消息</p>
</li>
<li><p><code>XREADGROUP</code>：按消费组形式读取消息；</p>
<p>创建消费组之后，Streams 可以使用 <code>XREADGROUP</code> 命令让消费组内的消费者读取消息</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">XGROUP create mqstream group1 0<br>OK<br></code></pre></td></tr></table></figure>
<p>创建一个名为 group1 的消费组，这个消费组消费的消息队列是 mqstream</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">XREADGROUP group group1 consumer1 streams mqstream &gt;<br>1) 1) <span class="hljs-string">&quot;mqstream&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1599203861727-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;5&quot;</span><br>      2) 1) <span class="hljs-string">&quot;1599274912765-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;3&quot;</span><br>      3) 1) <span class="hljs-string">&quot;1599274925823-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;2&quot;</span><br>      4) 1) <span class="hljs-string">&quot;1599274927910-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure>
<p>group1 消费组里的消费者 consumer1 从 mqstream 中读取所有消息，其中，命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取</p>
</blockquote>
<p><strong>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了</strong></p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;<br>1) 1) <span class="hljs-string">&quot;mqstream&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1599203861727-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;5&quot;</span><br><br>XREADGROUP group group2 consumer2 count 1 streams mqstream &gt;<br>1) 1) <span class="hljs-string">&quot;mqstream&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1599274912765-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;3&quot;</span><br><br>XREADGROUP group group2 consumer3 count 1 streams mqstream &gt;<br>1) 1) <span class="hljs-string">&quot;mqstream&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1599274925823-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;2&quot;</span><br></code></pre></td></tr></table></figure>
<p>group2 中的 consumer1、2、3 各自读取一条消息</p>
</blockquote>
</li>
<li><p><code>XPENDING</code> 和 <code>XACK</code>：<code>XPENDING</code> 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 <code>XACK</code> 命令用于向消息队列确认消息处理已完成。</p>
<p>为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 <code>XACK</code> 命令通知 Streams“消息已经处理完成”。</p>
<p>如果消费者没有成功处理消息，它就不会给 Streams 发送 <code>XACK</code> 命令，消息仍然会留存。此时，消费者可以在重启后，用 <code>XPENDING</code> 命令查看已读取、但尚未确认处理完成的消息。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">XPENDING mqstream group2<br>1) (<span class="hljs-built_in">integer</span>) 3<br>2) <span class="hljs-string">&quot;1599203861727-0&quot;</span><br>3) <span class="hljs-string">&quot;1599274925823-0&quot;</span><br>4) 1) 1) <span class="hljs-string">&quot;consumer1&quot;</span><br>      2) <span class="hljs-string">&quot;1&quot;</span><br>   2) 1) <span class="hljs-string">&quot;consumer2&quot;</span><br>      2) <span class="hljs-string">&quot;1&quot;</span><br>   3) 1) <span class="hljs-string">&quot;consumer3&quot;</span><br>      2) <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure>
<p>查看 group2 中各个消费者已读取、但尚未确认的消息个数</p>
<p><code>XPENDING</code> 返回结果的第二、三行分别表示 group2 中所有消费者读取的消息最小 ID 和最大 ID。</p>
</blockquote>
<blockquote>
<p>进一步查看某个消费者具体读取了哪些数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">XPENDING mqstream group2 - + 10 consumer2<br>1) 1) <span class="hljs-string">&quot;1599274912765-0&quot;</span><br>   2) <span class="hljs-string">&quot;consumer2&quot;</span><br>   3) (<span class="hljs-built_in">integer</span>) 513336<br>   4) (<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure>
<p>consumer2 已读取的消息的 ID 是 1599274912765-0</p>
</blockquote>
</li>
</ol>
<h2 id="Redis性能影响因素"><a href="#Redis性能影响因素" class="headerlink" title="Redis性能影响因素"></a>Redis性能影响因素</h2><h3 id="Redis-内部的阻塞式操作-以及-异步机制"><a href="#Redis-内部的阻塞式操作-以及-异步机制" class="headerlink" title="Redis 内部的阻塞式操作 以及 异步机制"></a>Redis 内部的阻塞式操作 以及 异步机制</h3><h4 id="Redis-内部的阻塞式操作"><a href="#Redis-内部的阻塞式操作" class="headerlink" title="Redis 内部的阻塞式操作"></a>Redis 内部的阻塞式操作</h4><p><strong>Redis 实例交互的对象，以及交互时会发生的操作：</strong></p>
<ol>
<li>客户端：网络 IO，键值对增删改查操作，数据库操作；</li>
<li>磁盘：生成 RDB 快照，记录 AOF 日志，AOF 日志重写；</li>
<li>主从节点：主库生成、传输 RDB 文件，从库接收 RDB 文件、清空数据库、加载 RDB 文件；</li>
<li>切片集群实例：向其他实例传输哈希槽信息，数据迁移。</li>
</ol>
<p><img src="/article/Redis 实例交互的对象，以及交互时会发生的操作.jpg"><span class="image-caption">Redis 实例交互的对象，以及交互时会发生的操作</span></p>
<p><strong>Redis 实例阻塞点：</strong></p>
<ol>
<li><p>和客户端交互时的阻塞点</p>
<p>键值对的增删改查操作是 Redis 和客户端交互的主要部分，<strong>复杂度高的增删改查操作</strong>肯定会阻塞 Redis。</p>
<p>最基本的标准，就是看操作的复杂度是否为 O(N)。</p>
<ol>
<li><p>集合全量查询和聚合操作</p>
</li>
<li><p>bigkey 删除操作</p>
<p>删除操作的<strong>本质是要释放键值对占用的内存空间</strong>。首先释放内存，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序，所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞。</p>
</li>
<li><p>清空数据库</p>
<p>涉及到删除和释放所有的键值对</p>
</li>
</ol>
</li>
<li><p>和磁盘交互时的阻塞点</p>
<p>AOF 日志同步写</p>
</li>
<li><p>主从节点交互时的阻塞点</p>
<ol>
<li>主从库同步，从库在接收了 RDB 文件后，需要使用 <code>FLUSHDB</code> 命令<strong>清空当前数据库</strong></li>
<li>从库在清空当前数据库后，还需要把 <strong>RDB 文件加载到内存</strong>，这个过程的快慢和 RDB 文件的大小密切相关，RDB 文件越大，加载过程越慢</li>
</ol>
</li>
</ol>
<h4 id="异步机制"><a href="#异步机制" class="headerlink" title="异步机制"></a>异步机制</h4><p>为了避免阻塞式操作，Redis 提供了异步线程机制，启动一些子线程，然后把一些任务交给这些子线程，让它们在后台完成，而不再由主线程来执行这些任务。</p>
<blockquote>
<ol>
<li><p>集合全量查询和聚合操作都涉及到了<strong>读操作</strong>，<strong>不能进行异步操作</strong></p>
<p>读操作是典型的关键路径操作，因为客户端发送了读操作之后，就会等待读取的数据返回，以便进行后续的数据处理。</p>
<blockquote>
<p>可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算；</p>
</blockquote>
</li>
<li><p>从库加载 RDB 文件，<strong>不能进行异步操作</strong></p>
<p>从库要想对客户端提供数据存取服务，就必须把 RDB 文件加载完成。所以，这个操作也属于关键路径上的操作。</p>
<blockquote>
<p>从库加载 RDB 文件，把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载。</p>
</blockquote>
</li>
</ol>
</blockquote>
<ol>
<li><p>bigkey 删除操作</p>
</li>
<li><p>清空数据库</p>
<p>删除操作与清空数据库并不需要给客户端返回具体的数据结果，所以不算是关键路径操作</p>
</li>
<li><p>AOF 日志同步写</p>
<p>不会返回具体的数据结果给实例，可以启动一个子线程来执行 AOF 日志的同步写</p>
</li>
</ol>
<p><strong>异步的子线程机制</strong></p>
<p>Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。</p>
<img src="/article/30584/%E5%BC%82%E6%AD%A5%E7%9A%84%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6.jpg" class title="异步的子线程机制">
<p>主线程通过一个链表形式的任务队列和子线程进行交互。当收到<strong>键值对删除和清空数据库的操作</strong>时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始<strong>实际删除键值对</strong>，并释放相应的内存空间。因此，我们把这种异步删除也称为惰性删除（lazy free）。</p>
<p><strong>AOF 日志同步写</strong>，AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志，这样主线程就不用一直等待 AOF 日志写完了。</p>
<p>异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能：</p>
<ol>
<li>键值对删除：当集合类型中有大量元素需要删除时，建议使用 <code>UNLINK</code> 命令。</li>
<li>清空数据库：可以在 <code>FLUSHDB</code> 和 <code>FLUSHALL</code> 命令后加上 <code>ASYNC</code> 选项，这样就可以让后台子线程异步地清空数据库</li>
</ol>
<h3 id="CPU结构影响性能"><a href="#CPU结构影响性能" class="headerlink" title="CPU结构影响性能"></a>CPU结构影响性能</h3><p><strong>主流的 CPU 架构</strong></p>
<p>一个 CPU 处理器中一般有多个运行核心，一个运行核心称为一个物理核，每个物理核都可以运行应用程序。每个物理核都拥有私有的一级缓存（Level 1 cache，简称 L1 cache），包括一级指令缓存和一级数据缓存，以及私有的二级缓存（Level 2 cache，简称 L2 cache）。</p>
<p><strong>物理核的私有缓存。它其实是指缓存空间只能被当前的这个物理核使用，其他的物理核无法对这个核的缓存空间进行数据存取。</strong></p>
<p><img src="/article/CPU 物理核的架构.jpg"><span class="image-caption">CPU 物理核的架构</span></p>
<p>L1 和 L2 缓存的大小受限于处理器的制造技术，一般只有 KB 级别</p>
<p>不同的物理核还会共享一个共同的三级缓存（Level 3 cache，简称为 L3 cache）。L3 缓存能够使用的存储资源比较多，能达到几 MB 到几十 MB，这就能让应用程序缓存更多的数据。当 L1、L2 缓存中没有数据缓存时，可以访问 L3，尽可能避免访问内存。</p>
<p>每个物理核通常都会运行两个超线程，也叫作逻辑核。同一个物理核的逻辑核会共享使用 L1、L2 缓存。</p>
<img src="/article/30584/%E7%89%A9%E7%90%86%E6%A0%B8%E5%92%8C%E9%80%BB%E8%BE%91%E6%A0%B8.jpg" class title="物理核和逻辑核">
<p><strong>多 CPU Socket 架构</strong></p>
<p><img src="/article/多 CPU Socket 架构.jpg"><span class="image-caption">多 CPU Socket 架构</span></p>
<p>在多 CPU 架构上，应用程序可以在不同的处理器上运行</p>
<p>在多 CPU 架构下，一个应用程序访问所在 Socket 的本地内存和访问远端内存的延迟并不一致，所以，我们也把这个架构称为<strong>非统一内存访问架构（</strong>Non-Uniform Memory Access，NUMA 架构）。</p>
<h4 id="CPU-多核对-Redis-性能的影响"><a href="#CPU-多核对-Redis-性能的影响" class="headerlink" title="CPU 多核对 Redis 性能的影响"></a>CPU 多核对 Redis 性能的影响</h4><p>在一个 CPU 核上运行时，应用程序需要记录自身使用的软硬件资源信息（例如栈指针、CPU 核的寄存器值等），这些信息称为<strong>运行时信息</strong>。同时，应用程序访问最频繁的指令和数据还会被缓存到 L1、L2 缓存上，以便提升执行速度。</p>
<p>在多核 CPU 的场景下，一旦应用程序<strong>调度</strong>在一个新的 CPU 核上运行，那么，运行时信息就需要重新加载到新的 CPU 核上。而且，新的 CPU 核的 L1、L2 缓存也需要重新加载数据和指令，这会导致程序的运行时间增加。</p>
<p><strong>每调度一次，一些请求就会受到运行时信息、指令和数据重新加载过程的影响，这就会导致某些请求的延迟明显高于其他请求。</strong></p>
<p>可以使用 <code>taskset</code> 命令把一个程序绑定在一个核上运行</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">taskset -c 0 ./redis-server<br></code></pre></td></tr></table></figure>
<p>把 Redis 实例绑在了 0 号核上，其中，“-c”选项用于设置要绑定的核编号。</p>
</blockquote>
<h4 id="NUMA-架构对-Redis-性能的影响"><a href="#NUMA-架构对-Redis-性能的影响" class="headerlink" title="NUMA 架构对 Redis 性能的影响"></a>NUMA 架构对 Redis 性能的影响</h4><p>Redis 实例和网络中断程序的数据交互：网络中断处理程序从网卡硬件中读取数据，并把数据写入到操作系统内核维护的一块内存缓冲区。内核会通过 epoll 机制触发事件，通知 Redis 实例，Redis 实例再把数据从内核的内存缓冲区拷贝到自己的内存空间，如下图所示：</p>
<p><img src="/article/Redis 实例和网络中断程序的数据交互.jpg"><span class="image-caption">Redis 实例和网络中断程序的数据交互</span></p>
<p>在 CPU 的 NUMA 架构下，当网络中断处理程序、Redis 实例分别和 CPU 核绑定后，就会有一个<strong>潜在的风险</strong>：如果网络中断处理程序和 Redis 实例各自所绑的 CPU 核不在同一个 CPU Socket 上，那么，Redis 实例读取网络数据时，就需要跨 CPU Socket 访问内存，这个过程会花费较多时间。</p>
<p><strong>为了避免 Redis 跨 CPU Socket 访问网络数据，最好把网络中断程序和 Redis 实例绑在同一个 CPU Socket 上</strong></p>
<p><strong>NUMA 架构下，CPU 核的编号规则：</strong>先给每个 CPU Socket 中每个物理核的第一个逻辑核依次编号，再给每个 CPU Socket 中的物理核的第二个逻辑核依次编号。</p>
<blockquote>
<p>假设有 2 个 CPU Socket，每个 Socket 上有 6 个物理核，每个物理核又有 2 个逻辑核，总共 24 个逻辑核。可以执行 <code>lscpu</code> 命令，查看到这些核的编号：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">lscpu<br>Architecture: x86_64<br>...<br>NUMA node0 CPU(s): 0-5,12-17<br>NUMA node1 CPU(s): 6-11,18-23<br>...<br></code></pre></td></tr></table></figure>
<p>NUMA node0 的 CPU 核编号是 0 到 5、12 到 17。其中，0 到 5 是 node0 上的 6 个物理核中的第一个逻辑核的编号，12 到 17 是相应物理核中的第二个逻辑核编号。NUMA node1 的 CPU 核编号规则和 node0 一样。</p>
</blockquote>
<p><strong>在 CPU 多核的场景下，用 taskset 命令把 Redis 实例和一个核绑定，可以减少 Redis 实例在不同核上被来回调度执行的开销，避免较高的尾延迟；</strong></p>
<p><strong>在多 CPU 的 NUMA 架构下，建议同时把 Redis 实例和网络中断程序绑在同一个 CPU Socket 的不同核上，这样可以避免 Redis 跨 Socket 访问内存中的网络数据的时间开销。</strong></p>
<h4 id="绑核的风险和解决方案"><a href="#绑核的风险和解决方案" class="headerlink" title="绑核的风险和解决方案"></a>绑核的风险和解决方案</h4><p><strong>风险：</strong>把 Redis 实例绑到一个 CPU 逻辑核上时，就会导致子进程、后台线程和 Redis 主线程竞争 CPU 资源，一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致 Redis 请求延迟增加。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>一个 Redis 实例对应绑一个物理核</p>
<p>在给 Redis 实例绑核时，不要把一个实例和一个逻辑核绑定，而要和一个物理核绑定，把一个物理核的 2 个逻辑核都用上。</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">taskset -c 0,12 ./redis-server<br></code></pre></td></tr></table></figure>
<p>把 Redis 实例绑定到了逻辑核 0 和 12 上，而这两个核正好都属于物理核 1</p>
</blockquote>
</li>
<li><p>优化 Redis 源码</p>
<p>通过修改 Redis 源码，把子进程和后台线程绑到不同的 CPU 核上</p>
<blockquote>
<p>1 个数据结构 cpu_set_t 和 3 个函数 CPU_ZERO、CPU_SET 和 sched_setaffinity</p>
<ol>
<li>cpu_set_t 数据结构：是一个位图，每一位用来表示服务器上的一个 CPU 逻辑核</li>
<li>CPU_ZERO 函数：以 cpu_set_t 结构的位图为输入参数，把位图中所有的位设置为 0</li>
<li>CPU_SET 函数：以 CPU 逻辑核编号和 cpu_set_t 位图为参数，把位图中和输入的逻辑核编号对应的位设置为 1</li>
<li>sched_setaffinity 函数：以进程 / 线程 ID 号和 cpu_set_t 为参数，检查 cpu_set_t 中哪一位为 1，就把输入的 ID 号所代表的进程 / 线程绑在对应的逻辑核上</li>
</ol>
</blockquote>
<ol>
<li>创建一个 cpu_set_t 结构的位图变量；</li>
<li>使用 CPU_ZERO 函数，把 cpu_set_t 结构的位图所有的位都设置为 0；</li>
<li>根据要绑定的逻辑核编号，使用 CPU_SET 函数，把 cpu_set_t 结构的位图相应位设置为 1；</li>
<li>使用 sched_setaffinity 函数，把程序绑定在 cpu_set_t 结构位图中为 1 的逻辑核上。</li>
</ol>
<p>对于 Redis 来说，生成 RDB 和 AOF 日志重写的子进程分别是下面两个文件的函数中实现的。</p>
<ol>
<li>rdb.c 文件：rdbSaveBackground 函数；</li>
<li>aof.c 文件：rewriteAppendOnlyFileBackground 函数。</li>
</ol>
<p>这两个函数中都调用了 fork 创建子进程，可以在子进程代码部分加上绑核的四步操作。</p>
</li>
</ol>
<h3 id="波动的响应延迟"><a href="#波动的响应延迟" class="headerlink" title="波动的响应延迟"></a>波动的响应延迟</h3><h4 id="判断-Redis-是否变慢"><a href="#判断-Redis-是否变慢" class="headerlink" title="判断 Redis 是否变慢"></a>判断 Redis 是否变慢</h4><ol>
<li><p>查看 Redis 的响应延迟，是看 Redis 延迟的绝对值，不同的硬件环境条件不同</p>
</li>
<li><p>基于当前环境下的 Redis 基线性能（一个系统在低压力、无干扰下的基本性能）判断</p>
<p>从 2.8.7 版本开始，<code>redis-cli</code> 命令提供了 <code>–intrinsic-latency</code> 选项，可以用来监测和统计测试期间内的最大延迟，这个延迟可以作为 Redis 的基线性能。</p>
</li>
</ol>
<p>如果 Redis 运行时延迟是其基线性能的 2 倍及以上，就可以认定 Redis 变慢了。</p>
<blockquote>
<p>用 iPerf 工具，测量从 Redis 客户端到服务器端的网络延迟。如果这个延迟有几十毫秒甚至是几百毫秒，就说明，Redis 运行的网络环境中很可能有大流量的其他应用程序在运行，导致网络拥塞了。这个时候，就需要协调网络运维，调整网络的流量分配了。</p>
</blockquote>
<h4 id="如何应对-Redis-变慢？"><a href="#如何应对-Redis-变慢？" class="headerlink" title="如何应对 Redis 变慢？"></a>如何应对 Redis 变慢？</h4><p><img src="/article/影响 Redis 性能的三大要素.jpg"><span class="image-caption">影响 Redis 性能的三大要素</span></p>
<h5 id="Redis-自身操作特性的影响"><a href="#Redis-自身操作特性的影响" class="headerlink" title="Redis 自身操作特性的影响"></a><strong>Redis 自身操作特性的影响</strong></h5><ol>
<li><p>慢查询命令</p>
<p>慢查询命令，就是指在 Redis 中执行速度慢的命令，这会导致 Redis 延迟增加。</p>
<blockquote>
<p>可以通过 Redis 日志，或者是 latency monitor 工具，查询变慢的请求，根据请求对应的具体命令以及官方文档，确认下是否采用了复杂度高的慢查询命令。</p>
</blockquote>
<p><strong>处理方式：</strong></p>
<ol>
<li>用其他高效命令代替。</li>
<li>需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。</li>
</ol>
</li>
<li><p>过期 key 操作</p>
<p>是 Redis 用来回收内存空间的常用机制，本身就会引起 Redis 操作阻塞，导致性能变慢</p>
<p>默认情况下，Redis 每 100 毫秒会删除一些过期 key，具体的算法如下：</p>
<ol>
<li>采样 <code>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code>(默认是 20，一秒内基本有 200 个过期 key 会被删除) 个数的 key，并将其中过期的 key 全部删除；</li>
<li>如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。</li>
</ol>
<p><strong>处理方式：</strong></p>
<p>检查业务代码在使用 <code>EXPIREAT</code> 命令设置 key 过期时间时，是否使用了相同的 UNIX 时间戳，有没有使用 <code>EXPIRE</code> 命令给批量的 key 设置相同的过期秒数。因为，这都会造成大量 key 在同一时间过期，导致性能变慢。</p>
</li>
</ol>
<h5 id="文件系统：AOF-模式"><a href="#文件系统：AOF-模式" class="headerlink" title="文件系统：AOF 模式"></a><strong>文件系统：AOF 模式</strong></h5><p>AOF 日志提供了三种日志写回策略：no、everysec、always。这三种写回策略依赖文件系统的两个系统调用完成，也就是 write 和 fsync。</p>
<ol>
<li>write 只要把日志记录写到内核缓冲区，就可以返回了，并不需要等待日志实际写回到磁盘；</li>
<li>fsync 需要把日志记录写回到磁盘后才能返回，时间较长。</li>
</ol>
<blockquote>
<p>使用 everysec 时，Redis 允许丢失一秒的操作记录，所以，Redis 主线程并不需要确保每个操作记录日志都写回磁盘。而且，fsync 的执行时间很长，如果是在 Redis 主线程中执行 fsync，就容易阻塞主线程。所以，当写回策略配置为 everysec 时，Redis 会使用<strong>后台的子线程异步完成 fsync 的操作。</strong></p>
</blockquote>
<p>对于 always 策略来说，Redis 需要确保每个操作记录日志都写回磁盘，如果用后台子线程异步完成，主线程就无法及时地知道每个操作是否已经完成了，就不符合 always 策略的要求了。所以，<strong>always 策略并不使用后台子线程来执行。</strong></p>
<blockquote>
<p>使用 AOF 日志时，为了避免日志文件不断增大，Redis 会执行 AOF 重写，生成体量缩小的新的 AOF 日志文件。AOF 重写本身需要的时间很长，也容易阻塞 Redis 主线程，所以，<strong>Redis 使用子进程来进行 AOF 重写。</strong></p>
<p><strong>潜在的风险点：</strong>AOF 重写会对磁盘进行大量 IO 操作，同时，fsync 又需要等到数据写到磁盘后才能返回，所以，当 AOF 重写的压力比较大时，就会导致 fsync 被阻塞。虽然 fsync 是由后台子线程负责执行的，但是，主线程会监控 fsync 的执行进度。</p>
<p>当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞。所以，如果后台子线程执行的 fsync 频繁阻塞的话（比如 AOF 重写占用了大量的磁盘 IO 带宽），主线程也会阻塞，导致 Redis 性能变慢。</p>
</blockquote>
<p><strong>排查和解决建议</strong></p>
<p>检查下 Redis 配置文件中的 appendfsync 配置项，该配置项的取值表明了 Redis 实例使用的是哪种 AOF 日志写回策略。</p>
<ol>
<li><p>如果 AOF 写回策略使用了 everysec 或 always 配置，请先确认下业务方对数据可靠性的要求，明确是否需要每一秒或每一个操作都记日志。</p>
</li>
<li><p>如果业务应用对延迟非常敏感，但同时允许一定量的数据丢失，那么，可以把配置项 no-appendfsync-on-rewrite 设置为 yes</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">no-appendfsync-on-rewrite yes<br></code></pre></td></tr></table></figure>
<p>这个配置项设置为 yes 时，表示在 AOF 重写时，不进行 fsync 操作。Redis 实例把写命令写到内存后，不调用后台线程进行 fsync 操作，就可以直接返回了。<strong>如果此时实例发生宕机，就会导致数据丢失。</strong></p>
<p>如果这个配置项设置为 no（也是默认配置），在 AOF 重写时，Redis 实例仍然会调用后台线程进行 fsync 操作，这就会给实例带来阻塞。</p>
</li>
</ol>
<p>如果的确需要高性能，同时也需要高可靠数据保证，考虑采用<strong>高速的固态硬盘</strong>作为 AOF 日志的写入设备。</p>
<h5 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h5><ol>
<li><p>Swap</p>
<p>内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写，所以，一旦触发 swap（swap 触发后影响的是 Redis 主 IO 线程），无论是被换入数据的进程，还是被换出数据的进程，其性能都会受到慢速磁盘读写的影响。</p>
<p><strong>触发 swap 的原因主要是物理机器内存不足</strong></p>
<ol>
<li>Redis 实例自身使用了大量的内存，导致物理机器的可用内存不足；</li>
<li>Redis 实例在同一台机器上运行的其他进程，在进行大量的文件读写操作。文件读写本身会占用系统内存，这会导致分配给 Redis 实例的内存量变少，进而触发 Redis 发生 swap。</li>
</ol>
<p><strong>增加机器的内存或者使用 Redis 集群</strong></p>
</li>
<li><p>内存大页</p>
<p>内存大页机制（Transparent Huge Page, THP）</p>
<p>Linux 内核从 2.6.38 开始支持内存大页机制，该机制支持 2MB 大小的内存页分配，而常规的内存页分配是按 4KB 的粒度来执行的。</p>
<blockquote>
<p>Redis 为了提供数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，所以，Redis 主线程仍然可以接收客户端写请求。客户端的写请求可能会修改正在进行持久化的数据。在这一过程中，Redis 就会采用写时复制机制，也就是说，一旦有数据要被修改，Redis 并不会直接修改内存中的数据，而是将这些数据拷贝一份，然后再进行修改。</p>
<p>如果采用了内存大页，即使客户端请求只修改很小的数据，Redis 也需要拷贝 2MB 的大页。当客户端请求修改或新写入数据较多时，内存大页机制将导致大量的拷贝，这就会影响 Redis 正常的访存操作，最终导致性能变慢。</p>
</blockquote>
<p><strong>关闭内存大页</strong></p>
<blockquote>
<p>排查下内存大页</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">cat /sys/kernel/mm/transparent_hugepage/enabled<br></code></pre></td></tr></table></figure>
<p>如果执行结果是 always，就表明内存大页机制被启动了；如果是 never，就表示，内存大页机制被禁止。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sh\">echo never /sys/kernel/mm/transparent_hugepage/enabled<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Redis-性能变慢-8-个检查点"><a href="#Redis-性能变慢-8-个检查点" class="headerlink" title="Redis 性能变慢 8 个检查点:"></a><strong>Redis 性能变慢 8 个检查点:</strong></h3><blockquote>
<ol>
<li>获取 Redis 实例在当前环境下的基线性能。</li>
<li>是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做。</li>
<li>是否对过期 key 设置了相同的过期时间？对于批量删除的 key，可以在每个 key 的过期时间上加一个随机数，避免同时删除。</li>
<li>是否存在 bigkey？ 对于 bigkey 的删除操作，如果你的 Redis 是 4.0 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 Redis 4.0 以前的版本，可以使用 SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 SCAN 命令在客户端完成。</li>
<li>Redis AOF 配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入盘。</li>
<li>Redis 实例的内存使用是否过大？发生 swap 了吗？如果是的话，就增加机器内存，或者是使用 Redis 集群，分摊单机 Redis 的键值对数量和内存压力。同时，要避免出现 Redis 和其他内存需求大的应用共享机器的情况。在 Redis 实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了。</li>
<li>是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。</li>
<li>是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上。</li>
</ol>
</blockquote>
<h2 id="Redis-的内存空间存储效率"><a href="#Redis-的内存空间存储效率" class="headerlink" title="Redis 的内存空间存储效率"></a>Redis 的内存空间存储效率</h2><p>当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存</p>
<p><strong>潜在的风险点：</strong>Redis 释放的内存空间可能并不是连续的，那么，这些不连续的内存空间很有可能处于一种闲置的状态。虽然有空闲空间，Redis 却无法用来保存数据，不仅会减少 Redis 能够实际保存的数据量，还会降低 Redis 运行机器的成本回报率。</p>
<h3 id="内存碎片的形成"><a href="#内存碎片的形成" class="headerlink" title="内存碎片的形成"></a>内存碎片的形成</h3><ol>
<li><p>内因：内存分配器的分配策略</p>
<p>内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。</p>
</li>
<li><p>外因：键值对大小不一样和删改操作</p>
</li>
</ol>
<h3 id="判断是否有内存碎片"><a href="#判断是否有内存碎片" class="headerlink" title="判断是否有内存碎片"></a>判断是否有内存碎片</h3><p>Redis 自身提供了 INFO 命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">INFO memory<br><span class="hljs-comment"># Memory</span><br>used_memory:1073741736<br>used_memory_human:1024.00M<br>used_memory_rss:1997159792<br>used_memory_rss_human:1.86G<br>…<br>mem_fragmentation_ratio:1.86<br></code></pre></td></tr></table></figure>
<p>mem_fragmentation_ratio 指标，表示的就是 Redis 当前的内存碎片率</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">mem_fragmentation_ratio = used_memory_rss/ used_memory<br></code></pre></td></tr></table></figure>
<p>used_memory_rss 是操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片；</p>
<p>used_memory 是 Redis 为了保存数据实际申请使用的空间。</p>
<ol>
<li><p>mem_fragmentation_ratio 大于 1 但小于 1.5</p>
<p><strong>合理</strong></p>
</li>
<li><p>mem_fragmentation_ratio 大于 1.5</p>
<p>表明内存碎片率已经超过了 50%，需要采取措施来降低内存碎片率</p>
</li>
</ol>
<h3 id="清理内存碎片"><a href="#清理内存碎片" class="headerlink" title="清理内存碎片"></a>清理内存碎片</h3><ol>
<li><p>重启 Redis 实例</p>
<ol>
<li>如果 Redis 中的数据没有持久化，就会丢失数据；</li>
<li>即使 Redis 数据持久化了，还需要通过 AOF 或 RDB 进行恢复，恢复时长取决于 AOF 或 RDB 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。</li>
</ol>
</li>
<li><p>4.0-RC3 版本以后，Redis 自身提供了一种内存碎片自动清理的方法</p>
<img src="/article/30584/%E7%A2%8E%E7%89%87%E6%B8%85%E7%90%86.jpg" class title="碎片清理">
<p>Redis 是单线程，在数据拷贝时，Redis 只能等着，这就导致 Redis 无法及时处理请求，性能就会降低。</p>
<p>可以通过设置参数，来控制碎片清理的开始和结束时机，以及占用的 CPU 比例，从而减少碎片清理对 Redis 本身请求处理的性能影响。</p>
<ol>
<li><p>Redis 需要启用自动内存碎片清理， activedefrag 配置项设置为 yes</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">config <span class="hljs-built_in">set</span> activedefrag yes<br></code></pre></td></tr></table></figure>
</li>
<li><p>内存碎片的字节数达到 XXMB 时，开始清理；</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">active-defrag-ignore-bytes XXmb<br></code></pre></td></tr></table></figure>
<p>内存碎片空间占操作系统分配给 Redis 的总空间比例达到 XX% 时，开始清理</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">active-defrag-threshold-lower XX<br></code></pre></td></tr></table></figure>
<p><strong>同时满足这两个条件，就开始清理。在清理的过程中，只要有一个条件不满足了，就停止自动清理</strong></p>
</li>
<li><p>自动清理过程所用 CPU 时间的比例不低于 25%，清理能正常开展</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">active-defrag-cycle-min 25<br></code></pre></td></tr></table></figure>
<p>自动清理过程所用 CPU 时间的比例不高于 75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞 Redis，导致响应延迟升高</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">active-defrag-cycle-max 75<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="Redis-缓冲区"><a href="#Redis-缓冲区" class="headerlink" title="Redis 缓冲区"></a>Redis 缓冲区</h2><h3 id="客户端输入和输出缓冲区"><a href="#客户端输入和输出缓冲区" class="headerlink" title="客户端输入和输出缓冲区"></a>客户端输入和输出缓冲区</h3><p>为了避免客户端和服务器端的请求发送和处理速度不匹配，服务器端给每个连接的客户端都设置了一个输入缓冲区和输出缓冲区，称之为客户端输入缓冲区和输出缓冲区。</p>
<p>输入缓冲区会先把客户端发送过来的命令暂存起来，Redis 主线程再从输入缓冲区中读取命令，进行处理。当 Redis 主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端</p>
<img src="/article/30584/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA.jpg" class title="客户端输入和输出缓冲区">
<h4 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a><strong>输入缓冲区</strong></h4><p><strong>输入缓冲区溢出</strong></p>
<ol>
<li>写入了 bigkey</li>
<li>服务器端处理请求的速度过慢</li>
</ol>
<p><strong>查看输入缓冲区的内存使用情况</strong></p>
<p><code>CLIENT LIST</code> 命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">CLIENT LIST<br>id=5 addr=127.0.0.1:50487 fd=9 name= age=4 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client<br></code></pre></td></tr></table></figure>
<ol>
<li>一类是与服务器端连接的客户端的信息</li>
<li>一类是与输入缓冲区相关的三个参数<ol>
<li>cmd，表示客户端最新执行的命令</li>
<li>qbuf，表示输入缓冲区已经使用的大小</li>
<li>qbuf-free，表示输入缓冲区尚未使用的大小</li>
</ol>
</li>
</ol>
<p><strong>避免输入缓冲区溢出</strong></p>
<blockquote>
<p>把缓冲区调大</p>
<p>Redis 服务器端允许为每个客户端最多暂存 1GB 的命令和数据，Redis 并没有提供参数让我们调节客户端输入p缓冲区的大小</p>
</blockquote>
<p>数据命令的发送和处理速度：避免客户端写入 bigkey，以及避免 Redis 主线程阻塞</p>
<h4 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h4><p>Redis 的输出缓冲区暂存的是 Redis 主线程要返回给客户端的数据</p>
<p>Redis 为每个客户端设置的输出缓冲区包括两部分：</p>
<ol>
<li>一个大小为 16KB 的固定缓冲空间，用来暂存 OK 响应和出错信息；</li>
<li>一个可以动态增加的缓冲空间，用来暂存大小可变的响应结果。</li>
</ol>
<p><strong>输出缓冲区溢出</strong></p>
<ol>
<li><p>服务器端返回 bigkey 的大量结果；</p>
</li>
<li><p>执行了 <code>MONITOR</code> 命令；</p>
<p><code>MONITOR</code> 命令是用来监测 Redis 执行的，持续输出监测到的各个命令操作</p>
<p><code>MONITOR</code> 的输出结果会持续占用输出缓冲区，并越占越多，最后的结果就是发生溢出</p>
<blockquote>
<p>MONITOR 命令主要用在调试环境中，不要在线上生产环境中持续使用 MONITOR</p>
</blockquote>
</li>
<li><p>缓冲区大小设置得不合理</p>
<p>通过 <code>client-output-buffer-limit</code> 配置项，来设置缓冲区的大小</p>
<ol>
<li>设置缓冲区大小的上限阈值；</li>
<li>设置输出缓冲区持续写入数据的数量上限阈值，和持续写入数据的时间的上限阈值。</li>
</ol>
<blockquote>
<p>和 Redis 实例进行交互的应用程序来说，主要使用两类客户端和 Redis 服务器端交互</p>
<ol>
<li>常规和 Redis 服务器端进行读写命令交互的普通客户端</li>
<li>订阅了 Redis 频道的订阅客户端</li>
<li>主节点上用来和从节点进行数据同步的客户端</li>
</ol>
</blockquote>
<ol>
<li><p>常规和 Redis 服务器端进行读写命令交互的普通客户端</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">client-output-buffer-limit normal 0 0 0<br></code></pre></td></tr></table></figure>
<p>normal 表示当前设置的是普通客户端，第 1 个 0 设置的是缓冲区大小限制，第 2 个 0 和第 3 个 0 分别表示缓冲区持续写入量限制和持续写入时间限制</p>
<blockquote>
<p>对于普通客户端来说，它每发送完一个请求，会等到请求结果返回后，再发送下一个请求，这种发送方式称为<strong>阻塞式发送</strong>。在这种情况下，如果不是读取体量特别大的 bigkey，服务器端的输出缓冲区一般不会被阻塞的。</p>
</blockquote>
<p>0 表示 不做限制 </p>
</li>
<li><p>订阅了 Redis 频道的订阅客户端</p>
<blockquote>
<p>对于订阅客户端来说，一旦订阅的 Redis 频道有消息了，服务器端都会通过输出缓冲区把消息发给客户端。所以，订阅客户端和服务器间的消息发送方式，不属于阻塞式发送。</p>
</blockquote>
<p>给订阅客户端设置缓冲区大小限制、缓冲区持续写入量限制，以及持续写入时间限制</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">client-output-buffer-limit pubsub 8mb 2mb 60<br></code></pre></td></tr></table></figure>
<p>pubsub 参数表示当前是对订阅客户端进行设置</p>
<p>8mb 表示输出缓冲区的大小上限为 8MB，一旦实际占用的缓冲区大小要超过 8MB，服务器端就会直接关闭客户端的连接；2mb 和 60 表示，如果连续 60 秒内对输出缓冲区的写入量超过 2MB 的话，服务器端也会关闭客户端连接。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p><strong>避免输出缓冲区溢出</strong></p>
<ol>
<li>避免 bigkey 操作返回大量数据结果；</li>
<li>避免在线上环境中持续使用 MONITOR 命令。</li>
<li>使用 <code>client-output-buffer-limit</code> 设置合理的缓冲区大小上限，或是缓冲区连续写入时间和写入量上限。</li>
</ol>
<h3 id="主从集群中的缓冲区"><a href="#主从集群中的缓冲区" class="headerlink" title="主从集群中的缓冲区"></a>主从集群中的缓冲区</h3><p>主从集群间的数据复制包括全量复制和增量复制两种，无论在哪种形式的复制中，为了保证主从节点的数据一致，都会用到缓冲区</p>
<h4 id="复制缓冲区的溢出问题（全量复制）"><a href="#复制缓冲区的溢出问题（全量复制）" class="headerlink" title="复制缓冲区的溢出问题（全量复制）"></a>复制缓冲区的溢出问题（全量复制）</h4><p>在全量复制过程中，主节点在向从节点传输 RDB 文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在复制缓冲区中，等 RDB 文件传输完成后，再发送给从节点去执行。主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步。</p>
<img src="/article/30584/%E5%A4%8D%E5%88%B6%E7%BC%93%E5%86%B2%E5%8C%BA.jpg" class title="复制缓冲区">
<p>在全量复制时，从节点接收和加载 RDB 较慢，同时主节点接收到了大量的写命令，写命令在复制缓冲区中就会越积越多，最终导致溢出。</p>
<p><strong>避免复制缓冲区溢出</strong></p>
<ol>
<li><p>控制主节点保存的数据量大小</p>
<p>一般把主节点的数据量控制在 2~4GB，这样可以让全量同步执行得更快些，避免复制缓冲区累积过多命令。</p>
</li>
<li><p>使用 <code>client-output-buffer-limit</code> 配置项，设置合理的复制缓冲区大小</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">config <span class="hljs-built_in">set</span> client-output-buffer-limit slave 512mb 128mb 60<br></code></pre></td></tr></table></figure>
<p>slave 参数表明该配置项是针对复制缓冲区的</p>
<p>512mb 代表将缓冲区大小的上限设置为 512MB；128mb 和 60 代表的设置是，如果连续 60 秒内的写入量超过 128MB 的话，也会触发缓冲区溢出。</p>
</blockquote>
<p>实际应用中设置复制缓冲区的大小时，可以根据写命令数据的大小和应用的实际负载情况（也就是写命令速率），来粗略估计缓冲区中会累积的写命令数据量；然后，再和所设置的复制缓冲区大小进行比较，判断设置的缓冲区大小是否足够支撑累积的写命令数据量。</p>
</li>
<li><p>控制和主节点连接的从节点个数</p>
<p>主节点上复制缓冲区的内存开销，会是每个从节点客户端输出缓冲区占用内存的总和</p>
<p>如果集群中的从节点数非常多的话，主节点的内存开销就会非常大</p>
</li>
</ol>
<h4 id="复制积压缓冲区的溢出问题-增量复制"><a href="#复制积压缓冲区的溢出问题-增量复制" class="headerlink" title="复制积压缓冲区的溢出问题(增量复制)"></a>复制积压缓冲区的溢出问题(增量复制)</h4><p>主节点在把接收到的写命令同步给从节点时，同时会把这些写命令写入复制积压缓冲区。一旦从节点发生网络闪断，再次和主节点恢复连接后，从节点就会从复制积压缓冲区中，读取断连期间主节点接收到的写命令，进而进行增量同步</p>
<img src="/article/30584/aedc9b41b31860e283c5d140bdb3318f.jpg" class title="img">
<ol>
<li>复制积压缓冲区(repl_backlog_buffer)是一个大小有限的环形缓冲区。当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据。如果从节点还没有同步这些旧命令数据，就会造成主从节点间重新开始执行全量复制。</li>
<li>为了应对复制积压缓冲区的溢出问题，我们可以调整复制积压缓冲区的大小，也就是设置 repl_backlog_size 这个参数的值</li>
</ol>
<h2 id="Java操作Redis"><a href="#Java操作Redis" class="headerlink" title="Java操作Redis"></a>Java操作Redis</h2><blockquote>
<p><strong>Redis依赖</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;!-- spring data redis 依赖 --&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>
<p>1.0 版本 默认使用连接池技术是 Jedis</p>
<p>2.0 以上版本 默认使用连接池技术是 Lettuce</p>
<p>如果使用 Jedis ，需要排除 Lettuce</p>
</blockquote>
<blockquote>
<p><strong>Redis配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">redis:</span><br>    <span class="hljs-comment">#超时时间</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-string">10000ms</span><br>    <span class="hljs-comment">#服务器地址</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>    <span class="hljs-comment">#服务器端口</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-comment">#数据库</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">*******</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-comment">#最大连接数</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">1024</span><br>        <span class="hljs-comment">#最大连接阻塞等待时间</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">10000ms</span><br>        <span class="hljs-comment">#最大空闲连接</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">200</span><br>        <span class="hljs-comment">#最小空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>Redis配置类</strong> – 进行序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.config;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;<br>    RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>    <span class="hljs-comment">//String类型key序列器</span><br>    redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>    <span class="hljs-comment">//String类型Value序列器</span><br>    redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer());<br>    <span class="hljs-comment">//Hash类型key序列器</span><br>    redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>    <span class="hljs-comment">//Hash类型Value序列器</span><br>    redisTemplate.setHashValueSerializer(<span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer());<br>    redisTemplate.setConnectionFactory(redisConnectionFactory);<br>    <span class="hljs-keyword">return</span> redisTemplate;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>通过用户ID查询菜单，并存入Redis</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> MenuMapper menuMapper;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getMenusByAdminID</span><span class="hljs-params">()</span> </span>&#123;<br>  Integer adminId = AdminUtils.getCurrentAdmin().getId();<br>  ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();<br>  <span class="hljs-comment">//从redis获取菜单数据</span><br>  List&lt;Menu&gt; menus = (List&lt;Menu&gt;) valueOperations.get(<span class="hljs-string">&quot;menu_&quot;</span> + adminId);<br>  <span class="hljs-comment">//如果为空，去数据库获取</span><br>  <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(menus)) &#123;<br>    menus = menuMapper.getMenusByAdminID(adminId);<br>    <span class="hljs-comment">//将数据设置到redis中</span><br>    valueOperations.set(<span class="hljs-string">&quot;menu_&quot;</span> + adminId, menus);<br>  &#125;<br>  <span class="hljs-keyword">return</span> menus;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="FastDFS-头像上传"><a href="#FastDFS-头像上传" class="headerlink" title="FastDFS 头像上传"></a>FastDFS 头像上传</h2><h3 id="FastDFS简介"><a href="#FastDFS简介" class="headerlink" title="FastDFS简介"></a>FastDFS简介</h3><ol>
<li><p>FastDFS 是一个开源的轻量级<strong>分布式文件系统</strong>，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。</p>
<p>FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p>
</li>
<li><p>FastDFS 服务端有两个角色：跟踪器（tracker）和存储节点（storage）。</p>
<ol>
<li>跟踪器主要做调度工作，在访问上起负载均衡的作用。</li>
<li>存储节点存储文件，完成文件管理的所有功能，存储、同步和提供存取接口。</li>
</ol>
</li>
</ol>
<p>FastDFS 同时对文件的 metadata 进行管理。所谓文件的 metadata 就是文件的相关属性，以键值对（key value）方式表示。</p>
<ol start="3">
<li><p>集群</p>
<p>跟踪器和存储节点都可以由一台或多台服务器构成【所以说都可以做集群】。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。【<strong>跟踪器除了做调度作用以外，还可以在访问上能起到简单的负载均衡的作用</strong>。】 </p>
<p>为了支持大容量，<strong>存储节点（服务器）采用了分卷（或分组）的组织方式</strong>。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了<strong>冗余备份和负载均衡</strong>的作用。</p>
<p>在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。</p>
</li>
</ol>
<p><strong>FastDFS 中的文件标识分为两个部分：卷名和文件名，二者缺一不可</strong></p>
<h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><img src="/article/30584/FastDFS%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class title="FastDFS架构图">
<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>同一组内的 storage server 之间是对等的，文件上传、删除等操作可以在任意一台 storage server 上进行；</p>
<p>文件同步只在同组内的 storage server 之间进行，采用 push 方式，即源服务器同步给目标服务器；</p>
<p>源头数据才需要同步，备份数据不需要再次同步，否则就构成环路了；</p>
<p>上述第二条规则有个例外，就是新增加一台storage server时，由已有的一台storage server将已有的所有数据（包括源头数据和备份数据）同步给该新增服务器</p>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强。</p>
<p>为了使Web应用直接使用HTTP协议，直接访问存储器中的文件</p>
<h3 id="Java使用FastDFS"><a href="#Java使用FastDFS" class="headerlink" title="Java使用FastDFS"></a>Java使用FastDFS</h3><blockquote>
<p><strong>依赖</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;org.csource&lt;/groupId&gt;<br>  &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">1.29</span>-SNAPSHOT&lt;/version&gt;<br> &lt;/dependency&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>常用类</strong></p>
<ol>
<li><p><strong>CLientGlobal</strong></p>
<p>用于加载配置文件的公共客户端工具</p>
<p>init(String conf_filename) 根据配置文件路径以及命名，加载配置文件，并设置客户端公共参数，配置文件类型为 <strong>.conf</strong> 文件，可以使用绝对路径或相对路径加载；</p>
<p>initByPropereties(Propereties props) 根据Propereties对象设置客户端公共参数</p>
</li>
<li><p><strong>TrackerClient</strong></p>
<p>跟踪器客户端类型，创建此类对象时，需要传递跟踪器组，就是跟踪器的访问地址信息，无参构造方法默认使用ClientGlobal.g_tracker_group 常量作为跟踪器来构造对象</p>
</li>
<li><p><strong>TrackerServer</strong></p>
<p>跟踪器服务类型，此类型的对象是通过跟踪器客户端构建的，实际上就是一个与FastDFS Tracker Server的链接对象。</p>
</li>
<li><p><strong>StorageServer</strong></p>
<p>存储服务类型，通过跟踪器客户端对象构建，实质上就是一个与FastDFS Storage Server 的链接对象，是代码只能够与 StorageServer 链接的工具，获取的具体存储服务链接，是由 TrackerServer 分配的，所以构建存储服务器对象时，需要依赖跟踪器服务对象。</p>
</li>
<li><p><strong>StorageClient</strong></p>
<p>存储客户端类型，此类型的对象时通过构造方法创建的，创建时，需传递跟踪器服务对象和存储服务对象，此对象实质上是一个访问 FastDFS Storage Server 的客户端对象，用于实现文件的读写操作。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>FastDFS配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs conf">#ubuntu 开启8888 23000 22122 端口<br>#开启tracker /etc/init.d/fdfs_trackerd stop<br>#开启stroage /etc/init.d/fdfs_storaged start<br>#开启nginx  /usr/local/nginx/sbin/nginx<br><br>#连接超时<br>connect_timeout = 2<br>#网络超时<br>network_time = 30<br>#编码格式<br>charset = UTF-8<br>#tracker端口<br>http.tracker_http_port = 8080<br>#防盗链功能<br>http.anit_steal_token = no<br>#密钥<br>http.secret_key = FastDFS1234567890<br>#tracker ip:端口号<br>tracker_server = 10.211.55.11:22122<br>#连接池配置<br>connection_pool.enabled = true<br>connection_pool.max_count_per_entry = 500<br>connection_pool.max_idle_time = 3600<br>connection_pool.max_wait_time_in_ms = 1000<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>FastDFS工具类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.utiles;<br><br><span class="hljs-keyword">import</span> org.csource.fastdfs.*;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;<br><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//centos服务器安装fastDFS</span><br><span class="hljs-comment">//https://www.cnblogs.com/homjun/p/14841843.html</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastDFSUtils</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(FastDFSUtils.class);<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化客户端</span><br><span class="hljs-comment">     * ClientGlobal 读取配置文件，并初始化对应属性</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      String filePath = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;fdfs_client.conf&quot;</span>).getFile().getAbsolutePath();<br>      ClientGlobal.init(filePath);<br>      logger.info(<span class="hljs-string">&quot;初始化FastDFS成功&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;初始化FastDFS失败&quot;</span>, e.getMessage());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成TrackerServer</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TrackerServer <span class="hljs-title">getTrackerServer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();<br>    TrackerServer trackerServer = trackerClient.getTrackerServer();<br>    <span class="hljs-keyword">return</span> trackerServer;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成StorageClient</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StorageClient <span class="hljs-title">getStorageClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    TrackerServer trackerServer = getTrackerServer();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StorageClient(trackerServer, <span class="hljs-keyword">null</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上传文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] upload(MultipartFile file) &#123;<br>    String name = file.getOriginalFilename();<br>    logger.info(<span class="hljs-string">&quot;文件名：&quot;</span>, name);<br>    StorageClient storageClient = <span class="hljs-keyword">null</span>;<br>    String[] uploadResults = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//获取 storageClient</span><br>      storageClient = getStorageClient();<br>      <span class="hljs-comment">//上传</span><br>      uploadResults = storageClient.upload_file(file.getBytes(), name.substring(name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>), <span class="hljs-keyword">null</span>);<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;上传文件失败！&quot;</span>, e.getMessage());<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == uploadResults &amp;&amp; <span class="hljs-keyword">null</span> != storageClient) &#123;<br>      logger.error(<span class="hljs-string">&quot;上传失败！&quot;</span>, storageClient.getErrorCode());<br>    &#125;<br>    <span class="hljs-keyword">return</span> uploadResults;<br>  &#125;<br><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取文件信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> remoteFileName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FileInfo <span class="hljs-title">getFileInfo</span><span class="hljs-params">(String groupName, String remoteFileName)</span> </span>&#123;<br>    StorageClient storageClient = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      storageClient = getStorageClient();<br>      <span class="hljs-keyword">return</span> storageClient.get_file_info(groupName, remoteFileName);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;文件信息获取失败！&quot;</span>, e.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下载文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> remoteFileName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InputStream <span class="hljs-title">downFile</span><span class="hljs-params">(String groupName, String remoteFileName)</span> </span>&#123;<br>    StorageClient storageClient = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      storageClient = getStorageClient();<br>      <span class="hljs-keyword">byte</span>[] fileByte = storageClient.download_file(groupName, remoteFileName);<br>      InputStream inputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(fileByte);<br>      <span class="hljs-keyword">return</span> inputStream;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;文件下载失败！&quot;</span>, e.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> remoteFileName</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFile</span><span class="hljs-params">(String groupName, String remoteFileName)</span> </span>&#123;<br>    StorageClient storageClient = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      storageClient = getStorageClient();<br>      storageClient.delete_file(groupName, remoteFileName);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;文件删除失败！&quot;</span>, e.getMessage());<br>    &#125;<br>  &#125;<br><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取文件路径</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getTrackerUrl</span><span class="hljs-params">()</span> </span>&#123;<br>    TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();<br>    TrackerServer trackerServer = <span class="hljs-keyword">null</span>;<br>    StorageServer storeStorage = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      trackerServer = trackerClient.getTrackerServer();<br>      storeStorage = trackerClient.getStoreStorage(trackerServer);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;文件路径获取失败！&quot;</span>, e.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;http://&quot;</span> + storeStorage.getInetSocketAddress().getHostString() + <span class="hljs-string">&quot;:8888/&quot;</span>;<br>    <span class="hljs-comment">//        return &quot;http://localhost:8888/&quot;;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/article/23384.html</url>
    <content><![CDATA[<p><strong>二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</strong></p>
<h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><img src="/article/23384/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%91.jpg" class title="什么是树">
<img src="/article/23384/%E6%A0%91.jpg" class title="树">
<p>A 节点就是 B 节点的<strong>父节点</strong>，B 节点是 A 节点的<strong>子节点</strong>。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为<strong>兄弟节点</strong>。没有父节点的节点叫做<strong>根节点</strong>，也就是图中的节点 E。我们把没有子节点的节点叫做<strong>叶子节点或者叶节点</strong>，比如图中的 G、H、I、J、K、L 都是叶子节点。</p>
<p><strong>高度（Height）：</strong>节点到叶子结点的最长路径（边数） （树的高度 = 根节点的高度）</p>
<p><strong>深度（Depth）：</strong>根节点到这个节点所经历的边得个数</p>
<p><strong>层（Level）：</strong>节点的深度 + 1</p>
<img src="/article/23384/%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E6%B7%B1%E5%BA%A6%E5%B1%82.jpg" class title="树的高度深度层">
<h2 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h2><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是<strong>左子节点和右子节点</strong>。</p>
<img src="/article/23384/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" class title="二叉树">
<p><strong>满二叉树：</strong>编号 2 的二叉树中，<strong>叶子节点全都在最底层</strong>，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树。</p>
<p><strong>完全二叉树：</strong>编号 3 的二叉树中，<strong>叶子节点都在最底下两层</strong>，<strong>最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</strong>，这种二叉树叫做完全二叉树。</p>
<blockquote>
<p><strong>如何求一棵包含 n 个节点的完全二叉树的高度？</strong></p>
<p>包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(K-1)。</p>
<p><strong>最后一层的节点个数包含的节点个数在 1 个到 2^(L-1) 个之间（假设最大层数是 L）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n &gt;= 1+2+4+8+...+2^(L-2)+1<br>n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)<br></code></pre></td></tr></table></figure>
<p><strong>L 的范围是[log<sub>2</sub>(n+1), log<sub>2</sub>n +1]</strong></p>
<p>完全二叉树的层数小于等于 log<sub>2</sub>n +1，也就是说，完全二叉树的高度小于等于 log<sub>2</sub>n。</p>
</blockquote>
<h3 id="如何表示（或者存储）一棵二叉树？"><a href="#如何表示（或者存储）一棵二叉树？" class="headerlink" title="如何表示（或者存储）一棵二叉树？"></a>如何表示（或者存储）一棵二叉树？</h3><p>想要存储一棵二叉树，有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p>
<ol>
<li><p>链式存储法</p>
<img src="/article/23384/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.jpg" class title="二叉树的链式存储">
<p>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针</p>
</li>
<li><p>顺序存储法</p>
<img src="/article/23384/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg" class title="二叉树的顺序存储">
<p><strong>根节点存储在下标 i = 1 的位置</strong></p>
<p><strong>左子节点</strong>存储在下标 <strong>2 * i = 2</strong> 的位置</p>
<p><strong>右子节点</strong>存储在 <strong>2 * i + 1 = 3</strong> 的位置</p>
<p>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 <em> i 的位置存储的就是左子节点，下标为 2 </em> i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。</p>
<p><strong>完全二叉树，用数组存储是最节省内存的一种方式</strong></p>
</li>
</ol>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><img src="/article/23384/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.jpg" class title="二叉树的遍历">
<p>二叉树的前、中、后序遍历就是一个递归的过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">前序遍历的递推公式：<br>preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)<br><br>中序遍历的递推公式：<br>inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)<br><br>后序遍历的递推公式：<br>postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>  print root <span class="hljs-comment">// 此处为伪代码，表示打印root节点</span><br>  preOrder(root-&gt;left);<br>  preOrder(root-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>  inOrder(root-&gt;left);<br>  print root <span class="hljs-comment">// 此处为伪代码，表示打印root节点</span><br>  inOrder(root-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>  postOrder(root-&gt;left);<br>  postOrder(root-&gt;right);<br>  print root <span class="hljs-comment">// 此处为伪代码，表示打印root节点</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说<strong>二叉树遍历的时间复杂度是 O(n)</strong></p>
<p><strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)</strong></p>
<h3 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h3><p><strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong></p>
<ol>
<li><p>二叉查找树的查找操作</p>
<p>先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p>
<img src="/article/23384/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C.jpg" class title="二叉查找树的查找操作">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> Node tree;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    Node p = tree;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (data &lt; p.data) p = p.left;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">private</span> Node left;<br>    <span class="hljs-keyword">private</span> Node right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>二叉查找树的插入操作</p>
<p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p>
<p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;<br>    tree = <span class="hljs-keyword">new</span> Node(data);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  Node p = tree;<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (data &gt; p.data) &#123;<br>      <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;<br>        p.right = <span class="hljs-keyword">new</span> Node(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      p = p.right;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span><br>      <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;<br>        p.left = <span class="hljs-keyword">new</span> Node(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      p = p.left;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>二叉查找树的删除操作</p>
<ol>
<li>如果要删除的节点没有子节点，只需要直接将父节点中，指向要删除节点的指针置为 null</li>
<li>如果要删除的节点只有一个子节点（只有左子节点或者右子节点），只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了</li>
<li>如果要删除的节点有两个子节点，需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了）</li>
</ol>
<img src="/article/23384/%E8%A6%81%E5%88%A0%E9%99%A4%E7%9A%84%E8%8A%82%E7%82%B9%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9.jpg" class title="要删除的节点有两个子节点">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>  Node p = tree; <span class="hljs-comment">// p指向要删除的节点，初始化指向根节点</span><br>  Node pp = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// pp记录的是p的父节点</span><br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.data != data) &#123;<br>    pp = p;<br>    <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;<br>    <span class="hljs-keyword">else</span> p = p.left;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span><br><br>  <span class="hljs-comment">// 要删除的节点有两个子节点</span><br>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span> &amp;&amp; p.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查找右子树中最小节点</span><br>    Node minP = p.right;<br>    Node minPP = p; <span class="hljs-comment">// minPP表示minP的父节点</span><br>    <span class="hljs-keyword">while</span> (minP.left != <span class="hljs-keyword">null</span>) &#123;<br>      minPP = minP;<br>      minP = minP.left;<br>    &#125;<br>    p.data = minP.data; <span class="hljs-comment">// 将minP的数据替换到p中</span><br>    p = minP; <span class="hljs-comment">// 下面就变成了删除minP了</span><br>    pp = minPP;<br>  &#125;<br><br>  <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span><br>  Node child; <span class="hljs-comment">// p的子节点</span><br>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) child = p.left;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) child = p.right;<br>  <span class="hljs-keyword">else</span> child = <span class="hljs-keyword">null</span>;<br><br>  <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>) tree = child; <span class="hljs-comment">// 删除的是根节点</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p) pp.left = child;<br>  <span class="hljs-keyword">else</span> pp.right = child;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>二叉查找树的其他操作</p>
<p>二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点</p>
</li>
</ol>
<p><strong>支持重复数据的二叉查找树</strong></p>
<p>二叉查找树也可以存储包含很多字段的对象</p>
<p>利用对象的<strong>某个字段作为键值（key）</strong>来构建二叉查找树。对象中的其他字段叫作卫星数据。</p>
<blockquote>
<p><strong>问题：如果存储的两个对象键值相同，这种情况该怎么处理呢？</strong></p>
<ol>
<li><p>二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
</li>
<li><p>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p>
<p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p>
</li>
</ol>
</blockquote>
<p><strong>二叉查找树的时间复杂度分析</strong></p>
<ol>
<li><p>最坏情况时间复杂度：O(n)</p>
</li>
<li><p>最好情况时间复杂度：二叉查找树是一棵完全二叉树（或满二叉树），跟树的高度成正比，也就是 O(height)</p>
</li>
</ol>
<hr>
<blockquote>
<p><strong>问题：相对散列表，为什么还要用二叉查找树呢？</strong></p>
<ol>
<li>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</li>
<li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</li>
<li>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li>
<li>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li>
<li>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li>
</ol>
</blockquote>
<hr>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h3><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。</p>
<img src="/article/23384/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" class title="平衡二叉树">
<p>很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1）。比如<strong>红黑树</strong>，<strong>它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</strong></p>
<h3 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h3><p>红黑树(Red-Black Tree，简称 R-B Tree)，是一种不严格的平衡二叉查找树。</p>
<p>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p>
<ol>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ol>
<img src="/article/23384/%E7%9C%81%E7%95%A5%E5%8C%85%E5%90%AB%E7%A9%BA%E8%8A%82%E7%82%B9%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" class title="省略包含空节点的红黑树">
<h3 id="为什么说红黑树是“近似平衡”的？"><a href="#为什么说红黑树是“近似平衡”的？" class="headerlink" title="为什么说红黑树是“近似平衡”的？"></a>为什么说红黑树是“近似平衡”的？</h3><p>平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，<strong>“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化得太严重。</strong></p>
<blockquote>
<p><strong>红黑树的高度分析</strong></p>
<ol>
<li><p>首先，如果将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？</p>
<p>红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。</p>
<img src="/article/23384/%E5%8E%BB%E6%8E%89%E7%BA%A2%E8%89%B2%E8%8A%82%E7%82%B9%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" class title="去掉红色节点的红黑树">
<blockquote>
<p>红黑树的定义中：从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。</p>
</blockquote>
<p>从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。</p>
</li>
<li><p>把红色节点加回去，高度会变成多少呢？</p>
<blockquote>
<p>红黑树的定义中：任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。</p>
</blockquote>
<p>红黑树中包含最多黑色节点的路径不会超过 log<sub>2</sub>n，所以加入红色节点之后，最长路径不会超过 2log<sub>2</sub>nn，也就是说，<strong>红黑树的高度近似 2log<sub>2</sub>n。</strong></p>
</li>
</ol>
</blockquote>
<h3 id="实现红黑树的基本思想"><a href="#实现红黑树的基本思想" class="headerlink" title="实现红黑树的基本思想"></a>实现红黑树的基本思想</h3><p>一棵合格的红黑树需要满足这样几个要求：</p>
<ol>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。</li>
</ol>
<p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏，而红黑树的“平衡调整”，实际上就是要把被破坏的第三、第四点恢复过来。</p>
<p><strong>左旋（rotate left）围绕某个节点的左旋、右旋（rotate right）围绕某个节点的右旋</strong></p>
<img src="/article/23384/%E5%B7%A6%E6%97%8B%E5%8F%B3%E6%97%8B%E7%AE%80%E5%9B%BE.jpg" class title="左旋右旋简图">
<h3 id="插入删除平衡调整"><a href="#插入删除平衡调整" class="headerlink" title="插入删除平衡调整"></a>插入删除平衡调整</h3><h4 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h4><p><strong>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上</strong></p>
<ol>
<li>如果插入节点的父节点是黑色的，什么都不用做，它仍然满足红黑树的定义。</li>
<li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</li>
<li>其他违背红黑树定义的情况。（<strong>左右旋转和改变颜色</strong>）</li>
</ol>
<p>正在处理的节点叫做<strong>关注节点</strong></p>
<ol>
<li><p>如果关注节点是 a，它的叔叔节点 d 是红色</p>
<p><img src="/article/插入CASE 1.jpg"><span class="image-caption">CASE 1</span></p>
<ol>
<li>将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；</li>
<li>将关注节点 a 的祖父节点 c 的颜色设置成红色；</li>
<li>关注节点变成 a 的祖父节点 c；</li>
<li>跳到 CASE 2 或者 CASE 3。</li>
</ol>
</li>
<li><p>如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点</p>
<p><img src="/article/插入CASE 2.jpg"><span class="image-caption">CASE 2</span></p>
<ol>
<li>关注节点变成节点 a 的父节点 b；</li>
<li>围绕新的关注节点b 左旋；</li>
<li>跳到 CASE 3。</li>
</ol>
</li>
<li><p>如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点</p>
<p><img src="/article/插入CASE 3.jpg"><span class="image-caption">CASE 3</span></p>
<ol>
<li>围绕关注节点 a 的祖父节点 c 右旋；</li>
<li>将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。</li>
<li>调整结束。</li>
</ol>
</li>
</ol>
<h4 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h4><p><strong>第一步是针对删除节点初步调整</strong>。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；<strong>第二步是针对关注节点进行二次调整</strong>，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p>
<ol>
<li><p>针对删除节点初步调整</p>
<p>红黑树的定义中“只包含红色节点和黑色节点”，</p>
<p>经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。</p>
<ol>
<li><p>如果要删除的节点是 a，它只有一个子节点 b</p>
<p><img src="/article/初步删除CASE 1.jpg"><span class="image-caption">初步删除CASE 1</span></p>
<ol>
<li>删除节点 a，并且把节点 b 替换到节点 a 的位置；</li>
<li>节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；</li>
<li>调整结束，不需要进行二次调整。</li>
</ol>
</li>
<li><p>如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c</p>
<p><img src="/article/初步删除CASE 2.jpg"><span class="image-caption">初步删除CASE 2</span></p>
<ol>
<li>如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。把节点 a 删除，并且将节点 c 替换到节点 a 的位置；</li>
<li>然后把节点 c 的颜色设置为跟节点 a 相同的颜色；</li>
<li>如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；</li>
<li>这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。</li>
</ol>
</li>
<li><p>如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点</p>
<p><img src="/article/初步删除CASE 3.jpg"><span class="image-caption">初步删除CASE 3</span></p>
<ol>
<li>找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；</li>
<li>将节点 a 替换成后继节点 d；</li>
<li>把节点 d 的颜色设置为跟节点 a 相同的颜色；</li>
<li>如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；</li>
<li>这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。</li>
</ol>
</li>
</ol>
</li>
<li><p>针对关注节点进行二次调整</p>
<p>经过初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点</p>
<ol>
<li><p>如果关注节点是 a，它的兄弟节点 c 是红色的</p>
<p><img src="/article/删除二次调整CASE 1.jpg"><span class="image-caption">删除二次调整CASE 1</span></p>
<ol>
<li>围绕关注节点 a 的父节点 b 左旋；</li>
<li>关注节点 a 的父节点 b 和祖父节点 c 交换颜色；</li>
<li>关注节点不变；</li>
<li>继续从四种情况中选择适合的规则来调整。</li>
</ol>
</li>
<li><p>如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的</p>
<p><img src="/article/删除二次调整CASE 2.jpg"><span class="image-caption">删除二次调整CASE 2</span></p>
<ol>
<li>将关注节点 a 的兄弟节点 c 的颜色变成红色；</li>
<li>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；</li>
<li>给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；</li>
<li>关注节点从 a 变成其父节点 b；</li>
<li>继续从四种情况中选择符合的规则来调整。</li>
</ol>
</li>
<li><p>如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色</p>
<p><img src="/article/删除二次调整CASE 3.jpg"><span class="image-caption">删除二次调整CASE 3</span></p>
<ol>
<li>围绕关注节点 a 的兄弟节点 c 右旋；</li>
<li>节点 c 和节点 d 交换颜色；</li>
<li>关注节点不变；</li>
<li>跳转到 CASE 4，继续调整。</li>
</ol>
</li>
<li><p>如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的</p>
<p><img src="/article/删除二次调整CASE 4.jpg"><span class="image-caption">删除二次调整CASE 4</span></p>
<ol>
<li>围绕关注节点 a 的父节点 b 左旋；</li>
<li>将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；</li>
<li>将关注节点 a 的父节点 b 的颜色设置为黑色；</li>
<li>从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；</li>
<li>将关注节点 a 的叔叔节点 e 设置为黑色；调整结束。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="递归树"><a href="#递归树" class="headerlink" title="递归树"></a>递归树</h2><p><strong>如何用递归树，来分析递归代码的时间复杂度</strong></p>
<blockquote>
<img src="/article/23384/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="归并排序递归树">
<p>归并排序递归树时间复杂度</p>
<p>因为每次分解都是一分为二，所以代价很低，把时间上的消耗记作常量 1。</p>
<p>归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。把每一层归并操作消耗的时间记作 n。</p>
<p>只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O(n * h)</p>
<p>归并排序递归树是一棵满二叉树。满二叉树的高度大约是 log<sub>2</sub>n，所以，<strong>归并排序递归实现的时间复杂度就是 O(nlogn)</strong></p>
</blockquote>
<h3 id="实战一：分析快速排序的时间复杂度"><a href="#实战一：分析快速排序的时间复杂度" class="headerlink" title="实战一：分析快速排序的时间复杂度"></a>实战一：分析快速排序的时间复杂度</h3><blockquote>
<p>快速排序在最好情况下，每次分区都能一分为二，用递推公式 T(n)=2T(n/2)+n，很容易就能推导出时间复杂度是 O(nlogn)。但是，不可能每次分区都正好一分为二。</p>
<p>假设平均情况下，每次分区之后，两个分区的大小比例为 1:k。当 k=9 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 T(n)=T(n/10)+T(9n/10)+n。</p>
</blockquote>
<p><strong>用递归树来分析快速排序的平均情况时间复杂度</strong></p>
<img src="/article/23384/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="快速排序递归树">
<p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。我们现在只要求出递归树的高度 h，这个快排过程遍历的数据个数就是 h <em> n ，也就是说，时间复杂度就是 O(h </em> n)。</p>
<p>因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。</p>
<blockquote>
<p>快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 1/10，最长的一个路径每次都乘以 9/10。通过计算可以得到，从根节点到叶子节点的最短路径是 log<sub>10</sub>n，最长的路径是 log<sub>10/9</sub>n</p>
<img src="/article/23384/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E6%A0%91%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6.jpg" class title="快速排序递归树路径长度">
</blockquote>
<p>所以，遍历数据的个数总和就介于 nlog<sub>10</sub>n 和 nlog<sub>10/9</sub>n 之间</p>
<p>当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 O(nlogn)</p>
<p>对于 k 等于 9，99，甚至是 999，9999……，只要 k 的值不随 n 变化，是一个事先确定的常量，那快排的时间复杂度就是 O(nlogn)。所以，从概率论的角度来说，快排的平均时间复杂度就是 O(nlogn)。</p>
<h3 id="实战二：分析斐波那契数列的时间复杂度"><a href="#实战二：分析斐波那契数列的时间复杂度" class="headerlink" title="实战二：分析斐波那契数列的时间复杂度"></a>实战二：分析斐波那契数列的时间复杂度</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) + f(n-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/23384/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="斐波那契数列递归树">
<blockquote>
<p>斐波那契数列递归树的高度</p>
<p>f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 n/2。</p>
<p>每次分解之后的合并操作只需要一次加法运算，把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 2<sup>2</sup>。依次类推，第 k 层的时间消耗就是 2<sup>k−1</sup>，那整个算法的总的时间消耗就是每一层时间消耗之和。</p>
<p>如果路径长度都为 n，那这个总和就是 2<sup>n</sup>−1。</p>
<p>如果路径长度都是 n/2 ，那整个算法的总的时间消耗就是 2<sup>n/2</sup>−1。</p>
</blockquote>
<p>算法的时间复杂度就介于 O(2<sup>n</sup>) 和 O(2<sup>n/2</sup>) 之间</p>
<h3 id="实战三：分析全排列的时间复杂度"><a href="#实战三：分析全排列的时间复杂度" class="headerlink" title="实战三：分析全排列的时间复杂度"></a>实战三：分析全排列的时间复杂度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">1, 2, 3<br>1, 3, 2<br>2, 1, 3<br>2, 3, 1<br>3, 1, 2<br>3, 2, 1<br></code></pre></td></tr></table></figure>
<p>如果确定了最后一位数据，那就变成了求解剩下 n−1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，“n 个数据的排列”问题，就可以分解成 n 个“n−1 个数据的排列”的子问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">假设数组中存储的是1，2， 3...n。<br>        <br>f(1,2,...n) = &#123;最后一位是1, f(n-1)&#125; + &#123;最后一位是2, f(n-1)&#125; +...+&#123;最后一位是n, f(n-1)&#125;。<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用方式：</span><br><span class="hljs-comment">// int[]a = a=&#123;1, 2, 3, 4&#125;; printPermutations(a, 4, 4);</span><br><span class="hljs-comment">// k表示要处理的子数组的数据个数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printPermutations</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] data, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      System.out.print(data[i] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>    <span class="hljs-keyword">int</span> tmp = data[i];<br>    data[i] = data[k-<span class="hljs-number">1</span>];<br>    data[k-<span class="hljs-number">1</span>] = tmp;<br><br>    printPermutations(data, n, k - <span class="hljs-number">1</span>);<br><br>    tmp = data[i];<br>    data[i] = data[k-<span class="hljs-number">1</span>];<br>    data[k-<span class="hljs-number">1</span>] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/23384/%E5%85%A8%E6%8E%92%E5%88%97%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="全排列递归树">
<p>第一层分解有 n 次交换操作，第二层有 n 个节点，每个节点分解需要 n−1 次交换，所以第二层总的交换次数是 n <em> (n−1)。第三层有 n </em> (n−1) 个节点，每个节点分解需要 n−2 次交换，所以第三层总的交换次数是 n <em> (n−1) </em> (n−2)。</p>
<p>以此类推，第 k 层总的交换次数就是 n <em> (n−1) </em> (n−2) <em> … </em> (n−k+1)。最后一层的交换次数就是 n <em> (n−1) </em> (n−2) <em> … </em> 2 * 1。每一层的交换次数之和就是总的交换次数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1<br></code></pre></td></tr></table></figure>
<p>最后一个数，n <em> (n−1) </em> (n−2) <em> … </em> 2 <em> 1 等于 n!，而前面的 n−1 个数都小于最后一个数，所以，总和肯定小于 n </em> n!，也就是说，<strong>全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n * n!)</strong></p>
<h2 id="“堆”（Heap）"><a href="#“堆”（Heap）" class="headerlink" title="“堆”（Heap）"></a>“堆”（Heap）</h2><p><strong>堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法</strong></p>
<p><strong>堆排序不是稳定的排序算法</strong></p>
<p>堆满足的两点要求：</p>
<ol>
<li>堆是一个完全二叉树；</li>
<li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li>
</ol>
<h3 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h3><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。</p>
<img src="/article/23384/%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%A0%86.jpg" class title="数组存储堆">
<p>数组中下标为 i 的节点的左子节点，就是下标为 i <em> 2 的节点，右子节点就是下标为 i </em> 2 + 1 的节点，父节点就是下标为 i/2 的节点。</p>
<p><strong>堆化（heapify）</strong></p>
<p>堆化有两种，从下往上和从上往下</p>
<ol>
<li><p>从下往上的堆化方法</p>
<img src="/article/23384/%E5%BE%80%E5%A0%86%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0.jpg" class title="往堆中插入一个元素">
<p>让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足堆的大小关系</p>
<img src="/article/23384/%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8A%E7%9A%84%E5%A0%86%E5%8C%96%E6%96%B9%E6%B3%95.jpg" class title="从下往上的堆化方法">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] a; <span class="hljs-comment">// 数组，从下标1开始存储数据</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;  <span class="hljs-comment">// 堆可以存储的最大数据个数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count; <span class="hljs-comment">// 堆中已经存储的数据个数</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[capacity + <span class="hljs-number">1</span>];<br>    n = capacity;<br>    count = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (count &gt;= n) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 堆满了</span><br>    ++count;<br>    a[count] = data;<br>    <span class="hljs-keyword">int</span> i = count;<br>    <span class="hljs-keyword">while</span> (i/<span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="hljs-number">2</span>]) &#123; <span class="hljs-comment">// 自下往上堆化</span><br>      swap(a, i, i/<span class="hljs-number">2</span>); <span class="hljs-comment">// swap()函数作用：交换下标为i和i/2的两个元素</span><br>      i = i/<span class="hljs-number">2</span>;<br>    &#125;<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>从上往下的堆化方法</p>
<p>删除堆顶元素之后，需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p>
<p>把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是<strong>从上往下的堆化方法</strong>。</p>
<img src="/article/23384/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E7%9A%84%E5%A0%86%E5%8C%96%E6%96%B9%E6%B3%95.jpg" class title="从上往下的堆化方法">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeMax</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 堆中没有数据</span><br>  a[<span class="hljs-number">1</span>] = a[count];<br>  --count;<br>  heapify(a, count, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i)</span> </span>&#123; <span class="hljs-comment">// 自上往下堆化</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">int</span> maxPos = i;<br>    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="hljs-number">2</span>]) maxPos = i*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) maxPos = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (maxPos == i) <span class="hljs-keyword">break</span>;<br>    swap(a, i, maxPos);<br>    i = maxPos;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>一个包含 n 个节点的完全二叉树，树的高度不会超过 log<sub>2</sub>n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。</p>
<h3 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h3><ol>
<li><p>建堆</p>
<p>将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。</p>
<ol>
<li><p>第一种是在堆中插入一个元素的思路。尽管数组中包含 n 个数据，假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，调用插入操作，将下标从 2 到 n 的数据依次插入到堆中。</p>
</li>
<li><p>第二种实现思路是从后往前处理数组，并且每个数据都是从上往下堆化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n/<span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>    heapify(a, n, i);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">int</span> maxPos = i;<br>    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="hljs-number">2</span>]) maxPos = i*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) maxPos = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (maxPos == i) <span class="hljs-keyword">break</span>;<br>    swap(a, i, maxPos);<br>    i = maxPos;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对下标从 n/2 开始到 1 的数据进行堆化，下标是 n/2+1 到 n 的节点是叶子节点，我们不需要堆化</p>
<p><strong>对于完全二叉树来说，下标从 n/2+1 到 n 的节点都是叶子节点</strong></p>
</li>
</ol>
<blockquote>
<p>建堆操作的时间复杂度:</p>
<p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。</p>
<img src="/article/23384/%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" class title="建堆的时间复杂度">
<img src="/article/23384/%E6%AF%8F%E4%B8%AA%E9%9D%9E%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E9%AB%98%E5%BA%A6%E6%B1%82%E5%92%8C.jpg" class title="每个非叶子节点的高度求和">
</blockquote>
<p>因为 h=log<sub>2</sub>n，代入公式 S，就能得到 S=O(n)，所以，建堆的时间复杂度就是 O(n)。</p>
</li>
<li><p>排序</p>
<p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。</p>
<p>然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  buildHeap(a, n);<br>  <span class="hljs-keyword">int</span> k = n;<br>  <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span>) &#123;<br>    swap(a, <span class="hljs-number">1</span>, k);<br>    --k;<br>    heapify(a, k, <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>堆排序的时间复杂度:</p>
<p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。</p>
</blockquote>
</li>
</ol>
<hr>
<blockquote>
<p><strong>问题：实际开发中，为什么快速排序要比堆排序性能好？</strong></p>
<ol>
<li><p>堆排序数据访问的方式没有快速排序友好</p>
</li>
<li><p>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序</p>
<p>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。</p>
<p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h3><ol>
<li><p>优先级队列</p>
<p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p>
<p>往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p>
<blockquote>
<ol>
<li><p>合并有序小文件</p>
<p>假设有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。希望将这些 100 个小文件合并成一个有序的大文件。</p>
<blockquote>
<p>将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。</p>
</blockquote>
</li>
<li><p>高性能定时器</p>
<p>假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</p>
<img src="/article/23384/%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E4%BE%8B.jpg" class title="高性能定时器实例">
<p>但是，这样每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</p>
<blockquote>
<p>按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。</p>
<p>定时器拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。</p>
<p>这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。</p>
<p>定时器就可以设定在 T 秒之后，再来执行任务。从当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情。</p>
<p>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。这样，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>利用堆求 Top K</p>
<blockquote>
<ol>
<li><p>针对静态数据集合：数据集合事先确定，不会再变</p>
<blockquote>
<p>维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。</p>
</blockquote>
<p>遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)。</p>
</li>
<li><p>针对动态数据集合：数据集合事先并不确定，有数据动态地加入到集合中</p>
<p>一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小。</p>
<blockquote>
<p>一直维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回。</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>利用堆求中位数</p>
<blockquote>
<p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</p>
<p>如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2 个数据存储在大顶堆中，后 n/2 个数据存储在小顶堆中。这样，大顶堆中的堆顶元素就是我们要找的中位数。如果 n 是奇数，情况是类似的，大顶堆就存储 n/2+1 个数据，小顶堆中就存储 n/2 个数据。</p>
<p>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。</p>
<p>可能出现，两个堆中的数据个数不符合前面约定的情况:从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。</p>
<img src="/article/23384/%E4%B8%A4%E4%B8%AA%E5%A0%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%E4%B8%8D%E7%AC%A6%E5%90%88.jpg" class title="两个堆中的数据个数不符合">
</blockquote>
</li>
</ol>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种<strong>专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</strong></p>
<blockquote>
<p>有 6 个字符串，它们分别是：how，hi，her，hello，so，see。希望在里面多次查找某个字符串是否存在。</p>
<p>对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。</p>
</blockquote>
<p><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</strong></p>
<blockquote>
<img src="/article/23384/Trie%E6%A0%91%E5%AE%9E%E4%BE%8B.jpg" class title="Trie树实例">
</blockquote>
<p>根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p>
<blockquote>
<p>Trie 树构造的分解过程</p>
<p><img src="/article/Trie 树构造的分解过程1.jpg"><span class="image-caption">img</span></p>
<p><img src="/article/Trie 树构造的分解过程2.jpg"><span class="image-caption">Trie 树构造的分解过程</span></p>
</blockquote>
<h3 id="如何实现一棵-Trie-树？"><a href="#如何实现一棵-Trie-树？" class="headerlink" title="如何实现一棵 Trie 树？"></a>如何实现一棵 Trie 树？</h3><p>Trie 树主要有两个操作</p>
<ol>
<li>一个是将字符串集合构造成 Trie 树。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。</li>
<li>另一个是在 Trie 树中查询一个字符串。</li>
</ol>
<p>借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> data;<br>  TrieNode children[<span class="hljs-number">26</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/23384/%E5%80%9F%E5%8A%A9%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0Trie%E6%A0%91.jpg" class title="借助散列表实现Trie树">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> TrieNode root = <span class="hljs-keyword">new</span> TrieNode(<span class="hljs-string">&#x27;/&#x27;</span>); <span class="hljs-comment">// 存储无意义字符</span><br><br>  <span class="hljs-comment">// 往Trie树中插入一个字符串</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; text.length; ++i) &#123;<br>      <span class="hljs-keyword">int</span> index = text[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-keyword">null</span>) &#123;<br>        TrieNode newNode = <span class="hljs-keyword">new</span> TrieNode(text[i]);<br>        p.children[index] = newNode;<br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    p.isEndingChar = <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 在Trie树中查找一个字符串</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] pattern)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pattern.length; ++i) &#123;<br>      <span class="hljs-keyword">int</span> index = pattern[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在pattern</span><br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p.isEndingChar == <span class="hljs-keyword">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不能完全匹配，只是前缀</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 找到pattern</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> data;<br>    <span class="hljs-keyword">public</span> TrieNode[] children = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEndingChar = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol>
<li><p>时间复杂度</p>
<p>构建 Trie 树的过程，需要扫描所有的字符串，<strong>时间复杂度是 O(n)</strong>（n 表示所有字符串的长度和）</p>
<p>每次查询时，如果要查询的字符串长度是 k，只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的<strong>时间复杂度是 O(k)</strong>，k 表示要查找的字符串的长度。</p>
</li>
<li><p>空间复杂度</p>
<p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组元素要存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>
<p><strong>在某些情况下，Trie 树不一定会节省存储空间。在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存。</strong></p>
</li>
</ol>
<h3 id="Trie-树与散列表、红黑树"><a href="#Trie-树与散列表、红黑树" class="headerlink" title="Trie 树与散列表、红黑树"></a>Trie 树与散列表、红黑树</h3><p>Trie 树对要处理的字符串有极其严苛的要求</p>
<ol>
<li>第一，字符串中包含的字符集不能太大。即便可以优化，但也要付出牺牲查询、插入效率的代价。</li>
<li>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</li>
<li>第三，如果要用 Trie 树解决问题，那就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</li>
<li>第四，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</li>
</ol>
<p>针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>数据结构与算法,树</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希算法</title>
    <url>/article/60365.html</url>
    <content><![CDATA[<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p><strong>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值</strong></p>
<p>优秀的哈希算法需要满足的几点要求：</p>
<ol>
<li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li>
<li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li>
<li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li>
<li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li>
</ol>
<h3 id="哈希算法的应用"><a href="#哈希算法的应用" class="headerlink" title="哈希算法的应用"></a>哈希算法的应用</h3><ol>
<li><p>应用一：安全加密</p>
<p>最常用于加密的哈希算法是 MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）、 SHA（Secure Hash Algorithm，安全散列算法）、DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。</p>
<p><strong>没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长</strong></p>
</li>
<li><p>应用二：唯一标识</p>
</li>
<li><p>应用三：数据校验</p>
</li>
<li><p>应用四：散列函数</p>
<p>散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。</p>
<p>散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p>
</li>
<li><p>应用五：负载均衡</p>
<p>负载均衡算法有很多，比如轮询、随机、加权轮询等。</p>
<blockquote>
<p>如何实现一个会话粘滞（session sticky）的负载均衡算法？</p>
<p>需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p>
<p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。</p>
<p>弊端：</p>
<ol>
<li>如果客户端很多，映射表可能会很大，比较浪费内存空间；</li>
<li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；</li>
</ol>
<p><strong>可以通过哈希算法</strong>，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</p>
</blockquote>
</li>
<li><p>应用六：数据分片</p>
<ol>
<li><blockquote>
<p>如何统计“搜索关键词”出现的次数？</p>
<p>假如我们有 <strong>1T</strong> 的日志文件，这里面记录了用户的搜索关键词，想要<strong>快速统计</strong>出每个关键词被搜索的次数，该怎么做呢？</p>
<p>可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。</p>
<p>具体思路：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p>
<p>哈希值相同的搜索关键词就被分配到了同一个机器上,每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p>
</blockquote>
</li>
<li><blockquote>
<p>如何快速判断图片是否在有1 亿张图片的图库中？</p>
<p>可以对数据进行分片，然后采用多机处理。</p>
<p>具体思路：准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</p>
<p>当要判断一个图片是否在图库中的时候，通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>应用七：分布式存储</p>
<p>现在互联网面对的都是海量的数据、海量的用户。为了提高数据的读取、写入能力，一般都采用<strong>分布式的方式来存储数据</strong>，比如分布式缓存。</p>
<p>该如何决定将哪个数据放到哪个机器上呢？可以借用数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。</p>
<blockquote>
<p>如果数据增多，原来的 10 个机器已经无法承受了，就需要扩容，比如扩到 11 个机器，<strong>但这里并不是简单地加个机器就可以了</strong>。</p>
<p>所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生雪崩效应，压垮数据库。</p>
</blockquote>
<p><strong><a href="https://www.zsythink.net/archives/1182">一致性哈希算法</a></strong>：假设有 k 个机器，数据的哈希值的范围是[0, MAX]。将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>哈希算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法,哈希算法</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/article/31130.html</url>
    <content><![CDATA[<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p><strong>散列表(Hash Table)，也叫“哈希表”或者“Hash 表”</strong></p>
<p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p>
<p>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成 <strong>hash(key)</strong>，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p>
<p><strong>散列函数设计的基本要求：</strong></p>
<ol>
<li>散列函数计算得到的散列值是一个非负整数；</li>
<li>如果 key1 = key2，那 hash(key1) == hash(key2)；</li>
<li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。</li>
</ol>
<h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p><strong>再好的散列函数也无法避免散列冲突</strong></p>
<ol>
<li><p>开放寻址法</p>
<p>开放寻址法的<strong>核心思想</strong>是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。</p>
<ol>
<li><p>线性探测（Linear Probing）</p>
<p><strong>插入数据</strong><br>往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<blockquote>
<img src="/article/31130/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.jpg" class title="线性探测插入数据">
<p>散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。</p>
<p>于是顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p>
</blockquote>
<p><strong>查找数据</strong></p>
<p>在散列表中查找元素的过程有点儿类似插入过程。</p>
<p>通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p>
<blockquote>
<img src="/article/31130/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE.jpg" class title="线性探测查找数据">
</blockquote>
<p><strong>删除数据</strong></p>
<p>删除数据时，不能单纯地把要删除的元素设置为空</p>
<blockquote>
<p>因为在查找的时候，一旦通过线性探测方法，找到一个空闲位置，就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。</p>
</blockquote>
<p>将删除的元素，<strong>特殊标记为 deleted</strong>。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>
</li>
</ol>
</li>
</ol>
<pre><code>**线性探测问题：**当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。
</code></pre><ol start="2">
<li><p>二次探测（Quadratic probing）</p>
<p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+1<sup>2</sup>，hash(key)+2<sup>2</sup>……</p>
</li>
<li><p>双重散列（Double hashing）</p>
<p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
</li>
</ol>
<p>   不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会<strong>尽可能保证散列表中有一定比例的空闲槽位</strong>。我们用<strong>装载因子（load factor）</strong>来表示空位的多少。</p>
<p>   <strong>散列表的装载因子=填入表中的元素个数/散列表的长度</strong></p>
<p>   装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<ol start="2">
<li><p>链表法</p>
<p>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<blockquote>
<img src="/article/31130/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg" class title="链表法">
</blockquote>
<p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。</p>
<p>当查找、删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。</p>
<p>时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p>
</li>
</ol>
<h3 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h3><ol>
<li><p>开放寻址法</p>
<p><strong>优点：</strong>开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。</li>
<li>而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</li>
</ol>
<p><strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。</strong></p>
</li>
<li><p>链表法</p>
<p><strong>优点：</strong></p>
<ol>
<li>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</li>
<li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。</li>
<li>因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</li>
</ol>
<p><strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></p>
</li>
</ol>
<h3 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h3><ol>
<li><p>散列函数的设计不能太复杂</p>
<p>过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能</p>
</li>
<li><p>散列函数生成的值要尽可能随机并且均匀分布</p>
<p>这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况</p>
</li>
</ol>
<h3 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h3><p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p>
<p>针对散列表，当装载因子过大时，可以进行<strong>动态扩容</strong>，重新申请一个更大的散列表，将数据搬移到这个新散列表中。</p>
<p>针对散列表的扩容，因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置。</p>
<p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol>
<li><p><strong>插入数据时间复杂度</strong></p>
<p><strong>最好时间复杂度：</strong>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。</p>
<p><strong>最坏时间复杂度：</strong>最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。</p>
<p><strong>摊还时间复杂度：</strong>用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p>
</li>
<li><p><strong>删除数据时间复杂度</strong></p>
<p>删除数据时间复杂度为O(1)。</p>
<p>对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。</p>
</li>
</ol>
<h3 id="如何避免低效的扩容？"><a href="#如何避免低效的扩容？" class="headerlink" title="如何避免低效的扩容？"></a>如何避免低效的扩容？</h3><p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p>
<p>当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。</p>
<p>经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p>
<p>对于查询操作，为了兼容了新、老散列表中的数据，先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p>
<p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。<strong>这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。</strong></p>
<h3 id="工业级散列表举例分析（Java-HashMap）"><a href="#工业级散列表举例分析（Java-HashMap）" class="headerlink" title="工业级散列表举例分析（Java HashMap）"></a>工业级散列表举例分析（Java HashMap）</h3><ol>
<li><p>初始大小</p>
<p>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p>
</li>
<li><p>装载因子和动态扩容</p>
<p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p>
</li>
<li><p>散列冲突解决方法</p>
<p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p>
<p>在 JDK1.8 版本中，为了对 HashMap 做进一步优化，<strong>引入了红黑树</strong>。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。但不是所有的链表长度为8后都会转成树，还需要判断存放key值的数组桶长度是否小于64。如果小于则需要扩容，扩容后链表上的数据会被拆分散列的相应的桶节点上，也就把链表长度缩短了。</p>
<p>可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p>
</li>
<li><p>散列函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> h = key.hashCode()；<br>  <span class="hljs-keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)) &amp; (capicity -<span class="hljs-number">1</span>); <span class="hljs-comment">//capicity表示散列表的大小</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> var1 = <span class="hljs-keyword">this</span>.hash;<br>  <span class="hljs-keyword">if</span>(var1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.value.length &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">char</span>[] var2 = <span class="hljs-keyword">this</span>.value;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var3 = <span class="hljs-number">0</span>; var3 &lt; <span class="hljs-keyword">this</span>.value.length; ++var3) &#123;<br>      var1 = <span class="hljs-number">31</span> * var1 + var2[var3];<br>    &#125;<br>    <span class="hljs-keyword">this</span>.hash = var1;<br>  &#125;<br>  <span class="hljs-keyword">return</span> var1;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<blockquote>
<p><strong>问题：如何设计一个工业级的散列函数？</strong></p>
<blockquote>
<p>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？</p>
<ol>
<li>支持快速地查询、插入、删除操作；</li>
<li>内存占用合理，不能浪费过多的内存空间；</li>
<li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</li>
</ol>
</blockquote>
<p>设计思路：</p>
<ol>
<li>设计一个合适的散列函数；</li>
<li>定义装载因子阈值，并且设计动态扩容策略；</li>
<li>选择合适的散列冲突解决方法。</li>
</ol>
</blockquote>
<h3 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h3><p><strong>借助散列表，可以把 LRU 缓存淘汰算法的时间复杂度降低为 O(1)</strong></p>
<blockquote>
<p>如何通过链表实现 LRU 缓存淘汰算法?</p>
<p>需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，直接将链表头部的结点删除。</p>
<p>当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。</p>
</blockquote>
<p>一个缓存（cache）系统主要包含下面这几个操作：</p>
<ol>
<li>往缓存中添加一个数据；</li>
<li>从缓存中删除一个数据；</li>
<li>在缓存中查找一个数据。</li>
</ol>
<blockquote>
<p>单纯地采用链表的话，时间复杂度只能是 O(n)</p>
<p>将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 <strong>O(1)</strong></p>
</blockquote>
<img src="/article/31130/%E6%95%A3%E5%88%97%E8%A1%A8%E9%93%BE%E8%A1%A8URL.jpg" class title="散列表链表URL">
<p>使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext</p>
<p>散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是双向链表，另一个链是散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。</p>
<p><strong>如何查找一个数据：</strong>散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，可以很快地在缓存中找到一个数据。当找到数据之后，还需要将它移动到双向链表的尾部。</p>
<p><strong>如何删除一个数据：</strong>需要找到数据所在的结点，然后将结点删除。借助散列表，可以在 O(1) 时间复杂度里找到要删除的结点。因为链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。</p>
<p><strong>如何添加一个数据：</strong>需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>散列表</category>
      </categories>
      <tags>
        <tag>数据结构与算法,散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表</title>
    <url>/article/44093.html</url>
    <content><![CDATA[<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><blockquote>
<p>假设每两个节点建立一个索引</p>
</blockquote>
<p>对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫做<strong>跳表（Skip list）</strong></p>
<p><strong>Redis 中的有序集合（Sorted Set）就是用跳表来实现的。</strong></p>
<h3 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h3><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p>
<p><strong>初级优化</strong></p>
<p>像图中那样，对链表建立一级“索引”，每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做<strong>索引或索引层</strong>。down 表示 down 指针，指向下一级结点。</p>
<img src="/article/44093/%E9%93%BE%E8%A1%A8+%E7%B4%A2%E5%BC%95.jpg" class title="链表+索引">
<p>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了</p>
<p><strong>再次优化</strong></p>
<p>跟前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。</p>
<img src="/article/44093/%E9%93%BE%E8%A1%A8+%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.jpg" class title="链表+二级索引">
<p><strong>这种链表加多级索引的结构，就是跳表</strong></p>
<h3 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h3><p>如果链表里有 n 个结点，会有多少级索引呢？</p>
<p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，<strong>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2<sup>k</sup>)。</strong></p>
<p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，可以得到 n/(2<sup>h</sup>)=2，从而求得 h=log<sub>2</sub>n-1。如果包含原始链表这一层，整个跳表的高度就是 log<sub>2</sub>n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p>
<p>m 的值是多少呢？</p>
<p>按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m=3。</p>
<blockquote>
<p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p>
<img src="/article/44093/%E6%AF%8F%E5%B1%82%E6%9C%80%E5%A4%9A3%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86.jpg" class title="每层最多3节点遍历">
</blockquote>
<p><strong>在跳表中查询任意数据的时间复杂度就是 O(logn)</strong></p>
<h3 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h3><p>假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。</p>
<img src="/article/44093/%E8%B7%B3%E8%A1%A8%E6%AF%8F%E5%B1%82%E8%8A%82%E7%82%B9%E6%95%B0.jpg" class title="跳表每层节点数">
<p>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2</p>
<p>所以，<strong>跳表的空间复杂度是 O(n)</strong></p>
<h3 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h3><p><strong>插入、删除操作的时间复杂度是 O(logn)</strong></p>
<img src="/article/44093/%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.jpg" class title="插入操作">
<h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当我们不停地往跳表中插入数据时，如果不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>
<p><strong>跳表是通过随机函数来维护前面提到的“平衡性”</strong></p>
<blockquote>
<p>当往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？</p>
</blockquote>
<p>通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<img src="/article/44093/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95.jpg" class title="随机函数更新索引">
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> skiplist;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跳表的一种实现方法。</span><br><span class="hljs-comment"> * 跳表中存储的是正整数，并且存储的是不重复的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> SKIPLIST_P = <span class="hljs-number">0.5f</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_LEVEL = <span class="hljs-number">16</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> levelCount = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">private</span> Node head = <span class="hljs-keyword">new</span> Node();  <span class="hljs-comment">// 带头链表</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    Node p = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = levelCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">while</span> (p.forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;<br>        p = p.forwards[i];<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p.forwards[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[<span class="hljs-number">0</span>].data == value) &#123;<br>      <span class="hljs-keyword">return</span> p.forwards[<span class="hljs-number">0</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> level = randomLevel();<br>    Node newNode = <span class="hljs-keyword">new</span> Node();<br>    newNode.data = value;<br>    newNode.maxLevel = level;<br>    Node update[] = <span class="hljs-keyword">new</span> Node[level];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; ++i) &#123;<br>      update[i] = head;<br>    &#125;<br><br>    <span class="hljs-comment">// record every level largest value which smaller than insert value in update[]</span><br>    Node p = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">while</span> (p.forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;<br>        p = p.forwards[i];<br>      &#125;<br>      update[i] = p;<span class="hljs-comment">// use update save node in search path</span><br>    &#125;<br><br>    <span class="hljs-comment">// in search path node next node become new node forwords(next)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; ++i) &#123;<br>      newNode.forwards[i] = update[i].forwards[i];<br>      update[i].forwards[i] = newNode;<br>    &#125;<br><br>    <span class="hljs-comment">// update node hight</span><br>    <span class="hljs-keyword">if</span> (levelCount &lt; level) levelCount = level;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    Node[] update = <span class="hljs-keyword">new</span> Node[levelCount];<br>    Node p = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = levelCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">while</span> (p.forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;<br>        p = p.forwards[i];<br>      &#125;<br>      update[i] = p;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p.forwards[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[<span class="hljs-number">0</span>].data == value) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = levelCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">if</span> (update[i].forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; update[i].forwards[i].data == value) &#123;<br>          update[i].forwards[i] = update[i].forwards[i].forwards[i];<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (levelCount&gt;<span class="hljs-number">1</span>&amp;&amp;head.forwards[levelCount]==<span class="hljs-keyword">null</span>)&#123;<br>      levelCount--;<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-comment">// 理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最顶层。</span><br>  <span class="hljs-comment">// 因为这里每一层的晋升概率是 50%。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的层数。</span><br>  <span class="hljs-comment">// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：</span><br>  <span class="hljs-comment">//        50%的概率返回 1</span><br>  <span class="hljs-comment">//        25%的概率返回 2</span><br>  <span class="hljs-comment">//      12.5%的概率返回 3 ...</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL)<br>      level += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> level;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">()</span> </span>&#123;<br>    Node p = head;<br>    <span class="hljs-keyword">while</span> (p.forwards[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span>) &#123;<br>      System.out.print(p.forwards[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; &quot;</span>);<br>      p = p.forwards[<span class="hljs-number">0</span>];<br>    &#125;<br>    System.out.println();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> Node forwards[] = <span class="hljs-keyword">new</span> Node[MAX_LEVEL];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxLevel = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>      builder.append(<span class="hljs-string">&quot;&#123; data: &quot;</span>);<br>      builder.append(data);<br>      builder.append(<span class="hljs-string">&quot;; levels: &quot;</span>);<br>      builder.append(maxLevel);<br>      builder.append(<span class="hljs-string">&quot; &#125;&quot;</span>);<br><br>      <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>跳表</category>
      </categories>
      <tags>
        <tag>数据结构与算法,跳表</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/article/42877.html</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找（Binary Search）算法，也叫折半查找算法</p>
<p>二分查找针对的是一个<strong>有序的数据集合</strong>，查找思想有点<strong>类似分治思想</strong>。<strong>每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</strong></p>
<h3 id="时间复杂度：O-logn"><a href="#时间复杂度：O-logn" class="headerlink" title="时间复杂度：O(logn)"></a>时间复杂度：O(logn)</h3><blockquote>
<p>假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。</p>
<img src="/article/42877/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E5%8F%98%E5%8C%96.jpg" class title="二分查找区间变化">
<p>其中 n/2k=1 时，k 的值就是总共缩小的次数。</p>
<p>而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。</p>
<p>通过 n/2<sup>k</sup>=1，我们可以求得 k=log<sub>2</sub>n，所以<strong>时间复杂度就是 O(logn)</strong>。</p>
</blockquote>
<p>指数时间复杂度的算法在大规模数据面前是无效的</p>
<h3 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h3><p><strong>非递归实现</strong></p>
<blockquote>
<p>有序数组中不存在重复元素，用二分查找值等于给定值的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>      <span class="hljs-comment">//int mid = (low + high) / 2;</span><br>      <span class="hljs-keyword">int</span> mid = low+(high-low)/<span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (a[mid] == value) &#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;<br>        low = mid + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        high = mid - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>注意：</strong></p>
<ol>
<li><p>注意是 low&lt;=high，而不是 &lt;</p>
</li>
<li><p><strong>mid=(low+high)/2 这种写法是有问题的</strong>。</p>
<p>因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。</p>
<p><strong>改进的方法是将 mid 的计算方式写成 low+(high-low)/2。</strong>更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 <strong>low+((high-low)&gt;&gt;1)</strong>。因为相比除法运算来说，计算机处理位运算要快得多。</p>
</li>
<li><p>low 和 high 的更新</p>
<p>low=mid+1，high=mid-1</p>
</li>
</ol>
<p><strong>递归实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二分查找的递归实现</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> bsearchInternally(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearchInternally</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (low &gt; high) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (a[mid] == value) &#123;<br>    <span class="hljs-keyword">return</span> mid;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;<br>    <span class="hljs-keyword">return</span> bsearchInternally(a, mid+<span class="hljs-number">1</span>, high, value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> bsearchInternally(a, low, mid-<span class="hljs-number">1</span>, value);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h3><ol>
<li><p>首先，二分查找依赖的是顺序表结构，简单点说就是数组。</p>
<p>二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。</p>
</li>
<li><p>其次，二分查找针对的是有序数据。</p>
<p>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中</p>
</li>
<li><p>再次，数据量太小不适合二分查找。</p>
<p><strong>例外：</strong>如果数据之间的比较操作非常耗时，不管数据量大小，推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p>
</li>
<li><p>最后，数据量太大也不适合二分查找。</p>
</li>
</ol>
<h3 id="二分查找变形问题"><a href="#二分查找变形问题" class="headerlink" title="二分查找变形问题"></a>二分查找变形问题</h3><h4 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h4><p><strong>问题：有序数据集合中存在重复的数据，希望找到第一个值等于给定值的数据</strong></p>
<blockquote>
<p>下面这样一个有序数组，其中，a[5]，a[6]，a[7]的值都等于 8，是重复的数据。希望查找第一个等于 8 的数据，也就是下标是 5 的元素。</p>
<img src="/article/42877/%E5%8F%98%E4%BD%93%E4%B8%80.jpg" class title="变体一">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//写法一：</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt;= value) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (low &lt; n &amp;&amp; a[low]==value) <span class="hljs-keyword">return</span> low;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//写法二：</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || (a[mid - <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;<br>      <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h4><p><strong>问题：有序数据集合中存在重复的数据，希望查找最后一个值等于给定值的元素</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> ((mid == n - <span class="hljs-number">1</span>) || (a[mid + <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;<br>      <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h4><p><strong>问题：在有序数组中，查找第一个大于等于给定值的元素</strong></p>
<blockquote>
<p>数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于 5 的元素，那就是 6。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt;= value) &#123;<br>      <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || (a[mid - <span class="hljs-number">1</span>] &lt; value)) <span class="hljs-keyword">return</span> mid;<br>      <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h4><p><strong>问题：查找最后一个小于等于给定值的元素</strong></p>
<blockquote>
<p>数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于 7 的元素就是 6</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch7</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> ((mid == n - <span class="hljs-number">1</span>) || (a[mid + <span class="hljs-number">1</span>] &gt; value)) <span class="hljs-keyword">return</span> mid;<br>      <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="LeetCode实战经验"><a href="#LeetCode实战经验" class="headerlink" title="LeetCode实战经验"></a>LeetCode实战经验</h3><ol>
<li><p>target 是在一个在左闭右闭的区间，<strong>[left, right]</strong> </p>
<p>left = 0;<br>right = nums.length - 1;</p>
<p>二分细节</p>
<blockquote>
<p>循环体：<strong>当left==right，区间[left, right]依然有效，所以用 &lt;=</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (left &lt;= right)&#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>target 在左区间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">right = middle - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>target 在右区间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">left = middle + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>target 是在一个在左闭右开的区间里，<strong>[left, right)</strong> </p>
<p>left = 0;<br>right = nums.length;</p>
<p>二分细节</p>
<blockquote>
<p>循环体：<strong>因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (left &lt; right)&#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>target 在左区间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">right = middle;<br></code></pre></td></tr></table></figure>
<p>target 在右区间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">left = middle + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<h3 id="Leetcode实战"><a href="#Leetcode实战" class="headerlink" title="Leetcode实战"></a>Leetcode实战</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<ol>
<li><p>先找到位置，遍历左右</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span> || nums[<span class="hljs-number">0</span>] &gt; target || nums[len-<span class="hljs-number">1</span>] &lt; target)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <span class="hljs-keyword">int</span> result = -<span class="hljs-number">1</span>;<br>    result =  binarySearch(nums,target);<br>    <span class="hljs-keyword">if</span>(result != -<span class="hljs-number">1</span>)&#123;<br>      <span class="hljs-keyword">int</span> left = result;<br>      <span class="hljs-keyword">int</span> right = result;<br>      <span class="hljs-keyword">while</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[left-<span class="hljs-number">1</span>] == target )&#123;<br>        left--;<br>      &#125;<br>      <span class="hljs-keyword">while</span>(right + <span class="hljs-number">1</span> &lt; len &amp;&amp; nums[right+<span class="hljs-number">1</span>] == target )&#123;<br>        right++;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left,right&#125;;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>      <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>        right = mid;<br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>        left = mid + <span class="hljs-number">1</span>;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>直接找到左右边界</p>
<ol>
<li><p>寻找右边界（不包括target）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRightBorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> rightBorder = -<span class="hljs-number">2</span>; <span class="hljs-comment">// 记录一下rightBorder没有被赋值的情况</span><br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 寻找右边界，nums[middle] == target的时候更新left</span><br>      left = middle + <span class="hljs-number">1</span>;<br>      rightBorder = left;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> rightBorder;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>寻找左边界（不包括target）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLeftBorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> leftBorder = -<span class="hljs-number">2</span>; <span class="hljs-comment">// 记录一下leftBorder没有被赋值的情况</span><br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] &gt;= target) &#123; <span class="hljs-comment">// 寻找左边界，nums[middle] == target的时候更新right</span><br>      right = middle - <span class="hljs-number">1</span>;<br>      leftBorder = right;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      left = middle + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> leftBorder;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>主函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>  <span class="hljs-keyword">int</span> leftBorder = getLeftBorder(nums, target);<br>  <span class="hljs-keyword">int</span> rightBorder = getRightBorder(nums, target);<br>  <span class="hljs-keyword">if</span> (leftBorder == -<span class="hljs-number">2</span> || rightBorder == -<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-keyword">if</span> (rightBorder - leftBorder &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;leftBorder + <span class="hljs-number">1</span>, rightBorder - <span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span> || nums == <span class="hljs-keyword">null</span>)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>      <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>        right = mid;<br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>        left = mid + <span class="hljs-number">1</span>;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 分别处理如下四种情况</span><br>    <span class="hljs-comment">// 目标值在数组所有元素之前 [0,0)</span><br>    <span class="hljs-comment">// 目标值等于数组中某一个元素 return middle</span><br>    <span class="hljs-comment">// 目标值插入数组中的位置 [left, right) ，return right 即可</span><br>    <span class="hljs-comment">// 目标值在数组所有元素之后的情况 [left, right)，因为是右开区间，所以 return right</span><br>    <span class="hljs-keyword">return</span> right;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>数据结构与算法,二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql45讲-实践（四）</title>
    <url>/article/17540.html</url>
    <content><![CDATA[<h2 id="自增主键为什么不是连续的？"><a href="#自增主键为什么不是连续的？" class="headerlink" title="自增主键为什么不是连续的？"></a>自增主键为什么不是连续的？</h2><p>自增主键，由于自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。</p>
<p><strong>自增主键不能保证连续递增</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `c` int(11) DEFAULT NULL,<br>  `d` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  UNIQUE KEY `c` (`c`)<br>) ENGINE=InnoDB;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="自增值保存在哪儿？"><a href="#自增值保存在哪儿？" class="headerlink" title="自增值保存在哪儿？"></a>自增值保存在哪儿？</h3><blockquote>
<p>在这个空表 t 里面执行 insert into t values(null, 1, 1); 插入一行数据，再执行 show create table 命令，就可以看到如下图所示的结果：</p>
<p><img src="/article/自动生成的 AUTO_INCREMENT 值.png"><span class="image-caption">自动生成的 AUTO_INCREMENT 值</span></p>
<p>表定义里面出现了一个 AUTO_INCREMENT=2，表示下一次插入数据时，如果需要自动生成自增值，会生成 id=2。</p>
<p>其实，这个输出结果容易引起这样的误解：自增值是保存在表结构定义里的。</p>
</blockquote>
<p><strong>表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。</strong></p>
<p>不同的引擎对于自增值的保存策略不同：</p>
<ol>
<li><p>MyISAM 引擎的自增值保存在数据文件中。</p>
</li>
<li><p>InnoDB 引擎的自增值，其实是保存在了内存里，并且到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为 MySQL 重启前的值”，具体情况是：</p>
<ol>
<li><p>在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。</p>
<p>﻿举例来说，如果一个表当前数据行里最大的 id 是 10，AUTO_INCREMENT=11。这时候，我们删除 id=10 的行，AUTO_INCREMENT 还是 11。但如果马上重启实例，重启后这个表的 AUTO_INCREMENT 就会变成 10。</p>
<p>   ﻿也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。</p>
</li>
<li><p>在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。</p>
</li>
</ol>
</li>
</ol>
<h3 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h3><p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p>
<ol>
<li><p>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</p>
</li>
<li><p>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</p>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。</p>
<p>假设，某次要插入的值是 X，当前的自增值是 Y。</p>
<ol>
<li>如果 X&lt;Y，那么这个表的自增值不变；</li>
<li>如果 X≥Y，就需要把当前自增值修改为新的自增值。</li>
</ol>
</li>
</ol>
<p><strong>新的自增值生成算法</strong>是：从 <code>auto_increment_offset</code> 开始，以 <code>auto_increment_increment</code> 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。</p>
<p>其中，<code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 是两个系统参数，分别用来表示自增的初始值和步长，默认值都是 1。</p>
<h3 id="自增值的修改时机"><a href="#自增值的修改时机" class="headerlink" title="自增值的修改时机"></a>自增值的修改时机</h3><p><strong>导致自增主键 id 不连续的原因</strong></p>
<ol>
<li>唯一键冲突</li>
<li>事务回滚</li>
<li>批量插入数据</li>
</ol>
<p><strong>自增值为什么不能回退：为了提升性能</strong></p>
<blockquote>
<p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请。</p>
<ol>
<li>假设事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。</li>
<li>事务 B 正确提交了，但事务 A 出现了唯一键冲突。</li>
<li>如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2。</li>
<li>接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。</li>
</ol>
<p>解决这个主键冲突，有两种方法：</p>
<ol>
<li>每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。</li>
<li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li>
</ol>
<p>这两个方法都会导致性能问题</p>
</blockquote>
<h3 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h3><p>自增 id 锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。</p>
<ol>
<li><p>MySQL 5.0 版本</p>
<p>自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。</p>
</li>
<li><p>MySQL 5.1.22 版本</p>
<p>新增参数 <code>innodb_autoinc_lock_mode</code>，默认值是 1</p>
<ol>
<li>这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁；</li>
<li>这个参数的值被设置为 1 时：<ol>
<li>普通 <code>insert</code> 语句，自增锁在申请之后就马上释放；</li>
<li>类似 <code>insert … select</code> 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ol>
</li>
<li>这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁。</li>
</ol>
</li>
</ol>
<p>在生产上，尤其是有 <code>insert … select</code> 这种批量插入数据(<code>insert … select</code>、<code>replace … select</code> 和 <code>load data</code> 语句)的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：<code>innodb_autoinc_lock_mode=2</code> ，并且 <code>binlog_format=row</code>. 这样做，既能提升并发性，又不会出现数据一致性问题。</p>
<p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p>
<ol>
<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>
<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>
<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>
<li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>
</ol>
<hr>
<blockquote>
<p><strong>问题：在 binlog_format=statement 时，语句 A 先获取 id=1，然后语句 B 获取 id=2；接着语句 B 提交，写 binlog，然后语句 A 再写 binlog。这时候，如果 binlog 重放，是不是会发生语句 B 的 id 为 1，而语句 A 的 id 为 2 的不一致情况呢？</strong></p>
<p>自增 id 的生成顺序，和 binlog 的写入顺序可能是不同的</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table t(id int auto_increment primary key);<br>insert into t values(null);<br></code></pre></td></tr></table></figure>
<p><img src="/article/insert 语句的 binlog.jpg"><span class="image-caption">insert 语句的 binlog</span></p>
<p>可以看到，在 insert 语句之前，还有一句 SET INSERT_ID=1。这条命令的意思是，这个线程里下一次需要用到自增值的时候，不论当前表的自增值是多少，固定用 1 这个值。</p>
<p>这个 SET INSERT_ID 语句是固定跟在 insert 语句之前的,主库上语句 A 的 id 是 1，语句 B 的 id 是 2，但是写入 binlog 的顺序先 B 后 A，那么 binlog 就变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET INSERT_ID=2;<br>语句B；<br>SET INSERT_ID=1;<br>语句A；<br></code></pre></td></tr></table></figure>
<p>在备库上语句 B 用到的 INSERT_ID 依然是 2，跟主库相同</p>
</blockquote>
<p><strong>因此，即使两个 INSERT 语句在主备库的执行顺序不同，自增主键字段的值也不会不一致。</strong></p>
</blockquote>
<hr>
<h2 id="insert语句的锁为什么这么多？"><a href="#insert语句的锁为什么这么多？" class="headerlink" title="insert语句的锁为什么这么多？"></a>insert语句的锁为什么这么多？</h2><h3 id="insert-…-select-语句"><a href="#insert-…-select-语句" class="headerlink" title="insert … select 语句"></a>insert … select 语句</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `c` int(11) DEFAULT NULL,<br>  `d` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  UNIQUE KEY `c` (`c`)<br>) ENGINE=InnoDB;<br><br>insert into t values(null, 1,1);<br>insert into t values(null, 2,2);<br>insert into t values(null, 3,3);<br>insert into t values(null, 4,4);<br><br>create table t2 like t<br></code></pre></td></tr></table></figure>
<p>在可重复读隔离级别下，binlog_format=statement 时执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">insert into t2(c,d) select c,d from t;<br></code></pre></td></tr></table></figure>
<p>需要对表 t 的所有行和间隙加锁。</p>
<p>执行序列：</p>
<p><img src="/article/并发 insert 场景.png"><span class="image-caption">并发 insert 场景</span></p>
<p>实际的执行效果是，如果 session B 先执行，由于这个语句对表 t 主键索引加了 (-∞,1]这个 next-key lock，会在语句执行完成后，才允许 session A 的 insert 语句执行。</p>
<p>但如果没有锁的话，就可能出现 session B 的 insert 语句先执行，但是后写入 binlog 的情况。于是，在 binlog_format=statement 的情况下，binlog 里面就记录了这样的语句序列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">insert into t values(-1,-1,-1);<br>insert into t2(c,d) select c,d from t;<br></code></pre></td></tr></table></figure>
<p>这个语句到了备库执行，就会把 id=-1 这一行也写到表 t2 中，出现主备不一致。</p>
</blockquote>
<p>执行 <code>insert … select</code> 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。</p>
<h3 id="insert-循环写入"><a href="#insert-循环写入" class="headerlink" title="insert 循环写入"></a>insert 循环写入</h3><blockquote>
<p>要往表 t2 中插入一行数据，这一行的 c 值是表 t 中 c 值的最大值加 1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">insert into t2(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);<br></code></pre></td></tr></table></figure>
<p>这个语句的加锁范围，就是表 t 索引 c 上的 (3,4]和 (4,supremum]这两个 next-key lock，以及主键索引上 id=4 这一行。</p>
<p>执行流程:从表 t 中按照索引 c 倒序，扫描第一行，拿到结果写入到表 t2 中。</p>
<p>整条语句的扫描行数是 1。</p>
</blockquote>
<blockquote>
<p>把这样的一行数据插入到表 t 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">insert into t(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);<br></code></pre></td></tr></table></figure>
<p>慢查询日志:</p>
<p><img src="/article/慢查询日志 -- 将数据插入表 t.png"><span class="image-caption">慢查询日志 -- 将数据插入表 t</span></p>
<p>Rows_examined 的值是 5</p>
<p>explain 结果:</p>
<p><img src="/article/explain 结果.png"><span class="image-caption">explain 结果.png</span></p>
<p>从 Extra 字段可以看到“Using temporary”字样，表示这个语句用到了临时表。执行过程中，需要把表 t 的内容读出来，写入临时表。</p>
<p>在执行这个语句前后查看 Innodb_rows_read 的结果:</p>
<p><img src="/article/查看 Innodb_rows_read 变化.png"><span class="image-caption">查看 Innodb_rows_read 变化</span></p>
<p>这个语句执行前后，Innodb_rows_read 的值增加了 4。因为默认临时表是使用 Memory 引擎的，所以这 4 行查的都是表 t，也就是说对表 t 做了全表扫描。</p>
<p>执行过程:</p>
<ol>
<li>创建临时表，表里有两个字段 c 和 d。</li>
<li>按照索引 c 扫描表 t，依次取 c=4、3、2、1，然后回表，读到 c 和 d 的值写入临时表。这时，Rows_examined=4。</li>
<li>由于语义里面有 limit 1，所以只取了临时表的第一行，再插入到表 t 中。这时，Rows_examined 的值加 1，变成了 5。</li>
</ol>
<p>这个语句会导致在表 t 上做全表扫描，并且会给索引 c 上的所有间隙都加上共享的 next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据。</p>
<p><strong>这个语句的执行为什么需要临时表?</strong></p>
<p>原因是这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。</p>
</blockquote>
<h3 id="insert-唯一键冲突"><a href="#insert-唯一键冲突" class="headerlink" title="insert 唯一键冲突"></a>insert 唯一键冲突</h3><blockquote>
<img src="/article/17540/%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81%E5%8A%A0%E9%94%81.png" class title="唯一键冲突加锁">
<p>在可重复读（repeatable read）隔离级别下执行</p>
<p>session B 要执行的 insert 语句进入了锁等待状态。</p>
<p>session A 执行的 insert 语句，发生唯一键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。</p>
<p>这时候，session A 持有索引 c 上的 (5,10]共享 next-key lock（读锁）。</p>
</blockquote>
<h3 id="insert-into-…-on-duplicate-key-update"><a href="#insert-into-…-on-duplicate-key-update" class="headerlink" title="insert into … on duplicate key update"></a>insert into … on duplicate key update</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">insert into t values(11,10,10) on duplicate key update d=100; <br></code></pre></td></tr></table></figure>
<p>会给索引 c 上 (5,10] 加一个排他的 next-key lock（写锁）</p>
</blockquote>
<p><code>insert into … on duplicate key update</code> 这个语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。</p>
<p>注意，如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行。</p>
<blockquote>
<p>现在表 t 里面已经有了 (1,1,1) 和 (2,2,2) 这两行</p>
<img src="/article/17540/%E4%B8%A4%E4%B8%AA%E5%94%AF%E4%B8%80%E9%94%AE%E5%90%8C%E6%97%B6%E5%86%B2%E7%AA%81.png" class title="两个唯一键同时冲突">
<p>主键 id 是先判断的，MySQL 认为这个语句跟 id=2 这一行冲突，所以修改的是 id=2 的行。</p>
<p>需要注意的是，执行这条语句的 affected rows 返回的是 2，很容易造成误解。实际上，真正更新的只有一行，只是在代码实现上，insert 和 update 都认为自己成功了，update 计数加了 1， insert 计数也加了 1。</p>
</blockquote>
<h2 id="怎么最快地复制一张表？"><a href="#怎么最快地复制一张表？" class="headerlink" title="怎么最快地复制一张表？"></a>怎么最快地复制一张表？</h2><ol>
<li>如果可以控制对源表的扫描行数和加锁范围很小的话，简单地使用 <code>insert … select</code>语句即可实现。</li>
<li>为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表。</li>
</ol>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create database db1;<br>use db1;<br><br>create table t(id int primary key, a int, b int, index(a))engine=innodb;<br>delimiter ;;<br>  create procedure idata()<br>  begin<br>    declare i int;<br>    set i=1;<br>    while(i&lt;=1000)do<br>      insert into t values(i,i,i);<br>      set i=i+1;<br>    end while;<br>  end;;<br>delimiter ;<br>call idata();<br><br>create database db2;<br>create table db2.t like db1.t<br></code></pre></td></tr></table></figure>
<p>先创建一个表 db1.t，并插入 1000 行数据，同时创建一个相同结构的表 db2.t</p>
</blockquote>
<h3 id="mysqldump-方法"><a href="#mysqldump-方法" class="headerlink" title="mysqldump 方法"></a>mysqldump 方法</h3><p>使用 mysqldump 命令将数据导出成一组 INSERT 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysqldump -h<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.982ex" height="2.343ex" style="vertical-align: -0.505ex;" viewbox="0 -791.3 3867.4 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">host -P</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="576" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="1062" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="1531" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="2115" y="0"/>
 <use xlink:href="#E1-MJMATHI-50" x="3115" y="0"/>
</g>
</svg>port -u$user --add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --result-file=/client_tmp/t.sql<br></code></pre></td></tr></table></figure>
<ol>
<li><code>–single-transaction</code> 的作用是，在导出数据的时候不需要对表 db1.t 加表锁，而是使用 <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code>(立即开启一个事务，否则事务是再执行到第一个sql语句的时候创建的) 的方法；</li>
<li><code>–add-locks</code> 设置为 0，表示在输出的文件结果里，不增加” <code>LOCK TABLES t WRITE;</code>“ ；</li>
<li><code>–no-create-info</code> 的意思是，不需要导出表结构；</li>
<li><code>–set-gtid-purged=off</code> 表示的是，不输出跟 GTID 相关的信息；</li>
<li><code>–result-file</code> 指定了输出文件的路径，其中 client 表示生成的文件是在客户端机器上的。</li>
</ol>
<blockquote>
<p>通过这条 mysqldump 命令生成的 t.sql 文件中就包含了如图所示的 INSERT 语句</p>
<p><img src="/article/mysqldump 输出文件的部分结果.png"><span class="image-caption">mysqldump 输出文件的部分结果</span></p>
<p>一条 INSERT 语句里面会包含多个 value 对，这是为了后续用这个文件来写入数据的时候，执行速度可以更快。</p>
<p>如果希望生成的文件中一条 INSERT 语句只插入一行数据的话，可以在执行 mysqldump 命令时，加上参数<code>–skip-extended-insert</code>。</p>
</blockquote>
<p>然后，可以通过下面这条命令，将这些 INSERT 语句放到 db2 库里去执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql -h127.0.0.1 -P13000  -uroot db2 -e &quot;source /client_tmp/t.sql&quot;<br></code></pre></td></tr></table></figure>
<p>source 并不是一条 SQL 语句，而是一个</p>
<p>客户端命令</p>
<p>mysql 客户端执行这个命令的流程是这样的：</p>
<ol>
<li>打开文件，默认以分号为结尾读取一条条的 SQL 语句；</li>
<li>将 SQL 语句发送到服务端执行。</li>
</ol>
<p>也就是说，服务端执行的并不是这个“<code>source t.sql</code>“语句，而是 <code>INSERT</code> 语句。所以，不论是在慢查询日志（slow log），还是在 binlog，记录的都是这些要被真正执行的 INSERT 语句。</p>
<h3 id="导出-CSV-文件"><a href="#导出-CSV-文件" class="headerlink" title="导出 CSV 文件"></a>导出 CSV 文件</h3><p>直接将结果导出成.csv 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from db1.t where a&gt;900 into outfile &#x27;/server_tmp/t.csv&#x27;;<br></code></pre></td></tr></table></figure>
<p>需要注意如下几点:</p>
<ol>
<li>这条语句会将结果保存在服务端。如果你执行命令的客户端和 MySQL 服务端不在同一个机器上，客户端机器的临时目录下是不会生成 t.csv 文件的。</li>
<li><code>into outfile</code> 指定了文件的生成位置（/server_tmp/），这个位置必须受参数 <code>secure_file_priv</code> 的限制。参数 <code>secure_file_priv</code> 的可选值和作用分别是：<ol>
<li>如果设置为 empty，表示不限制文件生成的位置，这是不安全的设置；</li>
<li>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li>
<li>如果设置为 NULL，就表示禁止在这个 MySQL 实例上执行 <code>select … into outfile</code> 操作。</li>
</ol>
</li>
<li>这条命令不会帮你覆盖文件，因此你需要确保 /server_tmp/t.csv 这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</li>
<li>这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。</li>
</ol>
<p>得到.csv 导出文件后，就可以用下面的 load data 命令将数据导入到目标表 db2.t 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">load data infile &#x27;/server_tmp/t.csv&#x27; into table db2.t;<br></code></pre></td></tr></table></figure>
<p>这条语句的执行流程如下所示:</p>
<ol>
<li>打开文件 /server_tmp/t.csv，以制表符 (\t) 作为字段间的分隔符，以换行符（\n）作为记录之间的分隔符，进行数据读取；</li>
<li>启动事务</li>
<li>判断每一行的字段数与表 db2.t 是否相同：<ol>
<li>若不相同，则直接报错，事务回滚；</li>
<li>若相同，则构造成一行，调用 InnoDB 引擎接口，写入到表中。</li>
</ol>
</li>
<li>重复步骤 3，直到 /server_tmp/t.csv 整个文件读入完成，提交事务。</li>
</ol>
<blockquote>
<p><strong>问题：如果 binlog_format=statement，这个 load 语句记录到 binlog 里以后，怎么在备库重放呢？</strong></p>
<p>由于 /server_tmp/t.csv 文件只保存在主库所在的主机上，如果只是把这条语句原文写到 binlog 中，在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。</p>
<p>所以，这条语句执行的完整流程，其实是下面这样的：</p>
<ol>
<li>主库执行完成后，将 /server_tmp/t.csv 文件的内容直接写到 binlog 文件中。</li>
<li>往 binlog 文件中写入语句 load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE `db2`.`t`。</li>
<li>把这个 binlog 日志传到备库。</li>
<li>备库的 apply 线程在执行这个事务日志时：<ol>
<li>先将 binlog 中 t.csv 文件的内容读出来，写入到本地临时目录 /tmp/SQL_LOAD_MB-1-0 中；</li>
<li>再执行 load data 语句，往备库的 db2.t 表中插入跟主库相同的数据。</li>
</ol>
</li>
</ol>
<p><img src="/article/load data 的同步流程.jpg"><span class="image-caption">load data 的同步流程</span></p>
<p>注意，这里备库执行的 load data 语句里面，多了一个“local”。它的意思是“将执行这条命令的客户端所在机器的本地文件 /tmp/SQL_LOAD_MB-1-0 的内容，加载到目标表 db2.t 中”。</p>
</blockquote>
<p>load data 命令有两种用法：</p>
<ol>
<li>不加“local”，是读取服务端的文件，这个文件必须在 secure_file_priv 指定的目录或子目录下；</li>
<li>加上“local”，读取的是客户端的文件，只要 mysql 客户端有访问这个文件的权限即可。这时候，MySQL 客户端会先把本地文件传给服务端，然后执行上述的 load data 流程</li>
</ol>
<p><code>select …into outfile</code> 方法<strong>不会生成表结构文件</strong>, 所以我们导数据时还需要单独的命令得到表结构定义。</p>
<p>mysqldump 提供了一个<code>–tab</code> 参数，可以同时导出表结构定义文件和 csv 数据文件。这条命令的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysqldump -h<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.982ex" height="2.343ex" style="vertical-align: -0.505ex;" viewbox="0 -791.3 3867.4 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">host -P</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="576" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="1062" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="1531" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="2115" y="0"/>
 <use xlink:href="#E1-MJMATHI-50" x="3115" y="0"/>
</g>
</svg>port -u<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="105.481ex" height="2.509ex" style="vertical-align: -0.671ex;" viewbox="0 -791.3 45415.1 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">user ---single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --tab=</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
<path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-67" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-6C" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMATHI-63" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/>
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
<path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/>
<path stroke-width="1" id="E1-MJMATHI-4F" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/>
<path stroke-width="1" id="E1-MJMATHI-46" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/>
<path stroke-width="1" id="E1-MJMATHI-62" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/>
<path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/>
<path stroke-width="1" id="E1-MJMATHI-77" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/>
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/>
<path stroke-width="1" id="E1-MJMAIN-3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/>
<path stroke-width="1" id="E1-MJMAIN-39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"/>
<path stroke-width="1" id="E1-MJMAIN-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-75" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="572" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="1042" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="1508" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="2182" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="3182" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="4183" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="5184" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="5653" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="5999" y="0"/>
 <use xlink:href="#E1-MJMATHI-67" x="6599" y="0"/>
 <use xlink:href="#E1-MJMATHI-6C" x="7080" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="7378" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="8067" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="9068" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="9429" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="9881" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="10410" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="11011" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="11480" y="0"/>
 <use xlink:href="#E1-MJMATHI-63" x="12010" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="12443" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="12805" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="13150" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="13636" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="14459" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="15459" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="16238" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="16707" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="17174" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="17758" y="0"/>
 <use xlink:href="#E1-MJMATHI-67" x="18758" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="19239" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="19600" y="0"/>
 <use xlink:href="#E1-MJMATHI-64" x="19946" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="20691" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="21692" y="0"/>
 <use xlink:href="#E1-MJMATHI-75" x="22196" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="22768" y="0"/>
 <use xlink:href="#E1-MJMATHI-67" x="23220" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="23700" y="0"/>
 <use xlink:href="#E1-MJMATHI-64" x="24167" y="0"/>
 <use xlink:href="#E1-MJMAIN-3D" x="24968" y="0"/>
 <use xlink:href="#E1-MJMATHI-4F" x="26024" y="0"/>
 <use xlink:href="#E1-MJMATHI-46" x="26788" y="0"/>
 <use xlink:href="#E1-MJMATHI-46" x="27537" y="0"/>
 <use xlink:href="#E1-MJMATHI-64" x="28287" y="0"/>
 <use xlink:href="#E1-MJMATHI-62" x="28810" y="0"/>
 <use xlink:href="#E1-MJMAIN-31" x="29240" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="29740" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="30324" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="31325" y="0"/>
 <use xlink:href="#E1-MJMATHI-77" x="32103" y="0"/>
 <use xlink:href="#E1-MJMATHI-68" x="32820" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="33396" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="33863" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="34314" y="0"/>
<g transform="translate(35058,0)">
 <use xlink:href="#E1-MJMAIN-3D"/>
 <use xlink:href="#E1-MJMAIN-22" x="778" y="0"/>
</g>
 <use xlink:href="#E1-MJMATHI-61" x="36615" y="0"/>
 <use xlink:href="#E1-MJMAIN-3E" x="37423" y="0"/>
<g transform="translate(38479,0)">
 <use xlink:href="#E1-MJMAIN-39"/>
 <use xlink:href="#E1-MJMAIN-30" x="500" y="0"/>
 <use xlink:href="#E1-MJMAIN-30" x="1001" y="0"/>
</g>
 <use xlink:href="#E1-MJMAIN-22" x="40258" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="41036" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="42037" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="43038" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="43399" y="0"/>
 <use xlink:href="#E1-MJMATHI-62" x="43929" y="0"/>
 <use xlink:href="#E1-MJMAIN-3D" x="44636" y="0"/>
</g>
</svg>secure_file_priv<br></code></pre></td></tr></table></figure>
<p>这条命令会在 <code>$secure_file_priv</code> 定义的目录下，创建一个 t.sql 文件保存建表语句，同时创建一个 t.txt 文件保存 CSV 数据。</p>
<h3 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h3><blockquote>
<p><strong>问题：直接把 db1.t 表的.frm 文件和.ibd 文件拷贝到 db2 目录下，是否可行呢？</strong></p>
<p>一个 InnoDB 表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有 db2.t 这个表，系统是不会识别和接受它们的。</p>
</blockquote>
<p>在 MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出 + 导入表空间的方式，实现物理拷贝表的功能。</p>
<blockquote>
<p>假设我们现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r，具体的执行步骤如下：</p>
<ol>
<li>执行 <code>create table r like t</code>，创建一个相同表结构的空表；</li>
<li>执行 <code>alter table r discard tablespace</code>，这时候 r.ibd 文件会被删除；</li>
<li>执行 <code>flush table t for export</code>，这时候 db1 目录下会生成一个 t.cfg 文件；</li>
<li>在 db1 目录下执行 <code>cp t.cfg r.cfg; cp t.ibd r.ibd；</code>这两个命令（这里需要注意的是，拷贝得到的两个文件，MySQL 进程要有读写权限）；</li>
<li>执行 <code>unlock tables</code>，这时候 t.cfg 文件会被删除；</li>
<li>执行 <code>alter table r import tablespace</code>，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</li>
</ol>
<img src="/article/17540/%E7%89%A9%E7%90%86%E6%8B%B7%E8%B4%9D%E8%A1%A8.jpg" class title="物理拷贝表">
<p><strong>注意点：</strong></p>
<ol>
<li>在第 3 步执行完 <code>flsuh table</code> 命令之后，db1.t 整个表处于只读状态，直到执行 <code>unlock tables</code> 命令后才释放读锁；</li>
<li>在执行 <code>import tablespace</code> 的时候，为了让文件里的表空间 id 和数据字典中的一致，会修改 r.ibd 的表空间 id。而这个表空间 id 存在于每一个数据页中。因此，如果是一个很大的文件（比如 TB 级别），每个数据页都需要修改，所以你会看到这个 import 语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import 语句的耗时是非常短的。</li>
</ol>
</blockquote>
<h3 id="三种方法的优缺点"><a href="#三种方法的优缺点" class="headerlink" title="三种方法的优缺点"></a>三种方法的优缺点</h3><ol>
<li>物理拷贝的方式速度最快，尤其对于大表拷贝来说是最快的方法。如果出现误删表的情况，用备份恢复出误删之前的临时库，然后再把临时库中的表拷贝到生产库上，是恢复数据最快的方法。但是，这种方法的使用也有一定的局限性：<ol>
<li>必须是全表拷贝，不能只拷贝部分数据；</li>
<li>需要到服务器上拷贝数据，在用户无法登录数据库主机的场景下无法使用；</li>
<li>由于是通过拷贝物理文件实现的，源表和目标表都是使用 InnoDB 引擎时才能使用。</li>
</ol>
</li>
<li>用 mysqldump 生成包含 INSERT 语句文件的方法，可以在 where 参数增加过滤条件，来实现只导出部分数据。这个方式的不足之一是，不能使用 join 这种比较复杂的 where 条件写法。</li>
<li>用 <code>select … into outfile</code> 的方法是最灵活的，支持所有的 SQL 写法。但，这个方法的缺点之一就是，每次只能导出一张表的数据，而且表结构也需要另外的语句单独备份。</li>
</ol>
<h2 id="grant之后要跟着flush-privileges吗？"><a href="#grant之后要跟着flush-privileges吗？" class="headerlink" title="grant之后要跟着flush privileges吗？"></a>grant之后要跟着flush privileges吗？</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create user &#x27;ua&#x27;@&#x27;%&#x27; identified by &#x27;pa&#x27;;<br></code></pre></td></tr></table></figure>
<p>这条语句的逻辑是创建一个用户’ua’@’%’，密码是 pa。注意，在 MySQL 里面，用户名 (user)+ 地址 (host) 才表示一个用户。</p>
<p>这条命令做了两个动作：</p>
<ol>
<li>磁盘上，往 mysql.user 表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是 N；</li>
<li>内存里，往数组 acl_users 里插入一个 acl_user 对象，这个对象的 access 字段值为 0。</li>
</ol>
<p>用户 ua 在 user 表中的状态</p>
<p><img src="/article/mysql.user 数据行.png"><span class="image-caption">mysql.user 数据行</span></p>
</blockquote>
<h3 id="全局权限"><a href="#全局权限" class="headerlink" title="全局权限"></a>全局权限</h3><p>全局权限，作用于整个 MySQL 实例，这些权限信息保存在 mysql 库的 user 表里。</p>
<blockquote>
<p>如果要给用户 ua 赋一个最高权限的话，语句是这么写的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">grant all privileges on *.* to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;<br></code></pre></td></tr></table></figure>
<p>这个 grant 命令做了两个动作：</p>
<ol>
<li>磁盘上，将 mysql.user 表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为‘Y’；</li>
<li>内存里，从数组 acl_users 中找到这个用户对应的对象，将 access 值（权限位）修改为二进制的“全 1”。</li>
</ol>
<p>在这个 grant 命令执行完成后，如果有新的客户端使用用户名 ua 登录成功，MySQL 会为新连接维护一个线程对象，然后从 acl_users 数组里查到这个用户的权限，并将权限值拷贝到这个线程对象中。之后在这个连接中执行的语句，所有关于全局权限的判断，都直接使用线程对象内部保存的权限位</p>
</blockquote>
<p>基于上面的分析我们可以知道：</p>
<ol>
<li>grant 命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的连接会使用新的权限。</li>
<li>对于一个已经存在的连接，它的全局权限不受 grant 命令的影响。</li>
</ol>
<blockquote>
<p>如果要回收上面的 grant 语句赋予的权限，可以使用下面这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">revoke all privileges on *.* from &#x27;ua&#x27;@&#x27;%&#x27;;<br></code></pre></td></tr></table></figure>
<p>这条 revoke 命令的用法与 grant 类似，做了如下两个动作：</p>
<ol>
<li>磁盘上，将 mysql.user 表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为“N”；</li>
<li>内存里，从数组 acl_users 中找到这个用户对应的对象，将 access 的值修改为 0。</li>
</ol>
</blockquote>
<h3 id="db-权限"><a href="#db-权限" class="headerlink" title="db 权限"></a>db 权限</h3><p>除了全局权限，MySQL 也支持库级别的权限定义。</p>
<blockquote>
<p>如果要让用户 ua 拥有库 db1 的所有权限，可以执行下面这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">grant all privileges on db1.* to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;<br></code></pre></td></tr></table></figure>
<p>基于库的权限记录保存在 mysql.db 表中，在内存里则保存在数组 acl_dbs 中。这条 grant 命令做了如下两个动作：</p>
<ol>
<li>磁盘上，往 mysql.db 表中插入了一行记录，所有权限位字段设置为“Y”；</li>
<li>内存里，增加一个对象到数组 acl_dbs 中，这个对象的权限位为“全 1”。</li>
</ol>
<p>这个时刻用户 ua 在 db 表中的状态:</p>
<p><img src="/article/mysql.db 数据行.png"><span class="image-caption">mysql.db 数据行</span></p>
<p>每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次 acl_dbs 数组，根据 user、host 和 db 找到匹配的对象，然后根据对象的权限位来判断。</p>
</blockquote>
<p>grant 修改 db 权限的时候，是同时对磁盘和内存生效的</p>
<p>对于全局权限，因为全局权限存储在线程对象中，所以修改用户的全局权限后，不会影响到已经存在的连接； </p>
<p>对于数据库权限，因为acl_dbs是一个全局数组，修改用户的数据库权限，acl_dbs也会立马随之修改，线程对象可以立刻读到，所以会直接影响到已经存在的连接。</p>
<h3 id="表权限和列权限"><a href="#表权限和列权限" class="headerlink" title="表权限和列权限"></a>表权限和列权限</h3><p>除了 db 级别的权限外，MySQL 支持更细粒度的表权限和列权限。</p>
<p>其中，表权限定义存放在表 mysql.tables_priv 中，列权限定义存放在表 mysql.columns_priv 中。</p>
<p>这两类权限，组合起来存放在内存的 hash 结构 column_priv_hash 中。</p>
<blockquote>
<p>这两类权限的赋权命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table db1.t1(id int, a int);<br><br>grant all privileges on db1.t1 to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;<br>GRANT SELECT(id), INSERT (id,a) ON mydb.mytbl TO &#x27;ua&#x27;@&#x27;%&#x27; with grant option;<br></code></pre></td></tr></table></figure>
<p>跟 db 权限类似，这两个权限每次 grant 的时候都会修改数据表，也会同步修改内存中的 hash 结构。因此，<strong>对这两类权限的操作，也会马上影响到已经存在的连接。</strong></p>
</blockquote>
<h3 id="flush-privileges-命令"><a href="#flush-privileges-命令" class="headerlink" title="flush privileges 命令"></a>flush privileges 命令</h3><p><code>flush privileges</code> 命令会清空 acl_users 数组，然后从 mysql.user 表中读取数据重新加载，重新构造一个 acl_users 数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一遍。</p>
<p>对于 db 权限、表权限和列权限，MySQL 也做了这样的处理</p>
<p>也就是说，如果内存的权限数据和磁盘数据表相同的话，不需要执行 flush privileges。而如果我们都是用 grant/revoke 语句来执行的话，内存和数据表本来就是保持同步更新的。<strong>因此，正常情况下，grant 命令之后，没有必要跟着执行 flush privileges 命令。</strong></p>
<h3 id="flush-privileges-使用场景"><a href="#flush-privileges-使用场景" class="headerlink" title="flush privileges 使用场景"></a>flush privileges 使用场景</h3><p>当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges 语句可以用来重建内存数据，达到一致状态。</p>
<blockquote>
<p>直接用 DML 语句操作系统权限表</p>
<p><img src="/article/使用 flush privileges.png"><span class="image-caption">使用 flush privileges</span></p>
<p>T3 时刻虽然已经用 delete 语句删除了用户 ua，但是在 T4 时刻，仍然可以用 ua 连接成功。原因就是，这时候内存中 acl_users 数组中还有这个用户，因此系统判断时认为用户还正常存在。</p>
<p>在 T5 时刻执行过 flush 命令后，内存更新，T6 时刻再要用 ua 来登录的话，就会报错“无法访问”了</p>
</blockquote>
<h2 id="要不要使用分区表？"><a href="#要不要使用分区表？" class="headerlink" title="要不要使用分区表？"></a>要不要使用分区表？</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t` (<br>  `ftime` datetime NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  KEY (`ftime`)<br>) ENGINE=InnoDB DEFAULT CHARSET=latin1<br>PARTITION BY RANGE (YEAR(ftime))<br>(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,<br> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,<br> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,<br>PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);<br>insert into t values(&#x27;2017-4-1&#x27;,1),(&#x27;2018-4-1&#x27;,1);<br></code></pre></td></tr></table></figure>
<p><img src="/article/表 t 的磁盘文件.png"><span class="image-caption">表 t 的磁盘文件</span></p>
<p>在表 t 中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在 p_2018 和 p_2019 这两个分区上。</p>
<p>这个表包含了一个.frm 文件和 4 个.ibd 文件，每个分区对应一个.ibd 文件。也就是说：</p>
<ol>
<li>对于引擎层来说，这是 4 个表；</li>
<li>对于 Server 层来说，这是 1 个表。</li>
</ol>
</blockquote>
<ol>
<li>MySQL 在第一次打开分区表的时候，需要访问所有的分区；</li>
<li>在 server 层，认为这是同一张表，因此所有分区共用同一个 MDL 锁；</li>
<li>在引擎层，认为这是不同的表，因此 MDL 锁之后的执行过程，会根据分区表规则，只访问必要的分区。</li>
</ol>
<ol>
<li>分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。</li>
<li>分区也不要提前预留太多，在使用之前预先创建即可。</li>
<li>对于没有数据的历史分区，要及时的 drop 掉。</li>
</ol>
<h2 id="自增id用完怎么办？"><a href="#自增id用完怎么办？" class="headerlink" title="自增id用完怎么办？"></a>自增id用完怎么办？</h2><p>MySQL 里有很多自增的 id，每个自增 id 都是定义了初始值，然后不停地往上加步长。虽然自然数是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。比如，无符号整型 (unsigned int) 是 4 个字节，上限就是 2<sup>32</sup>-1。</p>
<h3 id="表定义自增值-id"><a href="#表定义自增值-id" class="headerlink" title="表定义自增值 id"></a>表定义自增值 id</h3><p>表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table t(id int unsigned auto_increment primary key) auto_increment=4294967295;<br>insert into t values(null);<br>//成功插入一行 4294967295<br>show create table t;<br>/* CREATE TABLE `t` (<br>  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=4294967295;<br>*/<br><br>insert into t values(null);<br>//Duplicate entry &#x27;4294967295&#x27; for key &#x27;PRIMARY&#x27;<br></code></pre></td></tr></table></figure>
<p>第一个 insert 语句插入数据成功后，这个表的 AUTO_INCREMENT 没有改变（还是 4294967295），就导致了第二个 insert 语句又拿到相同的自增 id 值，再试图执行插入语句，报主键冲突错误。</p>
</blockquote>
<h3 id="InnoDB-系统自增-row-id"><a href="#InnoDB-系统自增-row-id" class="headerlink" title="InnoDB 系统自增 row_id"></a>InnoDB 系统自增 row_id</h3><p>如果创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节的 <strong>row_id</strong>。</p>
<p>InnoDB 维护了一个全局的 ‘dict_sys.row_id’ 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 ‘dict_sys.row_id’ 值作为要插入数据的 row_id，然后把 ‘dict_sys.row_id’ 的值加 1。                                                                                                                              </p>
<p>实际上，在代码实现时 row_id 是一个长度为 8 字节的无符号长整型 (bigint unsigned)。但是，InnoDB 在设计时，给 row_id 留的只是 6 个字节的长度，这样写到数据表中时只放了最后 6 个字节，所以 row_id 能写到数据表中的值，就有两个特征：</p>
<ol>
<li><p>row_id 写入表中的值范围，是从 0 到 2<sup>48</sup>-1；</p>
</li>
<li><p>当 ‘dict_sys.row_id=2<sup>48</sup>‘时，如果再有插入数据的行为要来申请 row_id，拿到以后再取最后 6 个字节的话就是 0。(写入表的 row_id 是从 0 开始到 2<sup>48</sup>-1。达到上限后，下一个值就是 0，然后继续循环。)</p>
<p>在 InnoDB 逻辑里，申请到 row_id=N 后，就将这行数据写入表中；如果表中已经存在 row_id=N 的行，新写入的行就会覆盖原有的行。</p>
</li>
</ol>
<h3 id="Xid"><a href="#Xid" class="headerlink" title="Xid"></a>Xid</h3><p>MySQL 内部维护了一个全局变量 ‘global_query_id’，每次执行语句的时候将它赋值给 ‘Query_id’，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 ‘Query_id’ 赋值给这个事务的 <strong>Xid</strong>。</p>
<p>而 <strong>‘global_query_id’ 是一个纯内存变量</strong>，重启之后就清零了。所以在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，<strong>同一个 binlog 文件里，Xid 一定是惟一的</strong>。</p>
<p>虽然 MySQL 重启不会导致同一个 binlog 里面出现两个相同的 Xid，但是如果 ‘global_query_id’ 达到上限后，就会继续从 0 开始计数。从理论上讲，还是就会出现同一个 binlog 里面出现相同 Xid 的场景。</p>
<h3 id="Innodb-trx-id"><a href="#Innodb-trx-id" class="headerlink" title="Innodb trx_id"></a>Innodb trx_id</h3><p><strong>Xid 是由 server 层维护的</strong>。InnoDB 内部使用 Xid，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，<strong>InnoDB 自己的 trx_id，是另外维护的</strong>。</p>
<p>InnoDB 内部维护了一个 ‘max_trx_id’ 全局变量，每次需要申请一个新的 trx_id 时，就获得 ‘max_trx_id’ 的当前值，然后并将 ‘max_trx_id’ 加 1。</p>
<p>InnoDB 数据可见性的<strong>核心思想</strong>是：每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比。</p>
<p>对于正在执行的事务，可以从 <code>information_schema.innodb_trx</code> 表中看到事务的 trx_id。</p>
<blockquote>
<p><img src="/article/事务的 trx_id.png"><span class="image-caption">事务的 trx_id</span></p>
<p>session B 里，从 innodb_trx 表里查出的这两个字段，第二个字段 <code>trx_mysql_thread_id</code> 就是线程 id。显示线程 id，是为了说明这两次查询看到的事务对应的线程 id 都是 5，也就是 session A 所在的线程。</p>
<p>实际上，在 T1 时刻，session A 还没有涉及到更新，是一个只读事务。而对于只读事务，InnoDB 并不会分配 trx_id。也就是说：</p>
<ol>
<li>在 T1 时刻，trx_id 的值其实就是 0。而这个很大的数，只是显示用的。</li>
<li>直到 session A 在 T3 时刻执行 insert 语句的时候，InnoDB 才真正分配了 trx_id。所以，T4 时刻，session B 查到的这个 trx_id 的值就是 1289。</li>
</ol>
</blockquote>
<p>除了修改类语句外，如果在 select 语句后面加上 for update，这个事务也不是只读事务。</p>
<ol>
<li>update 和 delete 语句除了事务本身，还涉及到标记删除旧数据，也就是要把数据放到 purge 队列里等待后续物理删除，这个操作也会把 max_trx_id+1， 因此在一个事务中至少加 2；</li>
<li>InnoDB 的后台操作，比如表的索引信息统计这类操作，也是会启动内部事务的，因此你可能看到，trx_id 值并不是按照加 1 递增的。</li>
</ol>
<blockquote>
<p>T2 时刻查到的这个很大的数字是怎么来的呢？</p>
</blockquote>
<p>这个数字是每次查询的时候由系统临时计算出来的。它的算法是：把当前事务的 trx 变量的指针地址转成整数，再加上 2<sup>48</sup>。使用这个算法，就可以保证以下两点：</p>
<ol>
<li>因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在 innodb_trx 还是在 innodb_locks 表里，同一个只读事务查出来的 trx_id 就会是一样的。</li>
<li>如果有并行的多个只读事务，每个事务的 trx 变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的 trx_id 就是不同的。</li>
<li>在显示值里面加上 2<sup>48</sup>，目的是要保证只读事务显示的 trx_id 值比较大，正常情况下就会区别于读写事务的 id。但是，trx_id 跟 row_id 的逻辑类似，定义长度也是 8 个字节。因此，在理论上还是可能出现一个读写事务与一个只读事务显示的 trx_id 相同的情况。不过这个概率很低，并且也没有什么实质危害，可以不管它。</li>
</ol>
<p>只读事务不分配 trx_id，有什么好处呢？</p>
<ol>
<li>一个好处是，这样做可以减小事务视图里面活跃事务数组的大小。因为当前正在运行的只读事务，是不影响数据的可见性判断的。所以，在创建事务的一致性视图时，InnoDB 就只需要拷贝读写事务的 trx_id。</li>
<li>另一个好处是，可以减少 trx_id 的申请次数。在 InnoDB 里，即使你只是执行一个普通的 select 语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句不需要申请 trx_id，就大大减少了并发事务申请 trx_id 的锁冲突。</li>
</ol>
<p>max_trx_id 会持久化存储，重启也不会重置为 0，那么从理论上讲，只要一个 MySQL 服务跑得足够久，就可能出现 max_trx_id 达到 2<sup>48</sup>-1 的上限，然后从 0 开始的情况。</p>
<p>当达到这个状态后，MySQL 就会持续出现一个脏读的 bug</p>
<blockquote>
<p>脏读的 bug 复现</p>
<p>首先需要把当前的 max_trx_id 先修改成 248-1。注意：这个 case 里使用的是可重复读隔离级别。</p>
<img src="/article/17540/%E5%A4%8D%E7%8E%B0%E8%84%8F%E8%AF%BB.png" class title="复现脏读">
<p>由于已经把系统的 max_trx_id 设置成了 2<sup>48</sup>-1，所以在 session A 启动的事务 TA 的低水位就是 2<sup>48</sup>-1。</p>
<p>在 T2 时刻，session B 执行第一条 update 语句的事务 id 就是 2<sup>48</sup>-1，而第二条 update 语句的事务 id 就是 0 了，这条 update 语句执行后生成的数据版本上的 trx_id 就是 0。</p>
<p>在 T3 时刻，session A 执行 select 语句的时候，判断可见性发现，c=3 这个数据版本的 trx_id，小于事务 TA 的低水位，因此认为这个数据可见。</p>
<p>但，这个是脏读。</p>
<p>由于低水位值会持续增加，而事务 id 从 0 开始计数，就导致了系统在这个时刻之后，所有的查询都会出现脏读的。</p>
<p>并且，MySQL 重启时 max_trx_id 也不会清 0，也就是说重启 MySQL，这个 bug 仍然存在。</p>
</blockquote>
<h3 id="thread-id"><a href="#thread-id" class="headerlink" title="thread_id"></a>thread_id</h3><p><strong>线程 id（thread_id）</strong>才是 MySQL 中最常见的一种自增 id。</p>
<p>thread_id 的逻辑：系统保存了一个全局变量 ‘thread_id_counter’，每新建一个连接，就将 thread_id_counter 赋值给这个新连接的线程变量。</p>
<p>thread_id_counter 定义的大小是 4 个字节，因此达到 2<sup>32</sup>-1 后，它就会重置为 0，然后继续增加。</p>
<p><strong>但是，不会在 show processlist 里看到两个相同的 thread_id。</strong>因为 MySQL 设计了一个唯一数组的逻辑，给新线程分配 thread_id 的时候，逻辑代码是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">do &#123;<br>  new_id= thread_id_counter++;<br>&#125; while (!thread_ids.insert_unique(new_id).second);<br></code></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ol>
<li>表的自增 id 达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误。</li>
<li>row_id 达到上限后，则会归 0 再重新递增，如果出现相同的 row_id，后写的数据会覆盖之前的数据。</li>
<li>Xid 只需要不在同一个 binlog 文件中出现重复值即可。虽然理论上会出现重复值，但是概率极小，可以忽略不计。</li>
<li>InnoDB 的 max_trx_id 递增值每次 MySQL 重启都会被保存起来，脏读的例子就是一个必现的 bug。</li>
<li>thread_id 是最常见的，而且也是处理得最好的一个自增 id 逻辑。</li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>实习,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/article/38362.html</url>
    <content><![CDATA[<h2 id="如何理解“递归”？"><a href="#如何理解“递归”？" class="headerlink" title="如何理解“递归”？"></a>如何理解“递归”？</h2><h3 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h3><ol>
<li><p>一个问题的解可以分解为几个子问题的解</p>
<p>子问题就是数据规模更小的问题</p>
</li>
<li><p>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</p>
</li>
<li><p>存在递归终止条件</p>
<p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p>
</li>
</ol>
<h3 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h3><p>写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong></p>
<p><strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</strong></p>
<h3 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h3><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<blockquote>
<p><strong>问题：如何避免出现堆栈溢出呢？</strong></p>
<p>可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。</p>
<p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。</p>
</blockquote>
<h3 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h3><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p>
<ol>
<li>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。</li>
<li>在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>数据结构与算法,递归</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/article/26671.html</url>
    <content><![CDATA[<h2 id="队列：队列在线程池等有限资源池中的应用"><a href="#队列：队列在线程池等有限资源池中的应用" class="headerlink" title="队列：队列在线程池等有限资源池中的应用"></a>队列：队列在线程池等有限资源池中的应用</h2><p>CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。</p>
<blockquote>
<p>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</p>
</blockquote>
<p><strong>先进者先出，这就是典型的“队列”。</strong></p>
<p>最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。</p>
<p>队列跟栈一样，也是<strong>一种操作受限的线性表数据结构</strong>。</p>
<p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p>
<h3 id="基于数组的队列实现方法"><a href="#基于数组的队列实现方法" class="headerlink" title="基于数组的队列实现方法"></a>基于数组的队列实现方法</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用数组实现的队列</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span> </span>&#123;<br>  <span class="hljs-comment">// 数组：items，数组大小：n</span><br>  <span class="hljs-keyword">private</span> String[] items;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 申请一个大小为capacity的数组</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    items = <span class="hljs-keyword">new</span> String[capacity];<br>    n = capacity;<br>  &#125;<br><br>  <span class="hljs-comment">// 入队</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果tail == n 表示队列已经满了</span><br>    <span class="hljs-keyword">if</span> (tail == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    items[tail] = item;<br>    ++tail;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 出队</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果head == tail 表示队列为空</span><br>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span><br>    String ret = items[head];<br>    ++head;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>队列需要两个指针：</p>
<ol>
<li>一个是 head 指针，指向队头；</li>
<li>一个是 tail 指针，指向队尾。</li>
</ol>
<blockquote>
<p>每次进行出队操作都相当于删除数组下标为 0 的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的 O(1) 变为 O(n)。能不能优化一下呢？</p>
</blockquote>
<p>在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 入队操作，将item放入队尾</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;<br>  <span class="hljs-comment">// tail == n表示队列末尾没有空间了</span><br>  <span class="hljs-keyword">if</span> (tail == n) &#123;<br>    <span class="hljs-comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 数据搬移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head; i &lt; tail; ++i) &#123;<br>      items[i-head] = items[i];<br>    &#125;<br>    <span class="hljs-comment">// 搬移完之后重新更新head和tail</span><br>    tail -= head;<br>    head = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  items[tail] = item;<br>  ++tail;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/26671/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.jpg" class title="顺序队列数据迁移">
</blockquote>
<h3 id="基于链表的队列实现方法"><a href="#基于链表的队列实现方法" class="headerlink" title="基于链表的队列实现方法"></a>基于链表的队列实现方法</h3><p>基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。</p>
<img src="/article/26671/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.jpg" class title="基于链表的队列实现">
<p><strong>循环队列</strong></p>
<img src="/article/26671/%E5%9F%BA%E4%BA%8E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.jpg" class title="基于循环链表的队列实现">
<p><strong>确定好队空和队满的判定条件：</strong></p>
<ol>
<li><p>队列为空的判断条件是 head == tail</p>
</li>
<li><p>当队满时的判断条件是 (tail+1)%n=head</p>
<img src="/article/26671/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E9%98%9F%E6%BB%A1.jpg" class title="循环队列队满">
<p><strong>循环队列会浪费一个数组的存储空间</strong></p>
</li>
</ol>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularQueue</span> </span>&#123;<br>  <span class="hljs-comment">// 数组：items，数组大小：n</span><br>  <span class="hljs-keyword">private</span> String[] items;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 申请一个大小为capacity的数组</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    items = <span class="hljs-keyword">new</span> String[capacity];<br>    n = capacity;<br>  &#125;<br><br>  <span class="hljs-comment">// 入队</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;<br>    <span class="hljs-comment">// 队列满了</span><br>    <span class="hljs-keyword">if</span> ((tail + <span class="hljs-number">1</span>) % n == head) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    items[tail] = item;<br>    tail = (tail + <span class="hljs-number">1</span>) % n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 出队</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果head == tail 表示队列为空</span><br>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    String ret = items[head];<br>    head = (head + <span class="hljs-number">1</span>) % n;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h3><p><strong>阻塞队列</strong>就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>
<img src="/article/26671/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.jpg" class title="阻塞队列">
<p><strong>并发队列</strong>是线程安全的队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。</p>
<blockquote>
<p><strong>问题：线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</strong></p>
<ol>
<li>第一种是非阻塞的处理方式，直接拒绝任务请求；</li>
<li>另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<ol>
<li>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</li>
<li>而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</li>
</ol>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>数据结构与算法,队列</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/article/37273.html</url>
    <content><![CDATA[<h2 id="栈：如何实现浏览器的前进和后退功能？"><a href="#栈：如何实现浏览器的前进和后退功能？" class="headerlink" title="栈：如何实现浏览器的前进和后退功能？"></a>栈：如何实现浏览器的前进和后退功能？</h2><blockquote>
<p>当你依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果你后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。</p>
</blockquote>
<p><strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong></p>
<p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</strong></p>
<h3 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h3><p>栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。</p>
<p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 基于数组实现的顺序栈</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-comment">// 数组</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;       <span class="hljs-comment">// 栈中元素个数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;           <span class="hljs-comment">//栈的大小</span><br><br>  <span class="hljs-comment">// 初始化数组，申请一个大小为n的数组空间</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> String[n];<br>    <span class="hljs-keyword">this</span>.n = n;<br>    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 入栈操作</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">push</span><span class="hljs-params">(String item)</span> </span>&#123;<br>    <span class="hljs-comment">// 数组空间不够了，直接返回false，入栈失败。</span><br>    <span class="hljs-keyword">if</span> (count == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 将item放到下标为count的位置，并且count加一</span><br>    items[count] = item;<br>    ++count;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 出栈操作</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 栈为空，则直接返回null</span><br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span><br>    String tmp = items[count-<span class="hljs-number">1</span>];<br>    --count;<br>    <span class="hljs-keyword">return</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>空间复杂度是 O(1)</p>
<p>时间复杂度是 O(1)</p>
<h3 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h3><blockquote>
<p>如何来实现一个支持动态扩容的数组的？</p>
<p>当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p>
</blockquote>
<p>要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</p>
<img src="/article/37273/%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88.jpg" class title="支持动态扩容的顺序栈">
<p>对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。</p>
<p>但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。<strong>对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。</strong></p>
<p>入栈操作的均摊时间复杂度为 O(1)</p>
<blockquote>
<p>假设和定义：</p>
<ul>
<li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li>
<li>为了简化分析，假设只有入栈操作没有出栈操作；</li>
<li>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)。</li>
</ul>
<p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。</p>
<img src="/article/37273/%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E6%A0%88.jpg" class title="动态扩容栈">
<p>这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，<strong>入栈操作的均摊时间复杂度就为 O(1)</strong>。</p>
</blockquote>
<h3 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h3><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; <br>   <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>   ret = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>   res = a + ret;<br>   printf(<span class="hljs-string">&quot;%d&quot;</span>, res);<br>   reuturn <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>   sum = x + y;<br>   <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相加，最后打印 res 的值</p>
<p> 函数调用栈.jpg)</p>
</blockquote>
<h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h3><blockquote>
<p>3+5*8-6</p>
</blockquote>
<p>编译器就是通过两个栈来实现的。</p>
<ol>
<li>其中一个保存操作数的栈，</li>
<li>另一个是保存运算符的栈。</li>
</ol>
<p>我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<blockquote>
<img src="/article/37273/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.jpg" class title="表达式的计算过程">
</blockquote>
<h3 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h3><blockquote>
<p>假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。</p>
</blockquote>
<p>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>
<p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>
<h3 id="如何实现浏览器的前进、后退功能？"><a href="#如何实现浏览器的前进、后退功能？" class="headerlink" title="如何实现浏览器的前进、后退功能？"></a>如何实现浏览器的前进、后退功能？</h3><p>使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>数据结构与算法,栈</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/article/54862.html</url>
    <content><![CDATA[<h2 id="如何实现LRU缓存淘汰算法"><a href="#如何实现LRU缓存淘汰算法" class="headerlink" title="如何实现LRU缓存淘汰算法?"></a>如何实现LRU缓存淘汰算法?</h2><p><strong>缓存</strong>是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。</p>
<p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：</p>
<ol>
<li>先进先出策略 FIFO（First In，First Out）</li>
<li>最少使用策略 LFU（Least Frequently Used）</li>
<li>最近最少使用策略 LRU（Least Recently Used）</li>
</ol>
<blockquote>
<p><strong>数组与链表的对比</strong></p>
<p>底层的存储结构</p>
<img src="/article/54862/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.jpg" class title="数组与链表内存分布">
<p>数组需要一块连续的内存空间来存储，对内存的要求比较高。</p>
<p>链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。把内存块称为链表的“结点”。</p>
</blockquote>
<h3 id="常见的链表结构"><a href="#常见的链表结构" class="headerlink" title="常见的链表结构"></a>常见的链表结构</h3><ol>
<li><p>单链表</p>
<img src="/article/54862/%E5%8D%95%E9%93%BE%E8%A1%A8.jpg" class title="单链表">
<p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：<strong>元素(数据元素的映象) +指针(指示后继元素存储位置)</strong>，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p>
<p>有两个结点是比较特殊的</p>
<ol>
<li>第一个结点叫作头结点，头结点用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。</li>
<li>最后一个结点叫作尾结点。尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。</li>
</ol>
<blockquote>
<p>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。</p>
<hr>
<p>针对<strong>链表的插入和删除操作</strong>，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p>
<img src="/article/54862/%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.jpg" class title="链表的插入和删除操作">
<hr>
<p><strong>链表不能随机访问第 k 个元素</strong>。</p>
<p>因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p>
<p><strong>链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</strong></p>
</blockquote>
</li>
<li><p>循环链表</p>
<img src="/article/54862/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg" class title="循环链表">
<p>循环链表是一种特殊的单链表，它的特点是表中<strong>最后一个结点的指针域指向头结点</strong>，整个链表形成一个环。</p>
<p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。</p>
</li>
<li><p>双向链表</p>
<img src="/article/54862/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg" class title="双向链表">
<p>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有<strong>两个指针</strong>，分别指向<strong>直接后继和直接前驱</strong>。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造<strong>双向循环链表</strong>。</p>
<img src="/article/54862/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg" class title="双向循环链表">
<p>双向链表需要<strong>额外的两个空间</strong>来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</p>
<blockquote>
<p>双向链表可以支持 <strong>O(1) 时间复杂度的情况下找到前驱结点</strong>，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效</p>
<hr>
<p><strong>删除操作</strong></p>
<ol>
<li><p>删除结点中“值等于某个给定值”的结点；</p>
<p>不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。</p>
<p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，<strong>删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)</strong>。</p>
</li>
<li><p>删除给定指针指向的结点。</p>
<p>单链表：已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</p>
<p><strong>双链表：</strong>因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。单链表<strong>删除操作</strong>需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度。</p>
</li>
</ol>
<hr>
<p><strong>插入操作</strong></p>
<p>在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表需要 O(1) 时间复杂度，而单向链表需要 O(n) 的时间复杂度。</p>
<hr>
<p><strong>按值查询</strong></p>
<p>对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p>
</blockquote>
</li>
</ol>
<p><strong>用空间换时间的设计思想：</strong>当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。</p>
<p><strong>缓存实际上就是利用了空间换时间的设计思想。</strong>如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p>
<h3 id="如何基于链表实现-LRU-缓存淘汰算法？"><a href="#如何基于链表实现-LRU-缓存淘汰算法？" class="headerlink" title="如何基于链表实现 LRU 缓存淘汰算法？"></a>如何基于链表实现 LRU 缓存淘汰算法？</h3><p>维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p>
<ol>
<li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li>
<li>如果此数据没有在缓存链表中，又可以分为两种情况：<ol>
<li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li>
<li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li>
</ol>
</li>
</ol>
<p>这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</p>
<h2 id="如何轻松写出正确的链表代码？"><a href="#如何轻松写出正确的链表代码？" class="headerlink" title="如何轻松写出正确的链表代码？"></a>如何轻松写出正确的链表代码？</h2><h3 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h3><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p>
<h3 id="技巧二：警惕指针丢失和内存泄漏"><a href="#技巧二：警惕指针丢失和内存泄漏" class="headerlink" title="技巧二：警惕指针丢失和内存泄漏"></a>技巧二：警惕指针丢失和内存泄漏</h3><blockquote>
<img src="/article/54862/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.jpg" class title="单链表的插入操作">
<p>在结点 a 和相邻的结点 b 之间插入结点 x，假设当前指针 p 指向结点 a</p>
<p>将代码实现变成下面这个样子，就会发生指针丢失和内存泄露:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">p-&gt;next = x;  <span class="hljs-comment">// 将p的next指针指向x结点；</span><br>x-&gt;next = p-&gt;next;  <span class="hljs-comment">// 将x的结点的next指针指向b结点；</span><br></code></pre></td></tr></table></figure>
<p>p-&gt;next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。第 2 行代码相当于将 x 赋值给 x-&gt;next，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。</p>
</blockquote>
<p><strong>插入结点时，一定要注意操作的顺序</strong></p>
<blockquote>
<p>要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏</p>
</blockquote>
<p><strong>删除链表结点时，也一定要记得手动释放内存空间</strong></p>
<h3 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h3><p><strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</strong></p>
<p><strong>引入哨兵结点</strong>，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫<strong>带头链表</strong>。相反，没有哨兵结点的链表就叫作不带头链表。</p>
<p><strong>哨兵结点是不存储数据的</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构与算法,链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/article/32766.html</url>
    <content><![CDATA[<p><a href="https://time.geekbang.org/column/intro/100017301?tab=catalog">参考学习自·数据结构与算法之美</a></p>
<h2 id="数组：为什么很多编程语言中数组都从0开始编号？"><a href="#数组：为什么很多编程语言中数组都从0开始编号？" class="headerlink" title="数组：为什么很多编程语言中数组都从0开始编号？"></a>数组：为什么很多编程语言中数组都从0开始编号？</h2><p>数组（Array）是一种<strong>线性表</strong>数据结构。它用一组<strong>连续</strong>的内存空间，来存储一组具有<strong>相同类型</strong>的数据。</p>
<ol>
<li><p>线性表（Linear List）</p>
<p>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。</p>
</li>
<li><p>连续的内存空间和相同类型的数据</p>
</li>
</ol>
<blockquote>
<img src="/article/32766/%E5%86%85%E5%AD%98%E5%9D%97%E5%9C%B0%E5%9D%80.jpg" class title="内存块地址">
</blockquote>
<p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs wiki">a[i]_address = base_address + i * data_type_size<br></code></pre></td></tr></table></figure>
<p><strong>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</strong></p>
<h3 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h3><p>数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效</p>
<p><strong>插入操作</strong></p>
<blockquote>
<p>假设数组的长度为 n，现在，如果需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，需要将第 k～n 这部分的元素都顺序地往后挪一位。</p>
<p>最好时间复杂度： O(1)</p>
<p>最坏时间复杂度： O(n)</p>
<p>平均情况时间复杂度: (1+2+…n)/n=O(n)</p>
<p>如果数组中的数据是<strong>有序</strong>的，在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。</p>
<hr>
<p>但是，如果数组中存储的数据并<strong>没有任何规律</strong>，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，<strong>直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置</strong>。</p>
</blockquote>
<p><strong>删除操作</strong></p>
<blockquote>
<p>要删除第 k 个位置的数据</p>
<p>最好时间复杂度： O(1)</p>
<p>最坏时间复杂度： O(n)</p>
<p>平均情况时间复杂度: (1+2+…n)/n=O(n)</p>
</blockquote>
<p>在某些特殊场景下，我们并不一定非得追求数组中数据的连续性</p>
<blockquote>
<p>数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。依次删除 a，b，c 三个元素。</p>
<p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作<strong>并不是真正地搬移数据</strong>，只是<strong>记录数据已经被删除</strong>。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
</blockquote>
<h3 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h3><blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(; i&lt;=<span class="hljs-number">3</span>; i++)&#123;<br>        arr[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”</p>
<p>因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i&lt;=3 而非 i&lt;3，所以当 i=3 时，数组 a[3]访问越界。</p>
<p>在 <strong>C 语言</strong>中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。</p>
<p><strong>数组越界在 C 语言中是一种未决行为</strong>，并没有规定数组访问越界时编译器应该如何处理。因为，<strong>访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误</strong>。</p>
</blockquote>
<h3 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h3><p>ArrayList 最大的优势就是可以将很多数组操作的细节封装起来，还有一个优势，就是支持动态扩容。</p>
<p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</p>
<p>如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。</p>
<blockquote>
<p>因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。</p>
</blockquote>
<ol>
<li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li>
<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</li>
<li>当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList<object> &gt; array。</object></li>
</ol>
<h3 id="为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始呢？"><a href="#为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始呢？" class="headerlink" title="为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？"></a>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是<strong>“偏移（offset）”</strong>。</p>
<p>如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">a[k]_address = base_address + k * type_size<br></code></pre></td></tr></table></figure>
<blockquote>
<p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">a[k]_address = base_address + (k-1)*type_size<br></code></pre></td></tr></table></figure>
<p>从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p>
</blockquote>
<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以<strong>为了减少一次减法操作</strong>，数组选择了从 0 开始编号，而不是从 1 开始。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数据结构与算法,数组</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析</title>
    <url>/article/54635.html</url>
    <content><![CDATA[<p><a href="https://time.geekbang.org/column/intro/100017301?tab=catalog">参考学习自·数据结构与算法之美</a></p>
<p><strong>事后统计法</strong></p>
<p>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</p>
<p>局限性:</p>
<ol>
<li>测试结果非常依赖测试环境</li>
<li>测试结果受数据规模的影响很大</li>
</ol>
<p>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。</p>
<h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt;= n; ++i) &#123;<br>    sum = sum + i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：<strong>读数据-运算-写数据</strong>。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。</p>
<p>第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n<em>unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)</em>unit_time。</p>
<p><strong>所有代码的执行时间 T(n) 与每行代码的执行次数成正比</strong></p>
</blockquote>
<p><strong>所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比</strong></p>
<p><strong>大 O 时间复杂度表示法</strong></p>
<img src="/article/54635/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%E5%85%AC%E5%BC%8F.png" class title="复杂度分析公式">
<ol>
<li>T(n) 表示代码执行的时间；</li>
<li>n 表示数据规模的大小；</li>
<li>f(n) 表示每行代码执行的次数总和。</li>
<li>公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比</li>
</ol>
<p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="如何分析一段代码的时间复杂度？"><a href="#如何分析一段代码的时间复杂度？" class="headerlink" title="如何分析一段代码的时间复杂度？"></a>如何分析一段代码的时间复杂度？</h3><ol>
<li><p>只关注循环执行次数最多的一段代码</p>
<p>大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会<strong>忽略</strong>掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，在分析一个算法、一段代码的时间复杂度的时候，也<strong>只关注循环执行次数最多</strong>的那一段代码就可以了。</p>
</li>
<li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
<p><strong>总的时间复杂度就等于量级最大的那段代码的时间复杂度</strong></p>
<p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))，那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))</p>
</li>
<li><p>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))，那么 T(n)=T1(n)<em>T2(n)=O(f(n))</em>O(g(n))=O(f(n)*g(n))</p>
</li>
</ol>
<h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h3><img src="/article/54635/%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%87%8F%E7%BA%A7.jpg" class title="复杂度量级">
<p>多项式量级和非多项式量级，其中，非多项式量级只有两个：O(2<sup>n</sup>) 和 O(n!)</p>
<p><strong>越高阶复杂度的算法，执行效率越低</strong></p>
<p>时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题</p>
<p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。</p>
<ol>
<li><p>O(1)</p>
<p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码</p>
<p>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)</p>
</li>
<li><p>O(logn)、O(nlogn)</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">i=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &lt;= n)  &#123;<br>  i = i * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>变量 i 的值从 1 开始取，每循环一次就乘以 2，当大于 n 时，循环结束</p>
<p><img src="/article/变量 i 的取值就是一个等比数列.jpg"><span class="image-caption">变量 i 的取值就是一个等比数列</span></p>
<p>通过 2<sup>x</sup>=n 求解 x，x=log<sub>2</sub>n</p>
<p>所以，这段代码的时间复杂度就是 O(log<sub>2</sub>n)</p>
</blockquote>
<p><strong>在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))</strong></p>
<blockquote>
<p>log<sub>3</sub>n 就等于 log<sub>3</sub>2 <em> log<sub>2</sub>n，所以 O(log<sub>3</sub>n) = O(C </em> log<sub>2</sub>n)，其中 C=log<sub>3</sub>2 是一个常量。可以直接忽略</p>
<p>O(log<sub>2</sub>n) 就可以直接表示为 O(logn)</p>
</blockquote>
<p>因此，在对数阶时间复杂度的表示方法里，我们<strong>忽略对数的“底”，统一表示为 O(logn)。</strong></p>
</li>
<li><p>O(m+n)、O(m*n)</p>
<p><strong>代码的复杂度由两个数据的规模来决定</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> sum_1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; m; ++i) &#123;<br>    sum_1 = sum_1 + i;<br>  &#125;<br><br>  <span class="hljs-keyword">int</span> sum_2 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; j &lt; n; ++j) &#123;<br>    sum_2 = sum_2 + j;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> sum_1 + sum_2;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)</p>
</li>
</ol>
<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  <span class="hljs-keyword">for</span> (i; i &lt;n; ++i) &#123;<br>    a[i] = i * i;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (i = n<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>    print out a[i]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第 2 行代码中，申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。</p>
<p>第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>
</blockquote>
<p>常见的空间复杂度就是 O(1)、O(n)、O(n2 )</p>
<h2 id="浅析最好、最坏、平均、均摊时间复杂度"><a href="#浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="浅析最好、最坏、平均、均摊时间复杂度"></a>浅析最好、最坏、平均、均摊时间复杂度</h2><h3 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// n表示数组array的长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> pos = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (array[i] == x) &#123;<br>       pos = i;<br>       <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p>
</blockquote>
<p><strong>最好情况时间复杂度</strong>就是，在最理想的情况下，执行这段代码的时间复杂度。</p>
<p><strong>最坏情况时间复杂度</strong>就是，在最糟糕的情况下，执行这段代码的时间复杂度。</p>
<h3 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// n表示数组array的长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> pos = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (array[i] == x) &#123;<br>       pos = i;<br>       <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> pos;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：</p>
<img src="/article/54635/%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5.jpg" class title="平均情况">
<p>时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，这个公式简化之后，得到的平均时间复杂度就是 O(n)</p>
</blockquote>
<p><strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong></p>
<blockquote>
<p>要查找的变量 x，要么在数组里，要么就不在数组里。</p>
<p>假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p>
<img src="/article/54635/%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" class title="加权平均时间复杂度">
<p>这个值就是概率论中的<strong>加权平均值</strong>，也叫作<strong>期望值</strong>，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者<strong>期望时间复杂度</strong>。</p>
<p>引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p>
</blockquote>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// array表示一个长度为n的数组</span><br><span class="hljs-comment">// 代码中的array.length就等于n</span><br><span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (count == array.length) &#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; ++i) &#123;<br>      sum = sum + array[i];<br>    &#125;<br>    array[<span class="hljs-number">0</span>] = sum;<br>    count = <span class="hljs-number">1</span>;<br>  &#125;<br><br>  array[count] = val;<br>  ++count;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码实现了一个往数组中插入数据的功能</p>
<p>当数组满了之后，也就是代码中的 count == array.length 时，用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p>
<p><strong>最好情况时间复杂度:</strong>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。</p>
<p><strong>最坏情况时间复杂度:</strong>最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p>
<p><strong>平均情况时间复杂度：</strong>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p>
<img src="/article/54635/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.jpg" class title="数组中插入数据">
</blockquote>
<p><strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度我们起了一个名字，叫<strong>均摊时间复杂度</strong></p>
<blockquote>
<p>每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。</p>
</blockquote>
<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，<strong>在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度</strong>。</p>
<p><strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>复杂度分析</category>
      </categories>
      <tags>
        <tag>数据结构与算法,复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql45讲-实践（三）</title>
    <url>/article/10821.html</url>
    <content><![CDATA[<h2 id="如何判断一个数据库是不是出问题了？"><a href="#如何判断一个数据库是不是出问题了？" class="headerlink" title="如何判断一个数据库是不是出问题了？"></a>如何判断一个数据库是不是出问题了？</h2><h3 id="select-1-判断"><a href="#select-1-判断" class="headerlink" title="select 1 判断"></a>select 1 判断</h3><p>select 1 成功返回，只能说明这个库的进程还在，并不能说明主库没问题。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">set global innodb_thread_concurrency=3;<br><br>CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB;<br><br>insert into t values(1,1)<br></code></pre></td></tr></table></figure>
<p><img src="/article/查询 blocked.png"><span class="image-caption">查询 blocked</span></p>
<p>设置 innodb_thread_concurrency 参数的目的是，控制 InnoDB 的并发线程上限。</p>
</blockquote>
<p>select 1 是能执行成功的，但是查询表 t 的语句会被堵住。</p>
<p>如果用 select 1 来检测实例是否正常的话，是检测不出问题的。</p>
<p>通常情况下，建议把 innodb_thread_concurrency 设置为 64~128 之间的值。</p>
<blockquote>
<p><strong>并发连接和并发查询</strong>，并不是同一个概念：</p>
<p>在 <code>show processlist</code> 的结果里，看到的几千个连接，指的就是并发连接。而“当前正在执行”的语句，才是我们所说的并发查询。</p>
<p>并发连接数达到几千个影响并不大，就是多占一些内存而已。我们应该关注的是并发查询，因为并发查询太高才是 CPU 杀手。</p>
<p><strong>在线程进入锁等待以后，并发线程的计数会减一</strong></p>
</blockquote>
<p>在这个例子中，同时在执行的语句超过了设置的 innodb_thread_concurrency 的值，这时候系统其实已经不行了，但是通过 select 1 来检测系统，会认为系统还是正常的。</p>
<p>因此，我们使用 select 1 的判断逻辑要修改一下。</p>
<h3 id="查表判断"><a href="#查表判断" class="headerlink" title="查表判断"></a>查表判断</h3><p>为了能够检测 InnoDB 并发线程数过多导致的系统不可用情况，我们需要找一个访问 InnoDB 的场景。一般的做法是，在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from mysql.health_check; <br></code></pre></td></tr></table></figure>
<p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。</p>
<blockquote>
<p>问题：更新事务要写 binlog，而一旦 binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p>
<p>因此，我们还是把这条监控语句再改进一下。把查询语句改成更新语句。</p>
</blockquote>
<h3 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h3><p>既然要更新，就要放个有意义的字段，常见做法是放一个 timestamp 字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; update mysql.health_check set t_modified=now();<br></code></pre></td></tr></table></figure>
<p>节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。</p>
<p>但，备库的检测也是要写 binlog 的。由于我们一般会把数据库 A 和 B 的主备关系设计为双 M 结构，所以在备库 B 上执行的检测命令，也要发回给主库 A。</p>
<p>但是，如果主库 A 和备库 B 都用相同的更新命令，就可能出现行冲突，也就是可能会导致主备同步停止。所以，现在看来 mysql.health_check 这个表就不能只有一行数据了。</p>
<p><strong>为了让主备之间的更新不产生冲突，我们可以在 mysql.health_check 表上存入多行数据，并用 A、B 的 server_id 做主键。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE `health_check` (<br>  `id` int(11) NOT NULL,<br>  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB;<br><br>/* 检测命令 */<br>insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified=now();<br></code></pre></td></tr></table></figure>
<p>由于 MySQL 规定了主库和备库的 server_id 必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。</p>
<blockquote>
<p>问题：更新判断是一个相对比较常用的方案了，不过依然存在一些“判定慢”的问题。</p>
<p>涉及到的是服务器 IO 资源分配的问题</p>
<p>首先，所有的检测逻辑都需要一个超时时间 N。执行一条 update 语句，超过 N 秒后还不返回，就认为系统不可用。</p>
<p>IO 利用率 100% 表示系统的 IO 是在工作的，每个请求都有机会获得 IO 资源，执行自己的任务。而我们的检测使用的 update 命令，需要的资源很少，所以可能在拿到 IO 资源的时候就可以提交成功，并且在超时时间 N 秒未到达之前就返回给了检测系统。</p>
<p>检测系统一看，update 命令没有超时，于是就得到了“系统正常”的结论。</p>
<p>也就是说，这时候在业务系统上正常的 SQL 语句已经执行得很慢了，但是 DBA 上去一看，HA 系统还在正常工作，并且认为主库现在处于可用状态。</p>
<p><strong>根本原因是我们上面说的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随机性。</strong></p>
</blockquote>
<h3 id="内部统计"><a href="#内部统计" class="headerlink" title="内部统计"></a>内部统计</h3><p>在 MySQL 内部发现数据库问题的方法</p>
<p>MySQL 5.6 版本以后提供的 <code>performance_schema 库</code>，就在 <code>file_summary_by_event_name</code> 表里统计了每次 IO 请求的时间。</p>
<blockquote>
<p><code>event_name=&#39;wait/io/file/innodb/innodb_log_file’</code></p>
<p><img src="/article/performance_schema.file_summary_by_event_name 的一行.png"><span class="image-caption">performance_schema.file_summary_by_event_name 的一行</span></p>
<p>图中这一行表示统计的是 redo log 的写入时间，第一列 EVENT_NAME 表示统计的类型。</p>
<p>接下来的三组数据，显示的是 redo log 操作的时间统计。</p>
<p>第一组五列，是所有 IO 类型的统计。其中，COUNT_STAR 是所有 IO 的总次数，接下来四列是具体的统计项， 单位是皮秒；前缀 SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、平均值和最大值。</p>
<p>第二组六列，是读操作的统计。最后一列 SUM_NUMBER_OF_BYTES_READ 统计的是，总共从 redo log 里读了多少个字节。</p>
<p>第三组六列，统计的是写操作。</p>
<p>最后的第四组数据，是对其他类型数据的统计。在 redo log 里，你可以认为它们就是对 fsync 的统计。</p>
<p>在 <code>performance_schema 库</code>的 <code>file_summary_by_event_name</code> 表里，binlog 对应的是 <code>event_name = &quot;wait/io/file/sql/binlog&quot;</code>这一行。各个字段的统计逻辑，与 redo log 的各个字段完全相同。</p>
<p>每一次操作数据库，performance_schema 都需要额外地统计这些信息，所以我们打开这个统计功能是有性能损耗。如果打开所有的 performance_schema 项，性能大概会下降 10% 左右。</p>
<p><strong>建议只打开自己需要的项进行统计</strong></p>
<p>把这个信息用在实例状态诊断上：可以通过 MAX_TIMER 的值来判断数据库是否出问题了</p>
</blockquote>
<h2 id="误删数据后除了跑路，还能怎么办？"><a href="#误删数据后除了跑路，还能怎么办？" class="headerlink" title="误删数据后除了跑路，还能怎么办？"></a>误删数据后除了跑路，还能怎么办？</h2><p>对 MySQL 相关的误删数据，做下分类：</p>
<ol>
<li>使用 delete 语句误删数据行；</li>
<li>使用 drop table 或者 truncate table 语句误删数据表；</li>
<li>使用 drop database 语句误删数据库；</li>
<li>使用 rm 命令误删整个 MySQL 实例。</li>
</ol>
<h3 id="误删行"><a href="#误删行" class="headerlink" title="误删行"></a>误删行</h3><p>如果是使用 delete 语句误删了数据行，可以用 Flashback 工具通过闪回把数据恢复回来。</p>
<p>Flashback 恢复数据的原理，是修改 binlog 的内容，拿回原库重放。</p>
<p><strong>需要确保 <code>binlog_format=row</code> 和 <code>binlog_row_image=FULL</code></strong></p>
<p>具体恢复数据时，对单个事务做如下处理：</p>
<ol>
<li>对于 insert 语句，对应的 binlog event 类型是 <code>Write_rows event</code>，把它改成 <code>Delete_rows event</code> 即可；</li>
<li>同理，对于 delete 语句，也是将 <code>Delete_rows event</code> 改为 <code>Write_rows event</code>；</li>
<li>而如果是 Update_rows 的话，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li>
</ol>
<p>如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行</p>
<p><strong>不建议你直接在主库上执行这些操作</strong>:恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。</p>
<p><strong>更重要是要做到事前预防:</strong></p>
<ol>
<li><p>把 <code>sql_safe_updates</code> 参数设置为 <code>on</code>。这样一来，如果我们忘记在 delete 或者 update 语句中写 where 条件，或者 where 条件里面没有包含索引字段的话，这条语句的执行就会报错。</p>
<blockquote>
<p>如果你确定这个删除操作没问题的话，可以在 delete 语句中加上 where 条件，比如 where id&gt;=0。</p>
<p>但是，delete 全表是很慢的，需要生成回滚日志、写 redo、写 binlog。所以，从性能角度考虑，你应该优先考虑使用 <code>truncate table</code> 或者 <code>drop table</code> 命令。</p>
<p>使用 delete 命令删除的数据，你还可以用 Flashback 来恢复。而使用 <code>truncate /drop table</code> 和 <code>drop database</code> 命令删除的数据，就没办法通过 Flashback 来恢复了</p>
<p>因为，即使我们配置了 <code>binlog_format=row</code>，执行这三个命令时，记录的 binlog 还是 statement 格式。binlog 里面就只有一个 truncate/drop 语句，这些信息是恢复不出数据的。</p>
</blockquote>
</li>
<li><p>代码上线前，必须经过 SQL 审计。</p>
</li>
</ol>
<h3 id="误删库-表"><a href="#误删库-表" class="headerlink" title="误删库 / 表"></a>误删库 / 表</h3><p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份 binlog。</p>
<blockquote>
<p>假如有人中午 12 点误删了一个库，恢复数据的流程如下：</p>
<ol>
<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天 0 点；</li>
<li>用备份恢复出一个临时库；</li>
<li>从日志备份里面，取出凌晨 0 点之后的日志；</li>
<li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li>
</ol>
<p><img src="/article/数据恢复流程 -mysqlbinlog 方法.png"><span class="image-caption">数据恢复流程 -mysqlbinlog 方法</span></p>
</blockquote>
<ol>
<li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用 mysqlbinlog 命令时，加上一个<code>–database</code> 参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。</li>
<li>在应用日志的时候，需要跳过 12 点误操作的那个语句的 binlog：<ol>
<li>如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用<code>–stop-position</code> 参数执行到误操作之前的日志，然后再用<code>–start-position</code> 从误操作之后的日志继续执行；</li>
<li>如果实例使用了 GTID 模式，就方便多了。假设误操作命令的 GTID 是 gtid1，那么只需要执行 <code>set gtid_next=gtid1;begin;commit;</code> 先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时候，就会自动跳过误操作的语句。</li>
</ol>
</li>
</ol>
<p><strong>使用 mysqlbinlog 方法恢复数据还是不够快</strong>，主要原因有两个：</p>
<ol>
<li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是 mysqlbinlog 工具并不能指定只解析一个表的日志；</li>
<li>用 mysqlbinlog 解析出日志应用，应用日志的过程就只能是单线程。</li>
</ol>
<p><strong>一种加速的方法是</strong>，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：</p>
<ol>
<li>在 <code>start slave</code> 之前，先通过执行﻿﻿<code>change replication filter replicate_do_table = (tbl_name)</code> 命令，就可以让临时库只同步误操作的表；</li>
<li>这样做也可以用上并行复制技术，来加速整个数据恢复过程。</li>
</ol>
<p>不论是把 mysqlbinlog 工具解析出的 binlog 文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：<strong>误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用 binlog 的方式。</strong></p>
<p>这两个方案都要求备份系统定期备份全量日志，而且需要确保 binlog 在被从本地删除之前已经做了备份。</p>
<h4 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h4><blockquote>
<p>虽然可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。</p>
<p>如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第 6 天发生误操作，那就需要恢复 6 天的日志，这个恢复时间可能是要按天来计算的。</p>
</blockquote>
<p><strong>缩短恢复数据需要的时间:</strong></p>
<p>如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑<strong>搭建延迟复制的备库</strong>。这个功能是 MySQL 5.6 版本引入的。</p>
<p>延迟复制的备库是一种特殊的备库，通过 <code>CHANGE MASTER TO MASTER_DELAY = N</code> 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。</p>
<h4 id="预防误删库-表的方法"><a href="#预防误删库-表的方法" class="headerlink" title="预防误删库 / 表的方法"></a>预防误删库 / 表的方法</h4><ol>
<li>账号分离，避免写错命令<ol>
<li>只给业务开发 DML 权限，而不给 truncate/drop 权限。而如果业务开发人员有 DDL 需求的话，也可以通过开发管理系统得到支持。</li>
<li>即使是 DBA 团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li>
</ol>
</li>
<li>制定操作规范，是避免写错要删除的表名<ol>
<li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li>
<li>改表名的时候，要求给表名加固定的后缀（比如加 _to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li>
</ol>
</li>
</ol>
<h3 id="rm-删除数据"><a href="#rm-删除数据" class="headerlink" title="rm 删除数据"></a>rm 删除数据</h3><p>对于一个有高可用机制的 MySQL 集群来说，最不怕的就是 rm 删除数据了。只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA 系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。</p>
<h2 id="为什么还有kill不掉的语句？"><a href="#为什么还有kill不掉的语句？" class="headerlink" title="为什么还有kill不掉的语句？"></a>为什么还有kill不掉的语句？</h2><p>在 MySQL 中有两个 kill 命令:</p>
<ol>
<li>kill query + 线程 id，表示终止这个线程中正在执行的语句；</li>
<li>kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</li>
</ol>
<blockquote>
<p>问题：使用了 kill 命令，却没能断开这个连接。再执行 show processlist 命令，看到这条语句的 Command 列显示的是 Killed</p>
</blockquote>
<h3 id="收到-kill-以后，线程做什么？"><a href="#收到-kill-以后，线程做什么？" class="headerlink" title="收到 kill 以后，线程做什么？"></a>收到 kill 以后，线程做什么？</h3><p>kill 并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。</p>
<p>当用户执行 kill 时，MySQL 里处理 kill 命令的线程做了两件事：</p>
<ol>
<li>把运行状态改成 THD::KILL_QUERY(将变量 killed 赋值为 THD::KILL_QUERY)；</li>
<li>给执行线程发一个信号。</li>
</ol>
<p>所以：</p>
<ol>
<li>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑；</li>
<li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；</li>
<li>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。</li>
</ol>
<p>在执行 show processlist 的时候，有一个特别的逻辑：<strong>如果一个线程的状态是KILL_CONNECTION，就把Command列显示成Killed</strong>。即使是客户端退出了，这个线程的状态仍然是在等待中。只有等到满足进入 InnoDB 的条件后，才有可能判断到线程状态已经变成了 KILL_QUERY 或者 KILL_CONNECTION，再进入终止逻辑阶段。</p>
<p><strong>kill 无效：</strong></p>
<ol>
<li>线程没有执行到判断线程状态的逻辑</li>
<li>由于 IO 压力过大，读写 IO 的函数一直无法返回，导致不能及时判断线程的状态</li>
<li>终止逻辑耗时较长<ol>
<li>超大事务执行期间被 kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</li>
<li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长。</li>
<li>DDL 命令执行到最后阶段，如果被 kill，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久。</li>
</ol>
</li>
</ol>
<h4 id="两个关于客户端的误解"><a href="#两个关于客户端的误解" class="headerlink" title="两个关于客户端的误解"></a>两个关于客户端的误解</h4><ol>
<li><p>如果库里面的表特别多，连接就会很慢</p>
<blockquote>
<p>当使用默认参数连接的时候，MySQL 客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</p>
<ol>
<li>执行 show databases；</li>
<li>切到库，执行 show tables；</li>
<li>把这两个命令的结果用于构建一个本地的哈希表。</li>
</ol>
</blockquote>
<p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。</p>
<p><strong>我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。</strong></p>
<blockquote>
<p>如果在连接命令中加上 <code>-A</code>，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了。</p>
</blockquote>
</li>
<li><p><code>–quick</code> 引起误会的参数</p>
<p>加<code>–quick</code>(或者简写为 <code>-q</code>) 参数，也可以关掉这个自动补全的功能</p>
<p>设置了这个参数可能会降低服务端的性能</p>
<blockquote>
<p>MySQL 客户端发送请求后，接收服务端返回结果的方式有两种：</p>
<ol>
<li>一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果你用 API 开发，对应的就是 mysql_store_result 方法。</li>
<li>另一种是不缓存，读一个处理一个。如果你用 API 开发，对应的就是 mysql_use_result 方法。</li>
</ol>
<p>MySQL 客户端默认采用第一种方式，而如果加上–quick 参数，就会使用第二种不缓存的方式。</p>
</blockquote>
<p>采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。</p>
<p>使用<code>–quick</code>参数可以达到以下三点效果：</p>
<ol>
<li>第一点，就是前面提到的，跳过表名自动补全功能。</li>
<li>第二点，mysql_store_result 需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能；</li>
<li>第三点，是不会把执行命令记录到本地的命令历史文件。</li>
</ol>
<p><code>–quick</code>参数的意思，是让客户端变得更快</p>
</li>
</ol>
<h2 id="我查这么多数据，会不会把数据库内存打爆？"><a href="#我查这么多数据，会不会把数据库内存打爆？" class="headerlink" title="我查这么多数据，会不会把数据库内存打爆？"></a>我查这么多数据，会不会把数据库内存打爆？</h2><h3 id="全表扫描对-server-层的影响"><a href="#全表扫描对-server-层的影响" class="headerlink" title="全表扫描对 server 层的影响"></a>全表扫描对 server 层的影响</h3><blockquote>
<p>假设，我们现在要对一个 200G 的 InnoDB 表 db1.t，执行一个全表扫描。当然，你要把扫描结果保存在客户端，会使用类似这样的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql -h<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.982ex" height="2.343ex" style="vertical-align: -0.505ex;" viewbox="0 -791.3 3867.4 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">host -P</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="576" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="1062" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="1531" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="2115" y="0"/>
 <use xlink:href="#E1-MJMATHI-50" x="3115" y="0"/>
</g>
</svg>port -u<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.562ex" height="2.343ex" style="vertical-align: -0.671ex;" viewbox="0 -719.6 3686.4 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">user -p</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
<path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-75" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="572" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="1042" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="1508" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="2182" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="3182" y="0"/>
</g>
</svg>pwd -e &quot;select * from db1.t&quot; &gt; $target_file<br></code></pre></td></tr></table></figure>
<p>InnoDB 的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表 t 的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到<strong>结果集</strong>里面，然后返回给客户端。</p>
<p>实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：</p>
<ol>
<li>获取一行，写到 net_buffer 中。这块内存的大小是由参数 <code>net_buffer_length</code> 定义的，默认是 16k。</li>
<li>重复获取行，直到 net_buffer 写满，调用网络接口发出去。</li>
<li>如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer。</li>
<li>如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</li>
</ol>
<img src="/article/10821/%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.jpg" class title="查询结果发送流程">
<ol>
<li>一个查询在发送过程中，占用的 MySQL 内部的内存最大就是 net_buffer_length 这么大，并不会达到 200G；</li>
<li>socket send buffer 也不可能达到 200G（默认定义 /proc/sys/net/core/wmem_default），如果 socket send buffer 被写满，就会暂停读数据的流程。</li>
</ol>
</blockquote>
<p>MySQL 是<strong>“边读边发的”</strong>。这就意味着，如果客户端接收得慢，会导致 MySQL 服务端由于结果发不出去，这个事务的执行时间变长。</p>
<p>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，建议使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。</p>
<h3 id="全表扫描对-InnoDB-的影响"><a href="#全表扫描对-InnoDB-的影响" class="headerlink" title="全表扫描对 InnoDB 的影响"></a>全表扫描对 InnoDB 的影响</h3><p>内存的数据页是在 Buffer Pool (BP) 中管理的，在 WAL 里 Buffer Pool 起到了加速更新的作用。而实际上，Buffer Pool 还有一个更重要的作用，就是加速查询。</p>
<p>Buffer Pool 对查询的加速效果，依赖于一个重要的指标，即：<strong>内存命中率</strong>。</p>
<blockquote>
<p>可以在 <code>show engine innodb status</code> 结果中，查看一个系统当前的 BP 命中率。一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在 99% 以上。</p>
</blockquote>
<p>InnoDB Buffer Pool 的大小是由参数 <code>innodb_buffer_pool_size</code> 确定的，一般建议设置成可用物理内存的 60%~80%。</p>
<p>InnoDB 内存管理用的是<strong>最近最少使用 (Least Recently Used, LRU) 算法</strong>，这个算法的核心就是淘汰最久未使用的数据。</p>
<blockquote>
<p><strong>基础的未改进的LRU算法</strong></p>
<p><img src="/article/基本 LRU 算法.jpg"><span class="image-caption">基本 LRU 算法</span></p>
<ol>
<li>在状态 1 里，链表头部是 P1，表示 P1 是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页；</li>
<li>这时候有一个读请求访问 P3，因此变成状态 2，P3 被移到最前面；</li>
<li>状态 3 表示，这次访问的数据页是不存在于链表中的，所以需要在 Buffer Pool 中新申请一个数据页 Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾 Pm 这个数据页的内存，存入 Px 的内容，然后放到链表头部。</li>
<li>从效果上看，就是最久没有被访问的数据页 Pm，被淘汰了。</li>
</ol>
<hr>
<p><strong>问题：</strong>假设按照这个算法，我们要扫描一个 200G 的表，而这个表是一个历史数据表，平时没有业务访问它。那么，按照这个算法扫描的话，就会把当前的 Buffer Pool 里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。也就是说 Buffer Pool 里面主要放的是这个历史数据表的数据。对于一个正在做业务服务的库，这可不妙。你会看到，Buffer Pool 的内存命中率急剧下降，磁盘压力增加，SQL 语句响应变慢。</p>
</blockquote>
<p><strong>InnoDB 对 LRU 算法做了改进</strong></p>
<blockquote>
<p><strong>改进的 LRU 算法</strong></p>
<p><img src="/article/改进的 LRU 算法.png"><span class="image-caption">改进的 LRU 算法</span></p>
<p>在 InnoDB 实现上，按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。图中 LRU_old 指向的就是 old 区域的第一个位置，是整个链表的 5/8 处。也就是说，靠近链表头部的 5/8 是 young 区域，靠近链表尾部的 3/8 是 old 区域。</p>
<ol>
<li>图中状态 1，要访问数据页 P3，由于 P3 在 young 区域，因此和优化前的 LRU 算法一样，将其移到链表头部，变成状态 2。</li>
<li>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页 Pm，但是新插入的数据页 Px，是放在 LRU_old 处。</li>
<li>处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：<ol>
<li>若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；</li>
<li>如果这个数据页在 LRU 链表中存在的时间短于 1 秒，位置保持不变。1 秒这个时间，是由参数 <code>innodb_old_blocks_time</code> 控制的。其默认值是 1000，单位毫秒。</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="到底可不可以使用join？"><a href="#到底可不可以使用join？" class="headerlink" title="到底可不可以使用join？"></a>到底可不可以使用join？</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t2` (<br>  `id` int(11) NOT NULL,<br>  `a` int(11) DEFAULT NULL,<br>  `b` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `a` (`a`)<br>) ENGINE=InnoDB;<br><br>drop procedure idata;<br>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=1;<br>  while(i&lt;=1000)do<br>    insert into t2 values(i, i, i);<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;<br>call idata();<br><br>create table t1 like t2;<br>insert into t1 (select * from t2 where id&lt;=100)<br></code></pre></td></tr></table></figure>
<p>这两个表都有一个主键索引 id 和一个索引 a，字段 b 上无索引。存储过程 idata() 往表 t2 里插入了 1000 行数据，在表 t1 里插入的是 100 行数据。</p>
</blockquote>
<h3 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from t1 straight_join t2 on (t1.a=t2.a);<br></code></pre></td></tr></table></figure>
<p>如果直接使用 join 语句，MySQL 优化器可能会选择表 t1 或 t2 作为驱动表，这样会影响我们分析 SQL 语句的执行过程。</p>
<p>所以，为了便于分析执行过程中的性能问题，改用 <code>straight_join</code> 让 MySQL 使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去 join。在这个语句里，t1 是驱动表，t2 是被驱动表。</p>
<p>执行流程：</p>
<ol>
<li>从表 t1 中读入一行数据 R；</li>
<li>从数据行 R 中，取出 a 字段到表 t2 里去查找；</li>
<li>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；</li>
<li>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。</li>
</ol>
<p>这个过程是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“<strong>Index Nested-Loop Join</strong>”，简称 NLJ。</p>
<p><img src="/article/Index Nested-Loop Join 算法的执行流程.jpg"><span class="image-caption">Index Nested-Loop Join 算法的执行流程</span></p>
<p>在这个流程里：</p>
<ol>
<li>对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；</li>
<li>而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；</li>
<li>所以，整个执行流程，总扫描行数是 200。</li>
</ol>
</blockquote>
<p><strong>使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好；</strong></p>
<p><strong>如果使用 join 语句的话，需要让小表做驱动表（前提是“可以使用被驱动表的索引”）。</strong></p>
<h3 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from t1 straight_join t2 on (t1.a=t2.b);<br></code></pre></td></tr></table></figure>
<p>由于表 t2 的字段 b 上没有索引，每次到 t2 去匹配的时候，就要做一次全表扫描。</p>
<p>由于表 t2 的字段 b 上没有索引，因此再用图 2 的执行流程时，每次到 t2 去匹配的时候，就要做一次全表扫描。</p>
<p>这样算来，这个 SQL 请求就要扫描表 t2 多达 100 次，总共扫描 100*1000=10 万行。</p>
</blockquote>
<h3 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from t1 straight_join t2 on (t1.a=t2.b);<br></code></pre></td></tr></table></figure>
<p>被驱动表上没有可用的索引，算法的流程是这样的：</p>
<ol>
<li>把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；</li>
<li>扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</li>
</ol>
<p><img src="/article/Block Nested-Loop Join 算法的执行流程.jpg"><span class="image-caption">Block Nested-Loop Join 算法的执行流程</span></p>
<p>在这个过程中，对表 t1 和 t2 都做了一次全表扫描，因此总的扫描行数是 1100。由于 join_buffer 是以无序数组的方式组织的，因此对表 t2 中的每一行，都要做 100 次判断，总共需要在内存中做的判断次数是：100*1000=10 万次</p>
<p>如果使用 Simple Nested-Loop Join 算法进行查询，扫描行数也是 10 万行。因此，从<strong>时间复杂度上来说，这两个算法是一样</strong>的。但是，<strong>Block Nested-Loop Join 算法的这 10 万次判断是内存操作，速度上会快很多，性能也更好</strong>。</p>
</blockquote>
<p><strong>驱动表选择：</strong></p>
<p>假设小表的行数是 N，大表的行数是 M，那么在这个算法里：</p>
<ol>
<li>两个表都做一次全表扫描，所以总的扫描行数是 M+N；</li>
<li>内存中的判断次数是 M*N。</li>
</ol>
<p>可以看到，调换这两个算式中的 M 和 N 没差别，因此这时候<strong>选择大表还是小表做驱动表，执行耗时是一样的。</strong></p>
<blockquote>
<p><strong>问题：要是表 t1 是一个大表，join_buffer 放不下怎么办呢？</strong></p>
<p>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t1 的所有数据话，策略很简单，就是<strong>分段放</strong>。</p>
<p>执行过程就变成了：</p>
<ol>
<li>扫描表 t1，顺序读取数据行放入 join_buffer 中，中途join_buffer 满了，继续第 2 步；</li>
<li>扫描表 t2，把 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回；</li>
<li>清空 join_buffer；</li>
<li>继续扫描表 t1，顺序读取最后的 12 行数据放入 join_buffer 中，继续执行第 2 步。</li>
</ol>
<p><img src="/article/Block Nested-Loop Join -- 两段.jpg"><span class="image-caption">Block Nested-Loop Join -- 两段</span></p>
</blockquote>
<p><strong>驱动表选择：</strong></p>
<p>假设，驱动表的数据行数是 N，需要分 K 段才能完成算法流程，被驱动表的数据行数是 M。</p>
<p>注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为λ*N，显然λ的取值范围是 (0,1)。</p>
<p>所以，在这个算法的执行过程中：</p>
<ol>
<li>扫描行数是 N+λ<em>N</em>M；</li>
<li>内存判断 N*M 次。</li>
</ol>
<p><strong>应该让小表当驱动表。</strong></p>
<hr>
<blockquote>
<p><strong>Simple Nested Loop Join 的性能问题</strong></p>
<p>虽然 BNL 算法和 Simple Nested Loop Join 算法都是要判断 M*N 次（M 和 N 分别是 join 的两个表的行数），但是 Simple Nested Loop Join 算法的每轮判断都要走全表扫描，因此性能上 BNL 算法执行起来会快很多。</p>
<blockquote>
<p>BNL 算法的执行逻辑是：</p>
<ol>
<li>首先，将驱动表的数据全部读入内存 join_buffer 中，这里 join_buffer 是无序数组；</li>
<li>然后，顺序遍历被驱动表的所有行，每一行数据都跟 join_buffer 中的数据进行匹配，匹配成功则作为结果集的一部分返回。</li>
</ol>
</blockquote>
<blockquote>
<p>Simple Nested Loop Join 算法的执行逻辑是：</p>
<p>顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。</p>
</blockquote>
<blockquote>
<p>MySQL 中索引结构和 Buffer Pool 的相关知识点：</p>
<ol>
<li><p>在对被驱动表做全表扫描的时候，如果数据没有在 Buffer Pool 中，就需要等待这部分数据从磁盘读入；</p>
<p>从磁盘读入数据到内存中，会影响正常业务的 Buffer Pool 命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到 Buffer Pool 的头部；</p>
</li>
<li><p>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而 join_buffer 中是数组，遍历的成本更低。</p>
</li>
</ol>
</blockquote>
<p><strong>所以说，BNL 算法的性能会更好</strong></p>
</blockquote>
<hr>
<h3 id="能不能使用-join-语句？"><a href="#能不能使用-join-语句？" class="headerlink" title="能不能使用 join 语句？"></a>能不能使用 join 语句？</h3><ol>
<li>如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li>
<li>如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要用。</li>
</ol>
<blockquote>
<p>所以你在判断要不要使用 join 语句时，就是看 explain 结果里面，Extra 字段里面有没有出现“Block Nested Loop”字样。</p>
</blockquote>
<h3 id="如果要使用-join，应该选择大表做驱动表还是选择小表做驱动表？"><a href="#如果要使用-join，应该选择大表做驱动表还是选择小表做驱动表？" class="headerlink" title="如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？"></a>如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？</h3><ol>
<li>如果是 Index Nested-Loop Join 算法，应该选择小表做驱动表；</li>
<li>如果是 Block Nested-Loop Join 算法：<ol>
<li>在 join_buffer_size 足够大的时候，是一样的；</li>
<li>在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表。</li>
</ol>
</li>
</ol>
<p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p>
<h2 id="join语句怎么优化？"><a href="#join语句怎么优化？" class="headerlink" title="join语句怎么优化？"></a>join语句怎么优化？</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table t1(id int primary key, a int, b int, index(a));<br>create table t2 like t1;<br>drop procedure idata;<br>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=1;<br>  while(i&lt;=1000)do<br>    insert into t1 values(i, 1001-i, i);<br>    set i=i+1;<br>  end while;<br>  <br>  set i=1;<br>  while(i&lt;=1000000)do<br>    insert into t2 values(i, i, i);<br>    set i=i+1;<br>  end while;<br><br>end;;<br>delimiter ;<br>call idata();<br></code></pre></td></tr></table></figure>
<p>在表 t1 里，插入了 1000 行数据，每一行的 a=1001-id 的值。也就是说，表 t1 中字段 a 是逆序的。同时，在表 t2 中插入了 100 万行数据。</p>
</blockquote>
<h3 id="Multi-Range-Read-优化"><a href="#Multi-Range-Read-优化" class="headerlink" title="Multi-Range Read 优化"></a>Multi-Range Read 优化</h3><p><strong>Multi-Range Read 优化 (MRR)：这个优化的主要目的是尽量使用顺序读盘。</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from t1 where a&gt;=1 and a&lt;=100;<br></code></pre></td></tr></table></figure>
<p>主键索引是一棵 B+ 树，在这棵树上，每次只能根据一个主键 id 查到一行数据。因此，回表肯定是一行行搜索主键索引的，基本流程如图所示</p>
<img src="/article/10821/%E5%9F%BA%E6%9C%AC%E5%9B%9E%E8%A1%A8%E6%B5%81%E7%A8%8B.png" class title="基本回表流程">
<p>如果随着 a 的值递增顺序查询的话，id 的值就变成随机的，那么就会出现随机访问，性能相对较差。(a虽然是倒叙存放在表中，但a上有B+tree索引，是顺序存储的，但是a索引的叶子节点存放的id的值是倒叙的，a索引的范围查询通过id回表查询，b+tree索引都是顺序存储的，那么通过a索引获取到的ID是倒序的，不是按照索引顺序查询就变成了随机查询。)</p>
</blockquote>
<p><strong>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p>
<blockquote>
<p>使用 MRR 优化，语句的执行流程变成了这样：</p>
<ol>
<li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</li>
<li>将 read_rnd_buffer 中的 id 进行递增排序；</li>
<li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li>
</ol>
<p>read_rnd_buffer 的大小是由 <code>read_rnd_buffer_size</code> 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</p>
</blockquote>
<p>如果你想要稳定地使用 MRR 优化的话，需要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code></p>
<p><strong>MRR 能够提升性能的核心</strong>在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p>
<h3 id="Batched-Key-Access"><a href="#Batched-Key-Access" class="headerlink" title="Batched Key Access"></a>Batched Key Access</h3><p>MySQL 在 5.6 版本后开始引入的 Batched Key Access(BKA) 算法。是对 NLJ 算法的优化。</p>
<blockquote>
<p>NLJ 算法执行的逻辑是：从驱动表 t1，一行行地取出 a 的值，再到被驱动表 t2 去做 join。也就是说，对于表 t2 来说，每次都是匹配一个值。这时，MRR 的优势就用不上了。</p>
</blockquote>
<blockquote>
<p>把表 t1 的数据取出来一部分，先放到一个临时内存(join_buffer)，<strong>复用 join_buffer 到 BKA 算法中</strong></p>
<p><img src="/article/Batched Key Access 流程.png"><span class="image-caption">Batched Key Access 流程</span></p>
</blockquote>
<p>如果要使用 BKA 优化算法的话，你需要在执行 SQL 语句之前，先设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">set optimizer_switch=&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;;<br></code></pre></td></tr></table></figure>
<p>前两个参数的作用是要启用 MRR</p>
<h3 id="BNL-算法的性能问题"><a href="#BNL-算法的性能问题" class="headerlink" title="BNL 算法的性能问题"></a>BNL 算法的性能问题</h3><p>大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</p>
<p><strong>为了减少这种影响，你可以考虑增大 join_buffer_size 的值，减少对被驱动表的扫描次数</strong></p>
<p>BNL 算法对系统的影响主要包括三个方面：</p>
<ol>
<li>可能会多次扫描被驱动表，占用磁盘 IO 资源；</li>
<li>判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；</li>
<li>可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。</li>
</ol>
<p><strong>优化</strong>的常见做法是，给被驱动表的 join 字段加上索引，<strong>把 BNL 算法转成 BKA 算法</strong>。</p>
<p>让 join 语句能够用上被驱动表上的索引，来触发 BKA 算法，提升查询性能</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>BKA 优化是 MySQL 已经内置支持的，建议你默认使用；</li>
<li>BNL 算法效率低，建议你都尽量转成 BKA 算法。优化的方向就是给被驱动表的关联字段加上索引；</li>
<li>基于临时表的改进方案，对于能够提前过滤出小数据的 join 语句来说，效果还是很好的；</li>
<li>MySQL 目前的版本还不支持 hash join，但你可以配合应用端自己模拟出来，理论上效果要好于临时表的方案。</li>
</ol>
<hr>
<blockquote>
<p><strong>问题：如果用 left join 的话，左边的表一定是驱动表吗？</strong></p>
<p><strong>问题：如果两个表的 join 包含多个条件的等值匹配，是都要写到 on 里面呢，还是只把一个条件写到 on 里面，其他条件写到 where 部分？</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table a(f1 int, f2 int, index(f1))engine=innodb;<br>create table b(f1 int, f2 int)engine=innodb;<br>insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);<br>insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);<br></code></pre></td></tr></table></figure>
<p>表 a 和 b 都有两个字段 f1 和 f2，不同的是表 a 的字段 f1 上有索引。然后，往两个表中都插入了 6 条记录，其中在表 a 和 b 中同时存在的数据有 4 行。</p>
</blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from a left join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q1*/<br>select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q2*/<br></code></pre></td></tr></table></figure>
<p>第二个问题的两种写法</p>
<p><img src="/article/两个 join 的查询结果.png"><span class="image-caption">两个 join 的查询结果</span></p>
<ol>
<li><p>语句 Q1 返回的数据集是 6 行，表 a 中即使没有满足匹配条件的记录，查询结果中也会返回一行，并将表 b 的各个字段值填成 NULL。</p>
<blockquote>
<p><img src="/article/Q1 的 explain 结果.jpg"><span class="image-caption">Q1 的 explain 结果</span></p>
<ol>
<li>驱动表是表 a，被驱动表是表 b；</li>
<li>由于表 b 的 f1 字段上没有索引，所以使用的是 Block Nested Loop Join（简称 BNL） 算法。</li>
</ol>
</blockquote>
<blockquote>
<p>这条语句的执行流程:</p>
<ol>
<li>把表 a 的内容读入 join_buffer 中。因为是 select * ，所以字段 f1 和 f2 都被放入 join_buffer 了。</li>
<li>顺序扫描表 b，对于每一行数据，判断 join 条件（也就是 (a.f1=b.f1) and (a.f1=1)）是否满足，满足条件的记录, 作为结果集的一行返回。如果语句中有 where 子句，需要先判断 where 部分满足条件后，再返回。</li>
<li>表 b 扫描完成后，对于没有被匹配的表 a 的行（在这个例子中就是 (1,1)、(2,2) 这两行），把剩余字段补上 NULL，再放入结果集中。</li>
</ol>
<p><img src="/article/left join -BNL 算法.jpg"><span class="image-caption">left join -BNL 算法</span></p>
</blockquote>
</li>
<li><p>语句 Q2 返回的是 4 行。从逻辑上可以这么理解，最后的两行，由于表 b 中没有匹配的字段，结果集里面 b.f2 的值是空，不满足 where 部分的条件判断，因此不能作为结果集的一部分。</p>
<blockquote>
<p><img src="/article/Q2 的 explain 结果.jpg"><span class="image-caption">Q2 的 explain 结果</span></p>
<ol>
<li>这条语句是以表 b 为驱动表的</li>
<li>如果一条 join 语句的 Extra 字段什么都没写的话，就表示使用的是 Index Nested-Loop Join（简称 NLJ）算法。</li>
</ol>
</blockquote>
<blockquote>
<p>语句 Q2 的执行流程:</p>
<ol>
<li>顺序扫描表 b，每一行用 b.f1 到表 a 中去查</li>
<li>匹配到记录后判断 a.f2=b.f2 是否满足，满足条件的话就作为结果集的一部分返回。</li>
</ol>
<p>语句 Q2 里面 where a.f2=b.f2 表示，查询结果里面不会包含 b.f2 是 NULL 的行，这样这个 left join 的语义就是“找到这两个表里面，f1、f2 对应相同的行。对于表 a 中存在，而表 b 中匹配不到的行，就放弃”。</p>
</blockquote>
<blockquote>
<p>这条语句虽然用的是 left join，但是语义跟 join 是一致的</p>
<p>因此，优化器就把这条语句的 left join 改写成了 join，然后因为表 a 的 f1 上有索引，就把表 b 作为驱动表，这样就可以用上 NLJ 算法。在执行 explain 之后，再执行 show warnings，就能看到这个改写的结果:</p>
<p><img src="/article/Q2 的改写结果.jpg"><span class="image-caption">Q2 的改写结果</span></p>
</blockquote>
<p>这个例子说明，即使我们在 SQL 语句中写成 left join，执行过程还是有可能不是从左到右连接的。也就是说，<strong>使用 left join 时，左边的表不一定是驱动表。</strong></p>
</li>
</ol>
</blockquote>
<p><strong>如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面。</strong></p>
<p><strong>join 将判断条件是否全部放在 on 部分没有区别</strong></p>
</blockquote>
<h2 id="为什么临时表可以重名？"><a href="#为什么临时表可以重名？" class="headerlink" title="为什么临时表可以重名？"></a>为什么临时表可以重名？</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create temporary table temp_t like t1;<br>alter table temp_t add index(b);<br>insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;<br>select * from t1 join temp_t on (t1.b=temp_t.b);<br></code></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>内存表，指的是使用 Memory 引擎的表，建表语法是 <code>create table … engine=memory</code>。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</li>
<li>临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎。</li>
</ol>
<h3 id="临时表的特性"><a href="#临时表的特性" class="headerlink" title="临时表的特性"></a>临时表的特性</h3><p>临时表在使用上有以下几个特点：</p>
<ol>
<li>建表语法是 <code>create temporary table …</code>。</li>
<li>一个临时表只能被创建它的 session 访问，对其他线程不可见。由于临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。</li>
<li>临时表可以与普通表同名。</li>
<li>有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li>
<li>show tables 命令不显示临时表。</li>
</ol>
<blockquote>
<p>临时表就特别适合我们文章开头的 join 优化这种场景:</p>
<ol>
<li>不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。</li>
<li>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。</li>
</ol>
</blockquote>
<h3 id="临时表的应用"><a href="#临时表的应用" class="headerlink" title="临时表的应用"></a>临时表的应用</h3><p>由于不用担心线程之间的重名冲突，临时表经常会被用在<strong>复杂查询的优化过程</strong>中。其中，分库分表系统的跨库查询就是一个典型的使用场景。</p>
<blockquote>
<p>一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如。将一个大表 ht，按照字段 f，拆分成 1024 个分表，然后分布到 32 个数据库实例上。如下图所示：</p>
<img src="/article/10821/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%AE%80%E5%9B%BE.jpg" class title="分库分表简图">
<p>一般情况下，这种分库分表系统都有一个中间层 proxy。不过，也有一些方案会让客户端直接连接数据库，也就是没有 proxy 这一层。</p>
<p>在这个架构中，分区 key 的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含 f 的等值条件，那么就要用 f 做分区键。这样，在 proxy 这一层解析完 SQL 语句以后，就能确定将这条语句路由到哪个分表做查询。</p>
<p>比如下面这条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select v from ht where f=N;<br></code></pre></td></tr></table></figure>
<p>这时，我们就可以通过分表规则（比如，N%1024) 来确认需要的数据被放在了哪个分表上。这种语句只需要访问一个分表，是分库分表方案最欢迎的语句形式了。</p>
<p>但是，如果这个表上还有另外一个索引 k，并且查询语句是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select v from ht where k &gt;= M order by t_modified desc limit 100;<br></code></pre></td></tr></table></figure>
<p>这时候，由于查询条件里面没有用到分区字段 f，只能到所有的分区中去查找满足条件的所有行，然后统一做 order by 的操作。这种情况下，有两种比较常用的思路。</p>
<p><strong>第一种思路是</strong>，在 proxy 层的进程代码中实现排序。</p>
<p>这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显：</p>
<ol>
<li>需要的开发工作量比较大。我们举例的这条语句还算是比较简单的，如果涉及到复杂的操作，比如 group by，甚至 join 这样的操作，对中间层的开发能力要求比较高；</li>
<li>对 proxy 端的压力比较大，尤其是很容易出现内存不够用和 CPU 瓶颈的问题。</li>
</ol>
<p><strong>另一种思路就是</strong>，把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。</p>
<p>比如上面这条语句，执行流程可以类似这样：</p>
<ol>
<li><p>在汇总库上创建一个临时表 temp_ht，表里包含三个字段 v、k、t_modified；</p>
</li>
<li><p>在各个分库上执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select v,k,t_modified from ht_x where k &gt;= M order by t_modified desc limit 100;<br></code></pre></td></tr></table></figure>
</li>
<li><p>把分库执行的结果插入到 temp_ht 表中；</p>
</li>
<li><p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select v from temp_ht order by t_modified desc limit 100;<br></code></pre></td></tr></table></figure>
</li>
<li><p>得到结果。</p>
</li>
</ol>
<img src="/article/10821/%E8%B7%A8%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" class title="跨库查询流程示意图">
<p>在实践中，我们往往会发现每个分库的计算量都不饱和，所以会直接把临时表 temp_ht 放到 32 个分库中的某一个上。</p>
</blockquote>
<h3 id="为什么临时表可以重名？-1"><a href="#为什么临时表可以重名？-1" class="headerlink" title="为什么临时表可以重名？"></a>为什么临时表可以重名？</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create temporary table temp_t(id int primary key)engine=innodb;<br></code></pre></td></tr></table></figure>
<p>这个语句的时候，MySQL 要给这个 InnoDB 表创建一个 frm 文件保存表结构定义，还要有地方保存表数据。</p>
<p>这个 frm 文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程 id}<em>{线程 id}</em> 序列号”。你可以使用 <code>select @@tmpdir</code> 命令，来显示实例的临时文件目录</p>
</blockquote>
<p>而关于表中数据的存放方式，在不同的 MySQL 版本中有着不同的处理方式：</p>
<ol>
<li>在 5.6 以及之前的版本里，MySQL 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件；</li>
<li>而从 5.7 版本开始，MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建 ibd 文件了。</li>
</ol>
<blockquote>
<p>从文件名的前缀规则，我们可以看到，其实创建一个叫作 t1 的 InnoDB 临时表，MySQL 在存储上认为我们创建的表名跟普通表 t1 是不同的，因此同一个库下面已经有普通表 t1 的情况下，还是可以再创建一个临时表 t1 的。</p>
</blockquote>
<p>MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个 table_def_key。</p>
<ol>
<li>一个普通表的 table_def_key 的值是由“库名 + 表名”得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了。</li>
<li>而对于临时表，table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”。</li>
</ol>
<p>在实现上，每个线程都维护了自己的临时表链表。这样每次 session 内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在 session 结束的时候，对链表里的每个临时表，执行 <code>“DROP TEMPORARY TABLE + 表名”</code>操作。</p>
<h3 id="临时表和主备复制"><a href="#临时表和主备复制" class="headerlink" title="临时表和主备复制"></a>临时表和主备复制</h3><p>binlog 中也记录了 <code>DROP TEMPORARY TABLE</code> 这条命令</p>
<p><strong>既然写 binlog，就意味着备库需要。</strong></p>
<p>如果当前的 <code>binlog_format=row</code>，那么跟临时表有关的语句，就不会记录到 binlog 里。也就是说，只在 <code>binlog_format=statment/mixed</code> 的时候，binlog 中才会记录临时表的操作。</p>
<p>这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个 <code>DROP TEMPORARY TABLE</code> 传给备库执行。</p>
<hr>
<blockquote>
<p><strong>问题：主库上不同的线程创建同名的临时表是没关系的，但是传到备库执行是怎么处理的呢？</strong></p>
<p>MySQL 在记录 binlog 的时候，会把主库执行这个语句的线程 id 写到 binlog 中。这样，在备库的应用线程就能够知道执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key。</p>
<p>由于 table_def_key 不同，所以这两个表在备库的应用线程里面是不会冲突的。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>问题：为什么不能用 rename 修改临时表的改名。</strong></p>
<p>在实现上，执行 rename table 语句的时候，要求按照“库名 / 表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的 frm 文件是放在 tmpdir 目录下的，并且文件名的规则是“#sql{进程 id}<em>{线程 id}</em> 序列号.frm”，因此会报“找不到文件名”的错误。</p>
</blockquote>
<h2 id="什么时候会使用内部临时表？"><a href="#什么时候会使用内部临时表？" class="headerlink" title="什么时候会使用内部临时表？"></a>什么时候会使用内部临时表？</h2><h3 id="union-执行流程"><a href="#union-执行流程" class="headerlink" title="union 执行流程"></a>union 执行流程</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table t1(id int primary key, a int, b int, index(a));<br>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br><br>  set i=1;<br>  while(i&lt;=1000)do<br>    insert into t1 values(i, i, i);<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;<br>call idata();<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">(select 1000 as f) union (select id from t1 order by id desc limit 2);<br></code></pre></td></tr></table></figure>
<p>这条语句用到了 union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。</p>
<p>下图是这个语句的 explain 结果:</p>
<p><img src="/article/union 语句 explain 结果.png"><span class="image-caption">union 语句 explain 结果</span></p>
<ol>
<li>第二行的 key=PRIMARY，说明第二个子句用到了索引 id。</li>
<li>第三行的 Extra 字段，表示在对子查询的结果集做 union 的时候，使用了临时表 (Using temporary)。</li>
</ol>
<p>这个语句的执行流程是这样的：</p>
<ol>
<li>创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段。</li>
<li>执行第一个子查询，得到 1000 这个值，并存入临时表中。</li>
<li>执行第二个子查询：<ol>
<li>拿到第一行 id=1000，试图插入临时表中。但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li>
<li>取到第二行 id=999，插入临时表成功。</li>
</ol>
</li>
<li>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是 1000 和 999。</li>
</ol>
<p><img src="/article/union 执行流程.jpg"><span class="image-caption">union 执行流程</span></p>
<p>这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键 id 的唯一性约束，实现了 union 的语义。</p>
<blockquote>
<p>如果把上面这个语句中的 union 改成 union all 的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p>
</blockquote>
</blockquote>
<h3 id="group-by-执行流程"><a href="#group-by-执行流程" class="headerlink" title="group by 执行流程"></a>group by 执行流程</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select id%10 as m, count(*) as c from t1 group by m;<br></code></pre></td></tr></table></figure>
<p>这个语句的逻辑是把表 t1 里的数据，按照 id%10 进行分组统计，并按照 m 的结果排序后输出。它的 explain 结果如下：</p>
<p><img src="/article/group by 的 explain 结果.png"><span class="image-caption">group by 的 explain 结果</span></p>
<ol>
<li>Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；</li>
<li>Using temporary，表示使用了临时表；</li>
<li>Using filesort，表示需要排序。</li>
</ol>
<p>这个语句的执行流程是这样的：</p>
<ol>
<li>创建内存临时表，表里有两个字段 m 和 c，主键是 m；</li>
<li>扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；<ol>
<li>如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);</li>
<li>如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；</li>
</ol>
</li>
<li>遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。</li>
</ol>
<p><img src="/article/group by 执行流程.jpg"><span class="image-caption">group by 执行流程</span></p>
<p>图中最后一步，对内存临时表的排序</p>
<img src="/article/10821/%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.jpg" class title="内存临时表排序流程">
</blockquote>
<h3 id="group-by-优化方法-–-索引"><a href="#group-by-优化方法-–-索引" class="headerlink" title="group by 优化方法 – 索引"></a>group by 优化方法 – 索引</h3><p>group by 逻辑需要构造一个带唯一索引的表，执行代价是比较高的</p>
<blockquote>
<p>执行 group by 语句为什么需要临时表？</p>
<p>group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p>
</blockquote>
<p>group by 优化方法 : 扫描过程中可以保证出现的数据是有序的</p>
<p><strong>InnoDB 的索引，就可以满足这个输入有序的条件</strong></p>
<blockquote>
<p>在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table t1 add column z int generated always as(id % 100), add index(z);<br></code></pre></td></tr></table></figure>
<p>上面的 group by 语句就可以改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select z, count(*) as c from t1 group by z;<br></code></pre></td></tr></table></figure>
<p>优化后的 group by 语句的 explain 结果，如下图所示：</p>
<p><img src="/article/group by 优化的 explain 结果.png"><span class="image-caption">group by 优化的 explain 结果</span></p>
</blockquote>
<h3 id="group-by-优化方法-–-直接排序"><a href="#group-by-优化方法-–-直接排序" class="headerlink" title="group by 优化方法 – 直接排序"></a>group by 优化方法 – 直接排序</h3><p>在 group by 语句中加入 SQL_BIG_RESULT 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p>
<blockquote>
<p>MySQL 的优化器一看，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;<br></code></pre></td></tr></table></figure>
<p>执行流程就是这样的：</p>
<ol>
<li>初始化 sort_buffer，确定放入一个整型字段，记为 m；</li>
<li>扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；</li>
<li>扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；</li>
<li>排序完成后，就得到了一个有序数组。</li>
</ol>
<p><img src="/article/使用 SQL_BIG_RESULT 的执行流程图.jpg"><span class="image-caption">使用 SQL_BIG_RESULT 的执行流程图</span></p>
<p><img src="/article/使用 SQL_BIG_RESULT 的 explain 结果.png"><span class="image-caption">使用 SQL_BIG_RESULT 的 explain 结果</span></p>
<p>从 Extra 字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。</p>
</blockquote>
<h3 id="group-by-使用的指导原则"><a href="#group-by-使用的指导原则" class="headerlink" title="group by 使用的指导原则"></a>group by 使用的指导原则</h3><ol>
<li>如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；</li>
<li>尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；</li>
<li>如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</li>
<li>如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。</li>
</ol>
<h3 id="MySQL-什么时候会使用内部临时表？"><a href="#MySQL-什么时候会使用内部临时表？" class="headerlink" title="MySQL 什么时候会使用内部临时表？"></a>MySQL 什么时候会使用内部临时表？</h3><ol>
<li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li>
<li>join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；</li>
<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。</li>
</ol>
<hr>
<blockquote>
<p><strong>问题：如果只需要去重，不需要执行聚合函数，distinct 和 group by 哪种效率高一些呢？</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select a from t group by a order by null;<br>select distinct a from t;<br></code></pre></td></tr></table></figure>
<p>表 t 的字段 a 上没有索引</p>
</blockquote>
<p><strong>不需要执行聚合函数时，distinct 和 group by 这两条语句的语义和执行流程是相同的，因此执行性能也相同。</strong></p>
<blockquote>
<p>这两条语句的执行流程是下面这样的:</p>
<ol>
<li>创建一个临时表，临时表有一个字段 a，并且在这个字段 a 上创建一个唯一索引；</li>
<li>遍历表 t，依次取数据插入临时表中：<ol>
<li>如果发现唯一键冲突，就跳过；</li>
<li>否则插入成功；</li>
</ol>
</li>
<li>遍历完成后，将临时表作为结果集返回给客户端。</li>
</ol>
</blockquote>
</blockquote>
<hr>
<h2 id="都说InnoDB好，那还要不要使用Memory引擎？"><a href="#都说InnoDB好，那还要不要使用Memory引擎？" class="headerlink" title="都说InnoDB好，那还要不要使用Memory引擎？"></a>都说InnoDB好，那还要不要使用Memory引擎？</h2><h3 id="内存表的数据组织结构"><a href="#内存表的数据组织结构" class="headerlink" title="内存表的数据组织结构"></a>内存表的数据组织结构</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create table t1(id int primary key, c int) engine=Memory;<br>create table t2(id int primary key, c int) engine=innodb;<br>insert into t1 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);<br>insert into t2 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);<br></code></pre></td></tr></table></figure>
<p>表 t1 使用 Memory 引擎， 表 t2 使用 InnoDB 引擎。</p>
<p>分别执行 select <em> from t1 和 select </em> from t2</p>
<p><img src="/article/两个查询结果 -0 的位置.png"><span class="image-caption">两个查询结果 -0 的位置</span></p>
<p>内存表 t1 的返回结果里面 0 在最后一行，而 InnoDB 表 t2 的返回结果里 0 在第一行。</p>
</blockquote>
<p><strong>InnoDB 引擎</strong>，它的主键索引 id 的组织方式：InnoDB 表的数据就放在<strong>主键索引树上</strong>，<strong>主键索引是 B+ 树</strong>。所以表 t2 的数据组织方式如下图所示：</p>
<p><img src="/article/表 t2 的数据组织.jpg"><span class="image-caption">表 t2 的数据组织</span></p>
<p><strong>主键索引上的值是有序存储的</strong></p>
<blockquote>
<p>在执行 select * 的时候，就会按照叶子节点从左到右扫描，所以得到的结果里，0 就出现在第一行。</p>
</blockquote>
<p><strong>Memory 引擎</strong>的数据和索引是分开的</p>
<blockquote>
<p><img src="/article/表 t1 的数据组织.jpg"><span class="image-caption">表 t1 的数据组织</span></p>
</blockquote>
<p>内存表的数据部分以数组的方式单独存放，而主键 id 索引里，存的是每个数据的位置。<strong>主键 id 是 hash 索引</strong>，可以看到索引上的 key 并不是有序的。</p>
<blockquote>
<p>在内存表 t1 中，当执行 select * 的时候，走的是全表扫描，也就是顺序扫描这个数组。因此，0 就是最后一个被读到，并放入结果集的数据。</p>
</blockquote>
<p><strong>InnoDB 和 Memory 引擎的数据组织方式是不同的：</strong></p>
<ol>
<li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。</li>
<li>Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。</li>
</ol>
<p><strong>两个引擎的一些典型不同：</strong></p>
<ol>
<li>InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li>
<li>当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li>
<li>数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；</li>
<li>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li>
<li>InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li>
</ol>
<h3 id="hash-索引和-B-Tree-索引"><a href="#hash-索引和-B-Tree-索引" class="headerlink" title="hash 索引和 B-Tree 索引"></a>hash 索引和 B-Tree 索引</h3><p><strong>内存表也是支持 B-Tree 索引的。</strong></p>
<blockquote>
<p>在 id 列上创建一个 B-Tree 索引，SQL 语句可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table t1 add index a_btree_index using btree (id);<br></code></pre></td></tr></table></figure>
<p>表 t1 的数据组织形式就变成了这样：</p>
<p><img src="/article/表 t1 的数据组织 -- 增加 B-Tree 索引.jpg"><span class="image-caption">表 t1 的数据组织 -- 增加 B-Tree 索引</span></p>
<p><img src="/article/使用 B-Tree 和 hash 索引查询返回结果对比.png"><span class="image-caption">使用 B-Tree 和 hash 索引查询返回结果对比</span></p>
</blockquote>
<h3 id="为什么不建议生产环境上使用内存表"><a href="#为什么不建议生产环境上使用内存表" class="headerlink" title="为什么不建议生产环境上使用内存表?"></a>为什么不建议生产环境上使用内存表?</h3><ol>
<li><p>锁粒度问题；</p>
<p>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</p>
</li>
<li><p>数据持久化问题。</p>
<p>数据库重启的时候，所有的内存表都会被清空。</p>
<p>由于重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是双 M 架构，还可能导致主库的内存表数据被删掉。</p>
</li>
</ol>
<p>内存临时表刚好可以无视内存表的两个不足，主要是下面的三个原因：</p>
<ol>
<li>临时表不会被其他线程访问，没有并发性的问题；</li>
<li>临时表重启后也是需要删除的，清空数据这个问题不存在；</li>
<li>备库的临时表也不会影响主库的用户线程。</li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>实习,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/article/62985.html</url>
    <content><![CDATA[<p><strong>函数式编程关心数据的映射，命令式编程关心解决问题的步骤</strong></p>
<p>函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda 表达式（lambda expression）是一个<a href="https://baike.baidu.com/item/匿名函数/4337265">匿名函数</a>，Lambda表达式基于数学中的<a href="https://baike.baidu.com/item/λ演算">λ演算</a>得名，直接对应于其中的lambda抽象（lambda abstraction），是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示<a href="https://baike.baidu.com/item/闭包/10908873">闭包</a>（注意和数学传统意义上的不同）。</p>
<p><strong>核心原则：可推导可省略</strong></p>
<p><strong>基本格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">(参数列表)-&gt;(代码)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>实例一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>     <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;新线程中run方法被执行了&quot;</span>);<br>      &#125;     <br>    &#125;).start();<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> <span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">&quot;新线程中run方法被执行了&quot;</span>)).start();<br>  &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p> 实例二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.function.IntBinaryOperator;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> <span class="hljs-keyword">int</span> i = calculateNum(<span class="hljs-keyword">new</span> IntBinaryOperator() &#123;<br>     <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">applyAsInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left + right;<br>      &#125;<br>    &#125;);<br>    System.out.println(i);<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateNum</span><span class="hljs-params">(IntBinaryOperator operator)</span> </span>&#123;<br> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>   <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">return</span> operator.applyAsInt(a, b);<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.function.IntBinaryOperator;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">int</span> i = calculateNum((<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right) -&gt; &#123;<br>     <span class="hljs-keyword">return</span> left + right;<br>   &#125;);<br>    System.out.println(i);<br>   &#125;<br>   <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateNum</span><span class="hljs-params">(IntBinaryOperator operator)</span> </span>&#123;<br> <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>   <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">return</span> operator.applyAsInt(a, b);<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>实例三：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.function.IntPredicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> printNum(<span class="hljs-keyword">new</span> IntPredicate() &#123;<br>     <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>      &#125;<br>    &#125;);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(IntPredicate predicate)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>      <span class="hljs-keyword">if</span> (predicate.test(i)) &#123;<br>        System.out.println(i);<br>      &#125;<br>    &#125;<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.function.IntPredicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;	<br>	printNum((<span class="hljs-keyword">int</span> value) -&gt; &#123;<br>     <span class="hljs-keyword">return</span> value % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>   &#125;);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(IntPredicate predicate)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : arr) &#123;<br>      <span class="hljs-keyword">if</span> (predicate.test(i)) &#123;<br>        System.out.println(i);<br>      &#125;<br>    &#125;<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p> 实例四：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.IntPredicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Integer integer = typeConver(<span class="hljs-keyword">new</span> Function&lt;String, Integer&gt;() &#123;<br>     <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">apply</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Integer.valueOf(s);<br>      &#125;<br>    &#125;);<br>    System.out.println(integer);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;R&gt; <span class="hljs-function">R <span class="hljs-title">typeConver</span><span class="hljs-params">(Function&lt;String,R&gt; function)</span></span>&#123;<br>   String str = <span class="hljs-string">&quot;1235&quot;</span>;<br>   R result = function.apply(str);<br>    <span class="hljs-keyword">return</span> result;<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.IntPredicate;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> Integer integer = typeConver((String s) -&gt; &#123;<br>     <span class="hljs-keyword">return</span> Integer.valueOf(s);<br>    &#125;);<br>    System.out.println(integer);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;R&gt; <span class="hljs-function">R <span class="hljs-title">typeConver</span><span class="hljs-params">(Function&lt;String,R&gt; function)</span></span>&#123;<br>   String str = <span class="hljs-string">&quot;1235&quot;</span>;<br>   R result = function.apply(str);<br>    <span class="hljs-keyword">return</span> result;<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p> 实例五：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.IntConsumer;<br><span class="hljs-keyword">import</span> java.util.function.IntPredicate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> foreachArr(<span class="hljs-keyword">new</span> IntConsumer() &#123;<br>     <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        System.out.println(value);<br>      &#125;<br>    &#125;);<br>   &#125;<br>   <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foreachArr</span><span class="hljs-params">(IntConsumer consumer)</span> </span>&#123;<br> <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i :<br>         arr) &#123;<br>      consumer.accept(i);<br>    &#125;<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>Lambda表达式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.IntConsumer;<br><span class="hljs-keyword">import</span> java.util.function.IntPredicate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br> foreachArr(<span class="hljs-keyword">new</span> IntConsumer() &#123;<br>     <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        System.out.println(value);<br>      &#125;<br>    &#125;);<br>   &#125;<br>   <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foreachArr</span><span class="hljs-params">(IntConsumer consumer)</span> </span>&#123;<br> <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i :<br>         arr) &#123;<br>      consumer.accept(i);<br>    &#125;<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>省略规则：</strong></p>
<ol>
<li>参数类型可以省略</li>
<li>方法体只有一句代码时打括号return和唯一一句代码的分号可以省略</li>
<li>方法体只有一个参数时小括号可以省略</li>
</ol>
<h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><ol>
<li>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果；</li>
<li>stream不会改变数据源，通常情况下会产生一个新的集合；</li>
<li>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li>
<li>对stream操作分为终端操作和中间操作，那么这两者分别代表什么呢？<ol>
<li>终端操作：会消费流，这种操作会产生一个结果的，如果一个流被消费过了，那它就不能被重用的。</li>
<li>中间操作：中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。一个特别需要注意的点是:中间操作不是立即发生的。相反，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。</li>
</ol>
</li>
<li>stream不可复用，对一个已经进行过终端操作的流再次调用，会抛出异常。</li>
</ol>
<blockquote>
<p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.EqualsAndHashCode;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-comment">//用于后期的去重使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>  <span class="hljs-comment">//id</span><br>  <span class="hljs-keyword">private</span> Long id;<br>  <span class="hljs-comment">//书名</span><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-comment">//分类</span><br>  <span class="hljs-keyword">private</span> String category;<br>  <span class="hljs-comment">//评分</span><br>  <span class="hljs-keyword">private</span> Integer score;<br>  <span class="hljs-comment">//简介</span><br>  <span class="hljs-keyword">private</span> String intro;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.EqualsAndHashCode;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-comment">//用于后期的去重使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Author</span>&gt;</span>&#123;<br>  <span class="hljs-comment">//id</span><br>  <span class="hljs-keyword">private</span> Long id;<br>  <span class="hljs-comment">//姓名</span><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-comment">//年龄</span><br>  <span class="hljs-keyword">private</span> Integer age;<br>  <span class="hljs-comment">//简介</span><br>  <span class="hljs-keyword">private</span> String intro;<br>  <span class="hljs-comment">//作品</span><br>  <span class="hljs-keyword">private</span> List&lt;Book&gt; books;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Author o)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> o.getAge()-<span class="hljs-keyword">this</span>.getAge();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Author&gt; authors = getAuthors();<br>    test01(authors);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">(List&lt;Author&gt; authors)</span> </span>&#123;<br>    <span class="hljs-comment">//把集合转换成流</span><br>    authors.stream()<br>      .distinct()<br>      .filter(author -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>        <span class="hljs-keyword">return</span> author.getAge() &lt; <span class="hljs-number">18</span>;<br>      &#125;)<br>      .forEach(author -&gt; System.out.println(author.getName()));<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Author&gt; <span class="hljs-title">getAuthors</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//数据初始化</span><br>    Author author = <span class="hljs-keyword">new</span> Author(<span class="hljs-number">1L</span>,<span class="hljs-string">&quot;蒙多&quot;</span>,<span class="hljs-number">33</span>,<span class="hljs-string">&quot;一个从菜刀中明悟哲理的祖安人&quot;</span>,<span class="hljs-keyword">null</span>);<br>    Author author2 = <span class="hljs-keyword">new</span> Author(<span class="hljs-number">2L</span>,<span class="hljs-string">&quot;亚拉索&quot;</span>,<span class="hljs-number">15</span>,<span class="hljs-string">&quot;狂风也追逐不上他的思考速度&quot;</span>,<span class="hljs-keyword">null</span>);<br>    Author author3 = <span class="hljs-keyword">new</span> Author(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;易&quot;</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;是这个世界在限制他的思维&quot;</span>,<span class="hljs-keyword">null</span>);<br>    Author author4 = <span class="hljs-keyword">new</span> Author(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;易&quot;</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;是这个世界在限制他的思维&quot;</span>,<span class="hljs-keyword">null</span>);<br><br>    <span class="hljs-comment">//书籍列表</span><br>    List&lt;Book&gt; books1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Book&gt; books2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Book&gt; books3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    books1.add(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">1L</span>,<span class="hljs-string">&quot;刀的两侧是光明与黑暗&quot;</span>,<span class="hljs-string">&quot;哲学,爱情&quot;</span>,<span class="hljs-number">88</span>,<span class="hljs-string">&quot;用一把刀划分了爱恨&quot;</span>));<br>    books1.add(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">2L</span>,<span class="hljs-string">&quot;一个人不能死在同一把刀下&quot;</span>,<span class="hljs-string">&quot;个人成长,爱情&quot;</span>,<span class="hljs-number">99</span>,<span class="hljs-string">&quot;讲述如何从失败中明悟真理&quot;</span>));<br><br>    books2.add(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;那风吹不到的地方&quot;</span>,<span class="hljs-string">&quot;哲学&quot;</span>,<span class="hljs-number">85</span>,<span class="hljs-string">&quot;带你用思维去领略世界的尽头&quot;</span>));<br>    books2.add(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;那风吹不到的地方&quot;</span>,<span class="hljs-string">&quot;哲学&quot;</span>,<span class="hljs-number">85</span>,<span class="hljs-string">&quot;带你用思维去领略世界的尽头&quot;</span>));<br>    books2.add(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">4L</span>,<span class="hljs-string">&quot;吹或不吹&quot;</span>,<span class="hljs-string">&quot;爱情,个人传记&quot;</span>,<span class="hljs-number">56</span>,<span class="hljs-string">&quot;一个哲学家的恋爱观注定很难把他所在的时代理解&quot;</span>));<br><br>    books3.add(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">5L</span>,<span class="hljs-string">&quot;你的剑就是我的剑&quot;</span>,<span class="hljs-string">&quot;爱情&quot;</span>,<span class="hljs-number">56</span>,<span class="hljs-string">&quot;无法想象一个武者能对他的伴侣这么的宽容&quot;</span>));<br>    books3.add(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">6L</span>,<span class="hljs-string">&quot;风与剑&quot;</span>,<span class="hljs-string">&quot;个人传记&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));<br>    books3.add(<span class="hljs-keyword">new</span> Book(<span class="hljs-number">6L</span>,<span class="hljs-string">&quot;风与剑&quot;</span>,<span class="hljs-string">&quot;个人传记&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));<br><br>    author.setBooks(books1);<br>    author2.setBooks(books2);<br>    author3.setBooks(books3);<br>    author4.setBooks(books3);<br><br>    List&lt;Author&gt; authorList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(author,author2,author3,author4));<br>    <span class="hljs-keyword">return</span> authorList;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol>
<li><code>Sequence of elements（元素序列）</code>：简单来说，就是我们操作的集合中的所有元素</li>
<li><code>source（数据源）</code> ：Stream流的作用就是操作数据，那么source 就是为Stream提供可操作的<code>源数据</code>(一般，集合、数组或I/OI/O resources 都可以成为Stream的source )</li>
<li><code>Data processing operations（数据处理操作）</code>：上面菜单程序代码中出现的<strong>filter、sorted、map、collect</strong>，以及<strong>reduce、find、match</strong>等都属于Stream 的一些操作数据的方法接口。这些操作可以顺序进行，也可以并行执行。</li>
<li><code>Pipelining（管道、流水线）</code>：Stream对数据的操作类似数据库查询，也像电子厂的生产流线一样，Stream的每一个中间操作（后面解释什么是中间操作）比如上面的filter、sorted、map，每一步都会返回一个新的流，这些操作全部连起来就是想是一个工厂得生产流水线 ：<br><a href="https://img2020.cnblogs.com/blog/2026387/202011/2026387-20201126155856126-577400707.jpg"><img src="https://img2020.cnblogs.com/blog/2026387/202011/2026387-20201126155856126-577400707.jpg"><span class="image-caption">img</span></a></li>
<li><code>Internal iteration（内部迭代）</code>：Stream API 实现了对数据迭代的封装，不用你再像操作集合一样，手动写for循环显示迭代数据。</li>
</ol>
</blockquote>
<p><strong>Stream最主要的三组成部分</strong></p>
<ol>
<li>创建流，也就是Stream开始的地方，负责创建一个Stream实例</li>
<li>中间操作，主要是一些对数据的过滤筛选，添加删除等等操作，形成一个流程链。</li>
<li>收尾，也就是终端操作，我感觉更适合叫终结操作，终端操作会从流的流水线（中间操作）生成结果</li>
</ol>
<p><strong>Stream流的生命周期:</strong>同一个流只能遍历一次，遍历完后，这个流就已经被消费掉了。你如果还需要在遍历，可以从原始数据源那里再获得一个新的流来重新遍历一遍。</p>
<p><strong>Stream操作分类</strong></p>
<img src="/article/62985/Stream%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB.png" class title="Stream操作分类">
<p><strong>常用中间操作</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">返回类型</th>
<th style="text-align:center">操作参数</th>
<th style="text-align:center">函数描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">filter</td>
<td style="text-align:center">中间</td>
<td style="text-align:center">Stream<T></T></td>
<td style="text-align:center">Predicate<T></T></td>
<td style="text-align:center">T-&gt;boolean</td>
</tr>
<tr>
<td style="text-align:center">map</td>
<td style="text-align:center">中间</td>
<td style="text-align:center">Stream<R></R></td>
<td style="text-align:center">Function&lt;T,R&gt;</td>
<td style="text-align:center">T-&gt;R</td>
</tr>
<tr>
<td style="text-align:center">limit</td>
<td style="text-align:center">中间</td>
<td style="text-align:center">Stream<T></T></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">sorted</td>
<td style="text-align:center">中间</td>
<td style="text-align:center">Stream<T></T></td>
<td style="text-align:center">Comparator<T></T></td>
<td style="text-align:center">(T,T)-&gt;int</td>
</tr>
<tr>
<td style="text-align:center">distinct</td>
<td style="text-align:center">中间</td>
<td style="text-align:center">Stream<T></T></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p><strong>常用终端操作</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">forEach</td>
<td style="text-align:center">终端</td>
<td style="text-align:center">消费流中的每个元素并对其应用Lambda，返回void</td>
</tr>
<tr>
<td style="text-align:center">count</td>
<td style="text-align:center">终端</td>
<td style="text-align:center">返回流中元素的个数(long)</td>
</tr>
<tr>
<td style="text-align:center">collect</td>
<td style="text-align:center">终端</td>
<td style="text-align:center">把流归约成一个集合，如List、Map、Integer</td>
</tr>
</tbody>
</table>
<h3 id="流的常用创建方法"><a href="#流的常用创建方法" class="headerlink" title="流的常用创建方法"></a>流的常用创建方法</h3><ol>
<li><p>使用Collection下的 stream() 和 parallelStream() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Stream&lt;String&gt; stream = list.stream(); <span class="hljs-comment">//获取一个顺序流</span><br>Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="hljs-comment">//获取一个并行流</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>使用Arrays 中的 stream() 方法，将数组转成流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer[] nums = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">10</span>];<br>Stream&lt;Integer&gt; stream = Arrays.stream(nums);<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用Stream中的静态方法：of()、iterate()、generate()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br> <br>Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">2</span>).limit(<span class="hljs-number">6</span>);<br>stream2.forEach(System.out::println); <span class="hljs-comment">// 0 2 4 6 8 10</span><br> <br>Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="hljs-number">2</span>);<br>stream3.forEach(System.out::println);<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 BufferedReader.lines() 方法，将每行内容转成流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">&quot;F:\\test_stream.txt&quot;</span>));<br>Stream&lt;String&gt; lineStream = reader.lines();<br>lineStream.forEach(System.out::println);<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 Pattern.splitAsStream() 方法，将字符串分隔成流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Pattern pattern = Pattern.compile(<span class="hljs-string">&quot;,&quot;</span>);<br>Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="hljs-string">&quot;a,b,c,d&quot;</span>);<br>stringStream.forEach(System.out::println);<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="流的中间操作"><a href="#流的中间操作" class="headerlink" title="流的中间操作"></a>流的中间操作</h3><ol>
<li><p>过滤通过 filter() 方法可以从流中筛选出我们想要的元素</p>
<p>distinct() 方法是一个中间操作（去重），它会返回一个新的流（没有共同元素）</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">(List&lt;Author&gt; authors)</span> </span>&#123;<br>  authors.stream()<span class="hljs-comment">//把集合转换成流</span><br>    .distinct()<br>    .filter(author -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>      <span class="hljs-keyword">return</span> author.getAge() &lt; <span class="hljs-number">18</span>;<br>    &#125;)<br>    .forEach(author -&gt; System.out.println(author.getName()));<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>filter() 方法接收的是一个 Predicate（Java 8 新增的一个函数式接口，接受一个输入参数返回一个布尔值结果）类型的参数，因此，我们可以直接将一个 Lambda 表达式传递给该方法。</p>
</li>
</ol>
<ol start="2">
<li><p>如果想通过某种操作把一个流中的元素转化成新的流中的元素，可以使用 map() 方法</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//        打印所有作家的姓名</span><br>  List&lt;Author&gt; authors = getAuthors();<br><br>  authors.stream()<br>    .map(<span class="hljs-keyword">new</span> Function&lt;Author, String&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">apply</span><span class="hljs-params">(Author author)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> author.getName();<br>      &#125;<br>    &#125;)<br>    .forEach(s -&gt; System.out.println(s));<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>map() 方法接收的是一个 Function（Java 8 新增的一个函数式接口，接受一个输入参数 T，返回一个结果 R）类型的参数，此时参数 为 String 类的 length 方法，也就是把 Stream<Author> 的流转成一个 Stream<Integer> 的流。</Integer></Author></p>
</li>
</ol>
<ol start="3">
<li><p>sorted() 方法按自然顺序排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span> </span>&#123;<br>  List&lt;Author&gt; authors = getAuthors();<br>  <span class="hljs-comment">//对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span><br>  authors.stream()<br>    .distinct()<br>    .sorted(<span class="hljs-keyword">new</span> Comparator&lt;Author&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Author o1, Author o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o2.getAge() - o1.getAge();<br>      &#125;<br>    &#125;)<br>    .forEach(author -&gt; System.out.println(author.getAge()));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>返回由该流的元素组成的流，按自然顺序排序。如果此流的元素不是 Comparable，则在执行终端操作时可能会抛出 java.lang.ClassCastException。对于有序流，排序是稳定的。对于无序流，不保证稳定性。</p>
<p>(如果调用空参的 sorted() 方法，需要流中的元素是实现了 Comparable 接口)</p>
</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/339038230">https://zhuanlan.zhihu.com/p/339038230</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1662741032559775199&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1662741032559775199&amp;wfr=spider&amp;for=pc</a></p>
<p><a href="https://www.cnblogs.com/MrYuChen-Blog/p/14042801.html">https://www.cnblogs.com/MrYuChen-Blog/p/14042801.html</a></p>
<p><a href="https://blog.csdn.net/y_k_y/article/details/84633001?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;utm_relevant_index=1">https://blog.csdn.net/y_k_y/article/details/84633001?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;utm_relevant_index=1</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql45讲-实践（二）</title>
    <url>/article/9788.html</url>
    <content><![CDATA[<h2 id="MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><p>业务高峰期，生产环境的 MySQL 压力太大，没法正常响应，需要短期内、临时性地提升一些性能。</p>
<h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><blockquote>
<p>正常的短连接模式就是连接到数据库后，执行很少的 SQL 语句就断开，下次需要的时候再重连。</p>
<p>如果使用的是短连接，在业务高峰期的时候，就可能出现连接数突然暴涨的情况。</p>
</blockquote>
<p>MySQL 建立连接的过程，成本是很高的。除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。</p>
<p><strong>短连接模型存在一个风险，就是一旦数据库处理得慢一些，连接数就会暴涨。</strong></p>
<p><code>max_connections</code> 参数，用来控制一个 MySQL 实例同时存在的连接数的上限，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。对于被拒绝连接的请求来说，从业务角度看就是数据库不可用。</p>
<blockquote>
<p>调高 max_connections 的值:</p>
<p>因为设计 max_connections 这个参数的目的是想保护 MySQL，如果我们把它改得太大，让更多的连接都可以进来，那么系统的负载可能会进一步加大，大量的资源耗费在权限验证等逻辑上，结果可能是适得其反，已经连接的线程拿不到 CPU 资源去执行业务的 SQL 请求。</p>
</blockquote>
<ol>
<li><p>第一种方法：先处理掉那些占着连接但是不工作的线程。</p>
<p>对于那些不需要保持的连接，我们可以通过 kill connection 主动踢掉。这个行为跟事先设置 wait_timeout 的效果是一样的。设置 wait_timeout 参数表示的是，一个线程空闲 wait_timeout 这么多秒之后，就会被 MySQL 直接断开连接。</p>
<p><strong>但是需要注意，在 show processlist 的结果里，踢掉显示为 sleep 的线程，可能是有损的。</strong></p>
<p><strong>应该优先断开事务外空闲的连接。</strong></p>
<blockquote>
<p>看事务具体状态的话，你可以查 <code>information_schema</code> 库的 <code>innodb_trx</code> 表。</p>
<p><code>trx_mysql_thread_id=n</code>，表示 id=n 的线程还处在事务中。</p>
</blockquote>
<p>如果是连接数过多，你可以优先断开事务外空闲太久的连接；如果这样还不够，再考虑断开事务内空闲太久的连接。</p>
<blockquote>
<p>从服务端断开连接使用的是 <code>kill connection + id</code> 的命令， 一个客户端处于 sleep 状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道。直到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p>
</blockquote>
<p>从数据库端主动断开连接可能是<strong>有损的</strong>，尤其是有的应用端收到这个错误后，不重新连接，而是直接用这个已经不能用的句柄重试查询。这会导致从应用端看上去，“MySQL 一直没恢复”。</p>
</li>
<li><p>第二种方法：减少连接过程的消耗。</p>
<p>有的业务代码会在短时间内先大量申请数据库连接做备用，如果现在数据库确认是被连接行为打挂了，那么一种可能的做法，是<strong>让数据库跳过权限验证阶段</strong>。</p>
<p>跳过权限验证的方法是：重启数据库，并使用<code>–skip-grant-tables</code> 参数启动。这样，整个 MySQL 会跳过所有的权限验证阶段，包括连接过程和语句执行过程在内。</p>
<p><strong>风险极高，特别不建议使用</strong></p>
</li>
</ol>
<h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><p>在 MySQL 中，会引发性能问题的慢查询，大体有以下三种可能：</p>
<ol>
<li><p>索引没有设计好；</p>
<p>这种场景一般就是通过紧急创建索引来解决。</p>
<blockquote>
<p>MySQL 5.6 版本以后，创建索引都支持 Online DDL 了，对于那种高峰期数据库已经被这个语句打挂了的情况，最高效的做法就是直接执行 alter table 语句。</p>
</blockquote>
<p>比较理想的是能够在备库先执行。假设你现在的服务是一主一备，主库 A、备库 B，这个方案的大致流程是这样的：</p>
<ol>
<li>在备库 B 上执行 <code>set sql_log_bin=off</code>，也就是不写 binlog，然后执行 alter table 语句加上索引；</li>
<li>执行主备切换；</li>
<li>这时候主库是 B，备库是 A。在 A 上执行 <code>set sql_log_bin=off</code>，然后执行 alter table 语句加上索引。</li>
</ol>
</li>
<li><p>SQL 语句没写好；</p>
<p>我们可以通过改写 SQL 语句来处理。MySQL 5.7 提供了 <code>query_rewrite</code> 功能，可以把输入的一种语句改写成另外一种模式。</p>
</li>
<li><p>MySQL 选错了索引。</p>
<p>使用查询重写功能，给原来的语句加上 force index</p>
</li>
</ol>
<h3 id="预先发现问题"><a href="#预先发现问题" class="headerlink" title="预先发现问题"></a>预先发现问题</h3><ol>
<li>上线前，在测试环境，把慢查询日志（slow log）打开，并且把 long_query_time 设置成 0，确保每个语句都会被记录入慢查询日志；</li>
<li>在测试表里插入模拟线上的数据，做一遍回归测试；</li>
<li>观察慢查询日志里每类语句的输出，特别留意 Rows_examined 字段是否与预期一致。</li>
</ol>
<h3 id="QPS-突增问题"><a href="#QPS-突增问题" class="headerlink" title="QPS 突增问题"></a>QPS 突增问题</h3><blockquote>
<p>有时候由于业务突然出现高峰，或者应用程序 bug，导致某个语句的 QPS 突然暴涨，也可能导致 MySQL 压力过大，影响服务。</p>
</blockquote>
<p>由一个新功能的 bug 导致的，最理想的情况是让业务把这个功能下掉，服务自然就会恢复。</p>
<ol>
<li><p>一种是由全新业务的 bug 导致的。假设你的 DB 运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</p>
</li>
<li><p>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的 QPS 就会变成 0。</p>
</li>
<li><p>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的 SQL 语句直接重写成 <code>select 1</code> 返回。</p>
<p>副作用:</p>
<ol>
<li>如果别的功能里面也用到了这个 SQL 语句模板，会有误伤；</li>
<li>很多业务并不是靠这一个语句就能完成逻辑的，所以如果单独把这一个语句以 <code>select 1</code> 的结果返回的话，可能会导致后面的业务逻辑一起失败。</li>
</ol>
<p><strong>风险极高，特别不建议使用</strong></p>
</li>
</ol>
<h2 id="MySQL是怎么保证数据不丢的？"><a href="#MySQL是怎么保证数据不丢的？" class="headerlink" title="MySQL是怎么保证数据不丢的？"></a>MySQL是怎么保证数据不丢的？</h2><p>只要 redo log 和 binlog 保证持久化到磁盘，就能确保 MySQL 异常重启后，数据可以恢复。</p>
<h3 id="binlog-的写入机制"><a href="#binlog-的写入机制" class="headerlink" title="binlog 的写入机制"></a>binlog 的写入机制</h3><p>事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p>
<p><strong>一个事务的 binlog 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入</strong></p>
<p><strong>binlog cache 的保存</strong>：</p>
<p>系统给 binlog cache 分配了一片内存，每个线程一个，参数 binlog_cache_size 用于控制单个线程内 binlog cache 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。</p>
<p>事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 中，并清空 binlog cache。</p>
<p><img src="/article/binlog 写盘状态.png"><span class="image-caption">binlog 写盘状态</span></p>
<p>每个线程有自己 binlog cache，但是共用同一份 binlog 文件</p>
<ol>
<li>图中的 write，指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快。 </li>
<li>图中的 fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为 fsync 才占磁盘的 IOPS。</li>
</ol>
<blockquote>
<ol>
<li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。(对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。)</li>
</ol>
</blockquote>
<h3 id="redo-log-的写入机制"><a href="#redo-log-的写入机制" class="headerlink" title="redo log 的写入机制"></a>redo log 的写入机制</h3><p>事务在执行过程中，生成的 redo log 是要先写到 redo log buffer 的。</p>
<ol>
<li><p>redo log buffer 里面的内容，是不是每次生成后都要直接持久化到磁盘呢？</p>
<p>不需要</p>
<p>如果事务执行期间 MySQL 发生异常重启，那这部分日志就丢了。由于事务并没有提交，所以这时日志丢了也不会有损失。</p>
</li>
<li><p>事务还没提交的时候，redo log buffer 中的部分日志有没有可能被持久化到磁盘呢？</p>
<p>有可能</p>
<p><img src="/article/MySQL redo log 存储状态.png"><span class="image-caption">MySQL redo log 存储状态</span></p>
<ol>
<li>存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分；</li>
<li>写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分；</li>
<li>持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。</li>
</ol>
<blockquote>
<p>为了控制 redo log 的写入策略，InnoDB 提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它有三种可能取值：</p>
<ol>
<li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
<li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ol>
</blockquote>
<p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p>
<p><strong>注意</strong>，事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。也就是说，一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。</p>
</li>
</ol>
<pre><code>实际上，除了后台线程每秒一次的轮询操作外，还有两种场景会让一个没有提交的事务的 redo log 写入到磁盘中。

1. 一种是，redo log buffer 占用的空间即将达到 `innodb_log_buffer_size `**一半**的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。
2. 另一种是，并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。假设一个事务 A 执行到一半，已经写了一些 redo log 到 buffer 中，这时候有另外一个线程的事务 B 提交，如果 `innodb_flush_log_at_trx_commit` 设置的是 1，那么按照这个参数的逻辑，事务 B 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上事务 A 在 redo log buffer 里的日志一起持久化到磁盘

&gt; 如果把 `innodb_flush_log_at_trx_commit` 设置成 1，那么 redo log 在 prepare 阶段就要持久化一次，因为有一个崩溃恢复逻辑是要依赖于 prepare 的 redo log，再加上 binlog 来恢复的。
&gt;
&gt; 每秒一次后台轮询刷盘，再加上崩溃恢复这个逻辑，InnoDB 就认为 redo log 在 commit 的时候就不需要 fsync 了，只会 write 到文件系统的 page cache 中就够了。
</code></pre><p><strong>MySQL 的“双 1”配置</strong></p>
<p><code>sync_binlog</code> 和 <code>innodb_flush_log_at_trx_commit</code> 都设置成 1</p>
<p>一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p>
<h3 id="组提交（group-commit）机制"><a href="#组提交（group-commit）机制" class="headerlink" title="组提交（group commit）机制"></a>组提交（group commit）机制</h3><p><strong>日志逻辑序列号（log sequence number，LSN）</strong>:LSN 是单调递增的，用来对应 redo log 的一个个写入点。每次写入长度为 length 的 redo log， LSN 的值就会加上 length。</p>
<p>LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log。</p>
<blockquote>
<p><img src="/article/redo log 组提交.png"><span class="image-caption">redo log 组提交</span></p>
<p>三个并发事务 (trx1, trx2, trx3) 在 prepare 阶段，都写完 redo log buffer，持久化到磁盘的过程，对应的 LSN 分别是 50、120 和 160。</p>
<ol>
<li>trx1 是第一个到达的，会被选为这组的 leader；</li>
<li>等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；</li>
<li>trx1 去写盘的时候，带的就是 LSN=160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；</li>
<li>这时候 trx2 和 trx3 就可以直接返回了。</li>
</ol>
</blockquote>
<p>一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。</p>
<p>但如果只有单线程压测，那就只能一个事务对应一次持久化操作。</p>
<blockquote>
<p>为了让一次 fsync 带的组员更多，MySQL 有一个很有趣的优化：拖时间</p>
<img src="/article/9788/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%BB%86%E5%8C%96.png" class title="两阶段提交细化">
<p>把 redo log 做 fsync 的时间拖到了步骤 1 之后</p>
<p>在执行第 4 步把 binlog fsync 到磁盘时，如果有多个事务的 binlog 已经写完了，也是一起持久化的，这样也可以减少 IOPS 的消耗。</p>
<p>不过通常情况下第 3 步执行得会很快，所以 binlog 的 write 和 fsync 间的间隔时间短，导致能集合到一起持久化的 binlog 比较少，因此 binlog 的组提交的效果通常不如 redo log 的效果那么好。</p>
<p><strong>提升 binlog 组提交的效果:</strong></p>
<p>可以通过设置 <code>binlog_group_commit_sync_delay</code> 和 <code>binlog_group_commit_sync_no_delay_count</code> 来实现。</p>
<ol>
<li><code>binlog_group_commit_sync_delay</code> 参数，表示延迟多少微秒后才调用 fsync;</li>
<li><code>binlog_group_commit_sync_no_delay_count</code> 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>只要有一个满足条件就会调用 fsync</p>
</blockquote>
<p>WAL 机制是减少磁盘写，可是每次提交事务都要写 redo log 和 binlog，磁盘读写次数为什么没变少？</p>
<p>WAL 机制主要得益于两个方面：</p>
<ol>
<li>redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快；</li>
<li>组提交机制，可以大幅度降低磁盘的 IOPS 消耗。</li>
</ol>
<h3 id="IO性能瓶颈，提升性能"><a href="#IO性能瓶颈，提升性能" class="headerlink" title="IO性能瓶颈，提升性能"></a>IO性能瓶颈，提升性能</h3><ol>
<li>设置 <code>binlog_group_commit_sync_delay</code> 和 <code>binlog_group_commit_sync_no_delay_count</code> 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
<li>将 <code>sync_binlog</code> 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</li>
<li>将 <code>innodb_flush_log_at_trx_commit</code> 设置为 2。这样做的风险是，主机掉电的时候会丢数据。(不建议把 <code>innodb_flush_log_at_trx_commit</code> 设置成 0,因为把这个参数设置成 0，表示 redo log 只保存在内存中，这样的话 MySQL 本身异常重启也会丢数据，风险太大。而 redo log 写到文件系统的 page cache 的速度也是很快的，所以将这个参数设置成 2 跟设置成 0 其实性能差不多，但这样做 MySQL 异常重启时就不会丢数据了，相比之下风险会更小。)</li>
</ol>
<hr>
<p><strong>问题：为什么 binlog cache 是每个线程自己维护的，而 redo log buffer 是全局共用的？</strong></p>
<blockquote>
<p>MySQL 这么设计的主要原因是，binlog 是不能“被打断的”。一个事务的 binlog 必须连续写，因此要整个事务完成后，再一起写到文件里。</p>
<p>而 redo log 并没有这个要求，中间有生成的日志可以写到 redo log buffer 中。redo log buffer 中的内容还能“搭便车”，其他事务提交的时候可以被一起写到磁盘中。</p>
</blockquote>
<hr>
<h2 id="MySQL是怎么保证主备一致的？"><a href="#MySQL是怎么保证主备一致的？" class="headerlink" title="MySQL是怎么保证主备一致的？"></a>MySQL是怎么保证主备一致的？</h2><h3 id="MySQL-主备的基本原理"><a href="#MySQL-主备的基本原理" class="headerlink" title="MySQL 主备的基本原理"></a>MySQL 主备的基本原理</h3><p><strong>基本的主备切换流程</strong></p>
<p><img src="/article/MySQL 主备切换流程.png"><span class="image-caption">MySQL 主备切换流程</span></p>
<p>在状态 1 中，客户端的读写都直接访问节点 A，而节点 B 是 A 的备库，只是将 A 的更新都同步过来，到本地执行。这样可以保持节点 B 和 A 的数据是相同的。</p>
<p>当需要切换的时候，就切成状态 2。这时候客户端读写访问的都是节点 B，而节点 A 是 B 的备库。</p>
<blockquote>
<p>在状态 1 中，虽然节点 B 没有被直接访问，但是依然建议把节点 B（也就是备库）设置成只读（readonly）模式。这样做，有以下几个考虑：</p>
<ol>
<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li>
<li>防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致；</li>
<li>可以用 readonly 状态，来判断节点的角色。</li>
</ol>
<p><strong>readonly 设置对超级 (super) 权限用户是无效的，而用于同步更新的线程，就拥有超级权限。</strong></p>
</blockquote>
<blockquote>
<p><strong>节点 A 到 B 这条线的内部流程是什么样的?</strong></p>
<p>一个 update 语句在节点 A 执行，然后同步到节点 B 的完整流程图</p>
<img src="/article/9788/%E4%B8%BB%E5%A4%87%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class title="主备流程图">
<p>主库接收到客户端的更新请求后，执行内部事务的更新逻辑，同时写 binlog</p>
<p>备库 B 跟主库 A 之间维持了一个长连接。主库 A 内部有一个线程，专门用于服务备库 B 的这个长连接。一个事务日志同步的完整过程是这样的：</p>
<ol>
<li>在备库 B 上通过 <code>change master</code> 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 <strong>io_thread</strong> 和 <strong>sql_thread</strong>。其中 io_thread 负责与主库建立连接。</li>
<li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li>
<li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
</blockquote>
<h3 id="binlog-的三种格式对比"><a href="#binlog-的三种格式对比" class="headerlink" title="binlog 的三种格式对比"></a>binlog 的三种格式对比</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `a` int(11) DEFAULT NULL,<br>  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,<br>  PRIMARY KEY (`id`),<br>  KEY `a` (`a`),<br>  KEY `t_modified`(`t_modified`)<br>) ENGINE=InnoDB;<br><br>insert into t values(1,1,&#x27;2018-11-13&#x27;);<br>insert into t values(2,2,&#x27;2018-11-12&#x27;);<br>insert into t values(3,3,&#x27;2018-11-11&#x27;);<br>insert into t values(4,4,&#x27;2018-11-10&#x27;);<br>insert into t values(5,5,&#x27;2018-11-09&#x27;);<br></code></pre></td></tr></table></figure>
</blockquote>
<p>在表中删除一行数据的话， delete 语句的 binlog 是怎么记录的?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; delete from t /*comment*/  where a&gt;=4 and t_modified&lt;=&#x27;2018-11-10&#x27; limit 1;<br></code></pre></td></tr></table></figure>
<ol>
<li><p>当 binlog_format=statement 时，binlog 里面记录的就是 SQL 语句的原文</p>
<blockquote>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; show binlog events in &#x27;master.000001&#x27;;<br></code></pre></td></tr></table></figure>
<p>查看 binlog 中的内容</p>
<p><img src="/article/statement 格式 binlog 示例.png"><span class="image-caption">statement 格式 binlog 示例</span></p>
<ol>
<li>第一行 SET @@SESSION.GTID_NEXT=’ANONYMOUS’你可以先忽略，后面文章我们会在介绍主备切换的时候再提到；</li>
<li>第二行是一个 BEGIN，跟第四行的 commit 对应，表示中间是一个事务；</li>
<li>第三行就是真实执行的语句了。可以看到，在真实执行的 delete 命令之前，还有一个“use ‘test’”命令。这条命令不是我们主动执行的，而是 MySQL 根据当前要操作的表所在的数据库，自行添加的。这样做可以保证日志传到备库去执行的时候，不论当前的工作线程在哪个库里，都能够正确地更新到 test 库的表 t。</li>
<li>最后一行是一个 COMMIT。（XID是用来联系bin log和redo log的。比如redo log里面有一个事务是prepare状态，但是不知道是不是commit状态，那就可以用XID去bin log里面查询该事务到底有没有提交。有提交则是commit状态，若没有提交则回滚该事务。）</li>
</ol>
</blockquote>
</li>
<li><p>当 binlog_format=row 时，binlog 里面记录的就是 事件</p>
<blockquote>
<p><img src="/article/row 格式 binlog 示例.png"><span class="image-caption">row 格式 binlog 示例</span></p>
<p>与 statement 格式的 binlog 相比，前后的 BEGIN 和 COMMIT 是一样的。但是，row 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。</p>
<ol>
<li>Table_map event，用于说明接下来要操作的表是 test 库的表 t;</li>
<li>Delete_rows event，用于定义删除的行为。</li>
</ol>
<p>看不到详细信息需要借助 mysqlbinlog 工具，用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysqlbinlog  -vv data/master.000001 --start-position=8900;<br></code></pre></td></tr></table></figure>
<p>解析和查看 binlog 中的内容</p>
<p><img src="/article/row 格式 binlog 示例的详细信息.png"><span class="image-caption">row 格式 binlog 示例的详细信息</span></p>
<ol>
<li>server id 1，表示这个事务是在 server_id=1 的这个库上执行的</li>
<li>每个 event 都有 CRC32 的值，这是因为我把参数 binlog_checksum 设置成了 CRC32</li>
<li>Table_map event 显示了接下来要打开的表，map 到数字 226。现在我们这条 SQL 语句只操作了一张表，如果要操作多张表呢？每个表都有一个对应的 Table_map event、都会 map 到一个单独的数字，用于区分对不同表的操作。</li>
<li>我们在 mysqlbinlog 的命令中，使用了 <code>-vv</code> 参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4、 @2=4 这些值）。binlog_row_image 的默认配置是 FULL，因此 Delete_event 里面，包含了删掉的行的所有字段的值。如果把 binlog_row_image 设置为 MINIMAL，则只会记录必要的信息，在这个例子里，就是只会记录 id=4 这个信息。</li>
<li>最后的 Xid event，用于表示事务被正确地提交了。</li>
</ol>
</blockquote>
</li>
<li><p>为什么会有 mixed 格式的 binlog？</p>
<ol>
<li>因为有些 statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式。</li>
<li>但 row 格式的缺点是，很占空间。比如你用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</li>
<li>所以，MySQL 就取了个折中方案，也就是有了 mixed 格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</li>
</ol>
</li>
</ol>
<h3 id="循环复制问题"><a href="#循环复制问题" class="headerlink" title="循环复制问题"></a>循环复制问题</h3><p>实际生产上使用比较多的是双 M 结构</p>
<p><img src="/article/MySQL 主备切换流程 -- 双 M 结构.png"><span class="image-caption">MySQL 主备切换流程 -- 双 M 结构</span></p>
<p>节点 A 和 B 之间总是互为主备关系。这样在切换的时候就不用再修改主备关系。</p>
<p><strong>循环复制问题:</strong></p>
<blockquote>
<p>业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。</p>
<p>那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是<strong>循环复制</strong>了。</p>
</blockquote>
<p><strong>解决两个节点间的循环复制的问题：</strong></p>
<p>MySQL 在 binlog 中记录了这个命令第一次执行时所在实例的 server id。</p>
<ol>
<li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li>
<li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li>
<li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
<h2 id="MySQL是怎么保证高可用的？"><a href="#MySQL是怎么保证高可用的？" class="headerlink" title="MySQL是怎么保证高可用的？"></a>MySQL是怎么保证高可用的？</h2><p><img src="/article/MySQL 主备切换流程 -- 双 M 结构.png"><span class="image-caption">MySQL 主备切换流程 -- 双 M 结构</span></p>
<h3 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h3><blockquote>
<p> 与数据同步有关的时间点主要包括以下三个：</p>
<ol>
<li>主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1;</li>
<li>之后传给备库 B，我们把备库 B 接收完这个 binlog 的时刻记为 T2;</li>
<li>备库 B 执行完成这个事务，我们把这个时刻记为 T3。</li>
</ol>
<p><strong>主备延迟</strong>，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是 T3-T1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">&gt;show slave status<br></code></pre></td></tr></table></figure>
<p>返回结果里面会显示 <code>seconds_behind_master</code>，用于表示当前备库延迟了多少秒</p>
<ol>
<li>每个事务的 binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 seconds_behind_master。</li>
</ol>
</blockquote>
<p>主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产 binlog 的速度要慢。</p>
<h3 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h3><ol>
<li><p>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。</p>
</li>
<li><p>备库的压力大</p>
<blockquote>
<p>因为主备可能发生切换，备库随时可能变成主库，所以主备库选用相同规格的机器，并且做对称部署，是现在比较常见的情况。</p>
</blockquote>
<p>备库上的查询耗费了大量的 CPU 资源，影响了同步速度，造成主备延迟。</p>
<p><strong>处理</strong>:</p>
<ol>
<li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li>
<li>通过 binlog 输出到外部系统，比如 Hadoop 这类系统，让外部系统提供统计类查询的能力。</li>
</ol>
</li>
<li><p>大事务</p>
<blockquote>
<p>因为主库上必须等事务执行完成才会写入 binlog，再传给备库。所以，如果一个主库上的语句执行 10 分钟，那这个事务很可能就会导致从库延迟 10 分钟。</p>
</blockquote>
</li>
<li><p>备库的并行复制能力</p>
</li>
</ol>
<h3 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h3><blockquote>
<p>在双 M 结构下，从状态 1 到状态 2 切换的详细过程是这样的：</p>
<ol>
<li>判断备库 B 现在的 <code>seconds_behind_master</code>，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；</li>
<li>把主库 A 改成只读状态，即把 readonly 设置为 true；</li>
<li>判断备库 B 的 <code>seconds_behind_master</code> 的值，直到这个值变成 0 为止；</li>
<li>把备库 B 改成可读写状态，也就是把 readonly 设置为 false；</li>
<li>把业务请求切到备库 B。</li>
</ol>
<p><img src="/article/MySQL 可靠性优先主备切换流程.png"><span class="image-caption">MySQL 可靠性优先主备切换流程</span></p>
<p>这个切换流程中是有不可用时间的。因为在步骤 2 之后，主库 A 和备库 B 都处于 readonly 状态，也就是说这时系统处于不可写状态，直到步骤 5 完成后才能恢复。</p>
</blockquote>
<h3 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h3><p>把步骤 4、5 调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库 B，并且让备库 B 可以读写，那么系统几乎就没有不可用时间了。</p>
<p>把这个切换流程，暂时称作可用性优先流程。这个切换流程的代价，就是可能出现数据不一致的情况。</p>
<ol>
<li>使用 row 格式的 binlog 时，数据不一致的问题更容易被发现。而使用 mixed 或者 statement 格式的 binlog 时，数据很可能悄悄地就不一致了。如果过了很久才发现数据不一致的问题，很可能这时的数据不一致已经不可查，或者连带造成了更多的数据逻辑不一致。</li>
<li>主备切换的可用性优先策略会导致数据不一致。因此，大多数情况下，建议使用可靠性优先策略。毕竟对数据服务来说的话，数据的可靠性一般还是要优于可用性的。</li>
</ol>
<h2 id="备库为什么会延迟好几个小时？"><a href="#备库为什么会延迟好几个小时？" class="headerlink" title="备库为什么会延迟好几个小时？"></a>备库为什么会延迟好几个小时？</h2><blockquote>
<img src="/article/9788/%E4%B8%BB%E5%A4%87%E6%B5%81%E7%A8%8B%E5%9B%BE1.png" class title="主备流程图1">
<p>一个箭头代表了客户端写入主库，另一箭头代表的是备库上 sql_thread 执行中转日志（relay log）。</p>
<p>如果用箭头的粗细来代表并行度的话，第一个箭头要明显粗于第二个箭头。</p>
<p>日志在备库上的执行，就是图中备库上 sql_thread 更新数据 (DATA) 的逻辑。如果是用单线程的话，就会导致备库应用日志不够快，造成<strong>主备延迟</strong>。</p>
</blockquote>
<blockquote>
<p>在官方的 5.6 版本之前，MySQL 只支持单线程复制，由此在主库并发高、TPS 高时就会出现严重的主备延迟问题。</p>
</blockquote>
<p><strong>MySQL 多线程复制</strong></p>
<img src="/article/9788/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" class title="多线程模型">
<p>把只有一个线程的 sql_thread，拆成多个线程。</p>
<p>coordinator 就是原来的 sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了 worker 线程。而 work 线程的个数，就是由参数 <code>slave_parallel_workers</code> 决定的。</p>
<p>coordinator 在分发的时候，需要满足以下这两个基本要求：</p>
<ol>
<li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中。</li>
<li>同一个事务不能被拆开，必须放到同一个 worker 中。</li>
</ol>
<h3 id="按表分发策略"><a href="#按表分发策略" class="headerlink" title="按表分发策略"></a>按表分发策略</h3><img src="/article/9788/%E6%8C%89%E8%A1%A8%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" class title="按表并行复制程模型">
<p>每个 worker 线程对应一个 hash 表，用于保存当前正在这个 worker 的“执行队列”里的事务所涉及的表。<strong>hash 表的 key 是“库名. 表名”，value 是一个数字，表示队列中有多少个事务修改这个表。</strong></p>
<p>每个事务在分发的时候，跟所有 worker 的冲突关系包括以下三种情况：</p>
<ol>
<li>如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker;</li>
<li>如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；</li>
<li>如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。</li>
</ol>
<p>问题：如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</p>
<h3 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h3><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：如果两个事务没有更新相同的行，它们在备库上可以并行执行。</p>
<p><strong>这个模式要求 binlog 格式必须是 row。</strong></p>
<p>基于行的策略，事务 hash 表中还需要考虑唯一键，即 <strong>key 应该是“库名 + 表名 + 索引名 + 该索引的值”。</strong></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t1` (<br>  `id` int(11) NOT NULL,<br>  `a` int(11) DEFAULT NULL,<br>  `b` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  UNIQUE KEY `a` (`a`)<br>) ENGINE=InnoDB;<br><br>insert into t1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);<br></code></pre></td></tr></table></figure>
<img src="/article/9788/%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81%E7%A4%BA%E4%BE%8B.png" class title="唯一键冲突示例">
<ol>
<li>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。</li>
<li>key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表 a=2 的行。</li>
<li>key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表 a=1 的行。</li>
</ol>
</blockquote>
<p><strong>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。</strong></p>
<p>这两个方案其实都有一些约束条件：</p>
<ol>
<li>要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；</li>
<li>表必须有主键；不能有外键。</li>
<li>表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。</li>
</ol>
<h3 id="MySQL-5-6-版本的并行复制策略"><a href="#MySQL-5-6-版本的并行复制策略" class="headerlink" title="MySQL 5.6 版本的并行复制策略"></a>MySQL 5.6 版本的并行复制策略</h3><p><strong>用于决定分发策略的 hash 表里，key 就是数据库名。</strong></p>
<p>相比于按表和按行分发，这个策略有两个优势：</p>
<ol>
<li>构造 hash 值的时候很快，只需要库名；而且一个实例上 DB 数也不会很多，不会出现需要构造 100 万个项这种情况。</li>
<li>不要求 binlog 的格式。因为 statement 格式的 binlog 也可以很容易拿到库名。</li>
</ol>
<h3 id="MariaDB-的并行复制策略"><a href="#MariaDB-的并行复制策略" class="headerlink" title="MariaDB 的并行复制策略"></a>MariaDB 的并行复制策略</h3><ol>
<li>在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；</li>
<li>commit_id 直接写到 binlog 里面；</li>
<li>传到备库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；</li>
<li>这一组全部执行完成后，coordinator 再去取下一批。</li>
</ol>
<p>这个方案很容易被大事务拖后腿</p>
<h3 id="MySQL-5-7-的并行复制策略"><a href="#MySQL-5-7-的并行复制策略" class="headerlink" title="MySQL 5.7 的并行复制策略"></a>MySQL 5.7 的并行复制策略</h3><p>由参数 <code>slave-parallel-type</code> 来控制并行复制策略：</p>
<ol>
<li>配置为 DATABASE，表示使用 MySQL 5.6 版本的按库并行策略；</li>
<li>配置为 LOGICAL_CLOCK，表示的就是类似 MariaDB 的策略</li>
</ol>
<p>MySQL 5.7 并行复制策略的思想是：</p>
<ol>
<li>同时处于 prepare 状态的事务，在备库执行时是可以并行的；</li>
<li>处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的。</li>
</ol>
<h3 id="MySQL-5-7-22-的并行复制策略"><a href="#MySQL-5-7-22-的并行复制策略" class="headerlink" title="MySQL 5.7.22 的并行复制策略"></a>MySQL 5.7.22 的并行复制策略</h3><p>基于 WRITESET 的并行复制</p>
<p>新增了一个参数 <code>binlog-transaction-dependency-tracking</code>，用来控制是否启用这个新策略。参数的可选值有以下三种：</p>
<ol>
<li><code>COMMIT_ORDER</code>，表示的就是前面介绍的，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</li>
<li><code>WRITESET</code>，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。(hash 值是通过“库名 + 表名 + 索引名 + 值”计算)</li>
<li><code>WRITESET_SESSION</code>，是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ol>
<p><strong>优势:</strong></p>
<ol>
<li>writeset 是在主库生成后直接写入到 binlog 里面的，这样在备库执行的时候，不需要解析 binlog 内容（event 里的行数据），节省了很多计算量；</li>
<li>不需要把整个事务的 binlog 都扫一遍才能决定分发到哪个 worker，更省内存；</li>
<li>由于备库的分发策略不依赖于 binlog 内容，所以 binlog 是 statement 格式也是可以的。</li>
</ol>
<p><strong>约束：</strong></p>
<p>对于“表上没主键”和“外键约束”的场景，WRITESET 策略是没法并行的，也会暂时退化为单线程模型。</p>
<h2 id="主库出问题了，从库怎么办？"><a href="#主库出问题了，从库怎么办？" class="headerlink" title="主库出问题了，从库怎么办？"></a>主库出问题了，从库怎么办？</h2><blockquote>
<img src="/article/9788/%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" class title="一主多从基本结构">
<p>虚线箭头表示的是主备关系，也就是 A 和 A’互为主备， 从库 B、C、D 指向的是主库 A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p>
</blockquote>
<blockquote>
<p>主库发生故障，主备切换后的结果</p>
<p><img src="/article/一主多从基本结构 -- 主备切换.png"><span class="image-caption">一主多从基本结构 -- 主备切换</span></p>
<p>一主多从结构在切换完成后，A’会成为新的主库，从库 B、C、D 也要改接到 A’。正是由于多了从库 B、C、D 重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>
</blockquote>
<h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><blockquote>
<p>当把节点 B 设置成节点 A’的从库的时候，需要执行一条 change master 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CHANGE MASTER TO <br>MASTER_HOST=$host_name <br>MASTER_PORT=$port <br>MASTER_USER=$user_name <br>MASTER_PASSWORD=$password <br>MASTER_LOG_FILE=$master_log_name <br>MASTER_LOG_POS=$master_log_pos  <br></code></pre></td></tr></table></figure>
<ol>
<li>MASTER_HOST、MASTER_PORT、MASTER_USER 和 MASTER_PASSWORD 四个参数，分别代表了主库 A’的 IP、端口、用户名和密码。</li>
<li>参数 MASTER_LOG_FILE 和 MASTER_LOG_POS 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。</li>
</ol>
</blockquote>
<p><strong>同步位点</strong></p>
<p>节点 B 是 A 的从库，本地记录的也是 A 的位点。但是相同的日志<strong>，A 的位点和 A’的位点是不同的</strong>。因此，从库 B 要切换的时候，就需要先经过“找同步位点”这个逻辑。</p>
<p>考虑到切换过程中不能丢数据，所以总是要找一个“稍微往前”的，然后再通过判断跳过那些在从库 B 上已经执行过的事务。</p>
<p><strong>主动跳过错误</strong></p>
<p>在进行主从切换时，由于同步位点找的并不是很精确，就会出现如 主键冲突，停止同步 的错误</p>
<p>通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法</p>
<ol>
<li><p>主动跳过一个事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">set global sql_slave_skip_counter=1;<br>start slave;<br></code></pre></td></tr></table></figure>
<p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库 B 刚开始接到新主库 A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p>
</li>
<li><p>通过设置 <code>slave_skip_errors</code> 参数，直接设置跳过指定的错误</p>
<p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p>
<ol>
<li>1062 错误是插入数据时唯一键冲突；</li>
<li>1032 错误是删除数据时找不到行。</li>
</ol>
<p>可以把 <code>slave_skip_errors</code> 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过</p>
<p>这种直接跳过指定错误的方法，<strong>针对</strong>的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。</p>
</li>
</ol>
<h3 id="GTID"><a href="#GTID" class="headerlink" title="GTID"></a>GTID</h3><p>MySQL 5.6 版本引入了 GTID</p>
<p>GTID 的全称是 <em>Global Transaction Identifier</em>，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">GTID=server_uuid:gno<br></code></pre></td></tr></table></figure>
<ul>
<li>server_uuid 是一个实例第一次启动时自动生成的，是一个全局唯一的值；</li>
<li>gno 是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1。</li>
</ul>
<p>GTID 模式的启动也很简单，我们只需要在启动一个 MySQL 实例的时候，加上参数 <code>gtid_mode=on</code> 和 <code>enforce_gtid_consistency=on</code></p>
<p>在 GTID 模式下，每个事务都会跟一个 GTID 一一对应。这个 GTID 有两种生成方式，而使用哪种方式取决于 session 变量 <code>gtid_next</code> 的值。</p>
<ol>
<li><p>如果 <code>gtid_next=automatic</code>，代表使用默认值。这时，MySQL 就会把 <code>server_uuid:gno</code> 分配给这个事务。</p>
<ol>
<li><p>记录 binlog 的时候，先记录一行 SET </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">@@SESSION.GTID_NEXT=‘server_uuid:gno’;<br></code></pre></td></tr></table></figure>
</li>
<li><p>把这个 GTID 加入本实例的 GTID 集合。</p>
</li>
</ol>
</li>
<li><p>如果 gtid_next 是一个指定的 GTID 的值，比如通过 set <code>gtid_next=&#39;current_gtid’</code> 指定为 current_gtid，那么就有两种可能：</p>
<ol>
<li>如果 current_gtid 已经存在于实例的 GTID 集合中，接下来执行的这个事务会直接被系统忽略；</li>
<li>如果 current_gtid 没有存在于实例的 GTID 集合中，就将这个 current_gtid 分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的 GTID，因此 gno 也不用加 1。</li>
</ol>
</li>
</ol>
<p>一个 current_gtid 只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行 set 命令，把 gtid_next 设置成另外一个 gtid 或者 automatic。</p>
<h3 id="基于-GTID-的主备切换"><a href="#基于-GTID-的主备切换" class="headerlink" title="基于 GTID 的主备切换"></a>基于 GTID 的主备切换</h3><p>在 GTID 模式下，备库 B 要设置为新主库 A’的从库的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs MYSQL">CHANGE MASTER TO <br>MASTER_HOST=$host_name <br>MASTER_PORT=$port <br>MASTER_USER=$user_name <br>MASTER_PASSWORD=$password <br>master_auto_position=1 <br></code></pre></td></tr></table></figure>
<p><code>master_auto_position=1</code> 就表示这个主备关系使用的是 GTID 协议。</p>
<blockquote>
<p>实例 A’的 GTID 集合记为 set_a，实例 B 的 GTID 集合记为 set_b。</p>
<p>我们在实例 B 上执行 start slave 命令，取 binlog 的逻辑是这样的：</p>
<ol>
<li>实例 B 指定主库 A’，基于主备协议建立连接。</li>
<li>实例 B 把 set_b 发给主库 A’。</li>
<li>实例 A’算出 set_a 与 set_b 的差集，也就是所有存在于 set_a，但是不存在于 set_b 的 GTID 的集合，判断 A’本地是否包含了这个差集需要的所有 binlog 事务。<ol>
<li>如果不包含，表示 A’已经把实例 B 需要的 binlog 给删掉了，直接返回错误；</li>
<li>如果确认全部包含，A’从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B；</li>
</ol>
</li>
<li>之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。</li>
</ol>
</blockquote>
<p>在基于 GTID 的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。</p>
<h2 id="读写分离有哪些坑？"><a href="#读写分离有哪些坑？" class="headerlink" title="读写分离有哪些坑？"></a>读写分离有哪些坑？</h2><blockquote>
<p><strong>读写分离基本结构</strong></p>
<img src="/article/9788/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png" class title="读写分离基本结构">
<p><strong>带 proxy 的读写分离架构</strong></p>
<p><img src="/article/带 proxy 的读写分离架构.jpg"><span class="image-caption">带 proxy 的读写分离架构</span></p>
</blockquote>
<ol>
<li>客户端直连方案，因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发。</li>
<li>带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。</li>
</ol>
<p><strong>过期读问题：</strong>由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p>
<p><strong>处理过期读的方案：</strong></p>
<ol>
<li>强制走主库方案；</li>
<li>sleep 方案；</li>
<li>判断主备无延迟方案；</li>
<li>配合 semi-sync 方案；</li>
<li>等主库位点方案；</li>
<li>等 GTID 方案。</li>
</ol>
<h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>强制走主库方案其实就是，将查询请求做分类</p>
<ol>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。</li>
<li>对于可以读到旧数据的请求，才将其发到从库上。</li>
</ol>
<h3 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h3><p>主库更新后，读从库之前先 sleep 一下。</p>
<blockquote>
<p>假设是，大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。</p>
</blockquote>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p><code>show slave status</code> 结果里的 <code>seconds_behind_master</code> 参数的值，可以用来衡量主备延迟时间的长短。</p>
<ol>
<li><p>每次从库执行查询请求前，先判断 <code>seconds_behind_master</code> 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。</p>
</li>
<li><p>对比位点确保主备无延迟</p>
<ol>
<li><code>Master_Log_File</code> 和 <code>Read_Master_Log_Pos</code>，表示的是读到的主库的最新位点；</li>
<li><code>Relay_Master_Log_File</code> 和 <code>Exec_Master_Log_Pos</code>，表示的是备库执行的最新位点。</li>
</ol>
<p>如果 <code>Master_Log_File</code> 和 <code>Relay_Master_Log_File</code>、<code>Read_Master_Log_Pos</code> 和 <code>Exec_Master_Log_Pos</code> 这两组值完全相同，就表示接收到的日志已经同步完成。</p>
</li>
<li><p>对比 GTID 集合确保主备无延迟</p>
<ol>
<li>Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。</li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；</li>
<li>Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li>
</ol>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p>
<blockquote>
<p>问题：有时，binlog 在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。</p>
</blockquote>
</li>
</ol>
<h3 id="配合-semi-sync"><a href="#配合-semi-sync" class="headerlink" title="配合 semi-sync"></a>配合 semi-sync</h3><p>semi-sync 引入半同步复制，也就是 <strong>semi-sync replication</strong></p>
<ol>
<li>事务提交的时候，主库把 binlog 发给从库；</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了；</li>
<li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p>
<p><strong>semi-sync+ 位点判断的方案，只对一主一备的场景是成立的</strong>，在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p>
<ol>
<li>如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据；</li>
<li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li>
</ol>
<p>semi-sync 配合判断主备无延迟的方案，存在两个问题：</p>
<ol>
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li>
<li>在持续延迟的情况下，可能出现过度等待的问题。</li>
</ol>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select master_pos_wait(file, pos[, timeout]);<br></code></pre></td></tr></table></figure>
<ol>
<li>它是在从库执行的；</li>
<li>参数 file 和 pos 指的是主库上的文件名和位置；</li>
<li>timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。</li>
</ol>
<p>这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。</p>
<p>除了正常返回一个正整数 M 外，这条命令还会返回一些其他结果，包括：</p>
<ol>
<li>如果执行期间，备库同步线程发生异常，则返回 NULL；</li>
<li>如果等待超过 N 秒，就返回 -1；</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。</li>
</ol>
</blockquote>
<h3 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select wait_for_executed_gtid_set(gtid_set, 1);<br></code></pre></td></tr></table></figure>
<ol>
<li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</li>
<li>超时返回 1。</li>
</ol>
</blockquote>
<p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行 show master status。而 MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。</p>
<p><strong>让 MySQL 在执行事务后，返回包中带上 GTID</strong></p>
<p>需要将参数 <code>session_track_gtids</code> 设置为 OWN_GTID，然后通过 API 接口 <code>mysql_session_track_get_first</code> 从返回包解析出 GTID 的值即可。</p>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>实习,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/article/52913.html</url>
    <content><![CDATA[<p>学习源于<a href="https://www.bilibili.com/video/BV1mm4y1X7Hc?p=8&amp;spm_id_from=pageDriver">三更草堂</a></p>
<h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><p>Spring Security是一个<strong>功能强大且高度可定制的身份验证和访问控制框架</strong>。这是保护基于Spring的应用程序的事实上的标准。</p>
<p>SpringSecurity 提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC、DI、AOP功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p>
<p>Spring Security是一个专注于为Java应用程序提供身份验证和授权的框架。像所有Spring项目一样，Spring Security的真正力量在于它有多容易被扩展以满足自定义要求。</p>
<p><strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p>
<p><strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>基础项目</strong></p>
<p><code>SecurityApplication.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityApplication</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(SecurityApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>HelloController.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>  <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloController</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<p>访问 <code>http://localhost:8080/hello</code></p>
<p>跳转页面</p>
<img src="/article/52913/SpringSecurity%E5%85%A5%E9%97%A8.png" class title="image-20220404100727005">
<p>默认用户名：user</p>
<p>默认密码：后台运行复制</p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><img src="/article/52913/%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%B5%81%E7%A8%8B.png" class title="登录校验流程">
<h3 id="SpringSecurity完整流程"><a href="#SpringSecurity完整流程" class="headerlink" title="SpringSecurity完整流程"></a>SpringSecurity完整流程</h3><p>SpringSecurity其实就是一个过滤器链，内部包含了各种功能的过滤器。</p>
<p><strong>基础流程图</strong></p>
<img src="/article/52913/%E6%B5%81%E7%A8%8B%E5%9B%BE-9039561.png" class title="流程图">
<p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。</p>
<p><strong>ExceptionTranslationFilter：</strong> 处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>
<p><strong>FilterSecurityInterceptor：</strong> 负责权限校验的过滤器。</p>
<p>SpringSecurity过滤器链中有哪些过滤器及它们的顺序：</p>
<img src="/article/52913/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.png" class title="SpringSecurity过滤器链">
<h3 id="认证流程详解"><a href="#认证流程详解" class="headerlink" title="认证流程详解"></a>认证流程详解</h3><img src="/article/52913/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-9040230.png" class title="认证流程详解">
<p><strong>Authentication接口</strong>: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>
<p><strong>AuthenticationManager接口</strong>：定义了认证Authentication的方法，在 Spring Security 中，用来处理身份认证的类是 AuthenticationManager，我们也称之为认证管理器。</p>
<p><strong>UserDetailsService接口</strong>：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>
<p><strong>UserDetails接口（继承了 Serializable 序列化）</strong>：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>
<ol>
<li><p>自定义登录验证</p>
<img src="/article/52913/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81.png" class title="自定义登录验证">
<ol>
<li><p>自定义登录接口</p>
<p>调用ProviderManager的方法进行认证 如果认证通过生成jwt</p>
<p>使用userId作为Key，用户信息作为Value，把用户信息存入redis中</p>
</li>
<li><p>自定义UserDetailsService</p>
<p>在这个实现类中去查询数据库</p>
</li>
</ol>
</li>
<li><p>校验</p>
<p>定义Jwt认证过滤器，获取token，解析token获取其中的userid，从redis中获取用户信息，存入SecurityContextHolder</p>
</li>
</ol>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><h3 id="授权基本流程"><a href="#授权基本流程" class="headerlink" title="授权基本流程"></a>授权基本流程</h3><p>在 SpringSecurity 中，会使用默认的 FilterSecurityInterceptor 来进行权限校验。在 FilterSecurityInterceptor 中会从 SecurityContextHolder 获取其中的 Authentication ，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>
<p>所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</p>
<p>然后设置我们的资源所需要的权限即可。</p>
<h3 id="授权实现"><a href="#授权实现" class="headerlink" title="授权实现"></a>授权实现</h3><p><strong>限制访问资源所需权限</strong></p>
<p>可以使用注解去指定访问对应的资源所需的权限</p>
<ol>
<li><p>需要先开启相关配置 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在方法中使用注解配置权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PreAuthorize(&quot;hasAuthority(&#x27;权限&#x27;)&quot;)</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>封装权限信息</strong></p>
<h2 id="自定义失败处理"><a href="#自定义失败处理" class="headerlink" title="自定义失败处理"></a>自定义失败处理</h2><p>希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。</p>
<p>在 SpringSecurity 中，如果我们在认证或者授权的过程中出现了异常会被 ExceptionTranslationFilter 捕获到。在 ExceptionTranslationFilter 中会去判断是认证失败还是授权失败出现的异常。</p>
<p>如果是认证过程中出现的异常会被封装成 AuthenticationException 然后调用 <strong>AuthenticationEntryPoint</strong>  对象的方法去进行异常处理。</p>
<p>如果是授权过程中出现的异常会被封装成 AccessDeniedException 然后调用 <strong>AccessDeniedHandler</strong> 对象的方法去进行异常处理。</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>浏览器出于安全的考虑，使用 XMLHttpRequest 对象发起 HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。</p>
<ol>
<li><p>先对SpringBoot配置，运行跨域请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>    <span class="hljs-comment">// 设置允许跨域的路径</span><br>    registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br>      <span class="hljs-comment">// 设置允许跨域请求的域名</span><br>      .allowedOriginPatterns(<span class="hljs-string">&quot;*&quot;</span>)<br>      <span class="hljs-comment">// 是否允许cookie</span><br>      .allowCredentials(<span class="hljs-keyword">true</span>)<br>      <span class="hljs-comment">// 设置允许的请求方式</span><br>      .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>)<br>      <span class="hljs-comment">// 设置允许的header属性</span><br>      .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)<br>      <span class="hljs-comment">// 跨域允许时间</span><br>      .maxAge(<span class="hljs-number">3600</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>开启 SpringSecurity 的跨域访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>  <span class="hljs-comment">//允许跨域</span><br>  http.cors();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。</p>
<p>SpringSecurit 去防止 CSRF 攻击的方式就是通过 csrf_token 。后端会生成一个 csrf_token ，前端发起请求的时候需要携带这个 csrf_token ,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。</p>
<p>CSRF 攻击依靠的是 cookie 中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是 token ，而 token 并不是存储中 cookie 中，并且需要前端代码去把token 设置到请求头中才可以，所以CSRF攻击也就不用担心了。</p>
<hr>
<h2 id="项目过程"><a href="#项目过程" class="headerlink" title="项目过程"></a><strong>项目过程</strong></h2><p><strong>前端输入用户密码传入后端，后端判断用户名密码是否正确，如果正确，会生成一个JWT令牌，返回给前端，如果不正确重新输入用户名密码。</strong></p>
<p><strong>前端拿到JWT令牌之后，会放在请求头中，之后每一次请求都会携带JWT令牌，后端 JWT令牌拦截器，每次有请求进入后端，先判断JWT令牌 是否存在以及令牌是否正确合法有效，如果不存在或者JWT令牌不合法有效，拦截请求，如果JWT令牌合法有效，允许请求访问。</strong></p>
<blockquote>
<p><strong>引入依赖</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;!--security 依赖--&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--JWT 依赖--&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;<br>  &lt;artifactId&gt;jjwt&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>
<p><strong>JWT配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jwt:</span><br>  <span class="hljs-comment"># JWT存储的请求头</span><br>  <span class="hljs-attr">tokenHeader:</span> <span class="hljs-string">Authorization</span><br>  <span class="hljs-comment"># JWT 加解密使用的密钥</span><br>  <span class="hljs-attr">secret:</span> <span class="hljs-string">yeb-secret</span><br>  <span class="hljs-comment"># JWT的超期限时间（60*60*24）</span><br>  <span class="hljs-attr">expiration:</span> <span class="hljs-number">604800</span><br>  <span class="hljs-comment"># JWT 负载中拿到开头</span><br>  <span class="hljs-attr">tokenHead:</span> <span class="hljs-string">Bearer</span><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>编写JwtToken工具类</strong></p>
<ol>
<li><p>根据用户信息生成Token</p>
<ol>
<li>generateToken(UserDetails userDetails)</li>
<li>generateToken(Map&lt;String,Object&gt; claims)</li>
<li>generateExpirationDate()</li>
</ol>
</li>
<li><p>从Token中获取信息</p>
<ol>
<li><p>从Token中获取登录用户名</p>
<p>public String getUserNameFromToken(String token)</p>
</li>
<li><p>从Token中获取荷载</p>
<p>private Claims getClaimsFromToken(String token)</p>
</li>
</ol>
</li>
<li><p>判断Token是否有效</p>
<ol>
<li><p>判断 Token中的用户名和 用户信息中的用户名是否一致 并且 是否失效</p>
<p>public boolean validateToken(String token , UserDetails userDetails)</p>
</li>
<li><p>判断 Token 是否失效</p>
<p>private boolean isTokenExpired(String token)</p>
</li>
<li><p>获取 Token 失效时间</p>
<p>private Date getExpiredDateFromToken(String token)</p>
</li>
</ol>
</li>
<li><p>判断 Token 是否可以被刷新</p>
<p>public boolean canRefreshToken(String token)</p>
</li>
<li><p>刷新 Token</p>
<p>public String refreshToken(String token)</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li><p><strong>前端输入用户密码传入后端，后端判断用户名密码是否正确，如果正确，会生成一个JWT令牌，返回给前端，如果不正确重新输入用户名密码。</strong></p>
<ol>
<li><p>使用 Admin 实现 UserDetails , 重写其中的方法</p>
</li>
<li><p>使用 AdminServiceImpl 实现类 ， 获取前端传入的 用户名、密码、图形验证码；</p>
<ol>
<li><p>获取请求中的的图形验证码进行校验；</p>
</li>
<li><p>通过 userDetailsService 接口中 loadUserByUsername(username) 根据传入的用户名生成用户信息 userDetails</p>
<p>校验 userDetails </p>
<p>校验 前端传入密码是否与数据库中存储的密码进行校验</p>
</li>
<li><p>SpringSecurity全局对象中 更新 用户登录信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//全局更新</span><br><span class="hljs-comment">//更新security登录用户对象</span><br>UsernamePasswordAuthenticationToken authenticationToken = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(userDetails, <span class="hljs-keyword">null</span>, userDetails.getAuthorities());<br>SecurityContextHolder.getContext().setAuthentication(authenticationToken);<br></code></pre></td></tr></table></figure>
</li>
<li><p>生成 Token ，将 Token 以及 请求头放入 map 传入前端</p>
</li>
</ol>
</li>
</ol>
<p>登录成功</p>
</li>
<li><p><strong>JWT登录授权过滤器</strong></p>
<p>存在token并且token格式正确，使其登录，同时判断token是否有效，有效重新 SpringSecurity全局对象中 更新 用户登录信息</p>
</li>
<li><p>自定义未授权和登录结果返回</p>
<ol>
<li>未登录或token失效处理器</li>
<li>授权失败处理器</li>
</ol>
</li>
</ol>
</blockquote>
<hr>
<h3 id="UserDetailsService接口"><a href="#UserDetailsService接口" class="headerlink" title="UserDetailsService接口"></a>UserDetailsService接口</h3><blockquote>
<p><strong>UserDetailsService接口</strong> 加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> throw UsernameNotFoundException</span>;<br></code></pre></td></tr></table></figure>
<hr>
<p><strong>UserDetails</strong>接口：提供核心用户信息。通过 UserDetailsService 根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>
<hr>
<p>UserDetails接口的实现类 <strong>User</strong> 其中有两个核心构造方法,其中第一个User()调用第二个 User()方法</p>
<ul>
<li>User()方法中的 username 是从 loadUserByUsername(String username) 中前端传入的username，然后 User()方法中的 password 是从数据库中 根据 username 查找对应的 用户，返回其密码（用来和前端传入的密码进行比较）。</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>(username, password, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, authorities);<br>	&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String username, String password, <span class="hljs-keyword">boolean</span> enabled, <span class="hljs-keyword">boolean</span> accountNonExpired,</span></span><br><span class="hljs-params"><span class="hljs-function">			<span class="hljs-keyword">boolean</span> credentialsNonExpired, <span class="hljs-keyword">boolean</span> accountNonLocked,</span></span><br><span class="hljs-params"><span class="hljs-function">			Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;<br>		Assert.isTrue(username != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(username) &amp;&amp; password != <span class="hljs-keyword">null</span>,<br>				<span class="hljs-string">&quot;Cannot pass null or empty values to constructor&quot;</span>);<br>		<span class="hljs-keyword">this</span>.username = username;<br>		<span class="hljs-keyword">this</span>.password = password;<br>		<span class="hljs-keyword">this</span>.enabled = enabled;<br>		<span class="hljs-keyword">this</span>.accountNonExpired = accountNonExpired;<br>		<span class="hljs-keyword">this</span>.credentialsNonExpired = credentialsNonExpired;<br>		<span class="hljs-keyword">this</span>.accountNonLocked = accountNonLocked;<br>		<span class="hljs-keyword">this</span>.authorities = Collections.unmodifiableSet(sortAuthorities(authorities));<br>	&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<blockquote>
<p><strong>PasswordEncoder 接口</strong> Spring已经实例化，需要自定义重新实现 PasswordEncoder 实例。</p>
<p>该接口共有两个主要方法</p>
<ol>
<li><p>对 密码进行加密 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span></span>;<br></code></pre></td></tr></table></figure>
<p>通过对 <strong>原始密码 rawPassword</strong> 进行加密，返回一个加密后的 字符串</p>
</li>
<li><p>匹配 原始密码 与 加密后的密码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span></span>;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>官方推荐使用<strong>PasswordEncoder 接口</strong>的实现类 <strong>BCryptPasswordEncoder</strong> 基于 <strong>Hash算法</strong> 实现单向加密 </p>
</blockquote>
<hr>
<blockquote>
<p><strong>UsernamePasswordAuthenticationFilter类</strong> 负责处理在登陆页面填写了用户名密码后的登陆请求</p>
</blockquote>
<hr>
<blockquote>
<p><strong>Authentication接口</strong>: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>
</blockquote>
<hr>
<blockquote>
<p><strong>FormLoginConfigurer类</strong> 可以自定义登陆成功登陆失败跳转</p>
<p><strong>ForwardAuthenticationSuccessHandler</strong> 实现了 <strong>AuthenticationSuccessHandler 接口</strong> 定义了成功跳转链接</p>
<p><strong>ForwardAuthenticationFailureHandler</strong> 实现了 <strong>AuthenticationFailureHandler 接口</strong> 定义了失败跳转链接</p>
</blockquote>
<hr>
<blockquote>
<p><strong>WebSecurityConfigurerAdapter</strong> 是个适配器，是构建<strong>SecurityFilterChain</strong>的关键， 在配置的时候,需要我们自己写个配置类去继承他,然后编写自己所特殊需要的配置</p>
<p>重写的 <strong>configure(HttpSecurity http)</strong> 的方法就是用来配置 <strong>HttpSecurity</strong> 的</p>
<blockquote>
<p>http.</p>
<p>anyRequest() 表示所有请求</p>
<p>antMatches() 表示匹配请求</p>
<p>regexMatches() 表示通过正则进行匹配</p>
<p>mvcMatches() 表示匹配 ServletPath 为特有方法</p>
<hr>
<p>permitAll() 表示不需要被认证</p>
<p>authenticated() 表示需要被认证</p>
<p>hasAuthority() 表示需要某种权限</p>
<p>hasAnyAuthority() 表示需要多个权限其中之一</p>
<p>hasRole() 表示需要某种角色（初始化角色时 前缀 ROLE_ 匹配值不需要前缀）</p>
<p>hasAnyRole() 表示需要多个角色中的其中之一</p>
<p>hasIpAddress() 表示特定的 IP地址 才可以通过</p>
<hr>
<p>http.csrf() 跨站请求伪造攻击</p>
<hr>
<p>http.</p>
<p>exceptionHandling() 表示异常处理</p>
<p>accessDeniedHandler() 表示授权失败处理器</p>
<p>authenticationEntryPoint() 表示认证失败处理器</p>
</blockquote>
</blockquote>
<hr>
<blockquote>
<p><strong>AccessDeniedHandler接口</strong> 该类用来统一处理 <strong>AccessDeniedException</strong> 异常，为授权过程中出现异常</p>
<p>自定义授权过程异常处理，实现<strong>AccessDeniedHandler接口</strong>，并重写handle() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> IOException, ServletException</span>;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>基于注解的访问控制</strong></p>
<p>需要通过 <strong>@EnableGlobalMethodSecurity</strong> 进行开启后使用</p>
<p><strong>@Secured</strong>（方法或类） 专门用于判断是否具有角色 ，参数以 <strong>ROLE_</strong> 开头</p>
<p><strong>@PreAuthorize/@PostAuthorize</strong>（方法或类） 在访问方法或类再执行之前/之后判断权限 </p>
</blockquote>
<hr>
<blockquote>
<p><strong>Token Auth</strong></p>
<p>基于Token的身份验证方法，在服务端不需要存储用户的登录记录</p>
<ol>
<li>客户端使用用户名跟密码请求登陆</li>
<li>服务端收到请求，验证用户名和密码</li>
<li>验证成功，服务器端签发一个 Token，将这个Token发送给客户端</li>
<li>客户端收到Token将其存储</li>
<li>客户端每次向服务器请求资源的时候携带该 Token</li>
<li>服务器端收到请求，验证请求中携带的Token，验证成功，返回请求数据</li>
</ol>
</blockquote>
<blockquote>
<p><strong>JWT</strong> JSON WEB Token ,定义了一种简介的、自包含的协议格式，用于在通信双方传递JSON对象，传递的信息经过数字签名可以被验证和信任。</p>
<ol>
<li>基于JSON，方便解析；</li>
<li>可以在令牌中自定义丰富内容，易扩展；</li>
<li>通过非对称加密算法及数字签名技术，防止篡改，安全性高；</li>
<li>资源服务使用JWT可不依赖认证服务即可完成授权。</li>
</ol>
<p>JWT令牌较长，占存储空间比较大</p>
</blockquote>
<h3 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a><strong>JWT组成</strong></h3><blockquote>
<ol>
<li><p>头部 Header 描述JWT最基本信息</p>
<p>对头部的 JSON 字符串 进行 BASE64编码解码</p>
</li>
<li><p>负载 payload 存放有效信息（不要放敏感信息）</p>
<ol>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ol>
</li>
<li><p>签证、签名 signature</p>
<ol>
<li>header（BASE64编码之后的头部信息）</li>
<li>payload （BASE64编码之后的载荷信息）</li>
<li>secret （盐 ，必须保密，保存在服务器端）</li>
</ol>
</li>
</ol>
<p>JWT签发在服务器端，secret相当于私钥 </p>
</blockquote>
<blockquote>
<p><strong>JJWT</strong>：提供端到端的JWT创建和验证的Java库</p>
</blockquote>
<hr>
<blockquote>
<p><strong>OAUTH2 认证</strong></p>
<p>优点</p>
<ol>
<li>更安全，客户端不接触用户密码</li>
<li>短寿命和封装的Token</li>
<li>广泛传播、持续采用</li>
<li>资源服务器和授权服务器解耦</li>
<li>集中式授权，简化客户端</li>
<li>客户可以具有不同的信任级别</li>
</ol>
<p>缺点</p>
<ol>
<li>协议框架太宽泛，造成各种实现的兼容性和互操作性差</li>
<li>不是一个认证协议，本身不能告诉你任何用户信息</li>
</ol>
<img src="/article/52913/%E5%BE%AE%E4%BF%A1%E8%AE%A4%E8%AF%81%E4%B8%BE%E4%BE%8B.png" class title="微信认证举例">
<img src="/article/52913/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png" class title="认证流程">
</blockquote>
<blockquote>
<p>客户凭证(client Credentials) 客户端的clientId和密码用于认证客户</p>
<p>令牌(tokens) 授权服务器在接受到客户请求后，颁发的访问令牌</p>
<blockquote>
<p>授权码 仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌</p>
<p>访问令牌 用于代表一个用户或服务直接去访问受保护的资源</p>
<p>刷新令牌 用于去授权服务器获取一个刷新访问令牌</p>
<p>beareaToken 不管谁拿到Token都可以访问资源</p>
<p>proof of Possession Token 可以校验client是否对Token有明确的拥有权</p>
</blockquote>
<p>作用域(scopes) 客户请求访问令牌时，由资源拥有者外指定的细分权限</p>
</blockquote>
<blockquote>
<img src="/article/52913/SpringSecurityOAuth2.png" class title="SpringSecurityOAuth2">
</blockquote>
<blockquote>
<img src="/article/52913/SpringSecurityOAuth2%E6%9E%B6%E6%9E%84.png" class title="SpringSecurityOAuth2架构">
<ol>
<li>用户访问，此时没有Token，Oauth2RestTemplate报错，报错信息会被Oauth2ClientContextFilter捕获，并重定向到认证服务器；</li>
<li>认证服务器通过 Authorization Endpoint进行授权，并通过  AuthorizationServerTokenServices 生成授权码并返回给客户；</li>
<li>客户端拿到授权码去认证服务器通过 Token Endpoint 调用 AuthorizationServerTokenServices 生成Token 并返回给客户端</li>
<li>客户端拿到Token 去资源服务器访问资源，一般会通过 Oauth2AuthenticationManager 调用 ResourceServerTokenServices 进行校验，校验通过可获取资源</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringSecurity</category>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>实习,SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql45讲-实践（一）</title>
    <url>/article/46662.html</url>
    <content><![CDATA[<h2 id="普通索引和唯一索引，应该怎么选择？"><a href="#普通索引和唯一索引，应该怎么选择？" class="headerlink" title="普通索引和唯一索引，应该怎么选择？"></a>普通索引和唯一索引，应该怎么选择？</h2><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p><strong>change buffer</strong></p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些<strong>更新操作</strong>缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>需要说明的是，虽然名字叫作 change buffer，实际上它是<strong>可以持久化的数据</strong>。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 <strong>merge</strong>。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p>
<blockquote>
<p>merge 的执行流程是这样的：</p>
<ol>
<li>从磁盘读入数据页到内存（老版本的数据页）；</li>
<li>从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；</li>
<li>写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。</li>
</ol>
<p>这时候，数据页和内存中 change buffer 对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</p>
</blockquote>
<p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够<strong>避免占用内存，提高内存利用率。</strong></p>
<blockquote>
<p><strong>问题：什么条件下可以使用 change buffer 呢？</strong></p>
<p>对于<strong>唯一索引</strong>来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p>
<p><strong>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</strong></p>
</blockquote>
<p>change buffer 用的是 buffer pool 里的内存，因此<strong>不能无限增大</strong>。change buffer 的大小，可以通过参数 <code>innodb_change_buffer_max_size</code> 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p>
<p><strong>在表中插入一个新纪录，InnoDB处理流程：</strong></p>
<ol>
<li>这个记录要更新的目标页在内存中<ol>
<li>对于唯一索引来说，找到位置，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，找到位置，插入这个值，语句执行结束。</li>
</ol>
</li>
<li><strong>这个记录要更新的目标页不在内存中</strong><ol>
<li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li>
</ol>
</li>
</ol>
<p>将数据从磁盘读入内存涉及<strong>随机 IO 的访问，是数据库里面成本最高的操作之一</strong>。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
<blockquote>
<p>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p>
<p>反过来，假设一个业务的更新模式是<strong>写入之后马上会做查询</strong>，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p>
</blockquote>
<h3 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h3><p><strong>建议尽量选择普通索引</strong></p>
<p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p>
<ol>
<li>首先，业务正确性优先。</li>
<li>然后，在一些“归档库”的场景，你是可以考虑使用普通索引的。</li>
</ol>
<h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><p>如果要简单地对比这两个机制在提升更新性能上的收益的话</p>
<p><strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写）</strong>，</p>
<p><strong>change buffer 主要节省的则是随机读磁盘的 IO 消耗</strong></p>
<hr>
<p><strong>问题：change buffer 一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？change buffer 丢失可不是小事儿，再从磁盘读入数据可就没有了 merge 过程，就等于是数据丢失了。会不会出现这种情况呢？</strong></p>
<blockquote>
<p><strong>不会丢失</strong></p>
<p>虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。</p>
</blockquote>
<hr>
<h2 id="MySQL为什么有时候会选错索引？"><a href="#MySQL为什么有时候会选错索引？" class="headerlink" title="MySQL为什么有时候会选错索引？"></a>MySQL为什么有时候会选错索引？</h2><h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p><strong>选择索引是优化器的工作。</strong></p>
<p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p>
<p><strong>扫描行数</strong>并不是唯一的判断标准，优化器还会结合<strong>是否使用临时表、是否排序</strong>等因素进行综合判断。</p>
<h3 id="扫描行数是怎么判断的？"><a href="#扫描行数是怎么判断的？" class="headerlink" title="扫描行数是怎么判断的？"></a>扫描行数是怎么判断的？</h3><p><strong>区分度</strong></p>
<p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据<strong>统计信息</strong>来估算记录数。这个统计信息就是索引的“<strong>区分度</strong>”。</p>
<p><strong>基数</strong></p>
<p>显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“<strong>基数</strong>”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p>
<p><strong>采样统计</strong></p>
<p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p>
<p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数</p>
<p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</p>
<p>在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 <code>innodb_stats_persistent</code> 的值来选择：</p>
<ol>
<li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li>
<li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li>
</ol>
<p>对于由于索引统计信息不准确导致的问题，你可以用 <code>analyze table</code> 来解决。</p>
<h3 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h3><p><strong>原本可以执行得很快的 SQL 语句，执行速度却比你预期的慢很多，你应该怎么办呢？</strong></p>
<ol>
<li><p>采用 <code>force index</code> 强行选择一个索引</p>
<p>MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果 force index 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p>
</li>
<li><p>考虑修改语句，引导 MySQL 使用我们期望的索引</p>
</li>
<li><p>在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引</p>
</li>
</ol>
<h2 id="怎么给字符串字段加索引？"><a href="#怎么给字符串字段加索引？" class="headerlink" title="怎么给字符串字段加索引？"></a>怎么给字符串字段加索引？</h2><p><strong>用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<blockquote>
<p>当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p>
</blockquote>
<p>我们在建立索引时关注的是<strong>区分度</strong>，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p>
<p>使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例。</p>
<h3 id="前缀索引对覆盖索引的影响"><a href="#前缀索引对覆盖索引的影响" class="headerlink" title="前缀索引对覆盖索引的影响"></a>前缀索引对覆盖索引的影响</h3><ol>
<li><p>使用前缀索引可能会增加扫描行数</p>
</li>
<li><p>使用前缀索引就用不上覆盖索引对查询性能的优化</p>
<blockquote>
<p>即使查询到的信息已经包含了所有的信息，但是系统并不确定前缀索引的定义是否截断了完整信息，依然需要回到主键索引再查一次</p>
</blockquote>
</li>
</ol>
<h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><ol>
<li>使用倒序存储</li>
<li>使用 hash 字段</li>
</ol>
<blockquote>
<p>使用倒序存储和使用 hash 字段这两种方法的<strong>异同点</strong></p>
<ol>
<li>相同点：都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的。同样地，hash 字段的方式也只能支持等值查询。</li>
<li>区别：<ol>
<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</li>
<li>在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li>
<li>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="为什么我的MySQL会“抖”一下？"><a href="#为什么我的MySQL会“抖”一下？" class="headerlink" title="为什么我的MySQL会“抖”一下？"></a>为什么我的MySQL会“抖”一下？</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。</p>
<p>内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>
<p><strong>不论是脏页还是干净页，都在内存中。</strong></p>
<p>InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</p>
<p>第一种是，还没有使用的；</p>
<p>第二种是，使用了并且是干净页；</p>
<p>第三种是，使用了并且是脏页。</p>
<p>InnoDB 的策略是<strong>尽量使用内存</strong>，因此对于一个长时间运行的库来说，未被使用的页面很少。</p>
<p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p>
<blockquote>
<p>刷脏页出现以下这两种情况，都是会明显影响性能的：</p>
<ol>
<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>
<li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</li>
</ol>
</blockquote>
<h3 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h3><p><code>innodb_io_capacity</code> 这个参数，会告诉 InnoDB 你的磁盘能力。建议设置成磁盘的 IOPS。</p>
<p>测试磁盘随机读写的命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest <br></code></pre></td></tr></table></figure>
<p>InnoDB 的刷盘速度就是要参考这两个因素：</p>
<ol>
<li>一个是脏页比例</li>
<li>一个是 redo log 写盘速度</li>
</ol>
<blockquote>
<p>InnoDB 会根据这两个因素先单独算出两个数字</p>
<p>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是 75%。InnoDB 会根据当前的<strong>脏页比例（假设为 M）</strong>，算出一个范围在 0 到 100 之间的数字：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">F1(M)<br>&#123;<br>  if M&gt;=innodb_max_dirty_pages_pct then<br>      return 100;<br>  return 100*M/innodb_max_dirty_pages_pct;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的<strong>差值，我们假设为 N</strong>。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。</p>
<p>根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 <strong>R</strong>，之后引擎就可以按照 <code>innodb_io_capacity</code> 定义的能力<strong>乘以 R%</strong> 来控制刷脏页的速度。</p>
</blockquote>
<p>InnoDB 会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到 MySQL“抖”了一下的原因。</p>
<p><strong>要尽量避免这种情况，你就要合理地设置 innodb_io_capacity 的值，并且平时要多关注脏页比例(Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total)，不要让它经常接近 75%。</strong></p>
<h2 id="为什么表数据删掉一半，表文件大小不变？"><a href="#为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="为什么表数据删掉一半，表文件大小不变？"></a>为什么表数据删掉一半，表文件大小不变？</h2><p>一个 InnoDB 表包含两部分，即：<strong>表结构定义和数据</strong>。在 MySQL 8.0 版本以前，表结构是存在以 <code>.frm</code> 为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。</p>
<p>表结构定义占用的空间很小</p>
<p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 <code>innodb_file_per_table</code> 控制的：</p>
<ol>
<li>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li>
<li>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 <code>.ibd</code> 为后缀的文件中。</li>
</ol>
<p>建议将这个值设置为 ON:因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 <code>drop table</code> 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的</p>
<h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><p>InnoDB 里的数据都是用 B+ 树的结构组织的,如果我们删掉了一个数据页上的记录，InnoDB 引擎只会把删除的记录标记为删除，如果之后要再插入一个记录时，可能会复用这个位置<strong>（记录的复用，只限于符合范围条件的数据）</strong>。</p>
<p>如果删掉了一个数据页上的所有记录，整个数据页就可以被复用了<strong>（当整个页从 B+ 树里面摘掉以后，可以复用到任何位置）</strong>。</p>
<p><strong>delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。</strong></p>
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>不止是删除数据会造成空洞，插入数据也会造成空洞。</p>
<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>
<blockquote>
<p>经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。而<strong>重建表</strong> <code>alter table</code>，就可以达到这样的目的。</p>
</blockquote>
<p>Online DDL 之后，重建表的流程：</p>
<ol>
<li>建立一个临时文件，扫描表 A 主键的所有数据页；</li>
<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li>
<li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中；</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件；</li>
<li>用临时文件替换表 A 的数据文件。</li>
</ol>
<h2 id="count-这么慢，我该怎么办？"><a href="#count-这么慢，我该怎么办？" class="headerlink" title="count(*)这么慢，我该怎么办？"></a>count(*)这么慢，我该怎么办？</h2><p><strong>count(*) 的实现方式</strong></p>
<ol>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li>
<li>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ol>
<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。</p>
<p>对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</strong></p>
<blockquote>
<p><strong>问题：<code>TABLE_ROWS</code> 能代替 count(*) 吗？</strong></p>
<p>索引统计的值是通过采样来估算的。TABLE_ROWS 就是从这个采样估算得来的，因此它也很不准。</p>
<p>官方文档说误差可能达到 40% 到 50%。所以，show table status 命令显示的行数也不能直接使用。</p>
</blockquote>
<h3 id="用缓存系统保存计数"><a href="#用缓存系统保存计数" class="headerlink" title="用缓存系统保存计数"></a>用缓存系统保存计数</h3><p>对于更新很频繁的库来说,可以用一个 Redis 服务来保存这个表的总行数。</p>
<blockquote>
<p><strong>问题1：缓存系统可能会丢失更新</strong></p>
<p>Redis 异常重启以后，到数据库里面单独执行一次 count(*) 获取真实的行数，再把这个值写回到 Redis 里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p>
<hr>
<p><strong>问题2：将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。</strong></p>
<ol>
<li>一种是，查到的结果里面有最新插入记录，而 Redis 的计数里还没加 1；</li>
<li>另一种是，查到的结果里没有最新插入的记录，而 Redis 的计数里已经加了 1。</li>
</ol>
<p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的。</p>
</blockquote>
<h3 id="在数据库保存计数"><a href="#在数据库保存计数" class="headerlink" title="在数据库保存计数"></a>在数据库保存计数</h3><p>把这个计数直接放到数据库里单独的一张计数表中</p>
<ol>
<li>解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的；</li>
<li>解决计数不精确的问题，利用“事务”这个特性，解决问题。</li>
</ol>
<h3 id="不同的-count-用法"><a href="#不同的-count-用法" class="headerlink" title="不同的 count 用法"></a>不同的 count 用法</h3><p>count() 的语义：</p>
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p>
<p>count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>
<blockquote>
<p>分析性能差别的时候，三个原则：</p>
<ol>
<li>server 层要什么就给什么；</li>
<li>InnoDB 只给必要的值；</li>
<li>现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。</li>
</ol>
</blockquote>
<ol>
<li><p><code>count(主键 id)</code> </p>
<p>InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
</li>
<li><p><code>count(1)</code></p>
<p>InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
</li>
<li><p><code>count(字段)</code></p>
<ol>
<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li>
<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li>
</ol>
</li>
<li><p><code>count(*)</code></p>
<p>不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p>
</li>
</ol>
<p>按照效率排序的话，<strong>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)</strong></p>
<p>所以尽量使用 count(*)。</p>
<h2 id="“order-by”是怎么工作的？"><a href="#“order-by”是怎么工作的？" class="headerlink" title="“order by”是怎么工作的？"></a>“order by”是怎么工作的？</h2><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer</p>
<p>排序时，可能在内存 sort_buffer 中排序 ，也可能需要使用外部排序，<strong>这取决于排序所需的内存和参数 sort_buffer_size。</strong></p>
<p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>
<blockquote>
<p>通过查看 <code>OPTIMIZER_TRACE</code> 的结果来确认</p>
<p><code>number_of_tmp_files</code> 表示是否使用了临时文件：</p>
<ol>
<li>如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。</li>
<li>如果 sort_buffer_size 太小，number_of_tmp_files 就是 n，表示排序过程中使用 n 个临时文件。</li>
</ol>
</blockquote>
<p>sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。</p>
<h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><p>全字段排序<strong>问题</strong>：如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p>
<p><strong>解决：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SET max_length_for_sort_data = 16;<br></code></pre></td></tr></table></figure>
<p><code>max_length_for_sort_data</code> ，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p>
<p><strong>新的算法放入 sort_buffer 的字段，只有要排序的列和主键 id。</strong></p>
<p>最后的“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p>
<h3 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h3><ol>
<li>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</li>
<li>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</li>
</ol>
<p><strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p>
<blockquote>
<p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</p>
</blockquote>
<h2 id="如何正确地显示随机消息？"><a href="#如何正确地显示随机消息？" class="headerlink" title="如何正确地显示随机消息？"></a>如何正确地显示随机消息？</h2><h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><p>用 order by rand() 来实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select word from words order by rand() limit 3;<br></code></pre></td></tr></table></figure>
<p>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL 这时就会选择 rowid 排序。</p>
<p><strong>rowid:每个引擎用来唯一标识数据行的信息</strong></p>
<ol>
<li><p>对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；</p>
</li>
<li><p>对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的。</p>
</li>
</ol>
<p><strong>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</strong></p>
<h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><p><code>tmp_table_size</code> 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 <code>tmp_table_size</code>，那么内存临时表就会转成磁盘临时表。</p>
<p>磁盘临时表使用的引擎默认是 InnoDB，是由参数 <code>internal_tmp_disk_storage_engine</code> 控制的。</p>
<p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。</p>
<p><strong>优先队列排序算法</strong></p>
<p>（当存在 limit 时，并且 limit 需要的维护的最大堆的大小小于 sort_buffer，就会使用这个算法。）</p>
<ol>
<li>对于这 n 个准备排序的 (R,rowid)，先取前三行，构造成一个堆；</li>
<li>取下一个行 (R’,rowid’)，跟当前堆里面最大的 R 比较，如果 R’小于 R，把这个 (R,rowid) 从堆中去掉，换成 (R’,rowid’)；</li>
<li>重复第 2 步，直到第 n 个 (R’,rowid’) 完成比较。</li>
</ol>
<h2 id="为什么我只查一行的语句，也执行这么慢？"><a href="#为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="为什么我只查一行的语句，也执行这么慢？"></a>为什么我只查一行的语句，也执行这么慢？</h2><h3 id="第一类：查询长时间不返回"><a href="#第一类：查询长时间不返回" class="headerlink" title="第一类：查询长时间不返回"></a>第一类：查询长时间不返回</h3><blockquote>
<p>出现情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t where id=1;<br></code></pre></td></tr></table></figure>
<p>一般碰到这种情况的话，大概率是表 t 被锁住了。</p>
</blockquote>
<p>查看当前语句处于什么状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">show processlist;<br></code></pre></td></tr></table></figure>
<ol>
<li><p>等 MDL 锁</p>
<p>使用 show processlist 命令查看 Waiting for table metadata lock</p>
<p>表示的是，现在有一个线程正在请求或者持有 MDL 写锁，把 select 语句堵住了。</p>
<p><strong>处理方法：找到谁持有 MDL 写锁，然后把它 kill 掉</strong></p>
<p>(MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失，建议可以开启mysql的 performance_schema 功能，这个可以定位被锁的线程情况)</p>
<p>通过查询 sys.schema_table_lock_waits 这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。</p>
</li>
<li><p>等 flush</p>
<blockquote>
<p>mysql&gt; select * from information_schema.processlist where id=1;</p>
</blockquote>
<p>查出来这个线程的状态是 <strong>Waiting for table flush</strong></p>
<p>这个状态表示的是，现在有一个线程正要做 flush 操作。MySQL 里面对表做 flush 操作的用法，一般有以下两个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#如果指定表 t 的话，代表的是只关闭表 t；<br>flush tables t with read lock;<br>#如果没有指定具体的表名，则表示关闭 MySQL 里所有打开的表。<br>flush tables with read lock;<br></code></pre></td></tr></table></figure>
<p>但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p>
<p>所以，出现 <strong>Waiting for table flush</strong> 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句。</p>
</li>
<li><p>等行锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t where id=1 lock in share mode; <br>#读锁（S 锁，共享锁） 由于访问 id=1 这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的 select 语句就会被堵住。<br>mysql&gt; select k from t where id=1 for update; <br>#写锁（X 锁，排他锁）<br></code></pre></td></tr></table></figure>
<p>MySQL 5.7，通过 <strong>sys.innodb_lock_waits</strong> 表查到是谁占着这个写锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from sys.innodb_lock_waits where locked_table=&#x27;`test`.`t`&#x27;\G<br></code></pre></td></tr></table></figure>
<p><strong>直接断开这个连接</strong>。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了 id=1 上的行锁。</p>
</li>
</ol>
<h3 id="第二类：查询慢"><a href="#第二类：查询慢" class="headerlink" title="第二类：查询慢"></a>第二类：查询慢</h3><p>一致性读导致回滚日志过大引起的一致性读慢，当前读快</p>
<h2 id="幻读是什么，幻读有什么问题？"><a href="#幻读是什么，幻读有什么问题？" class="headerlink" title="幻读是什么，幻读有什么问题？"></a>幻读是什么，幻读有什么问题？</h2><h3 id="幻读是什么？"><a href="#幻读是什么？" class="headerlink" title="幻读是什么？"></a>幻读是什么？</h3><p>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，<strong>幻读在“当前读”下才会出现。</strong></p>
<h3 id="幻读有什么问题？"><a href="#幻读有什么问题？" class="headerlink" title="幻读有什么问题？"></a>幻读有什么问题？</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  `d` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE=InnoDB;<br><br>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);<br></code></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>首先是语义上的。</p>
<blockquote>
<p><img src="/article/假设只在 id=5 这一行加行锁 -- 语义被破坏.png"><span class="image-caption">假设只在 id=5 这一行加行锁 -- 语义被破坏</span></p>
<p>T1: session A 声明，“我要把所有 d=5 的行锁住，不准别的事务进行读写操作”。</p>
<p>T2:session B 的第二条语句 update t set c=5 where id=0，语义是“我把 id=0、d=5 这一行的 c 值，改成了 5”。由于在 T1 时刻，session A 还只是给 id=5 这一行加了行锁， 并没有给 id=0 这行加上锁。因此，session B 在 T2 时刻，是可以执行这两条 update 语句的。</p>
<p><strong>这样，就破坏了 session A 里 Q1 语句要锁住所有 d=5 的行的加锁声明。</strong></p>
</blockquote>
</li>
<li><p>其次，是数据一致性的问题。</p>
<p>锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p>
<blockquote>
<p><img src="/article/假设只在 id=5 这一行加行锁 -- 数据一致性问题.png"><span class="image-caption">假设只在 id=5 这一行加行锁 -- 数据一致性问题</span></p>
<p><strong>update 的加锁语义和 select …for update 是一致的</strong></p>
<ol>
<li><p>正常执行</p>
<p>经过 T1 时刻，id=5 这一行变成 (5,5,100)，当然这个结果最终是在 T6 时刻正式提交的 ;</p>
<p>经过 T2 时刻，id=0 这一行变成 (0,5,5);</p>
<p>经过 T4 时刻，表里面多了一行 (1,5,5);</p>
</li>
<li><p>binlog 记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">#T2 时刻，session B 事务提交，写入了两条语句；<br>update t set d=5 where id=0; /*(0,0,5)*/<br>update t set c=5 where id=0; /*(0,5,5)*/<br>#T4 时刻，session C 事务提交，写入了两条语句；<br>insert into t values(1,1,5); /*(1,1,5)*/<br>update t set c=5 where id=1; /*(1,5,5)*/<br>#T6 时刻，session A 事务提交，写入了 update t set d=100 where d=5 这条语句。<br>update t set d=100 where d=5;/*所有d=5的行，d改成100*/<br></code></pre></td></tr></table></figure>
<p>这个语句序列，不论是拿到备库去执行，还是以后用 binlog 来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100) 和 (5,5,100)。</p>
<p>id=0 和 id=1 这两行，发生了数据不一致。</p>
</li>
</ol>
<hr>
<p>为了解决上面数据不一致的问题，假设把扫描过程中碰到的行都加锁</p>
<img src="/article/46662/%E5%81%87%E8%AE%BE%E6%89%AB%E6%8F%8F%E5%88%B0%E7%9A%84%E8%A1%8C%E9%83%BD%E8%A2%AB%E5%8A%A0%E4%B8%8A%E4%BA%86%E8%A1%8C%E9%94%81.png" class title="假设扫描到的行都被加上了行锁">
<p>由于 session A 把所有的行都加了写锁，所以 session B 在执行第一个 update 语句的时候就被锁住了。需要等到 T6 时刻 session A 提交以后，session B 才能继续执行。</p>
<p>binlog:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">insert into t values(1,1,5); /*(1,1,5)*/<br>update t set c=5 where id=1; /*(1,5,5)*/<br><br>update t set d=100 where d=5;/*所有d=5的行，d改成100*/<br><br>update t set d=5 where id=0; /*(0,0,5)*/<br>update t set c=5 where id=0; /*(0,5,5)*/<br></code></pre></td></tr></table></figure>
<p>按照日志顺序执行，id=0 这一行的最终结果也是 (0,5,5)。所以，id=0 这一行的问题解决了。</p>
<p>id=1 这一行，在数据库里面的结果是 (1,5,5)，而根据 binlog 的执行结果是 (1,5,100)，也就是说幻读的问题还是没有解决。(因为：在 T3 时刻，我们给所有行加锁的时候，id=1 这一行还不存在，不存在也就加不上锁。)</p>
</blockquote>
</li>
</ol>
<p><strong>即使把所有的记录都加上锁，还是阻止不了新插入的记录</strong></p>
<h3 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h3><p>产生幻读的原因是，<strong>行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。</strong></p>
<p><strong>为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</strong></p>
<p><strong>间隙锁，锁的就是两个值之间的空隙。</strong></p>
<blockquote>
<p>初始化插入了 6 个记录，这就产生了 7 个间隙</p>
<img src="/article/46662/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8A%E7%9A%84%E8%A1%8C%E9%94%81%E5%92%8C%E9%97%B4%E9%9A%99%E9%94%81.png" class title="主键索引上的行锁和间隙锁">
<p>当你执行 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from t where d=5 for update<br></code></pre></td></tr></table></figure>
<p>就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。</p>
</blockquote>
<p><strong>在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</strong></p>
<p>数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。</p>
<p><strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong>间隙锁之间都不存在冲突关系。</p>
<p>间隙锁和行锁合称 <strong>next-key lock</strong>，每个 next-key lock 是<strong>前开后闭区间</strong>。</p>
<blockquote>
<p>也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p>
</blockquote>
<p><strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。</strong></p>
<blockquote>
<p><strong>只有在可重复读的隔离级别下，才会有间隙锁。读提交的隔离级别下不会有间隙锁</strong></p>
</blockquote>
<h2 id="为什么我只改一行的语句，锁这么多？"><a href="#为什么我只改一行的语句，锁这么多？" class="headerlink" title="为什么我只改一行的语句，锁这么多？"></a>为什么我只改一行的语句，锁这么多？</h2><p><strong>加锁规则</strong>：两个“原则”、两个“优化”和一个“bug”</p>
<ol>
<li>原则 1：加锁的基本单位是 <strong>next-key lock</strong>。next-key lock 是前开后闭区间。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  `d` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE=InnoDB;<br><br>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h3><blockquote>
<img src="/article/46662/%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%97%B4%E9%9A%99%E9%94%81.png" class title="等值查询的间隙锁">
<p>由于表 t 中没有 id=7 的记录</p>
<ol>
<li>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</li>
<li>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</li>
</ol>
<p><strong>session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。</strong></p>
</blockquote>
<h3 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h3><blockquote>
<img src="/article/46662/%E5%8F%AA%E5%8A%A0%E5%9C%A8%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8A%E7%9A%84%E9%94%81.png" class title="只加在非唯一索引上的锁">
<ol>
<li>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5]加上 next-key lock。</li>
<li>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10]加 next-key lock。</li>
<li>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</li>
<li>根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。(加锁，是加在索引上的。 列上，有索引，就加在索引上； 列上，没有索引，就加在主键上；)</li>
</ol>
<p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</p>
<p><strong>lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁</strong>。</p>
<p>这个例子说明，<strong>锁是加在索引上的</strong>；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 select d from t where c=5 lock in share mode。（改为select d ，因为索引c，并没有d列的值，需要回表，查主键，这样就会把id=5这行数据加锁。session B会被锁住。 session C 还是会因为session A 在C列上的间隙锁(0,5},(5,10)而不能插入。 实际加锁范围是：id=5的行锁，普通索引c上锁范围(0,5},(5,10)）</p>
</blockquote>
<h3 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h3><blockquote>
<p>这两条查询语句，加锁范围相同吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from t where id=10 for update;<br>mysql&gt; select * from t where id&gt;=10 and id&lt;11 for update;<br></code></pre></td></tr></table></figure>
<img src="/article/46662/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8A%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%94%81.png" class title="主键索引上范围查询的锁">
<ol>
<li>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</li>
<li>范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。</li>
</ol>
<p>所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。</p>
<p>注意：首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</p>
</blockquote>
<h3 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h3><blockquote>
<img src="/article/46662/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81.png" class title="非唯一索引范围锁">
<p>这次 session A 用字段 c 来判断</p>
<p>加锁规则跟主键索引范围锁唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10]这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。</p>
</blockquote>
<h3 id="唯一索引范围锁-bug"><a href="#唯一索引范围锁-bug" class="headerlink" title="唯一索引范围锁 bug"></a>唯一索引范围锁 bug</h3><blockquote>
<p><img src="/article/唯一索引范围锁的 bug.png"><span class="image-caption">唯一索引范围锁的 bug</span></p>
<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15]这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了</p>
<p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20]这个 next-key lock 也会被锁上。</p>
</blockquote>
<h3 id="非唯一索引上存在”等值”的例子"><a href="#非唯一索引上存在”等值”的例子" class="headerlink" title="非唯一索引上存在”等值”的例子"></a>非唯一索引上存在”等值”的例子</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; insert into t values(30,10,30);<br></code></pre></td></tr></table></figure>
<p>新插入的这一行 c=10，也就是说现在表里有两个 c=10 的行。</p>
<p>由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。</p>
<img src="/article/46662/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E7%9A%84%E4%BE%8B%E5%AD%90.png" class title="非唯一索引等值的例子">
<p>可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和 30），因此这两个 c=10 的记录之间，也是有间隙的。</p>
<p><img src="/article/delete 示例.png"><span class="image-caption">delete 示例</span></p>
<ol>
<li>session A 在遍历的时候，先访问第一个 c=10 的记录。同样地，根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。</li>
<li>session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。</li>
</ol>
<p>也就是说，这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。</p>
<p><img src="/article/delete 加锁效果示例.png"><span class="image-caption">delete 加锁效果示例</span></p>
</blockquote>
<h3 id="limit-语句加锁"><a href="#limit-语句加锁" class="headerlink" title="limit 语句加锁"></a>limit 语句加锁</h3><blockquote>
<p><img src="/article/limit 语句加锁.png"><span class="image-caption">limit 语句加锁</span></p>
<p>session A 的 delete 语句加了 limit 2。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了。</p>
<p>这是因为， delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。</p>
<p>因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间。</p>
<p><img src="/article/带 limit 2 的加锁效果.png"><span class="image-caption">带 limit 2 的加锁效果</span></p>
<p><strong>在删除数据的时候尽量加 limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
</blockquote>
<h3 id="一个死锁的例子"><a href="#一个死锁的例子" class="headerlink" title="一个死锁的例子"></a>一个死锁的例子</h3><blockquote>
<img src="/article/46662/%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97.png" class title="操作序列">
<ol>
<li>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</li>
<li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</li>
<li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</li>
</ol>
<p>session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。</p>
<p><strong>也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>实习,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql45讲</title>
    <url>/article/53105.html</url>
    <content><![CDATA[<p>关于MySQL的发音：</p>
<blockquote>
<p>The official way to pronounce “MySQL” is “My Ess Que Ell” (not “my sequel”), but we do not mind if you pronounce it as “my sequel” or in some other localized way.</p>
</blockquote>
<h2 id="一条SQL查询语句是如何执行的？"><a href="#一条SQL查询语句是如何执行的？" class="headerlink" title="一条SQL查询语句是如何执行的？"></a>一条SQL查询语句是如何执行的？</h2><p><img src="/article/MySQL 的基本架构示意图.png"><span class="image-caption">img</span></p>
<p><strong>MySQL 可以分为 Server 层和存储引擎层两部分。</strong>不同的存储引擎共用一个 Server 层。</p>
<p>Server 层包括<strong>连接器、查询缓存、分析器、优化器、执行器</strong>等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>现在最常用的存储引擎是 <strong>InnoDB</strong>，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql -h<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.558ex" height="2.509ex" style="vertical-align: -0.671ex;" viewbox="0 -791.3 2823.4 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">ip -P</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/>
<path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/>
<path stroke-width="1" id="E1-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-69" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-70" x="345" y="0"/>
 <use xlink:href="#E1-MJMAIN-2212" x="1071" y="0"/>
 <use xlink:href="#E1-MJMATHI-50" x="2071" y="0"/>
</g>
</svg>port -u$user -p<br></code></pre></td></tr></table></figure>
<p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份。</p>
<blockquote>
<ol>
<li><p>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p>
</li>
<li><p>如果用户名密码认证通过，连接器会到<strong>权限表</strong>里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</p>
<p>(一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。)</p>
</li>
</ol>
</blockquote>
<p>显示用户正在运行的线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">show processlist<br></code></pre></td></tr></table></figure>
<p>Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是 8 小时。</p>
<p><strong>建议尽量使用长连接</strong></p>
<blockquote>
<p>数据库里面，<strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。<strong>短连接</strong>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
</blockquote>
<p>全部使用长连接后，有些时候 MySQL 占用内存涨得特别快</p>
<p><strong>这是因为</strong> MySQL 在执行过程中临时使用的内存是管理在<strong>连接对象里面的</strong>。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，<strong>被系统强行杀掉（OOM）</strong>，从现象看就是 MySQL 异常重启了。</p>
<blockquote>
<p><strong>解决方法</strong></p>
<ol>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>MySQL 5.7 或更新版本：可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。<strong>这个过程不需要重连和重新做权限验证</strong>，但是会将连接恢复到刚刚创建完时的状态。</li>
</ol>
</blockquote>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>MySQL 拿到一个查询请求后:</p>
<ol>
<li>先到查询缓存：之前是否执行过这条语句，之前执行过的语句及其结果可能会以 <code>key(查询语句)-value（查询结果）</code> 对的形式，被直接缓存在内存中。(<a href="https://dev.mysql.com/blog-archive/mysql-8-0-retiring-support-for-the-query-cache/">MySQL 8.0版本直接将查询缓存的整块功能删掉了</a> （弊大于利）查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空)。</li>
<li>没有找缓存结果：<a href="#分析器">开始真正执行语句</a></li>
</ol>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><ol>
<li><strong>词法分析</strong>：MySQL 需要识别出输入的的字符串（SQL语句）分别是什么，代表什么；</li>
<li><strong>语法分析</strong>：根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。（语法错误提示：“You have an error in your SQL syntax”）。</li>
</ol>
<p>分析器处理语法和解析查询, 生成一课对应的解析树。 预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>在开始执行之前，还要先经过优化器的处理。</p>
<p><strong>优化器</strong>是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><ol>
<li>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限(在工程实现上，如果命中查询缓存，会在<strong>查询缓存返回结果</strong>的时候，做权限验证。查询也会在<strong>优化器之前</strong>调用 precheck 验证权限)；</li>
<li>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的<strong>引擎定义</strong>，去使用这个引擎提供的接口。</li>
</ol>
<p>你会在数据库的慢查询日志中看到一个 <code>rows_examined</code> 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<blockquote>
<p>执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 <code>rows_examined</code> 并不是完全相同的</p>
</blockquote>
<h2 id="一条SQL更新语句是如何执行的？"><a href="#一条SQL更新语句是如何执行的？" class="headerlink" title="一条SQL更新语句是如何执行的？"></a>一条SQL更新语句是如何执行的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">update T set c=c+1 where ID=2;<br></code></pre></td></tr></table></figure>
<p><img src="/article/MySQL 的基本架构示意图.png"><span class="image-caption">img</span></p>
<p><strong>执行流程</strong></p>
<p>执行语句前要先<strong>连接</strong>数据库，这是连接器的工作</p>
<p>在一个表上有<strong>更新</strong>的时候，跟这个表有关的<strong>查询缓存会失效</strong>，所以这条语句就会把表 T 上所有缓存结果都清空。</p>
<p><strong>分析器</strong>会通过词法和语法解析知道这是一条更新语句。<strong>优化器</strong>决定要使用 ID 这个索引。然后，<strong>执行器</strong>负责具体执行，找到这一行，然后更新。</p>
<p>两个重要的日志模块：<strong>redo log（重做日志）和 binlog（归档日志）</strong>（只要我们写的是DML语句（insert,update,delete,create）等等，那么我们在数据库服务端执行的时候就会涉及到 redo log(重做日志) 和 binlog(归档日志) 两个日志文件的变动）</p>
<h3 id="redo-log（重做日志）–InnoDB特有的日志"><a href="#redo-log（重做日志）–InnoDB特有的日志" class="headerlink" title="redo log（重做日志）–InnoDB特有的日志"></a>redo log（重做日志）–InnoDB特有的日志</h3><blockquote>
<p>问题：如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。</p>
</blockquote>
<p>解决：<strong>WAL 技术</strong>，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。</p>
<p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 <strong>redo log</strong>里面，并更新内存，这个时候更新就算完成了。同时，<strong>InnoDB 引擎</strong>会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>
<blockquote>
<p>问题：InnoDB 的 redo log 是固定大小的，redo log 写满之后，先将日志中的部分记录写到磁盘，腾出redo log的空间继续写入。</p>
</blockquote>
<p><img src="/article/redo log 循环写入.png"><span class="image-caption">img</span></p>
<p><code>write pos</code> 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<code>check point</code> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p><code>write pos</code> 和 <code>checkpoint</code> 之间的是“redo log”上还空着的部分，可以用来记录新的操作。</p>
<p>如果 <code>write pos</code> 追上 <code>checkpoint</code>，表示“redo log”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。</p>
<p>redo log 用于保证 crash-safe 能力。<code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p>
<h3 id="binlog（归档日志）–Server层-日志"><a href="#binlog（归档日志）–Server层-日志" class="headerlink" title="binlog（归档日志）–Server层 日志"></a>binlog（归档日志）–Server层 日志</h3><blockquote>
<p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，<strong>binlog</strong> 日志只能用于<strong>归档</strong>。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p>
</blockquote>
<p><code>sync_binlog</code> 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p>
<table>
<thead>
<tr>
<th style="text-align:left">redo log</th>
<th style="text-align:left">binlog</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">InnoDB 引擎特有的</td>
<td style="text-align:left">MySQL 的 Server 层实现的，所有引擎都可以使用</td>
</tr>
<tr>
<td style="text-align:left">物理日志：记录的是“在某个数据页上做了什么修改”</td>
<td style="text-align:left">逻辑日志：记录的是这个语句的原始逻辑</td>
</tr>
<tr>
<td style="text-align:left">循环写入，空间固定会用完</td>
<td style="text-align:left">追加写入，binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</td>
</tr>
</tbody>
</table>
<p>浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p>
<p><img src="/article/update 语句执行流程.png"><span class="image-caption">img</span></p>
<p><strong>两阶段提交</strong>:为了让两份日志之间的逻辑一致</p>
<h2 id="事务隔离：为什么你改了我还看不见？"><a href="#事务隔离：为什么你改了我还看不见？" class="headerlink" title="事务隔离：为什么你改了我还看不见？"></a>事务隔离：为什么你改了我还看不见？</h2><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的（MySQL 原生的 MyISAM 引擎就不支持事务）。</p>
<p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p>
<h3 id="隔离性与隔离级"><a href="#隔离性与隔离级" class="headerlink" title="隔离性与隔离级"></a>隔离性与隔离级</h3><p><strong>隔离得越严实，效率就会越低</strong></p>
<p>当数据库上有多个事务同时执行的时候，就可能出现<strong>脏读</strong>（dirty read）、<strong>不可重复读</strong>（non-repeatable read）、<strong>幻读</strong>（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>
<ol>
<li><strong>脏读</strong>：读到其他事务未提交的数据；</li>
<li><strong>不可重复读</strong>：前后读取的记录内容不一致；</li>
<li><strong>幻读</strong>：前后读取的记录数量不一致。</li>
</ol>
<blockquote>
<p>脏读：事务A查询数据后进行了一次修改且未提交，而事务B这个时候去查询，然后使用了这个数据，因为这个数据还没有被事务A 提交到数据库中，所以事务B的得到数据就是脏数据，对脏数据进行操作可能是不正确的。 不可重复读: 事务A访问了两次数据，但是这访问第二次之间事务B进行一次并进行了修改，导致事务A访问第二次的时候得到的数据与第一次不同，导致一个事务访问两次数据得到的数据不相同。因此叫做不可重复读。 幻读： 与不可重复读都点相似，只是这次是事务B在事务A访问第二次的之前做了一个新增，导致事务A第二次读取的时候发现了多的记录，这就是幻读。 丢失修改：事务A访问该数据，事务B也访问该数据，事务A修改了该数据，事务B也修改了该数据，这样导致事务A的修改被丢失，因此称为丢失修改； 不可重复度和幻读区别： 不可重复读主要是修改操作，幻读的主要在于新增或者删除。 幻读主要在于数据的条数变了，而不可重复读主要在于数据内容变了。</p>
</blockquote>
<p>SQL 标准的事务隔离级别包括<strong>：读未提交</strong>（read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（serializable ）。</p>
<ol>
<li><strong>读未提交</strong>，一个事务还没提交时，它做的变更就能被别的事务看到；</li>
<li><strong>读提交</strong>，一个事务提交之后，它做的变更才会被其他事务看到；</li>
<li><strong>可重复读</strong>，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的；(<strong>别人改数据的事务已经提交，我在我的事务中也不去读</strong>。)</li>
<li><strong>串行化</strong>，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ol>
<p><strong>这4种隔离级别，并行性能依次降低，安全性依次提高</strong></p>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p>
<p>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。（事务启动时的视图可以认为是静态的，不受其他事务更新的影响。）</p>
<blockquote>
<p>事务启动方式：</p>
<ol>
<li>一致性视图是在执行第一个快照读语句时创建的；</li>
<li>一致性视图是在执行 <code>start transaction with consistent snapshot</code> 时创建的。</li>
</ol>
</blockquote>
<p>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。</p>
<p>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</p>
<p>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>
<p>Oracle 数据库的默认隔离级别其实就是“读提交”；</p>
<p>MySQL默认的隔离级别是”可重复读”。</p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>
<p><strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong></p>
<p>系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。（就是当系统里没有比这个回滚日志更早的视图的时候）</p>
<p><strong>问题：为什么建议你尽量不要使用长事务</strong></p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 <strong>ibdata</strong> 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。</p>
<p>长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><ol>
<li><p>显式启动事务语句， <code>begin</code> 或 <code>start transaction</code>。配套的提交语句是 <code>commit</code>，回滚语句是 <code>rollback</code>。</p>
</li>
<li><p><code>set autocommit=0</code>，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 <code>commit</code> 或<code>rollback</code>语句，或者断开连接。</p>
<p><strong>建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务。</strong></p>
</li>
<li><p>用 <code>commit work and chain</code> 语法</p>
<p>在 <strong>autocommit 为 1</strong> 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>
</li>
</ol>
<p><code>information_schema 库的 innodb_trx 这个表</code>中查询长事务</p>
<hr>
<p><strong>问题：有什么方案来避免出现或者处理长事物？</strong></p>
<blockquote>
<p>首先，从应用开发端来看：</p>
<ol>
<li>确认是否使用了 <code>set autocommit=0</code>。这个确认工作可以在测试环境中开展，把 MySQL 的 <code>general_log</code> 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</li>
<li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 <code>begin/commit</code> 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</li>
<li>业务连接数据库的时候，根据业务本身的预估，通过 <code>SET MAX_EXECUTION_TIME</code> 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li>
</ol>
<p>其次，从数据库端来看：</p>
<ol>
<li><p>监控 <code>information_schema.Innodb_trx 表</code>，设置长事务阈值，超过就报警 / 或者 kill；</p>
</li>
<li><p>Percona 的 pt-kill 这个工具不错，推荐使用；</p>
</li>
<li><p>在业务功能测试阶段要求输出所有的 <code>general_log</code>，分析日志行为提前发现问题；</p>
</li>
<li><p>如果使用的是 MySQL 5.6 或者更新版本，把 <code>innodb_undo_tablespaces</code> 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</p>
<p>(innodb_undo_tablespaces是控制undo是否开启独立的表空间的参数 </p>
<ol>
<li>为0表示：undo使用系统表空间，即ibdata1 </li>
<li>不为0表示：使用独立的表空间，一般名称为 undo001 undo002，存放地址的配置项为：innodb_undo_directory </li>
<li>一般innodb_undo_tablespaces 默认配置为0，innodb_undo_directory默认配置为当前数据目录)</li>
</ol>
</li>
</ol>
</blockquote>
<hr>
<h2 id="深入浅出索引"><a href="#深入浅出索引" class="headerlink" title="深入浅出索引"></a>深入浅出索引</h2><p><strong>索引的出现是为了提高查询效率</strong></p>
<h3 id="哈希表索引模型"><a href="#哈希表索引模型" class="headerlink" title="哈希表索引模型"></a>哈希表索引模型</h3><p>哈希表是一种以 <strong>键 - 值</strong>（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。</p>
<blockquote>
<p>思路：</p>
<p>用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>
</blockquote>
<blockquote>
<p><strong>问题</strong>：多个 key 值经过哈希函数的换算，会出现同一个值的情况</p>
<p><strong>解决方法：</strong>拉出一个链表</p>
<img src="/article/53105/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="根据身份证号查找对应的名字">
<p><strong>缺点：</strong>因为不是有序的（比如四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加），所以<strong>哈希索引做区间查询的速度是很慢的</strong>。</p>
<p>哈希表这种结构适用于只有<strong>等值查询</strong>的场景，比如 Memcached 及其他一些 NoSQL 引擎。</p>
</blockquote>
<h3 id="有序数组索引模型"><a href="#有序数组索引模型" class="headerlink" title="有序数组索引模型"></a>有序数组索引模型</h3><p>适用于<strong>等值查询</strong>和<strong>范围查询</strong>场景</p>
<blockquote>
<p>根据身份证号查找对应的名字<strong>有序数组</strong>示意图</p>
<img src="/article/53105/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="根据身份证号查找对应的名字">
<p>用二分法就可以快速得到，这个<strong>时间复杂度是 O(log(N))</strong></p>
<p><strong>优点：</strong>仅仅看查询效率，有序数组就是最好的数据结构</p>
<p><strong>缺点：</strong>中间插入一个记录就必须得挪动后面所有的记录，成本太高</p>
<p>有序数组索引<strong>只适用于静态存储引擎</strong></p>
</blockquote>
<h3 id="二叉搜索树索引模型"><a href="#二叉搜索树索引模型" class="headerlink" title="二叉搜索树索引模型"></a>二叉搜索树索引模型</h3><blockquote>
<p>根据身份证号查找对应的名字<strong>二叉搜索树</strong>示意图</p>
<img src="/article/53105/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class title="根据身份证号查找对应的名字">
<p>二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。</p>
<p><strong>时间复杂度是 O(log(N))</strong></p>
<p><strong>优点：</strong>二叉树是搜索效率最高的</p>
<p><strong>缺点：</strong></p>
<ol>
<li>为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是<strong>平衡二叉树</strong>。为了做这个保证，<strong>更新的时间复杂度也是 O(log(N))</strong>。</li>
<li>索引不止存在内存中，还要写到磁盘上（所以大多数的数据库存储并不使用二叉树）</li>
</ol>
<p><strong>解决方法：</strong>为了让一个查询<strong>尽量少地读磁盘</strong>，就必须让查询过程<strong>访问尽量少的数据块</strong>。那么，我们就不应该使用二叉树，而是要使用“<strong>N 叉</strong>”树。这里，<strong>“N 叉”树中的“N”取决于数据块的大小</strong>。</p>
<p><strong>N叉树优点：</strong>读写上的性能优点，以及适配磁盘的访问模式</p>
</blockquote>
<p>在 MySQL 中，<strong>索引是在存储引擎层实现</strong>的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><p>在 InnoDB 中，表都是根据<strong>主键顺序以索引</strong>的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。</p>
<p>InnoDB 使用了 <strong><a href="https://blog.csdn.net/weixin_35871519/article/details/113303881">B+ 树索引模型</a></strong>，所以数据都是存储在 B+ 树中的。</p>
<p><strong>每一个索引在 InnoDB 里面对应一棵 B+ 树</strong></p>
<p><strong>B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</strong></p>
<blockquote>
<p>假设有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; create table T(<br>id int primary key, <br>k int not null, <br>name varchar(16),<br>index (k))engine=InnoDB;<br></code></pre></td></tr></table></figure>
<p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下:</p>
<p><img src="/article/InnoDB 的索引组织结构.png"><span class="image-caption">InnoDB 的索引组织结构</span></p>
<p>图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p>查询时：</p>
<ol>
<li><p>主键查询方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from T where ID=500<br></code></pre></td></tr></table></figure>
<p>只需要搜索 ID 这棵 B+ 树</p>
</li>
<li><p>普通索引查询方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from T where k=5<br></code></pre></td></tr></table></figure>
<p>需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</p>
</li>
</ol>
<p>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该<strong>尽量使用主键查询</strong>。</p>
</blockquote>
<p><strong>主键索引</strong>的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为<strong>聚簇索引</strong>（clustered index）。</p>
<p><strong>非主键索引</strong>的叶子节点内容是<strong>主键的值</strong>。在 InnoDB 里，非主键索引也被称为<strong>二级索引</strong>（secondary index）。</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a><strong>索引维护</strong></h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p>
<blockquote>
<p><strong>页分裂</strong>:新插入的数据符合条件的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。（除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。）</p>
<p><strong>页合并</strong>：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
</blockquote>
<p><strong>性能和存储空间方面考量，自增主键往往是更合理的选择</strong></p>
<p>自增主键的插入数据模式，正符合了递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<blockquote>
<p>适合用业务字段直接做主键的场景:</p>
<ol>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ol>
<p>直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树</p>
</blockquote>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p><strong>经过索引优化，避免回表过程</strong></p>
<blockquote>
<p>搜索由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select * from T where k between 3 and 5<br></code></pre></td></tr></table></figure>
<p>变为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">select ID from T where k between 3 and 5<br></code></pre></td></tr></table></figure>
<p>只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为<strong>覆盖索引</strong>。</p>
</blockquote>
<p>由于覆盖索引可以<strong>减少树的搜索次数</strong>，<strong>显著提升查询性能</strong>，所以使用<strong>覆盖索引</strong>是一个常用的性能优化手段。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p><strong>为一个不频繁的请求创建一个索引感觉很浪费</strong></p>
<p><strong>最左前缀</strong>可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>
<blockquote>
<p><strong>问题：</strong>在建立联合索引的时候，如何安排索引内的字段顺序</p>
<p><strong>评估标准:</strong>索引的复用能力</p>
<ol>
<li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>
<li>(如果既有联合查询，又有基于 a、b 各自的查询)第二原则是,空间</li>
</ol>
</blockquote>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;<br></code></pre></td></tr></table></figure>
<p>无索引下推执行流程</p>
<img src="/article/53105/%E6%97%A0%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" class title="无索引下推执行流程">
<p>索引下推执行流程</p>
<img src="/article/53105/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" class title="索引下推执行流程">
</blockquote>
<hr>
<p><strong>问题：重建索引时，是重建非主键索引还是主键索引？</strong></p>
<p>重建非主键索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table T drop index k;<br>alter table T add index(k);<br></code></pre></td></tr></table></figure>
<p>重建主键索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">alter table T drop primary key;<br>alter table T add primary key(id);<br></code></pre></td></tr></table></figure>
<blockquote>
<p>重建索引 k 的做法是合理的，可以达到省空间的目的。</p>
<p>但是，重建主键的过程不合理。<strong>不论是删除主键还是创建主键，都会将整个表重建。</strong>所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。</p>
</blockquote>
<hr>
<h2 id="全局锁和表锁-：给表加个字段怎么有这么多阻碍？"><a href="#全局锁和表锁-：给表加个字段怎么有这么多阻碍？" class="headerlink" title="全局锁和表锁 ：给表加个字段怎么有这么多阻碍？"></a>全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h2><p>数据库锁设计的<strong>初衷是处理并发问题</strong>。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p>
<p>MySQL 里面的锁大致可以分成<strong>全局锁、表级锁和行锁</strong>三类。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock (FTWRL)</code>。</p>
<p>当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong></p>
<blockquote>
<p>全局锁的问题:</p>
<ol>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li>
</ol>
</blockquote>
<p>官方自带的逻辑备份工具是 <strong>mysqldump</strong>。当 mysqldump 使用参数<code>–single-transaction</code> 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p>
<blockquote>
<p><strong>问题：有了mysqldump功能，为什么还需要 FTWRL 呢？</strong></p>
<p>一致性读是好，但前提是引擎要支持<strong>可重复读</strong>隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p>
</blockquote>
<p><strong><code>-single-transaction</code> 方法只适用于所有的表使用事务引擎的库。</strong></p>
<blockquote>
<p><strong>问题：既然要全库只读，为什么不使用 set global readonly=true 的方式呢？</strong></p>
<ol>
<li>一在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议你使用。</li>
<li>在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ol>
</blockquote>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL 里面表级别的锁有两种：一种是<strong>表锁</strong>，一种是<strong>元数据锁</strong>（meta data lock，MDL)。</p>
<p><strong>表锁</strong></p>
<p>表锁的语法是 <code>lock tables … read/write</code>。与 FTWRL 类似，可以用 <code>unlock tables</code> 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法<strong>除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</strong></p>
<p><strong>元数据锁</strong>(MySQL 5.5 版本中引入)</p>
<p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。</p>
<p>MDL 的作用是，<strong>保证读写的正确性</strong>。</p>
<ol>
<li>当对一个表做增删改查操作的时候，加 <strong>MDL 读锁</strong>；</li>
<li>当要对表做结构变更操作的时候，加 <strong>MDL 写锁</strong>。</li>
</ol>
<p>每执行一条DML、DDL语句时都会申请MDL锁，<strong>DML操作需要MDL读锁，DDL操作需要MDL写锁</strong>（MDL加锁过程是系统自动控制，无法直接干预，读读共享，读写互斥，写写互斥）</p>
<ol>
<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ol>
<p><strong>MDL 会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</strong></p>
<p><strong>表锁一般是在数据库引擎 <em>不支持行锁</em> 的时候才会被用到的。</strong></p>
<hr>
<p><strong>问题：如何安全地给小表加字段？</strong></p>
<blockquote>
<p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 <code>information_schema 库的 innodb_trx 表</code>中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p>
</blockquote>
<hr>
<p><strong>问题：如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</strong></p>
<blockquote>
<p>在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p>
<p><code>DDL NOWAIT/WAIT n</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE tbl_name NOWAIT add column ...<br>ALTER TABLE tbl_name WAIT N add column ... <br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><strong>问题：如果你发现你的应用程序里有 lock tables 这样的语句，需要怎么做？</strong></p>
<blockquote>
<ol>
<li>要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；</li>
<li>要么是你的引擎升级了，但是代码还没升级。最后业务开发就是把 lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。</li>
</ol>
</blockquote>
<hr>
<p><strong>问题：备份一般都会在备库上执行，你在用–single-transaction 方法做逻辑备份的过程中，如果主库上的一个小表做了一个 DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</strong></p>
<blockquote>
<p>假设这个 DDL 是针对表 t1 的， 这里我把备份过程中几个关键的语句列出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；<br>/* other tables */<br>Q3:SAVEPOINT sp;<br>/* 时刻 1 */<br>Q4:show create table `t1`;<br>/* 时刻 2 */<br>Q5:SELECT * FROM `t1`;<br>/* 时刻 3 */<br>Q6:ROLLBACK TO SAVEPOINT sp;<br>/* 时刻 4 */<br>/* other tables */<br></code></pre></td></tr></table></figure>
<ol>
<li>如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。</li>
<li>如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；</li>
<li>如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。</li>
<li>从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。</li>
</ol>
</blockquote>
<hr>
<h2 id="行锁功过：怎么减少行锁对性能的影响？"><a href="#行锁功过：怎么减少行锁对性能的影响？" class="headerlink" title="行锁功过：怎么减少行锁对性能的影响？"></a>行锁功过：怎么减少行锁对性能的影响？</h2><p><strong>MySQL 的行锁是在引擎层由各个引擎自己实现的。</strong></p>
<p>(MyISAM 引擎就不支持行锁)</p>
<h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>
<p><strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></p>
<h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为<strong>死锁</strong>。</p>
<p>当出现死锁以后，有两种策略：</p>
<ol>
<li><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</p>
<blockquote>
<p>问题：在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
</blockquote>
</li>
<li><p>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。</p>
<p><code>innodb_deadlock_detect</code> 的默认值本身就是 on。</p>
<blockquote>
<p>问题：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p>
</blockquote>
</li>
</ol>
<hr>
<p><strong>问题：怎么解决由热点行更新导致的性能问题呢？</strong></p>
<blockquote>
<p>问题的症结在于，死锁检测要耗费大量的 CPU 资源。</p>
<ol>
<li><p>如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</p>
</li>
<li><p>控制并发度</p>
<p>并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。</p>
<p>基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p>
</li>
<li><p>设计上优化</p>
<p>将一行改成逻辑上的多行来减少锁冲突</p>
</li>
</ol>
</blockquote>
<hr>
<h2 id="事务到底是隔离的还是不隔离的？"><a href="#事务到底是隔离的还是不隔离的？" class="headerlink" title="事务到底是隔离的还是不隔离的？"></a>事务到底是隔离的还是不隔离的？</h2><p>在 MySQL 里，有两个“视图”的概念：</p>
<p>一个是 <strong>view</strong>。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</p>
<p>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 <code>consistent read view</code>，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。<strong>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</strong></p>
<p><a href="#事务隔离：为什么你改了我还看不见？">参考章节</a></p>
<h3 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h3><p>在<strong>可重复读</strong>隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是<strong>基于整库</strong>的。</p>
<p>InnoDB 里面每个事务有一个<strong>唯一</strong>的事务 ID，叫作 <code>transaction id</code>。它是在事务开始的时候向 InnoDB 的事务系统申请的，是<strong>按申请顺序严格递增</strong>的。</p>
<p>而每行数据也都是有多个版本的。<strong>每次</strong>事务更新数据的时候，都会生成一个<strong>新的数据版本</strong>，并且把 <code>transaction id</code> 赋值给这个数据版本的事务 ID，记为 <code>row trx_id</code>。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p><strong>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</strong></p>
<p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p>
<p>数组里面事务 ID 的最小值记为<strong>低水位</strong>，当前系统里面已经创建过的事务 ID 的最大值加 1 记为<strong>高水位</strong>。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>数据版本的可见性规则，就是<strong>基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</strong></p>
<img src="/article/53105/%E6%95%B0%E6%8D%AE%E7%89%88%E6%9C%AC%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99.png" class title="数据版本可见性规则">
<p>对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>
<ol>
<li><p>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</p>
</li>
<li><p>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</p>
</li>
<li><p>如果落在黄色部分，那就包括两种情况</p>
<ol>
<li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li>
<li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
<p>(高水位的定义是事务创建时所有未提交的事务ID的最大值+1是高水位，但并不是小于高水位大于低水位的事务就都没有提交。所以row trx_id 在这个范围内却不在数组中就是已经提交了的可见)</p>
</li>
</ol>
<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>
<ol>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，而且是在视图创建前提交的，可见。</li>
</ol>
<h3 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h3><p>更新数据都是先读后写的，而这个读，只能读当前的值，称为“<strong>当前读</strong>”（current read）。</p>
<p>除了 update 语句外，select 语句如果加锁，也是当前读。（<code>lock in share mode</code> 或 <code>for update</code>）</p>
<hr>
<p><strong>问题：事务的可重复读的能力是怎么实现的？</strong></p>
<blockquote>
<p>可重复读的<strong>核心就是一致性读</strong>（consistent read）；</p>
<p>而事务更新数据的时候，只能用<strong>当前读</strong>。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>
<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>
<ol>
<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>
<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>
</ol>
</blockquote>
<blockquote>
<p>这里需要说明一下，“<code>start transaction with consistent snapshot</code>; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在<strong>读提交</strong>隔离级别下，这个用法就没意义了，等效于普通的 <code>start transaction</code>。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>Mysql</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>实习,Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-梦开始的地方</title>
    <url>/article/23540.html</url>
    <content><![CDATA[<h2 id="Linux-梦开始的地方"><a href="#Linux-梦开始的地方" class="headerlink" title="Linux-梦开始的地方"></a>Linux-梦开始的地方</h2><p>Linux，全称GNU/Linux，是一种免费使用和自由传播的<a href="https://baike.baidu.com/item/类UNIX/9032872">类UNIX</a>操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到<a href="https://baike.baidu.com/item/Minix/7106045">Minix</a>和Unix思想的启发，是一个基于<a href="https://baike.baidu.com/item/POSIX">POSIX</a>的多用户、<a href="https://baike.baidu.com/item/多任务/1011764">多任务</a>、支持<a href="https://baike.baidu.com/item/多线程/1190404">多线程</a>和多<a href="https://baike.baidu.com/item/CPU">CPU</a>的操作系统。它能运行主要的<a href="https://baike.baidu.com/item/Unix/219943">Unix</a>工具软件、应用程序和网络协议。</p>
<p><a href="https://www.kernel.org">Linux源码</a></p>
<h3 id="网络连接三种模式"><a href="#网络连接三种模式" class="headerlink" title="网络连接三种模式"></a>网络连接三种模式</h3><img src="/article/23540/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png" class title="网络连接三种模式">
<h4 id="Bridged"><a href="#Bridged" class="headerlink" title="Bridged"></a><strong>Bridged</strong></h4><p><strong>桥接模式</strong></p>
<p>桥接模式是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。</p>
<blockquote>
<p>类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中。桥接模式通过虚拟网桥将主机上的网卡与虚拟交换机Vmnet0连接在一起，虚拟机上的虚拟网卡都连接在虚拟交换机Vmnet0上，所以桥接模式的虚拟机IP必须与主机在同一网段且子网掩码、网关与DNS也要与主机网卡一致。</p>
</blockquote>
<p>在桥接模式下，虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问局域网内的任何一台主机，局域网内的任何一台主机也可以访问它。</p>
<p>应用场景：当前虚拟机为整个局域网的用户提供访问服务，其他局域网用户都能访问到当前主机。</p>
<h4 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h4><p><strong>地址转换模式</strong></p>
<p>在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。</p>
<blockquote>
<p>在连接Vmnet8虚拟交换机时，虚拟机会将虚拟NAT设备以及虚拟DHCP服务器连接到Vmnet8虚拟交换机上，同时也会将主机上的虚拟网卡VMWare Network Adapter Vmnet8连接到Vmnet8虚拟交换机上。</p>
<p>网卡VMWare Network Adapter Vmnet8只是作为主机与虚拟机通信的接口，虚拟机并不是依靠网卡VMWare Network Adapter Vmnet8来联网的。</p>
</blockquote>
<p>虚拟机借助NAT功能，<strong>通过宿主机器所在的网络来访问公网</strong>，使用NAT模式可以实现虚拟机访问互联网。</p>
<p>NAT模式下虚拟机的TCP/IP配置信息是由VMnet8虚拟网络的DHCP服务器提供的，<strong>局域网中的其他真实主机将无法访问本虚拟机</strong>，但该主机上其他同一个网段的虚拟机可以访问。</p>
<p>可以理解成我们自己家里的宽带，你可以访问百度，但是其他人无法访问到你。应用场景：只是通过虚拟机上网，其他用户不能访问你的虚拟机。</p>
<h4 id="Host-only"><a href="#Host-only" class="headerlink" title="Host-only"></a>Host-only</h4><p><strong>主机模式</strong></p>
<p>Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只能与主机相互通讯。</p>
<blockquote>
<p>Host-Only模式通过主机的虚拟网卡VMWare Network Adapter VMnet1来连接虚拟交换机VMnet1，从而达到与虚拟机通信的目的。如果想要在Host-Only模式下联网，可以将能联网的主机网卡共享给VMWare Network Adapter VMnet1，以实现虚拟机联网。</p>
<p>Host-Only模式的配置过程和NAT模式基本相同。</p>
</blockquote>
<h2 id="Linux基本内容"><a href="#Linux基本内容" class="headerlink" title="Linux基本内容"></a>Linux基本内容</h2><ol>
<li><p>linux的文件系统是采用层级式的树状目录结构，在此结构的最上层是根目录<code>&quot;/&quot;</code>，然后再此目录下再创建其他的目录。</p>
</li>
<li><p>在linux的世界里，一切皆文件。cpu、磁盘、硬盘等等都会当成文件对待。</p>
</li>
<li>linux的目录是规定好的，和windows可以随意设置盘符名称不一样，而且不同的目录的作用也各有安排，不可更改。</li>
<li>学习linux一定要熟记各个目录。</li>
</ol>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ol>
<li><p><code>/</code> 根目录</p>
</li>
<li><p><code>/bin</code> 是binary的缩写，这个目录存放最经常使用的命令。所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。</p>
<ol>
<li><code>/usr/bin</code> 是系统安装时自带的一些可执行程序,即系统程序。</li>
<li><code>/usr/local/bin</code> 是用户自行编译安装时默认的可执行程序的安装位置。</li>
</ol>
</li>
<li><p><code>/sbin</code> s就是super user的意思，(<code>/usr/sbin</code>,<code>/usr/local/sbin</code>)这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><code>/home</code> 存放普通用户的主目录，在Linux中每个用户都有自己的目录，一般该里面的子目录名都以用户的账号命名。</p>
</li>
<li><p><code>/root</code> 该目录是系统管理员，也称为超级权限者的用户主目录。</p>
</li>
<li><p><code>/lib</code> 系统开机所需要的最基本的动态链接共享库，其作用类似Windows的dll文件，几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><code>/ect</code> 这个目录里面是所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><code>/usr</code> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与Windows下的program files目录。</p>
<ol>
<li><code>/usr/local</code> 这是给主机额外安装软件所安装的目录，是软件安装包的目标安装目录，一般通过编译源码的方式安装软件。</li>
</ol>
</li>
<li><p><code>/opt</code> 这是给主机额外安装软件的安装包源码所摆放的位置，例如安装Oracle数据库的源码就一般约定俗成放到这个目录下，默认为空。</p>
</li>
<li><p><code>/var</code> 这个目录中存放着在不断扩充的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</p>
<hr>
</li>
<li><p><code>/dev</code> 该目录类似Windows的设备管理器，把所有的硬件（例如磁盘、cpu、串口等）用文件的形式存储起来。</p>
</li>
<li><p><code>/mnt</code> 系统提供该目录是为了让用户临时挂载别的文件操作系统，我们可以将外部的存储挂载到 <code>/mnt</code> 上，然后进入这个目录就可以看到外部的存储内容了。注：vmtools可以共享windows的文件就在此目录下。</p>
</li>
<li><p><code>/tmp</code> 这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><code>/selinux</code> 该目录是security-enhanced linux的缩写，是一种安全子系统，类似windows上的360，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置。</p>
</li>
<li><p><code>/proc</code> <strong>[别动]</strong>这个目录是一个虚拟的目录，它是系统内存的映射 ，访问这个目录可以获取系统信息。</p>
</li>
<li><p><code>/srv</code> <strong>[别动]</strong>这是service的缩写，该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><code>/sys</code> <strong>[别动]</strong>这是Linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs。</p>
</li>
<li><p><code>/boot</code> 存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</p>
</li>
<li><p><code>/lost+found</code> 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><code>/media</code> Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别到的设备挂载到这个目录下。</p>
</li>
</ol>
<h3 id="Vi与Vim"><a href="#Vi与Vim" class="headerlink" title="Vi与Vim"></a>Vi与Vim</h3><p>Linux系统会内置<strong>vi文本编辑器</strong>。</p>
<p><strong>vim</strong>具有程序编辑的能力，可以看成是vi的增强版本，可以主动地以字体颜色辨别语法的正确性，方便程序设计，同时具备代码补全、编译和错误跳转等功能，因此被广泛程序员使用。</p>
<h4 id="常用三种模式"><a href="#常用三种模式" class="headerlink" title="常用三种模式"></a>常用三种模式</h4><img src="/article/23540/%E5%B8%B8%E7%94%A8%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png" class title="常用三种模式">
<img src="/article/23540/%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2.png" class title="Snipaste_2022-02-20_12-32-53">
<img src="/article/23540/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%9B%BE.png" class title="Snipaste_2022-02-20_15-32-10">
<h4 id="正常模式下的快捷键"><a href="#正常模式下的快捷键" class="headerlink" title="正常模式下的快捷键"></a>正常模式下的快捷键</h4><ol>
<li><p>拷贝当前行 <code>yy</code> ；</p>
</li>
<li><p>拷贝n行 <code>nyy</code> ；注意小键盘数字不行，用自带的数字。</p>
</li>
<li><p>粘贴 <code>p</code> ；</p>
</li>
<li><p>删除这一行 <code>dd</code> ;</p>
</li>
<li><p>删除n行 <code>ndd</code> ；</p>
</li>
<li><p>跳转到第一行 <code>gg</code> ；</p>
</li>
<li><p>跳转到末尾行 <code>G</code> ；</p>
</li>
<li><p>撤销刚才的操作 <code>u</code> ；</p>
</li>
<li><p>跳转到第i行 <code>i+shift+g</code> 。</p>
</li>
</ol>
<h4 id="命令模式下的快捷键"><a href="#命令模式下的快捷键" class="headerlink" title="命令模式下的快捷键"></a>命令模式下的快捷键</h4><ol>
<li>在命令模式下查找关键单词<ol>
<li>输入<code>/</code>name ，name是你要查找的单词名</li>
<li>按<code>n</code>查找下一个</li>
</ol>
</li>
<li>在命令模式下设置行号 <code>:set nu</code> ；</li>
<li>在命令模式下删除行号 <code>:set nonu</code> 。</li>
</ol>
<h3 id="Linux开机、重启和用户登录注销"><a href="#Linux开机、重启和用户登录注销" class="headerlink" title="Linux开机、重启和用户登录注销"></a>Linux开机、重启和用户登录注销</h3><h4 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h4><p><strong>注意，不管是重启系统还是关机，最好都执行一次sync指令，再重启或关机</strong></p>
<ol>
<li><p><code>shutdown -h now</code> #现在立即关机,h代表halt关机的意思</p>
</li>
<li><p><code>shutdown -h 1</code> #1分钟后关机</p>
</li>
<li><p><code>shutdown -h</code> #默认1分钟后关机</p>
</li>
<li><p><code>shutdown -r now</code> #现在立即重启,r代表reboot</p>
</li>
<li><p><code>halt</code> #关机,作用和上面指令一样</p>
</li>
<li><p><code>reboot</code> #重启计算机</p>
</li>
<li><p><code>sync</code> #把内存数据同步到磁盘</p>
</li>
</ol>
<h4 id="用户注销"><a href="#用户注销" class="headerlink" title="用户注销"></a>用户注销</h4><ol>
<li>登录时尽量少用root账号登录，可以利用普通用户登录，登录后使用<code>su - 用户名</code> ，来切换系统管理员程序；</li>
<li>在提示符下输入<code>logout</code>即可注销用户。<ol>
<li><code>logout</code> 在图形运行级别无效，在运行<a href="#指令运行级别">级别3</a>下有效。</li>
</ol>
</li>
</ol>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="创建删除设置用户"><a href="#创建删除设置用户" class="headerlink" title="创建删除设置用户"></a>创建删除设置用户</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个想要使用系统资源的用户，都必须首先向系统管理员root申请一个账号，然后再以这个账号的身份进入系统。</p>
<p>添加用户默认该用户的家目录在 <code>/home/username</code> ，username是用户的名称，也可以指定目录，但没必要.</p>
<ol>
<li><code>useradd milan</code> #添加milan这个用户</li>
<li><code>useradd -d /home/test milan</code> #添加milan这个用户,但用户文件夹名不是默认的milan，而是指定为 <code>test</code></li>
<li><code>passwd milan</code> #更改milan这个用户的密码</li>
<li><code>userdel milan</code> #删除用户milan，但是保留home家目录</li>
<li><code>userdel -r milan</code> #删除用户milan的所有信息，包括家目录</li>
</ol>
<p><strong>pwd ：该命令显示当前所在目录全程</strong></p>
<h3 id="查询切换用户"><a href="#查询切换用户" class="headerlink" title="查询切换用户"></a>查询切换用户</h3><ol>
<li>查询基本语法 <code>id 用户名</code> ：当不存在改用户时，返回无此用户；</li>
<li>切换基本语法 <code>su 用户名</code> ； <code>exit</code> 返回原用户；从权限高的用户切换到权限低的用户，不需要密码；反之需要。</li>
<li>查看当前登录用户语法 <code>whoami</code> 或者 <code>who am i</code> 。值得注意的是 <code>whoami</code> 返回当前使用的用户， <code>who am i</code> 返回第一次登录服务器的信息。</li>
<li></li>
</ol>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>用户组，类似于角色，系统可以对有共性的多个用户进行统一的管理。</p>
<ol>
<li><p>增加组 <code>groupadd 组名</code>；</p>
</li>
<li><p>删除组 <code>groupdel 组名</code>；</p>
</li>
<li><p>增加用户是直接加组 `useradd -g 用户组 用户名；</p>
</li>
<li><p>修改用户的组 <code>usermod -g 用户组 用户名</code>。</p>
</li>
</ol>
<h3 id="用户和组相关文件"><a href="#用户和组相关文件" class="headerlink" title="用户和组相关文件"></a>用户和组相关文件</h3><ol>
<li><p><code>/etc/passwd</code> </p>
<p>用户user的配置文件，记录用户的各种信息</p>
<p>每行的含义： 用户名：口令：用户表示号：组表示号：注释性描述：主目录：登录Shell</p>
</li>
<li><p><code>/etc/shadow</code></p>
<p>口令的配置文件</p>
<p>每行的含义： 登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p>
</li>
<li><p><code>etc/group</code></p>
<p>组的配置文件，记录Linux包含的组的信息</p>
<p>每行的含义：组名：口令：组标示号：组内用户列表</p>
</li>
</ol>
<h2 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h2><h3 id="指定运行级别"><a href="#指定运行级别" class="headerlink" title="指定运行级别"></a>指定运行级别</h3><p><strong>运行级别一共有7种</strong></p>
<ol>
<li>0：关机</li>
<li>1：单用户，root权限，可以帮助找回丢失的密码，用于系统维护，禁止远程登录</li>
<li>2：多用户状态没有网络服务</li>
<li>3：多用户状态有网络服务，登录后进入控制台命令行模式</li>
<li>4：系统未使用保留给用户</li>
<li>5：图形界面</li>
<li>6：系统重启</li>
</ol>
<p>常用运行级别是3和5，也可以指定默认运行级别。</p>
<p><strong>切换运行级别</strong> <code>init [运行级别]</code></p>
<p><strong>修改默认运行级别</strong></p>
<ol>
<li>在CentOs7之前，需要在<code>/etc/inittab</code>中修改；</li>
<li>在CentOs之后<ol>
<li>查看当前运行级别 <code>runlevel</code>；</li>
<li>查看当前默认运行级别 <code>systemctl get-default</code>；</li>
<li>设置默认运行级别<code>systemctl set-default multiuser.target</code>。</li>
</ol>
</li>
</ol>
<h3 id="找回root密码"><a href="#找回root密码" class="headerlink" title="找回root密码"></a>找回root密码</h3><p>进入到单用户模式，就可以修改root密码</p>
<ol>
<li>首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面；</li>
<li>进入编辑界面，使用键盘上的上下键把光标往下移动，找到以<code>Linux16</code>开头内容所在的行数，在行的最后面输入：<code>init=/bin/sh</code>；</li>
<li>接着，输入完成后，直接按快捷键：<code>Ctrl+x</code> 进入单用户模式；</li>
<li>接着，在光标闪烁的位置中输入：<code>mount -o remount,rw /</code>（注意：各个单词间有空格），完成后按键盘的回车键（Enter）；</li>
<li>在新的一行最后面输入：<code>passwd</code>， 完成后按键盘的回车键（Enter）。输入密码，<strong>然后再次确认密码即</strong>可(密码长度最好8位以上,但不是必须的), 密码修改成功后，会显示passwd…..的样式，说明密码修改成功；</li>
<li>接着，在鼠标闪烁的位置中（最后一行中）输入：<code>touch /.autorelabel</code>（注意：touch与 /后面有一个空格），完成后按键盘的回车键（Enter）；</li>
<li>继续在光标闪烁的位置中，输入：<code>exec /sbin/init</code>，完成后按键盘的回车键（Enter）,等待系统自动修改密码(这个过程时间可能有点长)，完成后，系统会自动重启, 新的密码生效了。</li>
</ol>
<h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><ol>
<li><p><code>man</code> 命令或配置信息</p>
<p>基本语法： man [命令或者配置文件]</p>
<p>(输入<code>q</code>退出)</p>
</li>
<li><p><code>help</code> 命令</p>
<p>基本语法： help [命令]</p>
</li>
</ol>
<h3 id="文件操作指令"><a href="#文件操作指令" class="headerlink" title="文件操作指令"></a>文件操作指令</h3><ol>
<li>文件目录<ol>
<li><code>pwd</code> 显示当前工作目录的绝对路径；</li>
<li><code>ls -a</code> 或者 <code>ls -l</code> ：-a显示当前目录的所有文件和目录，<strong>包括隐藏的</strong>；-l表示以列表的方式显示信息；注意可以组合；</li>
<li><code>cd [参数]</code> ：切换目录，后面可以是绝对路径或者相对路径，如果是 <code>/</code> 开头，表示绝对路径；否则为相对路径；<ol>
<li><code>cd ~ 或者 cd</code> ：回到自己的家目录；</li>
<li><code>cd ..</code> ：回到当前目录的上一级目录。</li>
</ol>
</li>
</ol>
</li>
<li>文件创建删除<ol>
<li><code>mkdir 目录名</code> ：创建目录，默认创建一级目录，如果要创建多级，要加 <code>-p</code>；</li>
<li><code>rmdir 目录名</code> ：默认删除空目录，如果目录下有内容无法删除；</li>
<li><code>rm -rf 目录名</code>：递归强制删除，可删除有内容的目录；</li>
<li><code>touch 文件名</code>：创建一个空文件。</li>
</ol>
</li>
<li>文件拷贝删除移动查看<ol>
<li><code>cp 文件 拷贝路径</code> ：拷贝文件到指定路径；</li>
<li><code>cp -r 文件夹 拷贝路径</code> ：递归拷贝文件夹到指定路径；</li>
<li><code>\cp</code> ：强制覆盖不提示拷贝；</li>
<li><code>rm 文件或目录</code> ：删除文件；</li>
<li><code>rm -r 文件夹</code> ：递归删除整个文件夹；</li>
<li><code>rm -f</code> ：强制删除不显示；</li>
<li><code>mv src tar</code> ：移动文件或者重命名文件；</li>
<li><code>cat 文件</code> ：查看文件内容；<ol>
<li><code>cat -n 文件</code> 显示行号；</li>
</ol>
</li>
<li><code>more 文件</code> ：以全屏按页显示文本文件内容，（more指令是一个基于VI编辑器的文本过滤器，以全屏的方式，按页显示文本文件的内容）；<ol>
<li><code>q</code> 退出；</li>
<li><code>=</code> 输出当前行的行号；</li>
<li><code>:f</code> 输出文件名和当前行的行号；</li>
</ol>
</li>
<li><code>less 文件</code>：用来分屏查看文件内容，和 more 功能类似，但比more功能更强大（支持各种显示终端，less指令在西安市文件内容时，并不是一次将整个文件加载后才显示，而是根据需要加载需要的内容，对于显示大型文件具有较高的效率），<code>q</code>退出。</li>
<li><code>echo</code> ：输出内容到控制台；<ol>
<li><code>echo $HOSTNAME</code> ：输出主机名；</li>
<li><code>echo $PATH</code> ：输出环境变量；</li>
</ol>
</li>
<li><code>head [可选 -n 行数] 文件</code>：用于显示文件的开头部分内容，默认情况显示前10行；</li>
<li><code>tail [可选 -n 行数] 文件</code>：用于显示文件的尾部内容，默认显示最后10行；<ol>
<li><code>tail -f 文件名</code> ：实时追踪文档的所有更新，退出按 <code>ctrl+C</code> ，适用于网络抓包、服务器网络监视；</li>
</ol>
</li>
<li><code>&gt;</code> 输出重定向（覆盖原文件）和 <code>&gt;&gt;</code> 追加；</li>
<li><code>ln</code> ：表示link的意思，软链接，也称为符号链接，类似Windows里面的快捷方式，主要存放了链接其他文件的路径；<ol>
<li><code>ln -s [原文件目录] [软连接名]</code> 给原文件创建一个软连接；</li>
<li>删除时不能加 <code>/</code> ,把软连接当成一个文件，而不是目录；</li>
</ol>
</li>
<li><code>history</code> ：查看已经执行过的历史命令；<ol>
<li><code>history n</code> 显示最近使用过的n个指令；</li>
<li><code>history !n</code> 执行历史编号为5的指令。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="时间日期指令"><a href="#时间日期指令" class="headerlink" title="时间日期指令"></a>时间日期指令</h3><ol>
<li><code>date</code> ：显示当前日期；<ol>
<li><code>date &quot;+%Y-%m-%d&quot;</code> 显示当前年月日；</li>
<li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 显示当前年月日时分秒；</li>
<li><code>data -s &quot;时间&quot;</code> 设置系统时间；</li>
</ol>
</li>
<li><code>cal</code> ：显示本月月历；<ol>
<li><code>cal 2022</code> ：显示2022年的所有月历。</li>
</ol>
</li>
</ol>
<h3 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h3><ol>
<li><code>find [搜索范围] [选项] [参数]</code> ：从指定目录向下递归的遍历子目录，将满足的文件或目录显示在终端；<ol>
<li>选项<code>[-name]</code> 按照指定文件名查找模式查找文件；</li>
<li>选项<code>[-usre]</code> 查找属于指定用户名所有文件；</li>
<li>选项<code>[-size [+n 大于n][-n 小于n][n 等于n]]</code> 按照指定的文件大小查找文件；</li>
</ol>
</li>
<li><code>locate</code> ：可以利用数据库快速实现文件搜索，但有的linux没有安装，先安装 yum install mlocate ，然后再使用之前更新数据库 <code>updatedb</code> ，才能使用locate；</li>
<li><code>which 指令</code> ：可以查看某个指令在哪个目录下；</li>
<li><code>grep</code> ：过滤查找，通常和管道符号 <code>|</code> 一起使用；<ol>
<li><code>grep -n &quot;内容&quot; 文件</code> -n表示显示匹配的行号；</li>
<li><code>grep -i &quot;内容&quot; 文件</code> -i表示忽略字母大小写；</li>
</ol>
</li>
</ol>
<h3 id="压缩和解压指令"><a href="#压缩和解压指令" class="headerlink" title="压缩和解压指令"></a>压缩和解压指令</h3><ol>
<li><code>gzip</code> 和 <code>gunzip</code> ：对<strong>单个文件</strong>进行压缩和解压，格式是 <em>.gz</em>；</li>
<li><code>zip</code> 和 <code>unzip</code> ：对<strong>文件夹</strong>压缩和解压，格式是 <em>.zip</em> ；<ol>
<li><code>zip -r 压缩完成后文件名.zip 文件夹或文件</code> 压缩文件夹以及其里面的文件和子文件夹成为压缩完成后文件名.zip；</li>
<li><code>unzip -d 解压后的文件或文件夹目录 压缩文件或文件夹目录</code>：-d表示指定的解压目录；</li>
</ol>
</li>
<li><code>tar [选项] xxx.tar.gz 打包的内容</code> ：既可以压缩，也可以解压，打包得到的文件格式是<em>.tar.gz</em>；<ol>
<li><code>tar -zcvf xxx.tar.gz</code> 打包内容 ：将内容进行打包；</li>
<li><code>tar -zxvf xxx.tar.gz -C 解压目标目录</code> ：将压缩文件解压到特定位置；</li>
<li>选项<code>[-c]</code> 产生 <em>.tar</em> 打包文件；</li>
<li>选项<code>[-v]</code> 显示详细信息；</li>
<li>选项<code>[-f]</code> 指定压缩后文件名；</li>
<li>选项<code>[-z]</code> 打包同时压缩；</li>
<li>选项<code>[-x]</code> 解包 <em>.tar</em> 文件；</li>
</ol>
</li>
</ol>
<h2 id="组管理和权限管理"><a href="#组管理和权限管理" class="headerlink" title="组管理和权限管理"></a>组管理和权限管理</h2><p><strong>Linux每个用户都必须属于一个组</strong>。</p>
<p><strong>Linux每个文件都有所有者、所在组、其他组这三个概念。</strong></p>
<p><strong>修改权限一般要 root 权限</strong></p>
<h3 id="文件和目录的所有者"><a href="#文件和目录的所有者" class="headerlink" title="文件和目录的所有者"></a>文件和目录的所有者</h3><ol>
<li><code>chown -R</code> ：change owner，修改所有者。-R表示递归修改；</li>
<li><code>chown [-R] 用户名 文件名</code> 修改文件所有者；</li>
<li><code>chown newnwner:newgroup 文件/目录</code> 改变所有者和所在组。</li>
</ol>
<h3 id="文件和目录的所在组"><a href="#文件和目录的所在组" class="headerlink" title="文件和目录的所在组"></a>文件和目录的所在组</h3><ol>
<li><code>chgrp -R</code> ：change group，修改所在组。-R表示递归修改；</li>
<li><code>chgrp [-R] newgroup 文件/目录</code> 改变所在组；</li>
</ol>
<p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组。</p>
<h3 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h3><ol>
<li><code>usermod -g 新组名 用户名</code> </li>
<li><code>usermod -d 目录名 用户名</code> 改变该用户登录的初始目录，用户需要有进入新目录的权限；</li>
</ol>
<h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>使用 <code>ls -l</code> 得出的信息，开头10个字符表示文件权限；</p>
<ol>
<li>第0位确定文件类型（ d,-,l,c,b ）<ol>
<li><code>d</code> 表示目录；</li>
<li><code>-</code> 表示普通文件；</li>
<li><code>l</code> 表示链接；</li>
<li><code>c</code> 表示字符设备文件，如鼠标、键盘等；</li>
<li><code>b</code> 表示块设备，比如硬盘等，blog；</li>
</ol>
</li>
<li>第1-3位确定所有者所拥有的权限—User；<ol>
<li>rwx 三种权限，对于文件和目录的作用分别不用；</li>
</ol>
</li>
<li>第4-6位确定所在组的权限—Group；</li>
<li>第7-9位确定其他用户所拥有的权限—Other；</li>
<li>其他说明：<ol>
<li>第10位： 文件：硬连接数 ；目录：子目录数；</li>
<li>第11位： 用户；</li>
<li>第12位： 组；</li>
<li>第13位： 文件大小（字节），如果是文件夹，显示4096字节；</li>
<li>第14位： 最后修改日期；</li>
<li>第15位： 文件名。 </li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:center">文件</th>
<th style="text-align:center">目录</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">读取、查看</td>
<td style="text-align:center">读取、<code>ls</code>查看</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">修改（但不代表可以删除，删除的前提条件是对该文件所在的目录有写权限）</td>
<td style="text-align:center">修改、目录内创建、删除、重命名目录</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">执行</td>
<td style="text-align:center">可以进入该目录</td>
</tr>
</tbody>
</table>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p><code>chmod</code> ：修改文件或目录的文件；</p>
<ol>
<li><p><code>chmod [[u 所有者] [g 所有组] [o 其他人] [a 所有人]][[+ 增加权限] [- 减少权限] [= 设置权限]] 文件/目录</code></p>
</li>
<li><p><code>chmod [[u 的权限求和] [g 的权限求和] [a 的权限求和]] 文件/目录</code> : r = 4 、r = 2、 x = 1;</p>
</li>
</ol>
<h2 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h2><p>任务调度：是指系统在某个时间执行的特定的命令或程序。</p>
<p>分类：</p>
<ol>
<li>系统工作</li>
<li>个别用户工作</li>
</ol>
<h3 id="crontab定时任务"><a href="#crontab定时任务" class="headerlink" title="crontab定时任务"></a>crontab定时任务</h3><p><code>crontab [选项]</code></p>
<ul>
<li><code>-e</code>  编辑crontab定时任务；</li>
<li><code>-l</code>  查询crontab定时任务；</li>
<li><code>-r</code>  删除当前用户所有的crontab任务。</li>
</ul>
<p><code>service crond restart</code> 重启任务调度</p>
<p>定时参数说明</p>
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第一个”*”</td>
<td style="text-align:center">一小时当中的第几分钟</td>
<td style="text-align:center">0～59</td>
</tr>
<tr>
<td style="text-align:center">第二个”*”</td>
<td style="text-align:center">一天当中的第几小时</td>
<td style="text-align:center">0～23</td>
</tr>
<tr>
<td style="text-align:center">第三个”*”</td>
<td style="text-align:center">一个月中的第几天</td>
<td style="text-align:center">1～31</td>
</tr>
<tr>
<td style="text-align:center">第四个”*”</td>
<td style="text-align:center">一年当中第几月</td>
<td style="text-align:center">1～12</td>
</tr>
<tr>
<td style="text-align:center">第五个”*”</td>
<td style="text-align:center">一周当中的星期几</td>
<td style="text-align:center">0～7（0和7都代表周日）</td>
</tr>
<tr>
<td style="text-align:center">‘</td>
<td style="text-align:center">代表不连续的时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">代表连续的时间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">*/n</td>
<td style="text-align:center">代表每个多久执行一次</td>
</tr>
</tbody>
</table>
<h3 id="at-定时任务"><a href="#at-定时任务" class="headerlink" title="at 定时任务"></a>at 定时任务</h3><p>crond是定时的，反复执行的；at命令是一次性定时计划任务。</p>
<ol>
<li><code>at</code>命令时一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。</li>
<li>默认情况下，<strong>atd</strong>守护进程每60s检查作业队列，有作业时，会检查作业运行时间，如果运行时间与当前时间匹配，则运行此作业。</li>
<li>at命令是一次性定时计划任务，执行完一个任务后，不再执行此任务。</li>
<li>在使用at命令的时候，一定要保证<strong>atd</strong>进程的启动。</li>
</ol>
<p><code>Ctrl + D</code> 连按两次结束at命令的输入；</p>
<p><code>atq</code> 查看设置的定时任务；</p>
<p><code>atrm +编号</code> 删除该编号的定时任务;</p>
<p><code>at [选项] [时间]</code></p>
<ol>
<li><code>-m</code> 当指定的任务被完成后，将给用户发送于邮件，即使没有标准输出；</li>
<li><code>-I</code> atq的别名</li>
<li><code>-d</code> atrm的别名</li>
<li><code>-v</code> 显示任务将被执行的时间</li>
<li><code>-V</code> 显示版本信息</li>
<li><code>-c</code> 打印任务的内容到标准输出</li>
<li><code>-q &lt;队列&gt;</code> 使用指定的队列</li>
<li><code>-f &lt;文件&gt;</code> 从指定文件读入任务而不是从标准输入读入</li>
<li><code>-t &lt;时间参数&gt;</code> 以时间参数的形式提交要运行的任务</li>
</ol>
<p>时间指定方法：</p>
<ol>
<li>接受在当天的 hh:mm （小时：分钟）式的时间指定。加入该时间已过去，那么就放在第二天执行。</li>
<li>midnighr（深夜） noon（中午） teatime（下午四点）</li>
<li>采用12小时制，在时间后面加上AM或PM</li>
<li>指定命令执行的具体日期  指定格式为 (month day)(月日) 或 mm/dd/yy(月/日/年) 或 dd.mm.yy (日.月.年)</li>
<li>使用相对计时法  指定格式为： (now + count time-units) now是当前时间，time-units是时间单位（minutes分钟 hours小时 days天 weeks星期），count是时间的数量</li>
<li>直接使用today（今天） tomorrow（明天）</li>
</ol>
<h2 id="Linux-磁盘分区和挂载"><a href="#Linux-磁盘分区和挂载" class="headerlink" title="Linux 磁盘分区和挂载"></a>Linux 磁盘分区和挂载</h2><h3 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h3><p>Linux无论有几个分区，分给哪一个目录来使用，他归根结底就<strong>只有一个根目录</strong>，一个<strong>独立且唯一的文件结构</strong>，Linux中每个分区都是用来组成整个文件系统的一部分。</p>
<p>Linux采用了一种叫“<strong>载入</strong>”的处理方式，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来，这时要载入的一个分区将使它的存储空间在一个目录下获得。</p>
<h3 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a><strong>硬盘说明</strong></h3><ol>
<li>linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘；</li>
<li>对于<strong>IDE硬盘</strong>，驱动器标识符为“hdx~”,其中“hd”表明分区所在设别的类型，这里是指IDE硬盘。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），“~”代表分区，前四个分区用数字1～4表示，他们是主分区或扩展分区，从5开始就是逻辑分区。</li>
<li>对于SCSI硬盘表示为“sdx~” ,SCSI硬盘是用“sd”来表示分区所在设备类型，其余则和IDE硬盘的表示方法一样。</li>
</ol>
<p><code>lsblk</code> ： 查看所有设备的挂载情况</p>
<p><code>lsblk -f</code> ： 显示的UUID是分区的40位的唯一标识符</p>
<p><code>fdisk /dev/sdx</code> ：分区命令</p>
<p><code>mkfs -t ext4 /dev/sdb~</code> 格式化磁盘，ext4是分区类型</p>
<p><code>mount 设备名称 挂载目录</code> 将一个分区与一个目录联系起来</p>
<p><code>umount 设备名称/挂载目录</code> 取消一个分区与一个目录的联系</p>
<p>修改<code>/etc/fstab</code>永久挂载，执行<code>mount -a</code> 即刻生效</p>
<h3 id="虚拟机添加硬盘并连接分区"><a href="#虚拟机添加硬盘并连接分区" class="headerlink" title="虚拟机添加硬盘并连接分区"></a>虚拟机添加硬盘并连接分区</h3><ol>
<li><p>虚拟机添加硬盘</p>
</li>
<li><p>分区</p>
<p><code>fdisk /dev/sdb</code></p>
<p><code>m</code> 显示命令列表</p>
<p><code>p</code> 显示磁盘分区</p>
<p><code>n</code> 新增分区</p>
<p><code>d</code> 删除分区</p>
<p><code>w</code> 写入并退出</p>
<ol>
<li>开始分区后输入n，新增分区</li>
<li>然后选择p，分区类型为主分区</li>
<li>两次回车默认剩余全部空间</li>
<li>最后输入w，写入分区并退出，若不保存退出输入q</li>
</ol>
</li>
<li><p><code>mkfs -t ext4 /dev/sdb1</code> 格式化磁盘，ext4是分区类型</p>
</li>
<li><p><code>mount /dev/sdb1 /newdisk</code> 将一个分区与一个目录联系起来（用命令行挂载，重启失效）</p>
</li>
<li><p>修改<code>/etc/fstab</code>永久挂载</p>
<p><code>/dev/sdb1 /newdisk ext4 defaults 0 0</code></p>
</li>
</ol>
<p>​    执行<code>mount -a</code> 即刻生效</p>
<h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><ol>
<li><p><code>df -h</code> 查询系统整体磁盘使用情况</p>
</li>
<li><p><code>du [选项] 目录</code> 查询指定目录的磁盘占用情况</p>
<p><code>-s</code> 指定目录占用大小汇总</p>
<p><code>-h</code> 带计量单位</p>
<p><code>-a</code> 含文件</p>
<p><code>--max-depth=1</code> 子目录深度</p>
<p><code>-c</code> 列出明细的同时，增加汇总值</p>
</li>
<li><p><code>tree 目录</code> 以树状结构得到显示目录结构</p>
</li>
</ol>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p><code>ping 目的主机ip</code> 测试当前服务器是否可以连接目的主机</p>
<h3 id="Linux网络环境配置"><a href="#Linux网络环境配置" class="headerlink" title="Linux网络环境配置"></a>Linux网络环境配置</h3><p><strong>指定ip</strong></p>
<p>直接修改配置文件来指定IP，并可以连接到外网</p>
<p>编辑 <code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<blockquote>
<p>DEVICE=enth0  #接口名（设备网卡）</p>
<p>HWADDR=xx:xx:xx:xx:xx:xx   #MAC地址</p>
<p>TYPE=Ethernet   #网络类型（通常是Ethernet）</p>
<p>UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   #碎解ID</p>
<p>ONBOOT=yes    #系统启动时网络接口是否有效</p>
<p>BOOTPROTO=static   #IP的配置方法[none(引导时不使用协议)|static(静态分配IP)|bootp(BOOTP协议)|dhcp(DHCP协议)]</p>
<p>IPADDR=xxx.xxx.xxx.xxx   #ip地址</p>
<p>GATEWAY=xxx.xxx.xxx.xxx   #网关</p>
<p>DNSI=xxx.xxx.xxx.xxx   #域名解析器</p>
</blockquote>
<p>重启网络服务或者重启系统生效</p>
<p><code>service network restart</code> 或 <code>reboot</code></p>
<h3 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h3><ol>
<li><p>修改主机名</p>
<p><code>hostname</code>  查看主机名</p>
<p>修改文件在<code>/etc/hostname</code> 中指定</p>
</li>
<li><p>设置主机映射</p>
<p>windows ： <code>C:\Windows\System32\drivers\etc\hosts</code> 文件指定</p>
<p>Linux ： <code>/etc/hosts</code> 文件指定</p>
</li>
</ol>
<p><strong>主机名解析机制</strong></p>
<p>Hosts：一个文本文件，用来记录IP和Hostname（主机名）的映射关系</p>
<p>DNS：域名解析系统，是互联网上作为域名和IP地址相互映射的一个分布式数据库</p>
<img src="/article/23540/image-20220327230200902.png" class title="image-20220327230200902">
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>在Linux中，每个执行的程序都称为一个进程，每个进程都分配一个ID号（pid，进程号）</p>
<p>每个进程都可能以两种方式存在，前台与后台。</p>
<p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，知道关机才结束。</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p><code>ps [选项]</code> 显示系统执行的进程</p>
<p><code>-a</code> 显示当前终端的所有进程信息</p>
<p><code>-u</code> 以用户的格式显示进程信息</p>
<p><code>-x</code> 显示后台进程运行的参数</p>
<blockquote>
<p><code>ps -aux</code></p>
<p>PID 进程识别号</p>
<p>TTY 终端机号</p>
<p>TIME 此进程所消耗CPU时间</p>
<p>CMD 正在执行的命令或进程名</p>
<p>%CPU 此进程占用CPU百分比</p>
<p>%MEM 此进程占用物理内存百分比</p>
<p>VSZ 此进程占用虚拟内存大小 KB</p>
<p>RSS 此进程占用物理内存大小 KB</p>
<p>STAT 此进程运行状态【S-休眠 r-正在运行 s-表示该进程是会话的先导进程 N-表示进程拥有比普通优先级更低的优先级 D-短期等待 Z-僵死进程 T-被跟踪或者被停止等待】</p>
<p>START 此进程执行开始时间</p>
<p>COMMAND 执行此进程的指令（过长会被截断）</p>
</blockquote>
<p><code>-e</code> 显示所有进程</p>
<p><code>-f</code> 全格式</p>
<blockquote>
<p><code>ps -ef</code></p>
<p>UID 用户ID</p>
<p>PID 进程ID</p>
<p>PPID 父进程ID</p>
<p>C CPU用于计算执行优先级的因子 </p>
<p>​    数值越大，表明进程时CPU密集型运算，执行优先级会降低</p>
<p>​    数值越小，表明进程时I/O密集型运算，执行优先级会提高</p>
<p>STIME 进程启动时间</p>
<p>TTY 完整的终端名称</p>
<p>TIME CPU时间</p>
<p>CMD 启动进程所用的命令和参数</p>
</blockquote>
<h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><ol>
<li><p><code>kill [选项] pid</code> 杀死某个进程</p>
<p><code>-9</code> 表示强迫进程立即停止</p>
</li>
<li><p><code>killall 进程名称</code> 杀死进程及其子进程</p>
<p>强制终止一个终端 <code>kill -9 bash 对应进程号</code></p>
</li>
</ol>
<h3 id="显示进程树"><a href="#显示进程树" class="headerlink" title="显示进程树"></a>显示进程树</h3><p><code>pstree [选项]</code> 更直观的查看进程信息</p>
<p><code>-p</code> 显示进程的PID</p>
<p><code>-u</code> 显示进程的所属用户</p>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>服务（service）本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，因此我们又称之为守护进程。  </p>
<p><strong>service 管理指令</strong></p>
<p><code>service 服务名 [start|stop|restart|reload|status]</code></p>
<p>service/systemctl</p>
<p>service 指令管理的服务在 <code>/etc/init.d</code> 查看</p>
<p><strong>查看service服务名</strong></p>
<ol>
<li>使用 setup -&gt; 系统服务 就可以看到全部setup</li>
<li><code>ls -l /etc/init.d</code></li>
</ol>
<p><strong>开机的流程说明</strong></p>
<p>开机 -&gt; BIOS -&gt; /boot -&gt; systemd进程1 -&gt; <a href="#指定运行级别运行级别">运行级别</a> -&gt; 运行级别对应的服务</p>
<ol>
<li><p><code>chkconfig</code> 给服务的各个运行级别设置启动/关闭</p>
<ol>
<li><code>chkconfig --list | grep xxx</code> ：查看过滤后的服务service</li>
<li><code>chkconfig --level 3 服务名 off</code> ：设置服务名的3级别自启动关闭</li>
</ol>
<p><code>chkconfig</code> 重新设置服务后自启动或者关闭，需要重启机器<code>reboot</code>生效</p>
</li>
<li><p><code>systemctl</code> ：管理服务指令</p>
<ol>
<li><code>service [start|stop|restart|reload|status] 服务名</code></li>
</ol>
<p>systemctl 指令管理的服务在 <code>usr/lib/systemd/system</code> 查看</p>
<ol start="2">
<li>systemctl设置服务自启动状态<ol>
<li><code>systemctl list-unit-files [|grep 服务名]</code> 查看服务开机启动状态，grep可以进行过滤</li>
<li><code>systemctl enable 服务名</code> 设置服务开机启动</li>
<li><code>systemctl disable 服务名</code> 关闭服务开机启动</li>
<li><code>systemctl is-enable 服务名</code> 查询某个服务是否是自启动的</li>
</ol>
</li>
<li><code>ls -l /usr/lib/systemd/system/ | more</code>：显示systemctl管理的服务名称。</li>
<li><code>systemctl list-unit-files | grep firewalld</code>：查看防火墙开启还是关闭</li>
</ol>
</li>
</ol>
<p><strong>firewalld</strong></p>
<ol>
<li><code>firewall-cmd --permanent --add-port=端口号/协议</code> 打开端口</li>
<li><code>firewall-cmd --permanent --remove-port=端口号/协议</code> 打开端口</li>
<li><code>firewall-cmd --reload</code>  重新载入，才能生效</li>
<li><code>firewall-cmd --query-port=端口号/协议</code> 查询端口是否开放</li>
</ol>
<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p><code>top</code>与<code>ps</code>命令很相似，他们都用来显示正在执行的进程</p>
<p>不同：top在执行一段时间可以更新正在运行的进程</p>
<p><code>top [选项]</code></p>
<p><code>-d 秒数</code> 指定top命令每个几秒更新，默认是3秒</p>
<p><code>-i</code> 使top不显示任何闲置或者僵死进程</p>
<p><code>-p</code> 通过指定监控进程ID来监控某个进程的状态</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>以CPU使用率排序，默认就是此项</td>
</tr>
<tr>
<td>M</td>
<td>以内存使用率排序</td>
</tr>
<tr>
<td>N</td>
<td>以PID排序</td>
</tr>
<tr>
<td>q</td>
<td>退出top</td>
</tr>
<tr>
<td>u + 用户名</td>
<td>监视特定用户</td>
</tr>
<tr>
<td>k</td>
<td>终止指定的进程</td>
</tr>
</tbody>
</table>
<h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p><code>netstat [选项]</code> 查看系统网络情况</p>
<p><code>-an</code> 按一定的顺序排序输出</p>
<p><code>-p</code> 显示哪个进程在调用</p>
<h2 id="网络性能测试"><a href="#网络性能测试" class="headerlink" title="网络性能测试"></a>网络性能测试</h2><h3 id="Iperf"><a href="#Iperf" class="headerlink" title="Iperf"></a>Iperf</h3><p>一款网络性能测试工具，在网络中单向传输数据流，根据需要调整传输速率和数据流大小，也可以根据需要报告带宽、延迟抖动和数据包丢失。</p>
<p><strong>TCP测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">服务器端</span><br>iperf -s<br><span class="hljs-meta">#</span><span class="bash">客户端  host需替换成服务器地址</span><br>iperf -c host<br></code></pre></td></tr></table></figure>
<p><strong>UDP测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">服务器端</span><br>iperf -u -s <br><span class="hljs-meta">#</span><span class="bash">客户端  host需替换成服务器地址</span><br>iperf -u -c host<br></code></pre></td></tr></table></figure>
<blockquote>
<p>-f [b|B|k|K|m|M|g|G]  //f参数表示单位<br>-r                    //r参数表示双向数据测试，但要先测c到s的带宽<br>-d                    //d参数和r近似，并且功能更强，可同时测试双向数据<br>-w [2000]             //w参数后跟数字，单位是byte，<br>-p [12000]            //p参数可指定端口号<br>-t [20]               //t参数默认表示测试10次，后加数字可以自己定义<br>-i [2]                //i参数表示测试开始到结束的间隔时间，单位s<br>-u -b 10m             //udp 10mbps 测试<br>-m                    //最大mpu测试<br>-P                    //并行测试<br>-h                    //帮助</p>
</blockquote>
<h2 id="IPC通信"><a href="#IPC通信" class="headerlink" title="IPC通信"></a>IPC通信</h2><p>ipcs：–用来查看system V的IPC机制标识符的命令<br>       -q，显示当前系统中 消息队列  的使用<br>       -m，显示当前系统中 共享内存  的使用<br>       -s，显示当前系统中 信号量    的使用</p>
<p>ipcrm：–用来删除 当前系统中 system V的IPC机制标识符的命令<br>       -q，删除当前系统中 消息队列的标识符<br>       -m，删除当前系统中 共享内存的标识符<br>       -s，删除当前系统中 信号灯集的标识符</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>云e办项目</title>
    <url>/article/5653.html</url>
    <content><![CDATA[<h2 id="前端问题"><a href="#前端问题" class="headerlink" title="前端问题"></a>前端问题</h2><ol>
<li><p>在写完导入 vuex 之后，重启项目，发现空白页</p>
<p>运行时发出了警告</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">export &#x27;watch&#x27; (imported as &#x27;watch&#x27;) was not found in &#x27;vue&#x27;<br>export &#x27;inject&#x27; (imported as &#x27;inject&#x27;) was not found in &#x27;vue&#x27;<br></code></pre></td></tr></table></figure>
<p>问题：</p>
<p>创建项目时没有下载 vuex 后期自己下载的，看了一下下载的 vuex 版本时是 4.x.x 页面报错</p>
<p>解决方法：</p>
<ol>
<li><p>看一下自己的vuex版本是不是4.x.x ，如果是，先卸载 vuex</p>
</li>
<li><p>重新下载vuex</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install vuex@3.4.0<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Mac环境搭建</title>
    <url>/article/42094.html</url>
    <content><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="安装以及多版本切换"><a href="#安装以及多版本切换" class="headerlink" title="安装以及多版本切换"></a>安装以及多版本切换</h3><p><a href="https://www.bilibili.com/video/BV1Qf4y1V7Co">b站up主做了很详细的教程</a></p>
<h3 id="彻底卸载MySQL"><a href="#彻底卸载MySQL" class="headerlink" title="彻底卸载MySQL"></a>彻底卸载MySQL</h3><ol>
<li><p>终端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo su<br></code></pre></td></tr></table></figure>
</li>
<li><p>依次执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo rm /usr/local/mysql<br>sudo rm -rf /usr/local/mysql*<br>sudo rm -rf /Library/StartupItems/MySQLCOM<br>sudo rm -rf /Library/PreferencePanes/My*<br>rm -rf ~/Library/PreferencePanes/My*<br>sudo rm -rf /Library/Receipts/mysql*<br>sudo rm -rf /Library/Receipts/MySQL*<br>sudo rm -rf /var/db/receipts/com.mysql.*<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="node-js-npm"><a href="#node-js-npm" class="headerlink" title="node.js + npm"></a>node.js + npm</h2><p>查看 node 安装目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">which node<br></code></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>(如果安装多版本node，<a href="#多版本管理">跳转多版本管理</a>)</p>
<p>使用<strong>HomeBrew</strong></p>
<ol>
<li><p>查看本机可安装的node版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew search node<br></code></pre></td></tr></table></figure>
</li>
<li><p>安装node</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew install node@版本号<br></code></pre></td></tr></table></figure>
</li>
<li><p>链接（很重要，否则node不能使用）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew link node@版本号<br></code></pre></td></tr></table></figure>
</li>
<li><p>链接之后会报两个建议希望你执行两个命令，按照执行就好了</p>
</li>
</ol>
<ol start="5">
<li><p>检查是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">node -v<br></code></pre></td></tr></table></figure>
<p>如果成功，会显示你安装的版本号</p>
</li>
</ol>
<hr>
<p><strong>安装包安装</strong></p>
<p><a href="https://nodejs.org/zh-cn/">中文官方下载地址</a></p>
<p><a href="https://nodejs.org/zh-cn/download/releases/">往期版本</a></p>
<p>【注意】：下载时，建议选择 <strong>尾缀名是 .pkg 的文件</strong> 下载</p>
<p>直接安装</p>
<h3 id="多版本管理"><a href="#多版本管理" class="headerlink" title="多版本管理"></a>多版本管理</h3><p>如果之前存在非n下载的node，要先<a href="#卸载node">卸载</a>掉</p>
<p><strong>清除 node 缓存</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo npm cache clean -f<br></code></pre></td></tr></table></figure>
<p>node开发中，经常遇到版本不匹配的问题，导致编译失败，卸载该版本重新安装的成本又太高，因此我们需要多版本管理的工具</p>
<p>n相比于nvm更容易安装 node，因此选用 n 作为多node版本的管理工具</p>
<blockquote>
<p>HomeBrew方式安装(如果没有node环境)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew install n<br></code></pre></td></tr></table></figure>
<p>npm方式安装(有node环境)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install -g n<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>查看 n 是否安装成功</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n -V<br></code></pre></td></tr></table></figure>
<ol>
<li><p>查看可用 node 列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n ls<br></code></pre></td></tr></table></figure>
</li>
<li><p>安装指定版本的 node</p>
<ol>
<li><p>查看官方所有的 node 版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm view node versions<br></code></pre></td></tr></table></figure>
</li>
<li><p>以安装 12 版本的 node 为例，命令行执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n 12<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>切换 node 版本</p>
<p>命令行执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n<br></code></pre></td></tr></table></figure>
<p>通过上下键，选择要使用的 node 版本</p>
</li>
</ol>
<blockquote>
<ol>
<li><p>安装n模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo npm install -g n<br></code></pre></td></tr></table></figure>
</li>
<li><p>升级node.js到最新稳定版</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n stable<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>升级到最新版</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n latest<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>n后面也可以跟随版本号,升级到任意版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n v12.22.10或sudo n 17.6.0<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>查看一下已安装的 node 版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n ls<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>切换使用版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n 17.6.0<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>删除指定版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n rm 17.6.0<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>用制定的版本执行脚本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">n use 17.6.0 some.js<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="卸载node"><a href="#卸载node" class="headerlink" title="卸载node"></a>卸载node</h3><p><strong>不使用HomeBrew安装时卸载</strong></p>
<ol>
<li><p>终端，确认工具存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">node -v<br>npm -v<br></code></pre></td></tr></table></figure>
</li>
<li><p>依次执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo rm -rf /usr/local/&#123;bin/&#123;node,npm&#125;,lib/node_modules/npm,lib/node,share/man/*/node.*&#125;<br>sudo npm uninstall npm -g<br>sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*<br>sudo rm -rf /usr/local/include/node /Users/$USER/.npm<br>sudo rm /usr/local/bin/node<br>sudo rm /usr/local/share/man/man1/node.1<br>sudo rm /usr/local/lib/dtrace/node.d<br></code></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>使用HomeBrew安装时卸载</strong></p>
<ol>
<li><p>使用brew</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">brew uninstall node@版本号<br></code></pre></td></tr></table></figure>
</li>
<li><p>进入个人主文件夹，检查各种 local、lib、include 文件夹，删除名字含有<code>node</code>和<code>node_modules</code>的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/local/bin<br>sudo rm -rf /usr/local/bin/npm<br>sudo rm -rf /usr/local/bin/node<br>ls -las 仔细查看，全局安装的npm包一般会在这个目录下创建软连接，发现就删除<br></code></pre></td></tr></table></figure>
</li>
<li><p>其他清理工作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo rm -rf /usr/local/share/man/man1/node.1<br>sudo rm -rf /usr/local/lib/dtrace/node.d<br>sudo rm -rf ~/.npm<br></code></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>版本管理工具 n 中 ，卸载指定版本node</strong></p>
<p>命令行运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo n rm 17.6.0<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br><strong>如果删除不成功，可进入<code>/usr/local/n/versions/node</code>目录删除版本</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/local/n/versions/node<br>sudo rm -rf 17.6.0<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><strong>卸载node环境管理工具 n</strong></p>
<ol>
<li><p>命令行执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm uninstall n -g<br>或<br>sudo npm uninstall n -g<br></code></pre></td></tr></table></figure>
</li>
<li><p>进入目录手动删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /usr/local<br></code></pre></td></tr></table></figure>
<p>删除n包</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac,安装</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/article/42622.html</url>
    <content><![CDATA[<blockquote>
<p>You are the big drop of dew under the lotus leaf, I am the smaller one on its upper side,” said the dewdrop to the lake.</p>
<p>露珠对湖水说道；“你是在荷叶下面的大露珠，我是在荷叶上面的较小的露<br>珠。”　</p>
</blockquote>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p><a href="https://www.springcloud.cc">SpringCloud中文网</a></p>
<p><a href="https://spring.io/projects/spring-cloud">SpringCloud官网</a></p>
<p>SpringCloud是一个基于SpringBoot实现的云应用开发工具，它为基于JVM的云应用开发中涉及<strong>的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理</strong>等操作提供了一种简单的开发方式。</p>
<p><strong>微服务架构</strong></p>
<p>微服务(Microservices Architecture)是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</p>
<p>微服务架构的<strong>核心思想</strong>是，一个应用是由多个小的、相互独立的、微服务组成，这些服务运行在自己的进程中，开发和发布都没有依赖。不同服务通过一些<strong>轻量级交互机制来通信</strong>，例如 RPC、HTTP 等，服务可独立扩展伸缩，每个服务定义了明确的边界，不同的服务甚至可以采用不同的编程语言来实现，由独立的团队来维护。简单的来说，一个系统的不同模块转变成不同的服务！而且服务可以使用不同的技术加以实现！</p>
<h3 id="学习环境搭建"><a href="#学习环境搭建" class="headerlink" title="学习环境搭建"></a>学习环境搭建</h3><img src="/article/42622/image-20220223124010573.png" class title="image-20220223124010573">
<p><code>父项目pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.13.1<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">lombok.version</span>&gt;</span>1.18.20<span class="hljs-tag">&lt;/<span class="hljs-name">lombok.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--打包方式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Springcloud依赖--&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2020.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--springboot--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--连接数据库--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--springboot启动器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--日志测试--&gt;</span><br>    <span class="hljs-comment">&lt;!--log4j--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--log4j--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="SpringCloud-api"><a href="#SpringCloud-api" class="headerlink" title="SpringCloud-api"></a>SpringCloud-api</h4><img src="/article/42622/image-20220223124034883.png" class title="image-20220223124034883">
<p>配置SpringCloud-api，pom环境引入父项目依赖，构建实体类。</p>
<h4 id="springcloud-provider-dept-8001"><a href="#springcloud-provider-dept-8001" class="headerlink" title="springcloud-provider-dept-8001"></a>springcloud-provider-dept-8001</h4><img src="/article/42622/image-20220223124230419.png" class title="image-20220223124230419">
<p>构建服务者，springcloud-provider-dept-8001</p>
<p>配置服务者<code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br><br><span class="hljs-comment">#mybatis配置</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.bobo.springcloud.pojo</span><br>  <span class="hljs-attr">config-location:</span> <span class="hljs-string">classpath:mybatis/mybatis-config.xml</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/mapper/*.xml</span><br><br><span class="hljs-comment">#spring配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">springcloud-provider-dept</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="hljs-comment">#数据源</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/(api实体类对应数据库名)?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowPublicKeyRetrieval=true</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">密码</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">用户名</span><br></code></pre></td></tr></table></figure>
<p>配置<code>pom.xml</code>版本号依赖于父项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--添加监控信息--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--我们需要拿到实体类  索要配置api module--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bobo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--test--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--web--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--jetty--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--热部署--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="springcloud-consumer-dept-80"><a href="#springcloud-consumer-dept-80" class="headerlink" title="springcloud-consumer-dept-80"></a>springcloud-consumer-dept-80</h4><img src="/article/42622/image-20220223124558372.png" class title="image-20220223124558372">
<p>构建消费者，springcloud-consumer-dept-80</p>
<p>配置消费者<code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>
<p>配置<code>pom.xml</code>版本号依赖于父项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>  <span class="hljs-comment">&lt;!--实体类+web--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.bobo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="SpringCloud-Eureka"><a href="#SpringCloud-Eureka" class="headerlink" title="SpringCloud Eureka"></a>SpringCloud Eureka</h2><p><strong>SpringCloud Eureka来实现服务治理</strong></p>
<p>SpringCloud Eureka是SpringCloud Netflix项目下的服务治理模块。而SpringCloud Netflix项目是SpringCloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为SpringBoot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。</p>
<p>它主要提供的模块包括：<strong>服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）</strong>等。</p>
<h3 id="EurekaServer"><a href="#EurekaServer" class="headerlink" title="EurekaServer"></a>EurekaServer</h3><p><strong>提供服务注册和发现  springcloud-eureka-7002</strong></p>
<ol>
<li><p><strong>添加依赖</strong></p>
<p>在项目 <code>pom.xml</code>中引入需要的依赖内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong></p>
<p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在<code>application.yml</code>配置文件中增加如下信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#配置端口号</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-comment">#Eureka</span><br><span class="hljs-attr">eureka:</span><br>	<span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span>   <span class="hljs-comment">#Eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#表示是否向eureka服务中心注册自己</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#如果为false则表示自己为注册中心</span><br>    <span class="hljs-attr">service-url:</span><br>    	<span class="hljs-comment">#监控页面</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="29.333ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 12629.6 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">{eureka.instance.hostname}:</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
<path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6B" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/>
<path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/>
<path stroke-width="1" id="E1-MJMAIN-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMATHI-63" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/>
<path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/>
<path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/>
<path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMAIN-3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-65" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-75" x="466" y="0"/>
 <use xlink:href="#E1-MJMATHI-72" x="1039" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="1490" y="0"/>
 <use xlink:href="#E1-MJMATHI-6B" x="1957" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="2478" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="3008" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="3453" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="3798" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="4399" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="4868" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="5230" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="5759" y="0"/>
 <use xlink:href="#E1-MJMATHI-63" x="6360" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="6793" y="0"/>
 <use xlink:href="#E1-MJMAIN-2E" x="7260" y="0"/>
 <use xlink:href="#E1-MJMATHI-68" x="7705" y="0"/>
 <use xlink:href="#E1-MJMATHI-6F" x="8281" y="0"/>
 <use xlink:href="#E1-MJMATHI-73" x="8767" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="9236" y="0"/>
 <use xlink:href="#E1-MJMATHI-6E" x="9598" y="0"/>
 <use xlink:href="#E1-MJMATHI-61" x="10198" y="0"/>
 <use xlink:href="#E1-MJMATHI-6D" x="10728" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="11606" y="0"/>
 <use xlink:href="#E1-MJMAIN-3A" x="12351" y="0"/>
</g>
</svg>&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>开启服务注册</strong></p>
<p>通过 <code>@EnableEurekaServer</code> 注解启动一个服务注册中心提供给其他应用进行对话,这个注解需要在SpringBoot工程的主启动类上加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span>   <span class="hljs-comment">//EnableEurekaServer服务端的启动类，可以接受别人注册进来</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServer_7001</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaServer_7001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>访问服务</strong></p>
<p>启动工程后，访问：<a href="http://localhost:7001/">http://localhost:7001/</a></p>
</li>
</ol>
<h3 id="Service-Provider"><a href="#Service-Provider" class="headerlink" title="Service Provider"></a>Service Provider</h3><p>服务提供方:将自身服务注册到 Eureka 注册中心，从而使服务消费方能够找到</p>
<ol>
<li><p><strong>添加依赖<code>pom.xml</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong><code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#Eureka的配置  服务注册到哪里</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka/</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">springcloud-provider-dept8001</span>   <span class="hljs-comment">#修改Eureka 的默认描述信息</span><br><br><span class="hljs-comment">#info配置</span><br><span class="hljs-attr">info:</span><br>  <span class="hljs-attr">app.name:</span> <span class="hljs-string">bobo-springcloud</span><br>  <span class="hljs-attr">company.name:</span> <span class="hljs-string">bobo666</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>开启服务注册</strong></p>
<p>在应用主类中通过加上 <code>@EnableEurekaClient</code>，但只有 Eureka 可用.</p>
<p>也可以使用@EnableDiscoveryClient,需要配置才能找到Eureka注册中心服务器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span>   <span class="hljs-comment">//自动在服务启动后自动注册到Eureka中</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeptProvider_8001</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(DeptProvider_8001.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>访问服务</strong></p>
<p>启动该工程后，再次访问启动工程：<a href="http://localhost:7001/">http://localhost:7001/</a></p>
</li>
</ol>
<h3 id="多集群模拟"><a href="#多集群模拟" class="headerlink" title="多集群模拟"></a>多集群模拟</h3><img src="/article/42622/image-20220224090112639.png" class title="image-20220224090112639">
<p><strong>如果一台主机试验，修改host文件</strong></p>
<p>注释默认映射，添加映射</p>
<img src="/article/42622/image-20220224090049462.png" class title="image-20220224090049462">
<p>分别修改每个项目下<code>application.yam</code>文件，以7001为例</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-comment">#Eureka</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">eureka7001.com</span>   <span class="hljs-comment">#Eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#表示是否向eureka服务中心注册自己</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#如果为false则表示自己为注册中心</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/,</span> <span class="hljs-string">http://eureka7003.com:7003/eureka/</span><br></code></pre></td></tr></table></figure>
<p>修改<strong>服务提供方</strong><code>application.yam</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#Eureka的配置  服务注册到哪里</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">springcloud-provider-dept8001</span>   <span class="hljs-comment">#修改Eureka 的默认描述信息</span><br><br><span class="hljs-comment">#info配置</span><br><span class="hljs-attr">info:</span><br>  <span class="hljs-attr">app.name:</span> <span class="hljs-string">bobo-springcloud</span><br>  <span class="hljs-attr">company.name:</span> <span class="hljs-string">bobo666</span><br></code></pre></td></tr></table></figure>
<p>启动<strong>7001、7002、7003</strong>项目</p>
<p>以7001为例</p>
<img src="/article/42622/image-20220224090644886.png" class title="image-20220224090644886">
<p>启动<strong>8001服务提供者</strong>项目</p>
<img src="/article/42622/image-20220224090950094.png" class title="image-20220224090950094">
<h3 id="Eureka与Zookeeper的区别"><a href="#Eureka与Zookeeper的区别" class="headerlink" title="Eureka与Zookeeper的区别"></a>Eureka与Zookeeper的区别</h3><p>CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)。由于<strong>分区容错性P在是分布式系统中必须要保证</strong>的，因此我们只能在A和C之间进行权衡。<br><strong>Zookeeper保证CP</strong><br>Zookeeper 为主从结构，有leader节点和follow节点。当leader节点down掉之后，剩余节点会重新进行选举。选举过程中会导致服务不可用，丢掉了可用行。<br><strong>Eureka保证AP</strong><br>Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。</p>
<blockquote>
<p><strong>为什么CAP只能达到 CP 或者 AP？</strong></p>
<p>由以上我们得知，P是必然存在的。<br>如果我们保证了CP，即一致性与分布容错。当我们通过一个服务器修改数据后，该服务器会向另一个服务器发送请求，将数据进行同步，但此时，该数据应处于锁定状态，不可再次修改，这样，如果此时我们想服务器发送请求，则得不到相应，这样就不能A，高可用。<br>如果我们保证了AP，那么我们不能对服务器进行锁定，任何时候都要得到相应，那么数据的一致性就不好说了。</p>
</blockquote>
<h3 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h3><p>在默认配置中Eureka Server服务在一定时间（<strong>默认为90秒</strong>）没接受到某个服务的心跳连接后，Eureka Server会注销该服务。但是会存在当网络分区发生故障，导致该时间内没有心跳连接，但该服务本身还是健康运行的情况。Eureka通过“自我保护模式”来解决这个问题。</p>
<ol>
<li><p>在自我保护模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。当他收到的心跳数重新恢复到阈值以上时，该Eureka Server节点会自动退出自我保护模式。</p>
</li>
<li><p>在自我保护模式下，Eureka Server 仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点依然可用。）</p>
</li>
<li>当网络稳定时，当前实例新的注册信息会被同步到其他节点中</li>
</ol>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>SpringCloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端负载均衡</strong>的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。</p>
<p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的<strong>软件负载均衡算法</strong>，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。</p>
<h3 id="LB方案"><a href="#LB方案" class="headerlink" title="LB方案"></a>LB方案</h3><p>负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。</p>
<p>负载均衡构建在原有网络结构之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性。</p>
<p><strong>集中式LB</strong>, 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；</p>
<p><strong>进程内LB</strong>，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。<strong>Ribbon就属于进程内LB</strong>，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p>
<h3 id="集群模拟"><a href="#集群模拟" class="headerlink" title="集群模拟"></a>集群模拟</h3><p><strong>Ribbon Consumer</strong></p>
<p><strong>服务消费者</strong></p>
<ol>
<li><p><strong>添加依赖 <code>pom.xml</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Ribbon负载均衡--&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-ribbon --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--erueka--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><br><span class="hljs-comment">#eureka配置</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">#不向eureka注册自己</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7002.com:7002/eureka/,</span> <span class="hljs-string">http://eureka7003.com:7003/eureka/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>开启服务负载均衡</strong></p>
<p>在工程的启动类中,通过<code>@EnableEurekaClient</code>向服务注册中心注册；并且向程序的<code>ioc</code>注入一个<code>bean: restTemplate</code>并通过<code>@LoadBalanced</code>注解表明这个<code>restTemplate</code>开启负载均衡的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeptConsumer_80</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(DeptConsumer_80.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud.config;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigBean</span> </span>&#123;   <span class="hljs-comment">//@Configuration   ----spring applicationContext.xml</span><br><br>  <span class="hljs-comment">//配置负载均衡实现  RestTemplate</span><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@LoadBalanced</span>  <span class="hljs-comment">//Ribbon</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>消费提供者方法</strong></p>
<p>在<code>Controller</code> 类中，调用提供者的 <code>home</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud.controller;<br><span class="hljs-keyword">import</span> com.bobo.springcloud.pojo.Dept;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeptConsumerController</span> </span>&#123;<br>  <span class="hljs-comment">//理解 消费者不应该有service层</span><br>  <span class="hljs-comment">//RestTemplate</span><br>  <span class="hljs-comment">//提供多种便捷访问远程http服务的方法，是一种简单的restful服务模版</span><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>  <span class="hljs-comment">//Ribbon 这里的地址 应该是一个变量，通过服务名来访问</span><br>  <span class="hljs-comment">//private static final String REST_URL_PREFIX = &quot;http://localhost:8001&quot;;</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REST_URL_PREFIX = <span class="hljs-string">&quot;http://SPRINGCLOUD-PROVIDER-DEPT&quot;</span>;<br><br>  <span class="hljs-meta">@RequestMapping(&quot;/consumer/dept/list&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Dept&gt; <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> restTemplate.getForObject(REST_URL_PREFIX + <span class="hljs-string">&quot;/dept/deptlist&quot;</span>, List.class);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>负载均衡</strong></p>
<p>访问<a href="http://localhost/consumer/dept/list`，发现Ribbon已经实现负载均衡">http://localhost/consumer/dept/list`，发现Ribbon已经实现负载均衡</a></p>
</li>
</ol>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ol>
<li><p>轮询法</p>
<p>轮询法，就是将用户的请求轮流分配给服务器，就像是挨个数数，轮流分配。这种算法比较简单，他具有绝对均衡的优点，但是也正是因为绝对均衡它必须付出很大的代价，例如它无法保证分配任务的合理性，无法根据服务器承受能力来分配任务。</p>
</li>
<li><p>随机法</p>
<p>随机法，是随机选择一台服务器来分配任务。它保证了请求的分散性达到了均衡的目的。同时它是没有状态的不需要维持上次的选择状态和均衡因子。但是随着任务量的增大，它的效果趋向轮询后也会具有轮询算法的部分缺点。</p>
</li>
<li><p>最小连接法</p>
<p>最小连接法，将任务分配给此时具有最小连接数的节点，因此它是动态负载均衡算法。一个节点收到一个任务后连接数就会加1，当节点故障时就将节点权值设置为0，不再给节点分配任务。</p>
<p>最小连接法适用于各个节点处理的性能相似时。任务分发单元会将任务平滑分配给服务器。但当服务器性能差距较大时，就无法达到预期的效果。因为此时连接数并不能准确表明处理能力，连接数小而自身性能很差的服务器可能不及连接数大而自身性能极好的服务器。所以在这个时候就会导致任务无法准确的分配到剩余处理能力强的机器上。 </p>
</li>
</ol>
<h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Feign是一个声明式的<strong>伪Http客户端</strong>，它使得写Http客户端变得更简单。</p>
<p>使用Feign，只需要创建一个接口并注解，它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解，<strong>Feign支持可插拔的编码器和解码器</strong>，<strong>Feign默认集成了Ribbo</strong>，并和Eureka结合，<strong>默认实现了负载均衡</strong>的效果。</p>
<p>在<strong>Feign</strong>的实现下，我们只需要创建一个接口并使用注解的方式来配置它。即可以完成对服务提供方的接口绑定，简化了使用SpringCloud Ribbon时，自动封装服务调用客户端的开发量。</p>
<p>Feign远程调用的基本流程</p>
<img src="/article/42622/1.png" class width="1">
<p><strong>Feign 具有如下特性</strong></p>
<ul>
<li>可插拔的注解支持，包括Feign注解和JAX-RS注解</li>
<li>支持可插拔的HTTP编码器和解码器</li>
<li>支持Hystrix和它的Fallback</li>
<li>支持Ribbon的负载均衡</li>
<li>支持HTTP请求和响应的压缩Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。它整合了Ribbon和Hystrix，从而不再需要显式地使用这两个组件。Feign还提供了HTTP请求的模板，通过编写简单的接口和注解，就可以定义好HTTP请求的参数、格式、地址等信息。接下来，Feign会完全代理HTTP的请求，我们只需要像调用方法一样调用它就可以完成服务请求。</li>
</ul>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在SpringCloud可以用RestTemplate+Ribbon和Feign来调用。</p>
<p>由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p>
<p>针对上述问题，在SpringCloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了<strong>服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控</strong>等强大功能。</p>
<table>
<thead>
<tr>
<th style="text-align:center">雪崩场景</th>
<th style="text-align:center">举例</th>
<th style="text-align:center">应对策略</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">硬件故障</td>
<td style="text-align:center">服务器宕机，机房断电，光纤被挖断等</td>
<td style="text-align:center">多机房容灾、异地多活等。</td>
</tr>
<tr>
<td style="text-align:center">流量激增</td>
<td style="text-align:center">异常流量，重试加大流量等</td>
<td style="text-align:center">服务自动扩容、流量控制（限流、关闭重试）等。</td>
</tr>
<tr>
<td style="text-align:center">缓存穿透</td>
<td style="text-align:center">一般发生在应用重启，所有缓存失效时，以及短时间内大量缓存失效时。大量的缓存不命中，使请求直击后端服务，造成服务提供者超负荷运行，引起服务不可用。</td>
<td style="text-align:center">缓存预加载、缓存异步加载等。</td>
</tr>
<tr>
<td style="text-align:center">程序BUG</td>
<td style="text-align:center">如程序逻辑导致内存泄漏，JVM长时间FullGC等。</td>
<td style="text-align:center">修改程序bug、及时释放资源等。</td>
</tr>
<tr>
<td style="text-align:center">同步等待</td>
<td style="text-align:center">服务间采用同步调用模式，同步等待造成的资源耗尽。</td>
<td style="text-align:center">资源隔离、MQ解耦、不可用服务调用快速失败等。资源隔离通常指不同服务调用采用不同的线程池；不可用服务调用快速失败一般通过熔断器模式结合超时机制实现。</td>
</tr>
</tbody>
</table>
<h3 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h3><p>断路器模式源于Martin Fowler的Circuit Breaker一文。“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。</p>
<p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，<strong>通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放</strong>，避免了故障在分布式系统中的蔓延。</p>
<h3 id="使用-Ribbon-Hystrix"><a href="#使用-Ribbon-Hystrix" class="headerlink" title="使用 Ribbon Hystrix"></a>使用 Ribbon Hystrix</h3><p><strong>服务熔断</strong></p>
<ol>
<li><p><strong>添加依赖</strong></p>
<p>在项目<code>pom</code> 加上<code>hystrix</code>的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- hystrix 断路器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在程序的启动类通过 <code>@EnableHystrix</code> 开启 <code>Hystrix</code> 断路器监控.</p>
</li>
<li><p><strong>消费提供者方法</strong></p>
<ol>
<li>新方法<code>defaultStores</code>,当出现雪崩情况，跳转到该方法</li>
<li>修改 <code>DeptConsumerController</code> 类的，<code>list</code> 方法，加上注解<code>@HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)</code></li>
</ol>
</li>
</ol>
<h3 id="服务熔断与降级"><a href="#服务熔断与降级" class="headerlink" title="服务熔断与降级"></a>服务熔断与降级</h3><p><strong>服务熔断:作用在服务提供者</strong></p>
<p>服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用,快速返回”错误”的响应信息。当检测到该节点微服务响应正常后恢复调用链路.</p>
<p><strong>服务降级：作用在消费者</strong></p>
<p><strong>服务降级处理是在客户端实现完成的，与服务端没有关系</strong></p>
<p>服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。\</p>
<p><strong>相同点</strong></p>
<p>目标一致 都是从可用性和可靠性出发，为了防止系统崩溃；</p>
<p>用户体验类似 最终都让用户体验到的是某些功能暂时不可用；</p>
<p><strong>不同点</strong></p>
<p>触发原因不同 服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑； </p>
<h2 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h2><p>务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供<code>REST API</code>的过程中，除了具备<strong>服务路由、均衡负载功能</strong>之外，它还具备了<strong>权限控制</strong>等功能。<code>Spring Cloud</code> <code>Netflix</code>中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p>
<p>路由在微服务体系结构的一个组成部分。例如，/可以映射到您的Web应用程序，<code>/api/users</code>映射到用户服务，并将<code>/api/shop</code>映射到商店服务。<code>Zuul</code>是<code>Netflix</code>的基于<code>JVM</code>的路由器和服务器端负载均衡器。</p>
<h3 id="什么是服务网关"><a href="#什么是服务网关" class="headerlink" title="什么是服务网关"></a>什么是服务网关</h3><p><strong>服务网关 = 路由转发 + 过滤器</strong></p>
<ol>
<li><p>路由转发：接收一切外界请求，转发到后端的微服务上去；</p>
</li>
<li><p>过滤器：在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，这些都可以通过过滤器完成（其实路由转发也是通过过滤器实现的）。</p>
</li>
</ol>
<h3 id="为什么需要服务网关"><a href="#为什么需要服务网关" class="headerlink" title="为什么需要服务网关"></a>为什么需要服务网关</h3><p>上述所说的横切功能（以权限校验为例）可以写在三个位置：</p>
<ul>
<li>每个服务自己实现一遍</li>
<li>写到一个公共的服务中，然后其他所有服务都依赖这个服务</li>
<li>写到服务网关的前置过滤器中，所有请求过来进行权限校验</li>
</ul>
<p><strong>第一种，缺点太明显，基本不用；</strong> </p>
<p><strong>第二种，相较于第一点好很多，代码开发不会冗余，但是有两个缺点：</strong></p>
<ul>
<li>由于每个服务引入了这个公共服务，那么相当于在每个服务中都引入了相同的权限校验的代码，使得每个服务的jar包大小无故增加了一些，尤其是对于使用docker镜像进行部署的场景，jar越小越好；</li>
<li>由于每个服务都引入了这个公共服务，那么我们后续升级这个服务可能就比较困难，而且公共服务的功能越多，升级就越难，而且假设我们改变了公共服务中的权限校验的方式，想让所有的服务都去使用新的权限校验方式，我们就需要将之前所有的服务都重新引包，编译部署。</li>
</ul>
<p><strong>而服务网关恰好可以解决这样的问题：</strong></p>
<ul>
<li>将权限校验的逻辑写在网关的过滤器中，后端服务不需要关注权限校验的代码，所以服务的jar包中也不会引入权限校验的逻辑，不会增加jar包大小；</li>
<li>如果想修改权限校验的逻辑，只需要修改网关中的权限校验过滤器即可，而不需要升级所有已存在的微服务。</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p><strong>新建项目</strong> <code>spring-cloud-zuul-service</code></p>
<ol>
<li><p><strong>添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>开启服务注册</strong></p>
<p>在程序的启动类 <code>ZuulApplication</code> 通过 <code>@EnableZuulProxy</code> 开启 Zuul 服务网关</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;<br><span class="hljs-meta">@EnableZuulProxy</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZuulApplication</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(ZuulApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong></p>
<p>配置文件 <code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-zuul</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9527</span><br><span class="hljs-attr">eureka:</span> <br>	<span class="hljs-attr">client:</span><br>		<span class="hljs-attr">service-url:</span> <br>			<span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://eureka7001.com:7001/eureka/,</span> <span class="hljs-string">,http://eureka7002.com:7002/eureka/,</span> <span class="hljs-string">http://eureka7003.com:7003/eureka/</span><br><span class="hljs-attr">instance:</span><br>	<span class="hljs-attr">instance-id:</span> <span class="hljs-string">zuul9527.com</span><br>	<br><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">routes:</span><br>  	<span class="hljs-attr">mydept.serverId:</span> <span class="hljs-string">springcloud-provider-dept</span><br>  	<span class="hljs-attr">mydept.path:</span> <span class="hljs-string">/mydept/**</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="SpringCloud-Config"><a href="#SpringCloud-Config" class="headerlink" title="SpringCloud Config"></a>SpringCloud Config</h2><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在SpringCloud中，有分布式配置中心组件<strong>pringloud Config</strong>，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是<strong>config server</strong>，二是<strong>config client</strong>。</p>
<p><strong>SpringCloud Config</strong>就是我们通常意义上的配置中心，把应用原本放在本地文件的配置抽取出来放在中心服务器，从而能够提供更好的管理、发布能力。SpringCloud Config分服务端和客户端，<strong>服务端</strong>负责将<strong>git svn</strong>中存储的配置文件发布成<strong>REST接口</strong>，<strong>客户端</strong>可以从<strong>服务端REST接口</strong>获取配置。但客户端并不能主动感知到配置的变化，从而主动去获取新的配置，这需要每个客户端通过<strong>POST</strong>方法触发各自的<code>/refresh</code>。</p>
<p><strong>SpringCloud Bus</strong>通过一个<strong>轻量级消息代理连接分布式系统的节点</strong>。这可以用于广播状态更改（如配置更改）或其他管理指令。SpringCloudBus提供了通过<strong>POST</strong>方法访问的<code>endpoint/bus/refresh</code>，这个接口通常由<strong>git</strong>的钩子功能调用，用以通知各个SpringCloud Config的客户端去服务端更新配置。</p>
<h3 id="服务端配置-Config-Server"><a href="#服务端配置-Config-Server" class="headerlink" title="服务端配置 Config Server"></a>服务端配置 Config Server</h3><ol>
<li><p><strong>新建项目</strong> spring-cloud-config-server</p>
</li>
<li><p><strong>添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong></p>
<p>配置文件 <code>application.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">3344</span><br><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">application:</span><br>		<span class="hljs-attr">name:</span> <span class="hljs-string">config-server</span><br>	<span class="hljs-attr">cloud:</span><br>		<span class="hljs-attr">config:</span> <br>			<span class="hljs-attr">label:</span> <span class="hljs-string">main</span><br>			<span class="hljs-attr">server:</span><br>				<span class="hljs-attr">git:</span> <br>					<span class="hljs-attr">uri:</span> <span class="hljs-string">git仓库HTTPS地址</span><br>					<span class="hljs-attr">search-paths:</span>	<span class="hljs-string">spring-cloud-config</span><br></code></pre></td></tr></table></figure>
<ul>
<li>spring.cloud.config.server.git.uri：配置git仓库地址</li>
<li>spring.cloud.config.server.git.searchPaths：配置仓库路径</li>
<li>spring.cloud.config.label：配置仓库的分支</li>
</ul>
</li>
<li><p><strong>开启服务注册</strong></p>
<p>在程序的启动类 <code>ConfigServerApplication</code> 通过 <code>@EnableConfigServer</code> 开启 SpringCloud Config 服务端 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;<br><span class="hljs-meta">@EnableConfigServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigServerApplication</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(ConfigServerApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="客户端配置-Config-Client"><a href="#客户端配置-Config-Client" class="headerlink" title="客户端配置  Config Client"></a>客户端配置  Config Client</h3><ol>
<li><p><strong>新建项目</strong> spring-cloud-config-client</p>
</li>
<li><p><strong>添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>添加配置</strong></p>
<p>配置文件 <code>application.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>	<span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br><span class="hljs-attr">spring:</span><br>	<span class="hljs-attr">application:</span><br>		<span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span><br>	<span class="hljs-attr">cloud:</span><br>		<span class="hljs-attr">config:</span><br>			<span class="hljs-attr">label:</span> <span class="hljs-string">mian</span><br>			<span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span><br>			<span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:3344/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>开启服务注册</strong></p>
<p>在程序的启动类 <code>ConfigClientApplication</code> 通过 <code>@Value</code> 获取服务端的 <code>content</code> 值的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.springcloud.controller;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigClientApplication</span> </span>&#123;<br>  <span class="hljs-meta">@Value(&quot;$&#123;content&#125;&quot;)</span><br>  String content;<br>  <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">home</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;content:&quot;</span> + content;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(ConfigClientApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringCloud</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java,SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot Web开发</title>
    <url>/article/43108.html</url>
    <content><![CDATA[<blockquote>
<p>The scabbard is content to be dull when it protects the keenness of the sword.</p>
<p>刀鞘保护刀的锋利，它自己则满足于它的迟钝。</p>
</blockquote>
<h2 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="SpringBoot Web开发"></a>SpringBoot Web开发</h2><a href="/article/4780.html" title="SpringMVC">SpringMVC</a>SpringMVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，其本身就是 Spring 框架的一部分，可以与 Spring 无缝集成，性能方面具有先天的优越性，是当今业界最主流的 Web 开发框架之一。<br><br>SpringBoot 是在 Spring 的基础上创建一款开源框架，它提供了 spring-boot-starter-web（Web 场景启动器） 来为 Web 开发予以支持。spring-boot-starter-web 为我们提供了嵌入的 Servlet 容器以及 SpringMVC 的依赖，并为 SpringMVC 提供了大量自动配置，可以适用于大多数 Web 开发场景。<br><br><br><br>### 静态资源导入<br><br>在 Web 应用中会涉及到大量的静态资源，例如 JS、CSS 和 HTML 等。我们知道，Spring MVC 导入静态资源文件时，需要配置静态资源的映射；但在 SpringBoot 中则不再需要进行此项配置，因为 SpringBoot 已经默认完成了这一工作。<br><br>Spring Boot 默认为我们提供了 3 种静态资源映射规则：<br><br>1. WebJars 映射<br>2. 默认资源映射<br>3. 静态首页（欢迎页）映射<br><br><br><br>#### WebJars 映射<br><br>WebJars 可以将 Web 前端资源（JS，CSS 等）打成一个个的 Jar 包，然后将这些 Jar 包部署到 Maven 中央仓库中进行统一管理，当 Spring Boot 项目中需要引入 Web 前端资源时，只需要访问 <a href="https://www.webjars.org/">WebJars 官网</a>，找到所需资源的 pom 依赖，将其导入到项目中即可。<br><br>所有通过 WebJars 引入的前端资源都存放在当前项目类路径（classpath）下的“<strong>/META-INF/resources/webjars/</strong>” 目录中。<br><br><br><br>#### 默认静态资源映射<br><br>当访问项目中的任意资源（即“/<strong>”）时，SpringBoot 会默认从以下路径中查找资源文件（优先级依次降低）：<br><br>1. classpath:/META-INF/resources/<br>2. classpath:/resources/<br>3. classpath:/static/<br>4. classpath:/public/<br><br>这些路径又被称为静态资源文件夹，它们的优先级顺序为：classpath:/META-INF/resources/ &gt; classpath:/resources/ &gt; classpath:/static/ &gt; classpath:/public/ 。<br><br>当我们请求某个静态资源（即以“.html”结尾的请求）时，SpringBoot 会先查找优先级高的文件夹，再查找优先级低的文件夹，直到找到指定的静态资源为止。<br><br><br><br>#### 静态首页（欢迎页）映射<br><br>静态资源文件夹下的所有 index.html 被称为静态首页或者欢迎页，它们会被被 `/</strong><code>映射，换句话说就是，当我们访问</code>/<code>或者</code>/index.html<code>时，都会跳转到静态首页（欢迎页）。



### Thymeleaf

[官方网站](https://www.thymeleaf.org)

[官方文档](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)

Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。它与 JSP，Velocity，FreeMaker 等模板引擎类似，也可以轻易地与 SpringMVC 等 Web 框架集成。与其它模板引擎相比，Thymeleaf 最大的特点是，即使不启动 Web 应用，也可以直接在浏览器中打开并正确显示模板页面 。



Thymeleaf 支持 HTML 原型，其文件后缀为</code>.html`，因此它可以直接被浏览器打开，此时浏览器会忽略未定义的 Thymeleaf 标签属性，展示 thymeleaf 模板的静态页面效果；当通过 Web 应用程序访问时，Thymeleaf 会动态地替换掉静态内容，使页面动态显示。<br><br>#### 依赖<br><br>使用thymeleaf,Maven导入依赖<br><br><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<img src="/article/43108/image-20220215235857183.png" class title="image-20220215235857183">
<p>我们要将html放在我们的<code>templates</code>目录下</p>
<h4 id="Thymeleaf-的特点"><a href="#Thymeleaf-的特点" class="headerlink" title="Thymeleaf 的特点"></a>Thymeleaf 的特点</h4><p>Thymeleaf 模板引擎具有以下特点：</p>
<ul>
<li>动静结合：Thymeleaf 既可以直接使用浏览器打开，查看页面的静态效果，也可以通过 Web 应用程序进行访问，查看动态页面效果。</li>
<li>开箱即用：Thymeleaf 提供了 Spring 标准方言以及一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li>
<li>多方言支持：它提供了 Thymeleaf 标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式；必要时，开发人员也可以扩展和创建自定义的方言。</li>
<li>与 SpringBoot 完美整合：SpringBoot 为 Thymeleaf 提供了的默认配置，并且还为 Thymeleaf 设置了视图解析器，因此 Thymeleaf 可以与 Spring Boot 完美整合。</li>
</ul>
<h4 id="标准表达式语法"><a href="#标准表达式语法" class="headerlink" title="标准表达式语法"></a>标准表达式语法</h4><p>Thymeleaf 模板引擎支持多种表达式：</p>
<ul>
<li><p>变量表达式：${…}</p>
<ul>
<li>获取对象的属性和方法</li>
<li>使用内置的基本对象<ul>
<li>#ctx ：上下文对象；</li>
<li>#vars ：上下文变量；</li>
<li>#locale：上下文的语言环境；</li>
<li>#request：HttpServletRequest 对象（仅在 Web 应用中可用）；</li>
<li>#response：HttpServletResponse 对象（仅在 Web 应用中可用）；</li>
<li>#session：HttpSession 对象（仅在 Web 应用中可用）；</li>
<li>#servletContext：ServletContext 对象（仅在 Web 应用中可用）。</li>
</ul>
</li>
<li>使用内置的工具对象</li>
</ul>
</li>
<li><p>选择变量表达式：*{…}</p>
<ul>
<li><p>选择变量表达式与变量表达式功能基本一致，只是在变量表达式的基础上增加了与 th:object 的配合使用。当使用 th:object 存储一个对象后，我们可以在其后代中使用选择变量表达式<code>*&#123;...&#125;</code>获取该对象中的属性，其中，<code>*</code> 即代表该对象。</p>
</li>
<li><p><code>`</code>html<br><div th:object="${session.user}"></div></p>
<pre><code>&lt;p th:text=&quot;*&#123;fisrtName&#125;&quot;&gt;firstname&lt;/p&gt;
</code></pre><p></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><br>- 链接表达式：@&#123;...&#125;<br><br>  - 不管是静态资源的引用，还是 form 表单的请求，凡是链接都可以用链接表达式 `@&#123;...&#125;`。 链接表达式的形式结构如下： 无参请求：@&#123;<span class="hljs-regexp">/xxx&#125; 有参请求：@&#123;/xxx</span>(k1=v1,k2=v2)&#125; <br><br>- 国际化表达式：<span class="hljs-comment">#&#123;...&#125;</span><br><br>- 片段引用表达式：~&#123;...&#125;<br><br>  - 推荐：~&#123;templatename::fragmentname&#125;<br>  - 支持：~&#123;templatename::<span class="hljs-comment">#id&#125;</span><br>  - templatename：模版名，Thymeleaf 会根据模版名解析完整路径：/resources/templates/templatename.html，要注意文件的路径。<br>  - fragmentname：片段名，Thymeleaf 通过 <span class="hljs-symbol">th:</span>fragment 声明定义代码块，即：<span class="hljs-symbol">th:</span>fragment=<span class="hljs-string">&quot;fragmentname&quot;</span><br>  - id：HTML 的 id 选择器，使用时要在前面加上 <span class="hljs-comment"># 号，不支持 class 选择器。</span><br><br><span class="hljs-comment">#### th 属性</span><br><br>|   属性    |                             描述                             |<br>| <span class="hljs-symbol">:-------</span>: | <span class="hljs-symbol">:----------------------------------------------------------</span>: |<br>|   <span class="hljs-symbol">th:</span>id   |                     替换 HTML 的 id 属性                     |<br>|  <span class="hljs-symbol">th:</span>text  |                    文本替换，转义特殊字符                    |<br>| <span class="hljs-symbol">th:</span>utext  |                   文本替换，不转义特殊字符                   |<br>|  <span class="hljs-symbol">th:</span>each  |              遍历，支持 Iterable、Map、数组等。              |<br>| <span class="hljs-symbol">th:</span>object | 在父标签选择对象，子标签使用 *&#123;…&#125; 选择表达式选取值。 没有选择对象，那子标签使用选择表达式和 <span class="hljs-variable">$&#123;</span>…&#125; 变量表达式是一样的效果。 同时即使选择了对象，子标签仍然可以使用变量表达式。 |<br>|  <span class="hljs-symbol">th:</span><span class="hljs-keyword">with</span>  |                       局部变量赋值运算                       |<br>|   <span class="hljs-symbol">th:</span>if   |                根据条件判断是否需要展示此标签                |<br>| <span class="hljs-symbol">th:</span><span class="hljs-keyword">unless</span> |             和 <span class="hljs-symbol">th:</span>if 判断相反，满足条件时不显示              |<br><br><br><br><span class="hljs-comment">### SpringBoot定制SpringMVC</span><br><br>SpringBoot 抛弃了传统 xml 配置文件，通过配置类（标注 <span class="hljs-variable">@Configuration</span> 的类，相当于一个 xml 配置文件）以 JavaBean 形式进行相关配置。<br><br>SpringBoot 对 SpringMVC 的自动配置可以满足我们的大部分需求，但是我们也可以通过自定义配置类（标注 <span class="hljs-variable">@Configuration</span> 的类）并实现 WebMvcConfigurer 接口来定制 Spring MVC 配置，<br><br>在 Spring Boot 项目中，我们可以通过以下 <span class="hljs-number">2</span> 中形式定制 Spring <span class="hljs-symbol">MVC:</span><br><br>- 扩展 Spring MVC<br>- 全面接管 Spring MVC<br><br><span class="hljs-comment">#### 扩展 SpringMVC </span><br><br>如果 SpringBoot 对 SpringMVC 的自动配置不能满足我们的需要，我们还可以通过自定义一个 WebMvcConfigurer 类型（**实现 WebMvcConfigurer 接口**）的配置类（**标注 <span class="hljs-variable">@Configuration</span>，但不标注 <span class="hljs-variable">@EnableWebMvc</span>** 注解的类），来扩展 SpringMVC。这样不但能够保留 SpringBoot 对 SpringMVC 的自动配置，享受 SpringBoot 自动配置带来的便利，还能额外增加自定义的 SpringMVC 配置。<br><br><span class="hljs-comment">#### 全面接管 SpringMVC</span><br><br>在一些特殊情况下，我们可能需要抛弃 SpringBoot 对 SpringMVC 的全部自动配置，完全接管 SpringMVC。此时我们可以自定义一个 WebMvcConfigurer 类型（**实现 WebMvcConfigurer 接口**）的配置类，并在该类上**标注 <span class="hljs-variable">@EnableWebMvc</span> 注解**，来实现完全接管 Spring MVC。<br><br><br><br><span class="hljs-comment">### 国际化</span><br><br>国际化（Internationalization 简称 I18n，其中“I”和“n”分别为首末字符，<span class="hljs-number">18</span> 则为中间的字符数）是指软件开发时应该具备支持多种语言和地区的功能。换句话说就是，开发的软件需要能同时应对不同国家和地区的用户访问，并根据用户地区和语言习惯，提供相应的、符合用具阅读习惯的页面和数据，例如，为中国用户提供汉语界面显示，为美国用户提供提供英语界面显示。<br><br>在 Spring 项目中实现国际化，通常需要以下 <span class="hljs-number">3</span> 步：<br><br><span class="hljs-number">1</span>. 编写国际化资源（配置）文件；<br><span class="hljs-number">2</span>. 使用 ResourceBundleMessageSource 管理国际化资源文件；<br><span class="hljs-number">3</span>. 在页面获取国际化内容。<br><span class="hljs-number">4</span>. <br><br><span class="hljs-comment">#### 编写国际化资源文件</span><br><br>在 Spring Boot 的类路径下创建国际化资源文件，文件名格式为：基本名_语言代码_国家或地区代码，例如 login_en_US.properties、login_zh_CN.properties。<br><br>在 src/main/resources 下创建一个 i18n 的目录，并在该目录中按照国际化资源文件命名格式分别创建以下三个文件，<br><br>- login.properties：无语言设置时生效<br>- login_en_US.properties ：英语时生效<br>- login_zh_CN.properties：中文时生效<br><br>以上国际化资源文件创建完成后，IDEA 会自动识别它们，并转换成如下的模式：<br><br>![image<span class="hljs-number">-20220219143717888</span>](SpringBoot-Web开发/image<span class="hljs-number">-20220219143717888</span>.png)<br><br>打开任意一个国际化资源文件，并切换为 Resource Bundle 模式，然后点击“+”号，创建所需的国际化属性<br><br><br><br><span class="hljs-comment">#### 使用 ResourceBundleMessageSource 管理国际化资源文件</span><br><br>SpringBoot 已经对 ResourceBundleMessageSource 提供了默认的自动配置。<br><br>只需要在 SpringBoot 全局配置文件中，使用配置参数`spring.messages.basename`指定我们自定义的国际资源文件的基本名即可，代码如下（当指定多个资源文件时，用逗号分隔）。<br><br>```properties<br>spring.messages.basename=i18n.login<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="获取国际化内容"><a href="#获取国际化内容" class="headerlink" title="获取国际化内容"></a>获取国际化内容</h4><p>由于页面使用的是 Tymeleaf 模板引擎，因此我们可以通过表达式 #{…} 获取国际化内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-lg btn-primary btn-block&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;login.btn&#125;&quot;</span>&gt;</span>Sign in<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;index.html(l=&#x27;zh_CN&#x27;)&#125;&quot;</span>&gt;</span>中文<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-sm&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;index.html(l=&#x27;en_US&#x27;)&#125;&quot;</span>&gt;</span>English<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="SpringBoot拦截器"><a href="#SpringBoot拦截器" class="headerlink" title="SpringBoot拦截器"></a>SpringBoot拦截器</h3><p>在 Spring Boot 项目中，使用拦截器功能通常需要以下 3 步：</p>
<ol>
<li>定义拦截器；</li>
<li>注册拦截器；</li>
<li>指定拦截规则（如果是拦截所有，静态资源也会被拦截）。</li>
</ol>
<h4 id="定义拦截器"><a href="#定义拦截器" class="headerlink" title="定义拦截器"></a>定义拦截器</h4><p>在 SpringBoot 中定义拦截器十分的简单，只需要创建一个拦截器类，并实现 <code>HandlerInterceptor</code> 接口即可。</p>
<p>HandlerInterceptor 接口中定义以下 3 个方法，如下表。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法声明</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</td>
<td>该方法在控制器处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。</td>
</tr>
<tr>
<td>void</td>
<td>postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</td>
<td>该方法在控制器处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步修改。</td>
</tr>
<tr>
<td>void</td>
<td>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</td>
<td>该方法在视图渲染结束后执行，可以通过此方法实现资源清理、记录日志信息等工作。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginHandlerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    <span class="hljs-comment">//登录成功 有用户的session</span><br>    Object loginUser = request.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>);<br>    <span class="hljs-comment">//没有登录</span><br>    <span class="hljs-keyword">if</span> (loginUser==<span class="hljs-keyword">null</span>)&#123; <br>      request.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;没有权限，请先登录&quot;</span>);<br>      request.getRequestDispatcher(<span class="hljs-string">&quot;/index.html&quot;</span>).forward(request,response);<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h4><p>创建一个实现了 WebMvcConfigurer 接口的配置类（使用了 <code>@Configuration</code> 注解的类），重写 <code>addInterceptors()</code> 方法，并在该方法中调用 <code>registry.addInterceptor()</code> 方法将自定义的拦截器注册到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.ViewControllerRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><span class="hljs-comment">//@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的&lt;beans&gt;，作用为：配置spring容器(应用上下文)</span><br><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> LoginHandlerInterceptor());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="指定拦截规则"><a href="#指定拦截规则" class="headerlink" title="指定拦截规则"></a>指定拦截规则</h4><p>在使用 registry.addInterceptor() 方法将拦截器注册到容器中后，我们便可以继续指定拦截器的拦截规则了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">registry.addInterceptor(<span class="hljs-keyword">new</span> LoginHandlerInterceptor())<br>        .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>        .excludePathPatterns(<span class="hljs-string">&quot;/index.html&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;/user/login&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>在指定拦截器拦截规则时，调用了两个方法，这两个方法的说明如下：</p>
<ul>
<li>addPathPatterns：该方法用于指定拦截路径，例如拦截路径为“/**”，表示拦截所有请求，包括对静态资源的请求。</li>
<li>excludePathPatterns：该方法用于排除拦截路径，即指定不需要被拦截器拦截的请求。</li>
</ul>
<h3 id="SpringBoot-JDBC访问数据库"><a href="#SpringBoot-JDBC访问数据库" class="headerlink" title="SpringBoot JDBC访问数据库"></a>SpringBoot JDBC访问数据库</h3><p>进行<a href="/article/37040.html" title="JDBC配置">JDBC配置</a>:</p>
<ol>
<li>在 pom.xml 中导入 JDBC 场景启动器：spring-boot-starter-data-jdbc</li>
<li>JDBC 的场景启动器中并没有导入数据库驱动，我们需要根据自身的需求引入所需的数据库驱动。</li>
<li>在导入了 JDBC 场景启动器和数据库驱动后，接下来我们就可以在配置文件（application.properties/yml）中配置数据源了</li>
</ol>
<h3 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h3><p>MyBatis 是一个半自动化的 ORM 框架，所谓半自动化是指 MyBatis 只支持将数据库查出的数据映射到 POJO 实体类上，而实体到数据库的映射则需要我们自己编写 SQL 语句实现，相较于Hibernate 这种完全自动化的框架，Mybatis 更加灵活，我们可以根据自身的需求编写 sql 语句来实现复杂的数据库操作。</p>
<p>进行<a href="/article/37040.html" title="MyBatis配置">MyBatis配置</a>:</p>
<ol>
<li>在项目的 pom.xml 中引入 mybatis-spring-boot-starter 的依赖</li>
<li>在 SpringBoot 的配置文件（application.properties/yml）中对 MyBatis 进行配置，例如指定 mapper.xml 的位置、实体类的位置、是否开启驼峰命名法等等</li>
</ol>
<h3 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h3><p>SpringSecurity 是 Spring 家族中的一个安全管理框架，实际上，在 SpringBoot 出现之前，SpringSecurity 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。</p>
<p><strong>Apache Shiro</strong><br>一个功能强大且易于使用的Java安全框架，提供了认证、授权、加密、会话管理。<br><strong>Spring Security</strong><br>Spring家族的一员，是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring的IOC（控制反转）、DI（依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，为了减少企业系统安全控制编写大量重复代码的工作。</p>
<a href="/article/37040.html" title="SpringSecurity配置">SpringSecurity配置</a>
<p><strong>通过SpringSecurity 对不同用户角色进行授权</strong></p>
<img src="/article/43108/image-20220220111203172.png" class title="image-20220220111203172">
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<br><span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<br><span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<br><br><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br>  <span class="hljs-comment">//链式编程</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//首页所有人可以访问 ,功能也只有对应有权限的人才能反应</span><br><br>    <span class="hljs-comment">//请求授权的规则</span><br>    http.authorizeRequests().antMatchers(<span class="hljs-string">&quot;/&quot;</span>).permitAll()<br>      .antMatchers(<span class="hljs-string">&quot;/level1/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip1&quot;</span>)<br>      .antMatchers(<span class="hljs-string">&quot;/level2/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip2&quot;</span>)<br>      .antMatchers(<span class="hljs-string">&quot;/level3/**&quot;</span>).hasRole(<span class="hljs-string">&quot;vip3&quot;</span>);<br><br>    <span class="hljs-comment">//没有权限默认到登录页面   需要开启登录的页面</span><br>    http.formLogin().loginPage(<span class="hljs-string">&quot;/toLogin&quot;</span>);<br><br>    <span class="hljs-comment">//防止网站攻击  get post</span><br>    <span class="hljs-comment">//http.csrf().disable();  //关闭请求跨站攻击</span><br><br>    <span class="hljs-comment">//注销 注销完成跳转到首页</span><br>    http.logout().logoutSuccessUrl(<span class="hljs-string">&quot;/&quot;</span>);<br><br>    <span class="hljs-comment">//开启记住我功能  cookie 自定义接收前端的参数</span><br>    http.rememberMe().rememberMeParameter(<span class="hljs-string">&quot;remember&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">//认证</span><br>  <span class="hljs-comment">//密码编码：passwordEncoder</span><br>  <span class="hljs-comment">//springSecurity 5.0+ 新增了很多加密方法</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    auth.inMemoryAuthentication().passwordEncoder(<span class="hljs-keyword">new</span> BCryptPasswordEncoder())<br>      .withUser(<span class="hljs-string">&quot;bobo&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>)).roles(<span class="hljs-string">&quot;vip2&quot;</span>,<span class="hljs-string">&quot;vip3&quot;</span>)<br>      .and()<br>      .withUser(<span class="hljs-string">&quot;root&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>)).roles(<span class="hljs-string">&quot;vip1&quot;</span>,<span class="hljs-string">&quot;vip2&quot;</span>,<span class="hljs-string">&quot;vip3&quot;</span>)<br>      .and()<br>      .withUser(<span class="hljs-string">&quot;guest&quot;</span>).password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">&quot;123456&quot;</span>)).roles(<span class="hljs-string">&quot;vip1&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h3><p><a href="https://shiro.apache.org/tutorial.html">官方文档</a></p>
<p>Apache Shiro 是一个强大灵活的开源安全框架，可以完全处理身份验证、授权、加密和会话管理。</p>
<p>Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成：认证、授权、加密、会话管理、与 Web 集成、缓存等。</p>
<img src="/article/43108/1.png" class title="img">
<ul>
<li><strong>Authentication</strong>：身份认证 / 登录，验证用户是不是拥有相应的身份；</li>
<li><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li>
<li><strong>Session</strong> <strong>Management</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；</li>
<li><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li>
<li><strong>Web Support</strong>：Web 支持，可以非常容易的集成到 Web 环境；</li>
<li><strong>Caching</strong>：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；</li>
<li><strong>Concurrency</strong>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li><strong>Testing</strong>：提供测试支持；</li>
<li><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
<li></li>
</ul>
<p><strong>从外部</strong></p>
<img src="/article/43108/2.png" class title="img">
<p>应用代码直接交互的对象是 Subject，也就是说 Shiro 的对外 API 核心就是 Subject</p>
<ul>
<li><p><strong>Subject</strong>：主体，代表了当前 “用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p>
</li>
<li><p><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</p>
</li>
<li><p><strong>Realm</strong>：域，Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p>
</li>
</ul>
<p>也就是说对于我们而言，最简单的一个 <code>Shiro</code> 应用：</p>
<ol>
<li>应用代码通过 <code>Subject</code> 来进行认证和授权，而 <code>Subject</code> 又委托给 <code>SecurityManager</code>；</li>
<li>我们需要给 <code>Shiro</code> 的 <code>SecurityManager</code> 注入 <code>Realm</code>，从而让 <code>SecurityManager</code> 能得到合法的用户及其权限进行判断。</li>
</ol>
<p><strong>从以上也可以看出，Shiro 不提供维护用户 / 权限，而是通过 Realm 让开发人员自己注入。</strong></p>
<p><strong>从内部</strong></p>
<img src="/article/43108/3.png" class title="img">
<ul>
<li><strong>Subject</strong>：主体，可以看到主体可以是任何可以与应用交互的 “用户”；</li>
<li><strong>SecurityManager</strong>：相当于 SpringMVC 中的 DispatcherServlet 或者 Struts2 中的 FilterDispatcher；是 Shiro 的心脏；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject、且负责进行认证和授权、及会话、缓存的管理。</li>
<li><strong>Authenticator</strong>：认证器，负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</li>
<li><strong>Authorizer</strong>：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</li>
<li><strong>Realm</strong>：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是 JDBC 实现，也可以是 LDAP 实现，或者内存实现等等；由用户提供；注意：Shiro 不知道你的用户 / 权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的 Realm；</li>
<li><strong>SessionManager</strong>：如果写过 Servlet 就应该知道 Session 的概念，Session 呢需要有人去管理它的生命周期，这个组件就是 SessionManager；而 Shiro 并不仅仅可以用在 Web 环境，也可以用在如普通的 JavaSE 环境、EJB 等环境；所以呢，Shiro 就抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</li>
<li><strong>SessionDAO</strong>：DAO 大家都用过，数据访问对象，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如 JDBC 写到数据库；比如想把 Session 放到 Memcached 中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能；</li>
<li><strong>CacheManager</strong>：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能</li>
<li><strong>Cryptography</strong>：密码模块，Shiro 提供了一些常见的加密组件用于如密码加密 / 解密的。</li>
</ul>
<h4 id="Shiro快速开始"><a href="#Shiro快速开始" class="headerlink" title="Shiro快速开始"></a>Shiro快速开始</h4><a href="/article/37040.html" title="Shiro配置">Shiro配置</a>
<p><strong>导入shiro依赖包</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Shiro uses SLF4J for logging.  We&#x27;ll use the &#x27;simple&#x27; binding</span><br><span class="hljs-comment">             in this example app.  See http://www.slf4j.org for more info. --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong><code>shiro.ini</code></strong></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[users]</span><br><span class="hljs-attr">root</span> = secret, admin<br><span class="hljs-attr">guest</span> = guest, guest<br><span class="hljs-attr">presidentskroob</span> = <span class="hljs-number">12345</span>, president<br><span class="hljs-attr">darkhelmet</span> = ludicrousspeed, darklord, schwartz<br><span class="hljs-attr">lonestarr</span> = vespa, goodguy, schwartz<br><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-comment"># Roles with assigned permissions</span><br><span class="hljs-comment"># roleName = perm1, perm2, ..., permN</span><br><span class="hljs-comment"># -----------------------------------------------------------------------------</span><br><span class="hljs-section">[roles]</span><br><span class="hljs-attr">admin</span> = *<br><span class="hljs-attr">schwartz</span> = lightsaber:*<br><span class="hljs-attr">goodguy</span> = winnebago:drive:eagle5<br></code></pre></td></tr></table></figure>
<p><code>Quickstart</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.shiro.SecurityUtils;<br><span class="hljs-keyword">import</span> org.apache.shiro.authc.*;<br><span class="hljs-keyword">import</span> org.apache.shiro.ini.IniSecurityManagerFactory;<br><span class="hljs-keyword">import</span> org.apache.shiro.mgt.SecurityManager;<br><span class="hljs-keyword">import</span> org.apache.shiro.session.Session;<br><span class="hljs-keyword">import</span> org.apache.shiro.subject.Subject;<br><span class="hljs-keyword">import</span> org.apache.shiro.lang.util.Factory;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Simple Quickstart application showing how to use Shiro&#x27;s API.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 0.9 RC2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quickstart</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> Logger log = LoggerFactory.getLogger(Quickstart.class);<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <br>    <br>    Factory&lt;SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">&quot;classpath:shiro.ini&quot;</span>);<br>    SecurityManager securityManager = factory.getInstance();<br>    SecurityUtils.setSecurityManager(securityManager);<br><br>    <span class="hljs-comment">// get the currently executing user:</span><br>    <span class="hljs-comment">//获取当前的用户对象：Subject</span><br>    Subject currentUser = SecurityUtils.getSubject();<br><br>    <span class="hljs-comment">//通过当前对象拿到Session</span><br>    Session session = currentUser.getSession();<br>    <br>    session.setAttribute(<span class="hljs-string">&quot;someKey&quot;</span>, <span class="hljs-string">&quot;aValue&quot;</span>);<br>    String value = (String) session.getAttribute(<span class="hljs-string">&quot;someKey&quot;</span>);<br>    <span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;aValue&quot;</span>)) &#123;<br>      log.info(<span class="hljs-string">&quot;Retrieved the correct value! [&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 测试当前用户是否被认证</span><br>    <span class="hljs-keyword">if</span> (!currentUser.isAuthenticated()) &#123;<br>      <br>      <span class="hljs-comment">//Token 令牌</span><br>      UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">&quot;lonestarr&quot;</span>, <span class="hljs-string">&quot;vespa&quot;</span>);<br>      <span class="hljs-comment">//设置记住我</span><br>      token.setRememberMe(<span class="hljs-keyword">true</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//执行登陆操作</span><br>        currentUser.login(token);<br>      &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException uae) &#123;<br>        log.info(<span class="hljs-string">&quot;There is no user with username of &quot;</span> + token.getPrincipal());<br>      &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice) &#123;<br>        log.info(<span class="hljs-string">&quot;Password for account &quot;</span> + token.getPrincipal() + <span class="hljs-string">&quot; was incorrect!&quot;</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (LockedAccountException lae) &#123;<br>        log.info(<span class="hljs-string">&quot;The account for username &quot;</span> + token.getPrincipal() + <span class="hljs-string">&quot; is locked.  &quot;</span> +<br>                 <span class="hljs-string">&quot;Please contact your administrator to unlock it.&quot;</span>);<br>      &#125;<br>      <span class="hljs-comment">// ... catch more exceptions here (maybe custom ones specific to your application?</span><br>      <span class="hljs-keyword">catch</span> (AuthenticationException ae) &#123;<br>        <span class="hljs-comment">//认证异常</span><br>        <span class="hljs-comment">//unexpected condition?  error?</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//say who they are:</span><br>    <span class="hljs-comment">//print their identifying principal (in this case, a username):</span><br>    log.info(<span class="hljs-string">&quot;User [&quot;</span> + currentUser.getPrincipal() + <span class="hljs-string">&quot;] logged in successfully.&quot;</span>);<br><br>    <span class="hljs-comment">//test a role:</span><br>    <span class="hljs-keyword">if</span> (currentUser.hasRole(<span class="hljs-string">&quot;schwartz&quot;</span>)) &#123;<br>      log.info(<span class="hljs-string">&quot;May the Schwartz be with you!&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      log.info(<span class="hljs-string">&quot;Hello, mere mortal.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//粗粒度</span><br>    <span class="hljs-comment">//test a typed permission (not instance-level)</span><br>    <span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">&quot;lightsaber:wield&quot;</span>)) &#123;<br>      log.info(<span class="hljs-string">&quot;You may use a lightsaber ring.  Use it wisely.&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      log.info(<span class="hljs-string">&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//细粒度</span><br>    <span class="hljs-comment">//a (very powerful) Instance Level permission:</span><br>    <span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">&quot;winnebago:drive:eagle5&quot;</span>)) &#123;<br>      log.info(<span class="hljs-string">&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot;</span> +<br>               <span class="hljs-string">&quot;Here are the keys - have fun!&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      log.info(<span class="hljs-string">&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//all done - log out!</span><br>    currentUser.logout();<br><br>    System.exit(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="SpringBoot整合shiro"><a href="#SpringBoot整合shiro" class="headerlink" title="SpringBoot整合shiro"></a>SpringBoot整合shiro</h4><p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- spring整合shiro的包 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--web--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--thymeleaf--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>Shiro 配置类 config</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.config; <br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration; <br><span class="hljs-comment">//声明为配置类 </span><br><span class="hljs-meta">@Configuration</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShiroConfig</span> </span>&#123; <br>  <br>  <span class="hljs-comment">//创建 ShiroFilterFactoryBean </span><br>  <span class="hljs-meta">@Bean</span> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> ShiroFilterFactoryBean <span class="hljs-title">getShiroFilterFactoryBean</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;securityManager&quot;)</span>DefaultWebSecurityMan ager securityManager)</span></span>&#123; <br>    ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="hljs-keyword">new</span> ShiroFilterFactoryBean(); <br>    <span class="hljs-comment">//设置安全管理器 </span><br>    shiroFilterFactoryBean.setSecurityManager(securityManager); 、<br>    <span class="hljs-comment">/* 添加Shiro内置过滤器，常用的有如下过滤器： </span><br><span class="hljs-comment">      anon： 无需认证就可以访问 </span><br><span class="hljs-comment">      authc： 必须认证才可以访问 </span><br><span class="hljs-comment">      user： 如果使用了记住我功能就可以直接访问 </span><br><span class="hljs-comment">      perms: 拥有某个资源权限才可以访问 </span><br><span class="hljs-comment">      role： 拥有某个角色权限才可以访问 </span><br><span class="hljs-comment">    */</span><br>    Map&lt;String,String&gt; filterMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, String&gt;();<br>    <span class="hljs-comment">//&quot;跳转目标&quot;,&quot;权限&quot;</span><br>    filterMap.put(<span class="hljs-string">&quot;/user/add&quot;</span>,<span class="hljs-string">&quot;authc&quot;</span>); <br>    shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap);<br>    <span class="hljs-keyword">return</span> shiroFilterFactoryBean; <br>  &#125;<br>  <br>  <span class="hljs-comment">//创建 DefaultWebSecurityManager </span><br>  <span class="hljs-meta">@Bean(name = &quot;securityManager&quot;)</span> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultWebSecurityManager <span class="hljs-title">getDefaultWebSecurityManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;userRealm&quot;)</span>UserRealm userRealm)</span></span>&#123; <br>    DefaultWebSecurityManager securityManager = <span class="hljs-keyword">new</span> DefaultWebSecurityManager(); <br>    <span class="hljs-comment">//关联Realm </span><br>    securityManager.setRealm(userRealm); <br>    <span class="hljs-keyword">return</span> securityManager; <br>  &#125;<br>  <br>  <span class="hljs-comment">//创建 realm 对象 </span><br>  <span class="hljs-meta">@Bean</span> <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> UserRealm <span class="hljs-title">userRealm</span><span class="hljs-params">()</span></span>&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserRealm(); <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>realm</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.config; <br><span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationException; <br><span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationInfo; <br><span class="hljs-keyword">import</span> org.apache.shiro.authc.AuthenticationToken; <br><span class="hljs-keyword">import</span> org.apache.shiro.authz.AuthorizationInfo; <br><span class="hljs-keyword">import</span> org.apache.shiro.realm.AuthorizingRealm; <br><span class="hljs-keyword">import</span> org.apache.shiro.subject.PrincipalCollection; <br><span class="hljs-comment">//自定义Realm </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123; <br>  <span class="hljs-comment">//执行授权逻辑 </span><br>  <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123; <br>    System.out.println(<span class="hljs-string">&quot;执行了=&gt;授权逻辑PrincipalCollection&quot;</span>); <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <br>  &#125;<br>  <span class="hljs-comment">//执行认证逻辑 </span><br>  <span class="hljs-meta">@Override</span> <br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123; <br>    System.out.println(<span class="hljs-string">&quot;执行了=&gt;认证逻辑AuthenticationToken&quot;</span>); <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h3><p><a href="https://swagger.io">Swagger官方网站</a></p>
<p>Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>
<p>Swagger 的目标是对 REST API 定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。当通过 Swagger 进行正确定义，用户可以理解远程服务并使用最少实现逻辑与远程服务进行交互。与为底层编程所实现的接口类似，Swagger 消除了调用服务时可能会有的猜测。</p>
<p><strong>优势</strong></p>
<ul>
<li>支持 API 自动生成同步的在线文档：使用 Swagger 后可以直接通过代码生成文档，不再需要自己手动编写接口文档了，对程序员来说非常方便，可以节约写文档的时间去学习新技术。</li>
<li>提供 Web 页面在线测试 API：光有文档还不够，Swagger 生成的文档还支持在线测试。参数和格式都定好了，直接在界面上输入参数对应的值即可在线测试接口。</li>
</ul>
<h4 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a><strong>SpringBoot集成Swagger</strong></h4><a href="/article/37040.html" title="Swagger配置">Swagger配置</a>
<p><strong>springboot版本使用2.5.6 swagger版本使用3.0.0</strong></p>
<h4 id="Swagger-UI配置"><a href="#Swagger-UI配置" class="headerlink" title="Swagger-UI配置"></a>Swagger-UI配置</h4><p>访问测试 ：<a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a> ，可以看到swagger的界面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.swagger.config;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> springfox.documentation.oas.annotations.EnableOpenApi;<br><span class="hljs-keyword">import</span> springfox.documentation.service.ApiInfo;<br><span class="hljs-keyword">import</span> springfox.documentation.service.Contact;<br><span class="hljs-keyword">import</span> springfox.documentation.spi.DocumentationType;<br><span class="hljs-keyword">import</span> springfox.documentation.spring.web.plugins.Docket;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> * EnableOpenApi 开启Swagger2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableOpenApi</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  配置Swagger 的 Docket的 Bean实例</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)<br>      .apiInfo(apiInfo());<br>  &#125;<br><br>  <span class="hljs-comment">//    //配置Swagger信息 apiInfo</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span></span>&#123;<br>    Contact contact = <span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;Bobo&quot;</span>, <span class="hljs-string">&quot;https://boyolo.github.io&quot;</span>, <span class="hljs-string">&quot;beau_renbo@163.com&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfo(<br>      <span class="hljs-string">&quot;BoBo Api Documentation&quot;</span>,<br>      <span class="hljs-string">&quot;Boyolo Api Documentation&quot;</span>,<br>      <span class="hljs-string">&quot;1.0&quot;</span>,<br>      <span class="hljs-string">&quot;https://boyolo.github.io&quot;</span>,<br>      contact,<br>      <span class="hljs-string">&quot;Apache 2.0&quot;</span>,<br>      <span class="hljs-string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,<br>      <span class="hljs-keyword">new</span> ArrayList());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/43108/image-20220221145938830.png" class title="image-20220221145938830">
<h4 id="swagger配置扫描接口以及开关"><a href="#swagger配置扫描接口以及开关" class="headerlink" title="swagger配置扫描接口以及开关"></a>swagger配置扫描接口以及开关</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  配置Swagger 的 Docket的 Bean实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)<br>    .apiInfo(apiInfo())<br>    <span class="hljs-comment">//是否启动swagger ，如果为false，则swagger不能再浏览器中访问</span><br>    .enable(<span class="hljs-keyword">false</span>)<br>    .select()<br>    <span class="hljs-comment">//RequestHandlerSelectors 配置要扫描接口的方式</span><br>    <span class="hljs-comment">//basePackage 指定要扫描的包  RequestHandlerSelectors.basePackage(&quot;com.bobo.swagger.controller&quot;)</span><br>    <span class="hljs-comment">//RequestHandlerSelectors.any()  扫描全部</span><br>    <span class="hljs-comment">//RequestHandlerSelectors.none() 都不扫描</span><br>    <span class="hljs-comment">//RequestHandlerSelectors.withClassAnnotation() 扫描类上的注解   参数是一个注解的反射对象</span><br>    <span class="hljs-comment">//RequestHandlerSelectors.withMethodAnnotation()  扫描方法上的注解</span><br>    .apis(RequestHandlerSelectors.withMethodAnnotation(GetMapping.class))<br>    <span class="hljs-comment">//过滤什么路径</span><br>    .paths(PathSelectors.ant(<span class="hljs-string">&quot;bobo/**&quot;</span>))<br>    .build();<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>.select() 与 .build() 属于一套</p>
<p>中间除了.apis() 与 .paths() 不能再添加其他方法</p>
</blockquote>
<p><strong>思考</strong></p>
<p>如何做使Swagger在生产环境中使用，在发布的时候不使用？</p>
<ul>
<li>判断是不是生产环境   flag == false</li>
<li>注入enable(flag)</li>
</ul>
<p><strong>配置swagger API文档的分组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docketA</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;A&quot;</span>);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docketB</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="hljs-string">&quot;B&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/43108/image-20220221153135200.png" class title="image-20220221153135200">
<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>分布式系统（<em>distributed system</em>）是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。</p>
<h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>RPC是远程过程调用（Remote Procedure Call）的缩写形式，是一种进程间的通信方式，是一种技术思想，而不是规范。SAP系统RPC调用的原理其实很简单，有一些类似于三层构架的C/S系统，第三方的客户程序通过接口调用SAP内部的标准或自定义函数，获得函数返回的数据进行处理后显示或打印。</p>
<p><strong>基本流程</strong></p>
<img src="/article/43108/86E55D7D3EBC4093ABAFF624FF75F523.png" class title="六、RPC基本原理_RPC基本原理">
<p>RPC两个核心模块：序列化、通讯</p>
<h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><p><a href="https://dubbo.apache.org/zh/docs/">官方文档</a></p>
<p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架。</p>
<img src="/article/43108/20151223153918914.jpeg" class title="dubbo架构图">
<p>Provider: 暴露服务的服务提供方。；<br>Consumer: 调用远程服务的服务消费方；<br>Registry: 服务注册与发现的注册中心；<br>Monitor: 统计服务的调用次调和调用时间的监控中心；<br>Container: 服务运行容器。</p>
<h4 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h4><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<p><a href="https://zookeeper.apache.org/releases.html">下载地址</a></p>
<p>3.5版本以后要下载后缀为<strong>bin.tar.gz</strong>的文件</p>
<p>更改默认配置文件名称 将conf目录下 <strong>zoo_sample.cfg</strong> 改为 zoo.cfg</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">&gt; /apache-zookeeper<span class="hljs-number">-3.6</span><span class="hljs-number">.3</span>-bin/bin/zkServer.sh start<br> .jenv/shims/java<br> ZooKeeper JMX enabled <span class="hljs-keyword">by</span> <span class="hljs-literal">default</span><br> apache-zookeeper<span class="hljs-number">-3.6</span><span class="hljs-number">.3</span>- bin/bin/../conf/zoo.cfg<br> Starting zookeeper ... STARTED<br></code></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">&gt; ./zkServer.sh stop <br> ZooKeeper JMX enabled <span class="hljs-keyword">by</span> <span class="hljs-literal">default</span><br> Using config: zookeeper<span class="hljs-number">-3.4</span><span class="hljs-number">.10</span>/bin/../conf/zoo.cfg<br> Stopping zookeeper ... STOPPED<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBootWeb开发</category>
        <category>SpringBootWeb开发</category>
      </categories>
      <tags>
        <tag>SpringBootWeb开发</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot（基础配置及原理）</title>
    <url>/article/33757.html</url>
    <content><![CDATA[<blockquote>
<p>The scabbard is content to be dull when it protects the keenness of the sword.</p>
<p>刀鞘保护刀的锋利，它自己则满足于它的迟钝。</p>
</blockquote>
<h2 id="SpringBoot（基础配置及原理）"><a href="#SpringBoot（基础配置及原理）" class="headerlink" title="SpringBoot（基础配置及原理）"></a>SpringBoot（基础配置及原理）</h2><p>什么是<a href="/article/18155.html" title="Spring">Spring</a>?</p>
<h3 id="什么是SpringBoot？"><a href="#什么是SpringBoot？" class="headerlink" title="什么是SpringBoot？"></a>什么是SpringBoot？</h3><p><a href="https://spring.io/projects/spring-boot">SpringBoot官方网站</a></p>
<p>SpringBoot 是 Pivotal 团队在 Spring 的基础上提供的一套全新的开源框架，其目的是为了简化 Spring 应用的搭建和开发过程。SpringBoot 去除了大量的 XML 配置文件，简化了复杂的依赖管理。</p>
<p>SpringBoot 具有 Spring 一切优秀特性，Spring 能做的事，SpringBoot 都可以做，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。随着近些年来微服务技术的流行，Spring Boot 也成了时下炙手可热的技术。</p>
<p>SpringBoot 集成了大量常用的第三方库配置，SpringBoot 应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 SpringBoot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。 </p>
<p><strong>特点</strong></p>
<p>Spring Boot 具有以下特点：</p>
<ol>
<li><p>独立运行的 Spring 项目</p>
<p>SpringBoot 可以以 jar 包的形式独立运行，SpringBoot 项目只需通过命令“ java–jar xx.jar” 即可运行。</p>
</li>
<li><p>内嵌 Servlet 容器</p>
<p>SpringBoot 使用嵌入式的 Servlet 容器（例如 Tomcat、Jetty 或者 Undertw 等），应用无需打成 WAR 包 。</p>
</li>
<li><p>提供 starter 简化 Maven 配置</p>
<p>Spring Boot 提供了一系列的“starter”项目对象模型（POMS）来简化 Maven 配置。</p>
</li>
<li><p>提供了大量的自动配置</p>
<p>SpringBoot 提供了大量的默认自动配置，来简化项目的开发，开发人员也通过配置文件修改默认配置。</p>
</li>
<li><p>自带应用监控</p>
<p>Spring Boot 可以对正在运行的项目提供监控。</p>
</li>
<li><p>无代码生成和 xml 配置</p>
<p>SpringBoot 不需要任何 xml 配置即可实现 Spring 的所有配置。</p>
</li>
</ol>
<p><strong>配置</strong></p>
<p><strong>maven中导入配置：</strong>spring-boot-starter-web、spring-boot-starter-test</p>
<a href="/article/37040.html" title="点击跳转SpringBoot配置">点击跳转SpringBoot配置</a>
<p>spring-boot-starter-web用于实现HTTP接口（该依赖中包含了SpringMVC）</p>
<p>spring-boot-starter-test用于编写单元测试的依赖包</p>
<h3 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h3><p>一种软件开发技术-面向服务的体系结构（SOA）架构样式的一种变体，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。</p>
<p>每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。</p>
<p>每个服务都围绕着具体业务进行构建，并且能够独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据上下文，选择合适的语言、工具对其进行构建。</p>
<h3 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h3><h4 id="SpringFactories-机制"><a href="#SpringFactories-机制" class="headerlink" title="SpringFactories 机制"></a>SpringFactories 机制</h4><p>SpringBoot 的自动配置是基于 SpringFactories 机制实现的。</p>
<p>SpringFactories 机制是 SpringBoot 中的一种服务发现机制，这种扩展机制与 Java SPI 机制十分相似。SpringBoot 会自动扫描所有 Jar 包类路径下 <code>META-INF/spring.factories</code> 文件，并读取其中的内容，进行实例化，这种机制也是 Spring-Boot-Starter 的基础。</p>
<p><strong>自动配置的生效和修改</strong></p>
<p>spring.factories 文件中的所有自动配置类（xxxAutoConfiguration），都是必须在一定的条件下才会作为组件添加到容器中，配置的内容才会生效。这些限制条件在 SpringBoot 中以 @Conditional 派生注解的形式体现。</p>
<a href="/article/37040.html" title="点击跳转SpringBoot自动配置注解">点击跳转SpringBoot自动配置注解</a>
<p><strong>spring.factories</strong></p>
<p>spring.factories 文件本质上与 properties 文件相似，其中包含一组或多组键值对（key=vlaue），其中，key 的取值为接口的完全限定名；value 的取值为接口实现类的完全限定名，一个接口可以设置多个实现类，不同实现类之间使用“，”隔开。</p>
<img src="/article/33757/image-20220210171223244.png" class title="image-20220210171223244">
<p><strong>SpringFactories 实现原理</strong></p>
<p>spring-core 包里定义了 SpringFactoriesLoader 类，这个类会扫描所有 Jar 包类路径下的 META-INF/spring.factories 文件，并获取指定接口的配置。在 SpringFactoriesLoader 类中定义了两个对外的方法，如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">返回值</th>
<th>方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><T>List<T></T></T></td>
<td>loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader)</T></td>
<td style="text-align:left">静态方法； <br>根据接口获取其实现类的实例； 该方法返回的是实现类对象列表。</td>
</tr>
<tr>
<td style="text-align:center">List<String></String></td>
<td>loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</td>
<td style="text-align:left">公共静态方法； <br>根据接口l获取其实现类的名称； 该方法返回的是实现类的类名的列表</td>
</tr>
</tbody>
</table>
<h4 id="SpringBoot自动装配流程"><a href="#SpringBoot自动装配流程" class="headerlink" title="SpringBoot自动装配流程"></a>SpringBoot自动装配流程</h4><ol>
<li><p><strong>spring-boot-dependencies</strong>:核心依赖在父工程中</p>
</li>
<li><p><strong>启动器</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SpringBoot 的启动场景--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>SpringBoot会将所有的功能场景，都变成一个个的启动器。</p>
<p>要使用什么功能只要找到对应的启动器即可。</p>
<p>如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--要使用什么功能，就启动对应的启动器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>主程序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot01HelloworldApplication</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Springboot01HelloworldApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>@SpringBootApplication</code>注解</p>
<p>标注这个类是一个springboot应用  启动类下的所有资源被导入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><p><strong>@SpringBootConfiguration</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">//Spring配置类，说明这也是一个组件</span><br><span class="hljs-meta">@Indexed</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>@EnableAutoConfiguration</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span>  <span class="hljs-comment">//自动配置包</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>@EnableAutoConfiguration</strong></p>
<ol>
<li><p><strong>@AutoConfigurationPackage</strong>：扫描并注册我们自己写的java类到spring容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>向容器中导入了一个AutoConfigurationPackages.Registrar的实例对象</p>
<blockquote>
<p><strong>AutoConfigurationPackages.Registrar</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">DeterminableImports</span> </span>&#123;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>			register(registry, <span class="hljs-keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br>		&#125;<br>		...<br>	&#125;<br></code></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">register(registry, <span class="hljs-keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br></code></pre></td></tr></table></figure>
<p>其实就是完成了我们自己写的类的扫描。</p>
<p>获取到的是指定扫描包的路径，如果未明确指定，默认为主启动类所在的包名。</p>
</blockquote>
</li>
<li><p><strong>@Import(AutoConfigurationImportSelector.class)</strong>：注册springboot提供的自动配置类到spring容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DeferredImportSelector</span>, <span class="hljs-title">BeanClassLoaderAware</span>,</span><br><span class="hljs-class">      <span class="hljs-title">ResourceLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">EnvironmentAware</span>, <span class="hljs-title">Ordered</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>将springboot提供好的自动配置装载进spring容器</p>
<blockquote>
<p><strong>AutoConfigurationImportSelector</strong></p>
<p>将springboot提供好的自动配置装载进spring容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法是获取所有的自动配置类的实体</p>
<p>spring-boot在启动时，默认就装载了springboot写好的127个自动配置类实体(spring.factories)，但是并没有启用，只有在引入相关依赖包的时候，这些自动配置才真正被启用，这种按需加载的原理是基于条件注解实现的</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>SpringApplication.run(Springboot01HelloworldApplication.class, args); </p>
<img src="/article/33757/%E4%B8%BB%E5%90%AF%E5%8A%A8%E7%B1%BB.png" class title="主启动类">
<p><a href="https://blog.csdn.net/qq_42261668/article/details/103029333">原理剖析</a></p>
<ol>
<li><p>run方法</p>
<p>大多数应用程序上下文(如果不是全部的话)将实现SPI（服务提供者）接口。</p>
<p>这里<strong>封装了配置和生命周期方法</strong>，以避免它们被ApplicationContext客户端代码发现（避免配置文件被公开给使用者）。目前的方法只能在启动和关闭代码中使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;···&#125;<br>---------------------------------------------------------<br><span class="hljs-comment">//可配置的应用上下文</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource,String... args)</span> </span>&#123;<br>    <span class="hljs-comment">//重载传入 将要被加载的类放到一个对应的CLASS数组中</span><br>    <span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);<br>  &#125;<br>  ---------------------------------------------------------<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources,String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//创建一个启动类传入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(primarySources).run(args);<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>run()方法启动Spring应用，实质上是为Spring应用创建并初始化Spring上下文</p>
<blockquote>
<ol>
<li>推断应用的类型是普通的项目还是Web项目</li>
<li>查找并加载所有可用初始化器，设置到initializers属性中</li>
<li>找出所有的应用程序监听器，设置到listeners属性中</li>
<li>推断并设置main方法的定义类，找到运行的主类</li>
</ol>
</blockquote>
<p>在启动时会加载三个jar将其对应的spring.factories工厂文件的接口实现类到MultiValueMap集合当中，并将对应加载器作为key,接口实现类作为value放到缓存当中</p>
<ul>
<li>spring-boot-2.1.3.RELEASE.jar!/META-INF/spring.factories</li>
<li>spring-boot-autocinfiggure-2.1.3.RELEASE.jar!/META-INF/spring.factories</li>
<li>spring-bean-5.1.5.RELEASE.jar!/META-INF/spring.factories</li>
</ul>
<blockquote>
<p><strong>执行流程：</strong></p>
<ol>
<li><p>初始化监听器，以及添加到SpringApplication的自定义监听器;</p>
</li>
<li><p>发布ApplicationStartedEvent事件;</p>
</li>
<li><p>装配参数和环境，确定是web环境还是非web环境;</p>
</li>
<li><p>装配完环境后，就触发ApplicationEnvironmentPreparedEvent事件;</p>
</li>
<li><p>如果SpringApplication的showBanner属性被设置为true，则打印启动的Banner;</p>
</li>
<li><p>创建ApplicationContext，会根据是否是web环境，来决定创建什么类型的ApplicationContext;</p>
</li>
<li><p>装配Context的环境变量，注册Initializers、beanNameGenerator等;</p>
</li>
<li><p>发布ApplicationPreparedEvent事件;</p>
</li>
<li><p>注册springApplicationArguments、springBootBanner，加载资源等;</p>
</li>
<li><p>遍历调用所有SpringApplicationRunListener的contextLoaded()方法;</p>
</li>
<li><p>调用ApplicationContext的refresh()方法,装配context beanfactory等非常重要的核心组件;</p>
</li>
<li><p>查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们;</p>
</li>
<li><p>发布ApplicationReadyEvent事件，启动完毕，表示服务已经可以开始正常提供服务了。通常我们这里会监听这个事件来打印一些监控性质的日志，表示应用正常启动了。</p>
</li>
</ol>
<p>SpringBoot会触发其他的一些事件，这些事件按下列顺序触发：</p>
<p>（1）ApplicationStartingEvent：项目刚启动时触发，此时除了注册监听器和初始器之外，其他所有处理都没有开始；</p>
<p>（2）ApplicationEnvironmentPreparedEvent：上下文得到环境信息之后触发，此时上下文创建还没有创建；</p>
<p>（3）ApplicationPreparedEvent：bean的定义信息加载完成之后触发，此时bean还没有初始化；</p>
<p>（4）ApplicationReadyEvent：在所有bean初始化完毕，所有回调处理完成，系统准备处理服务请求时触发；</p>
<p>（5）ApplicationFailedEvent：启动过程出现异常时候触发。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<pre><code>2. **SpringApplication构造器**

   <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, primarySources);<br>&#125;<br></code></pre></td></tr></table></figure>

   <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;<br>  <span class="hljs-comment">//null</span><br>  <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;<br>  <span class="hljs-comment">//断言  PrimarySources 不能为空</span><br>  Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>  <span class="hljs-comment">//将传过来对象数组放到集合中 并为primarySources 赋值</span><br>  <span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));<br>  <span class="hljs-comment">//推断webApplicationType 的枚举类型 一般都是SERVLET 标准webservice</span><br>  <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>  <span class="hljs-comment">//设置初始化器 读取一些控制器 </span><br>  <span class="hljs-comment">//获取实现了ApplicationContextInitializer初始化器的工厂并将其实例化 读取相应的一些控制器</span><br>  setInitializers((Collection) getSpringFactoriesInstances(<br>    ApplicationContextInitializer.class));<br>  <span class="hljs-comment">//设置监听器 流程同上</span><br>  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br>  <span class="hljs-comment">//存储带有main方法的启动对象（本例MyApplication）</span><br>  <span class="hljs-comment">//deduceMainApplicationClass 获取推断主应用类 获取对应的MyApplication.class</span><br>  <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure>

   [构造方法内容详解](https://blog.csdn.net/qq_42261668/article/details/103029333)
</code></pre><h3 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h3><p>SpringBoot 提供了大量的自动配置，极大地简化了spring 应用的开发过程，当用户创建了一个 SpringBoot 项目后，即使不进行任何配置，该项目也能顺利的运行起来。当然，用户也可以根据自身的需要使用配置文件修改 SpringBoot 的默认设置。</p>
<p>SpringBoot 默认使用以下 2 种全局的配置文件，其文件名是固定的。</p>
<ul>
<li>application.properties</li>
<li>application.yml</li>
</ul>
<p>YAML 全称 YAML Ain’t Markup Language，它是一种以数据为中心的标记语言，比 XML 和 JSON 更适合作为配置文件。</p>
<p>想要使用 YAML 作为属性配置文件（以 .yml 或 .yaml 结尾），需要将 SnakeYAML 库添加到 classpath 下，SpringBoot 中的 spring-boot-starter-web 或 spring-boot-starter 都对 SnakeYAML 库做了集成， 只要项目中引用了这两个 Starter 中的任何一个，SpringBoot 会自动添加 SnakeYAML 库到 classpath 下。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h4><p><strong>YAML 的语法如下：</strong></p>
<ul>
<li>使用缩进表示层级关系。</li>
<li>缩进时不允许使用 Tab 键，只允许使用空格。</li>
<li>缩进的空格数不重要，但同级元素必须左侧对齐。</li>
<li>大小写敏感。</li>
<li>‘#’表示注释</li>
</ul>
<p><strong>YAML 支持以下三种数据结构：</strong></p>
<ul>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li>
<li>字面量：单个的、不可拆分的值</li>
</ul>
<p><strong>YAML 字面量写法</strong></p>
<p>字面量是指单个的，不可拆分的值，例如：数字、字符串、布尔值、以及日期等。</p>
<p>字面量直接写在键值对的“value<strong>”</strong>中即可，且默认情况下字符串是不需要使用单引号或双引号的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">boolean:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-literal">TRUE</span>  <span class="hljs-comment">#true,True都可以</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-literal">FALSE</span>  <span class="hljs-comment">#false，False都可以</span><br><span class="hljs-attr">float:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">3.14</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">6.8523015e+5</span>  <span class="hljs-comment">#可以使用科学计数法</span><br><span class="hljs-attr">int:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">123</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">0b1010_0111_0100_1010_1110</span>    <span class="hljs-comment">#二进制表示</span><br><span class="hljs-attr">null:</span><br>    <span class="hljs-attr">nodeName:</span> <span class="hljs-string">&#x27;node&#x27;</span><br>    <span class="hljs-attr">parent:</span> <span class="hljs-string">~</span>  <span class="hljs-comment">#使用~表示null</span><br><span class="hljs-attr">string:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">哈哈</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;Hello world&#x27;</span>  <span class="hljs-comment">#可以使用双引号或者单引号包裹特殊字符</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">newline</span><br>      <span class="hljs-string">newline2</span>    <span class="hljs-comment">#字符串可以拆成多行，每一行会被转化成一个空格</span><br><span class="hljs-attr">date:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">2018-02-17</span>    <span class="hljs-comment">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="hljs-attr">datetime:</span> <br>    <span class="hljs-bullet">-</span>  <span class="hljs-number">2018-02-17T15:02:31+08:00</span>    <span class="hljs-comment">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br></code></pre></td></tr></table></figure>
<p><strong>YAML 对象写法</strong></p>
<p>在 YAML 中，对象可能包含多个属性，每一个属性都是一对键值对。<br>YAML 为对象提供了 2 种写法：</p>
<p>普通写法，使用缩进表示对象与属性的层级关系。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">key:</span> <br> <span class="hljs-attr">child-key:</span> <span class="hljs-string">value</span><br> <span class="hljs-attr">child-key2:</span> <span class="hljs-string">value2</span><br></code></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">?</span>  <br> <span class="hljs-bullet">-</span> <span class="hljs-string">complexkey1</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">complexkey2</span><br><span class="hljs-string">:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">complexvalue1</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">complexvalue2</span><br><span class="hljs-comment">#对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]</span><br></code></pre></td></tr></table></figure>
<p>行内写法：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">website:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">bianchengbang</span>,<span class="hljs-attr">url:</span> <span class="hljs-string">www.biancheng.net</span>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>YAML 数组写法</strong></p>
<p>YAML 使用“-”表示数组中的元素，普通写法如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">A</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">B</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">C</span><br></code></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">key</span>:<span class="hljs-meta"> [value1, value2, ...]</span><br></code></pre></td></tr></table></figure>
<p><strong>复合结构</strong></p>
<p>以上三种数据结构可以任意组合使用，以实现不同的用户需求</p>
<p><strong>引用</strong></p>
<p><strong>&amp;</strong> 锚点和 <strong>*</strong> 别名，可以用来引用:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">defaults:</span> <span class="hljs-meta">&amp;defaults</span><br>  <span class="hljs-attr">adapter:</span>  <span class="hljs-string">postgres</span><br>  <span class="hljs-attr">host:</span>     <span class="hljs-string">localhost</span><br><br><span class="hljs-attr">development:</span><br>  <span class="hljs-attr">database:</span> <span class="hljs-string">myapp_development</span><br>  <span class="hljs-string">&lt;&lt;:</span> <span class="hljs-meta">*defaults</span><br><br><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">database:</span> <span class="hljs-string">myapp_test</span><br>  <span class="hljs-string">&lt;&lt;:</span> <span class="hljs-meta">*defaults</span><br></code></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">defaults:</span><br>  <span class="hljs-attr">adapter:</span>  <span class="hljs-string">postgres</span><br>  <span class="hljs-attr">host:</span>     <span class="hljs-string">localhost</span><br><br><span class="hljs-attr">development:</span><br>  <span class="hljs-attr">database:</span> <span class="hljs-string">myapp_development</span><br>  <span class="hljs-attr">adapter:</span>  <span class="hljs-string">postgres</span><br>  <span class="hljs-attr">host:</span>     <span class="hljs-string">localhost</span><br><br><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">database:</span> <span class="hljs-string">myapp_test</span><br>  <span class="hljs-attr">adapter:</span>  <span class="hljs-string">postgres</span><br>  <span class="hljs-attr">host:</span>     <span class="hljs-string">localhost</span><br></code></pre></td></tr></table></figure>
<p><strong>&amp;</strong> 用来建立锚点（defaults），<strong>&lt;&lt;</strong> 表示合并到当前数据，<strong>*</strong> 用来引用锚点。</p>
<p><strong>YAML 组织结构</strong></p>
<p>YAML 文件可以由一或多个文档组成（也即相对独立的组织结构组成），文档间使用“—”（三个横线）在每文档开始作为分隔符,且个文档相互独立，互不干扰。同时，文档也可以使用“…”（三个点号）作为结束符（可选）。如果只是单个文档，分隔符“—”可省略。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">---website:</span>  <span class="hljs-attr">name: bianchengbang  url:</span> <span class="hljs-string">www.biancheng.net</span><br><span class="hljs-string">---website:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">bianchengbang</span>,<span class="hljs-attr">url:</span> <span class="hljs-string">www.biancheng.net</span>&#125;<span class="hljs-attr">pets:  -dog  -cat  -pig---pets:</span> [<span class="hljs-string">dog</span>,<span class="hljs-string">cat</span>,<span class="hljs-string">pig</span>]<span class="hljs-attr">name:</span> <span class="hljs-string">&quot;zhangsan \n lisi&quot;</span><span class="hljs-string">---name:</span> <span class="hljs-string">&#x27;zhangsan \n lisi&#x27;</span><br></code></pre></td></tr></table></figure>
<h4 id="给属性赋值"><a href="#给属性赋值" class="headerlink" title="给属性赋值"></a>给属性赋值</h4><p><strong>@ConfigurationProperties</strong>：告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定；</p>
<p>prefix = “ClassName”：配置文件中哪个下面的所有属性进行一一映射</p>
<p>例：</p>
<ol>
<li><p>在全局配置文件 application.yml 中添加以下自定义属性</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">person:</span><br>  <span class="hljs-attr">lastName:</span> <span class="hljs-string">bobo</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">boss:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">birth:</span> <span class="hljs-number">1997</span><span class="hljs-string">/07/09</span><br>  <span class="hljs-attr">maps:</span> &#123; <span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>,<span class="hljs-attr">k2:</span> <span class="hljs-number">12</span> &#125;<br>  <span class="hljs-attr">lists:</span><br>    <span class="hljs-string">‐</span> <span class="hljs-number">111</span><br>    <span class="hljs-string">‐</span> <span class="hljs-number">222</span><br>  <span class="hljs-attr">dog:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">旺财</span><br>    <span class="hljs-attr">age:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>创建一个名为 Person 的实体类，并将配置文件中的属性映射到这个实体类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 将配置文件中配置的每一个属性的值，映射到这个组件中</span><br><span class="hljs-comment">* 只有这个组件是容器中的组件，才能使用容器提供的<span class="hljs-doctag">@ConfigurationProperties</span>功能；</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String lastName;<br>  <span class="hljs-keyword">private</span> Integer age;<br>  <span class="hljs-keyword">private</span> Boolean boss;<br>  <span class="hljs-keyword">private</span> Date birth;<br>  <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; maps;<br>  <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;<br>  <span class="hljs-keyword">private</span> Dog dog;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;lastName=&#x27;&quot;</span> + lastName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>      <span class="hljs-string">&quot;, boss=&quot;</span> + boss +<br>      <span class="hljs-string">&quot;, birth=&quot;</span> + birth +<br>      <span class="hljs-string">&quot;, maps=&quot;</span> + maps +<br>      <span class="hljs-string">&quot;, lists=&quot;</span> + lists +<br>      <span class="hljs-string">&quot;, dog=&quot;</span> + dog +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String age;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>@Value</strong></p>
<p>只需要读取配置文件中的某一个配置时，可以通过 @Value 注解获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> net.biancheng.www.bean;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-meta">@Value(&quot;$&#123;person.lastName&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> String lastName;<br>  <span class="hljs-meta">@Value(&quot;$&#123;person.age&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> Integer age;<br>  <span class="hljs-meta">@Value(&quot;$&#123;person.boss&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> Boolean boss;<br>  <span class="hljs-meta">@Value(&quot;$&#123;person.birth&#125;&quot;)</span><br>  <span class="hljs-keyword">private</span> Date birth;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;lastName=&#x27;&quot;</span> + lastName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>      <span class="hljs-string">&quot;, boss=&quot;</span> + boss +<br>      <span class="hljs-string">&quot;, birth=&quot;</span> + birth +<br>      <span class="hljs-string">&quot;, maps=&quot;</span> + maps +<br>      <span class="hljs-string">&quot;, lists=&quot;</span> + lists +<br>      <span class="hljs-string">&quot;, dog=&quot;</span> + dog +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<a href="/article/37040.html" title="点击跳转SpringBoot注解">点击跳转SpringBoot注解</a>
<h3 id="给属性赋值的两种方法"><a href="#给属性赋值的两种方法" class="headerlink" title="给属性赋值的两种方法"></a>给属性赋值的两种方法</h3><ol>
<li><p>通过yaml文件赋值</p>
<p><a href="#给属性赋值">点击跳转通过yaml文件注解赋值</a></p>
<p>第一种方法通过<strong>@ConfigurationProperties</strong>或<strong>@Value</strong>给属性赋值</p>
</li>
<li><p>通过注解<strong>@PropertySource</strong>给属性赋值</p>
<p>如果将所有的配置都集中到 <code>application.properties</code> 或 <code>application.yml</code>中，那么这个配置文件会十分的臃肿且难以维护，因此我们通常会将与 SpringBoot 无关的配置（例如自定义配置）提取出来，写在一个单独的配置文件中，并在对应的 JavaBean 上使用 @PropertySource 注解指向该配置文件。</p>
<a href="/article/37040.html" title="点击跳转SpringBoot注解">点击跳转SpringBoot注解</a>
<p>例：</p>
<ol>
<li><p><strong>将与 <code>person</code> 相关的自定义配置移动到 <code>src/main/resources</code> 下的 <code>person.properties</code> 中（注意，必须把 application.properties 或 application.yml 中的相关配置删除）</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">person.last-name</span>=<span class="hljs-string">李四</span><br><span class="hljs-meta">person.age</span>=<span class="hljs-string">12</span><br><span class="hljs-meta">person.birth</span>=<span class="hljs-string">2000/12/15</span><br><span class="hljs-meta">person.boss</span>=<span class="hljs-string">false</span><br><span class="hljs-meta">person.maps.k1</span>=<span class="hljs-string">v1</span><br><span class="hljs-meta">person.maps.k2</span>=<span class="hljs-string">14</span><br><span class="hljs-meta">person.lists</span>=<span class="hljs-string">a,b,c</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在 Person 使用 @PropertySource 注解指向 person.properties</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> net.biancheng.www.bean;<br><br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.PropertySource;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@PropertySource(value = &quot;classpath:person.properties&quot;)</span><span class="hljs-comment">//指向对应的配置文件</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String lastName;<br>  <span class="hljs-keyword">private</span> Integer age;<br>  <span class="hljs-keyword">private</span> Boolean boss;<br>  <span class="hljs-keyword">private</span> Date birth;<br>  <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; maps;<br>  <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;lastName=&#x27;&quot;</span> + lastName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>      <span class="hljs-string">&quot;, boss=&quot;</span> + boss +<br>      <span class="hljs-string">&quot;, birth=&quot;</span> + birth +<br>      <span class="hljs-string">&quot;, maps=&quot;</span> + maps +<br>      <span class="hljs-string">&quot;, lists=&quot;</span> + lists +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="多-Profile-文件方式"><a href="#多-Profile-文件方式" class="headerlink" title="多 Profile 文件方式"></a>多 Profile 文件方式</h4><p>在实际的项目开发中，一个项目通常会存在多个环境。</p>
<p>SpringBoot 的配置文件共有两种形式：.properties 文件和 .yml 文件，不管哪种形式，它们都能通过文件名的命名形式区分出不同的环境的配置，文件命名格式为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">application-&#123;profile&#125;.properties/yml</span><br></code></pre></td></tr></table></figure>
<p>其中，{profile} 一般为各个环境的名称或简称，例如 dev、test 和 prod 等等。</p>
<p>在 项目 的 src/main/resources 下添加 4 个配置文件：</p>
<ul>
<li>application.properties/yml：主配置文件</li>
<li>application-dev.properties/yml：开发环境配置文件</li>
<li>application-test.properties/yml：测试环境配置文件</li>
<li>application-prod.properties/yml：生产环境配置文件</li>
</ul>
<p>激活配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#properties 激活指定的profile</span><br><span class="hljs-meta">spring.profiles.active</span>=<span class="hljs-string">prod</span><br></code></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#yml 激活开发环境配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#激活开发环境配置</span><br></code></pre></td></tr></table></figure>
<h4 id="多-Profile-文档块模式"><a href="#多-Profile-文档块模式" class="headerlink" title="多 Profile 文档块模式"></a>多 Profile 文档块模式</h4><p>在 YAML 配置文件中，可以使用“—”把配置文件分割成了多个文档块，因此我们可以在不同的文档块中针对不同的环境进行不同的配置，并在第一个文档块内对配置进行切换。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#默认配置</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-comment">#切换配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">test</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#开发环境</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">activate:</span><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">dev</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#测试环境</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">activate:</span><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">test</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#生产环境</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">activate:</span><br>      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">prod</span><br></code></pre></td></tr></table></figure>
<h4 id="Spring-Boot默认配置文件"><a href="#Spring-Boot默认配置文件" class="headerlink" title="Spring Boot默认配置文件"></a>Spring Boot默认配置文件</h4><p>通常情况下，SpringBoot 在启动时会将 resources 目录下的 application.properties 或 apllication.yml 作为其默认配置文件，我们可以在该配置文件中对项目进行配置，但这并不意味着 SpringBoot 项目中只能存在一个 application.properties 或 application.yml。</p>
<p>SpringBoot 项目中可以存在多个 application.properties 或 apllication.yml。</p>
<p>SpringBoot 启动时会扫描以下 5 个位置的 application.properties 或 apllication.yml 文件，并将它们作为 Spring boot 的默认配置文件。</p>
<ol>
<li>file:./config/</li>
<li>file:./config/*/</li>
<li>file:./</li>
<li>classpath:/config/</li>
<li>classpath:/</li>
</ol>
<blockquote>
<p>注：file: 指当前项目根目录；classpath: 指当前项目的类路径，即 resources 目录。</p>
</blockquote>
<p>以上所有位置的配置文件都会被加载，且它们<strong>优先级依次降低，序号越小优先级越高</strong>。其次，位于相同位置的 application.properties 的优先级高于 application.yml。</p>
<p><strong>高优先级配置会覆盖低优先级配置，形成互补配置</strong>，即：</p>
<ul>
<li>存在相同的配置内容时，高优先级的内容会覆盖低优先级的内容；</li>
<li>存在不同的配置内容时，高优先级和低优先级的配置内容取并集。</li>
</ul>
<p><strong>SpringBoot 配置文件加载位置及优先级</strong></p>
<img src="/article/33757/1544595010-1.png" class title="SpringBoot 配置文件加载顺序">
<ul>
<li>/myBoot：表示 JAR 包所在目录，目录名称自定义；</li>
<li>/childDir：表示 JAR 包所在目录下 config 目录的子目录，目录名自定义；</li>
<li>JAR：表示 Spring Boot 项目打包生成的 JAR；</li>
<li><strong>其余带有“/”标识的目录的目录名称均不能修改。</strong></li>
<li>红色数字：表示该配置文件的优先级，数字越小优先级越高。</li>
</ul>
<p>这些配置文件得优先级顺序，遵循以下规则：</p>
<ol>
<li>先加载 JAR 包外的配置文件，再加载 JAR 包内的配置文件；</li>
<li>先加载 config 目录内的配置文件，再加载 config 目录外的配置文件；</li>
<li>先加载 config 子目录下的配置文件，再加载 config 目录下的配置文件；</li>
<li>先加载 appliction-{profile}.properties/yml，再加载 application.properties/yml；</li>
<li>先加载 .properties 文件，再加载 .yml 文件。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/article/3410.html</url>
    <content><![CDATA[<blockquote>
<p>Let life be beautiful like summer flowers and death like autumn leaves.</p>
<p>使生如夏花之绚烂，死如秋叶之静美。　　</p>
</blockquote>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON: <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation(JavaScript 对象表示法)</p>
<p>JSON 是存储和交换文本信息的语法，类似 XML。</p>
<p>JSON 比 XML 更小、更快，更易解析。</p>
<p>JSON 是轻量级的文本数据交换格式</p>
<p>JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。</p>
<p>JSON 具有自我描述性，更易理解</p>
<h3 id="JSON-语法"><a href="#JSON-语法" class="headerlink" title="JSON 语法"></a>JSON 语法</h3><p><strong>语法规则</strong></p>
<p>JSON 语法是 JavaScript 对象表示语法的子集。</p>
<ul>
<li><p>数据在名称/值对中</p>
</li>
<li><p>数据由逗号分隔</p>
</li>
<li><p>大括号 <strong>{}</strong> 保存对象</p>
</li>
<li><p>中括号 <strong>[]</strong> 保存数组，数组可以包含多个对象</p>
<p>数组可包含多个对象：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">[<br>    &#123; key1 : value1<span class="hljs-number">-1</span> , key2:value1<span class="hljs-number">-2</span> &#125;, <br>    &#123; key1 : value2<span class="hljs-number">-1</span> , key2:value2<span class="hljs-number">-2</span> &#125;, <br>    &#123; key1 : value3<span class="hljs-number">-1</span> , key2:value3<span class="hljs-number">-2</span> &#125;, <br>    ...<br>    &#123; key1 : valueN<span class="hljs-number">-1</span> , key2:valueN<span class="hljs-number">-2</span> &#125;, <br>]<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p><strong>JSON 名称/值对</strong></p>
<p>JSON 数据的书写格式是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">key : value<br></code></pre></td></tr></table></figure>
<p>名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值</p>
<p>JSON 值可以是：</p>
<ul>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在中括号中）</li>
<li>对象（在大括号中）</li>
<li>null</li>
</ul>
<hr>
<p><strong>JSON 文件</strong></p>
<ul>
<li>JSON 文件的文件类型是 <strong>.json</strong></li>
<li>JSON 文本的 MIME 类型是 <strong>application/json</strong></li>
</ul>
<h3 id="Json方法"><a href="#Json方法" class="headerlink" title="Json方法"></a>Json方法</h3><p>JSON 通常用于与服务端交换数据。</p>
<p>在接收服务器数据时一般是字符串。</p>
<h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a><strong>JSON.parse()</strong></h4><p>将一个 JSON 字符串转换为 JavaScript 对象。</p>
<p>我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">JSON.parse(text[, reviver])<br></code></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>text:</strong>必需， 一个有效的 JSON 字符串。</li>
<li><strong>reviver:</strong> 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。</li>
</ul>
<p><strong>异常</strong></p>
<p>解析数据:</p>
<p>JSON 不能存储 Date 对象。如果你需要存储 Date 对象，需要将其转换为字符串。之后再将字符串转换为 Date 对象。</p>
<p><strong>解析函数</strong></p>
<p>JSON 不允许包含函数，但你可以将函数作为字符串存储，之后再将字符串转换为函数。</p>
<h4 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a><strong>JSON.stringify()</strong></h4><p>用于将 JavaScript 值转换为 JSON 字符串。</p>
<p>我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">JSON.stringify(value[, replacer[, space]])<br></code></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li><p>value:</p>
<p>必需， 要转换的 JavaScript 值（通常为对象或数组）。</p>
</li>
<li><p>replacer:</p>
<p>可选。用于转换结果的函数或数组。</p>
<p>如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。</p>
<p>如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。</p>
</li>
<li><p>space:</p>
<p>可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\t。</p>
</li>
</ul>
<p><strong>解析数据</strong></p>
<p>JSON 不能存储 Date 对象。</p>
<p>JSON.stringify() 会将所有日期转换为字符串。</p>
<p><strong>解析函数</strong></p>
<p>JSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value。</p>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><p>由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。</p>
<p>eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> obj = eval (<span class="hljs-string">&quot;(&quot;</span> + txt + <span class="hljs-string">&quot;)&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p><strong>对象语法</strong></p>
<p>JSON 对象使用在大括号({})中书写。</p>
<p>对象可以包含多个 <strong>key/value（键/值）</strong>对。</p>
<p>key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。</p>
<p>key 和 value 中使用冒号(:)分割。</p>
<p>每个 key/value 对使用逗号(,)分割。</p>
<p><strong>访问对象值</strong></p>
<p>可以使用点号 . 来访问对象的值；</p>
<p>也可以使用中括号 [] 来访问对象的值。</p>
<p><strong>嵌套 JSON 对象</strong></p>
<p>JSON 对象中可以包含另外一个 JSON 对象</p>
<p><strong>修改值</strong></p>
<p>可以使用点号 . 来修改 JSON 对象的值</p>
<p>可以使用中括号 [] 来修改 JSON 对象的值</p>
<p><strong>删除对象属性</strong></p>
<p>我们可以使用 <strong>delete</strong> 关键字来删除 JSON 对象的属性</p>
<h3 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h3><p>JSON 数组在中括号中书写。</p>
<p>JSON 中数组值必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。</p>
<p>JavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript 的表达式，包括函数，日期，及 <em>undefined</em>。</p>
<p><strong>JSON 对象中的数组</strong></p>
<p>对象属性的值可以是一个数组，我们可以使用索引值来访问数组</p>
<p><strong>嵌套 JSON 对象中的数组</strong></p>
<p>JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象</p>
<p><strong>修改数组值</strong></p>
<p>可以使用索引值来修改数组值</p>
<p><strong>删除数组属性</strong></p>
<p>我们可以使用 <strong>delete</strong> 关键字来删除 JSON 数组元素</p>
<h3 id="Json乱码问题"><a href="#Json乱码问题" class="headerlink" title="Json乱码问题"></a>Json乱码问题</h3><p>在SpringMVC配置文件中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    JSON乱码问题解决--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span> <span class="hljs-attr">register-defaults</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;objectMapper&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;failOnEmptyBeans&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JSON</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/article/4780.html</url>
    <content><![CDATA[<blockquote>
<p>In my solitude of heart I feel the sigh of this widowed evening veiled with mist and rain.</p>
<p>这寡独的黄昏，幕着雾与雨，我在我的心的孤寂里，感觉到它的叹息。　</p>
</blockquote>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html">SpringMVC官方文档</a></p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet。</p>
<p><strong>Spring MVC 是结构最清晰的 Servlet+JSP+JavaBean 的实现</strong></p>
<p>在 Spring MVC 框架中，Controller 替换 Servlet 来担负控制器的职责，用于接收请求，调用相应的 Model 进行处理，处理器完成业务处理后返回处理结果。Controller 调用相应的 View 并对处理结果进行视图渲染，最终客户端得到响应信息。</p>
<p>Spring的模型-视图-控制器（MVC）框架是围绕一个<code>DispatcherServlet</code>来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。</p>
<p>在Spring Web MVC中，你可以使用任何对象来作为命令对象或表单返回对象，而无须实现一个框架相关的接口或基类。</p>
<p><strong>使用SpringMVC基础配置</strong></p>
<a href="/article/37040.html" title="点击跳转springmvc">点击跳转springmvc</a>
<h3 id="原生配置实现SpringMVC"><a href="#原生配置实现SpringMVC" class="headerlink" title="原生配置实现SpringMVC"></a>原生配置实现SpringMVC</h3><p><strong>SpringMVC执行原理</strong></p>
<img src="/article/4780/1619751763609616.png" class title="img">
<p><code>DispatcherServlet</code>其实就是个<code>Servlet</code>（它继承自<code>HttpServlet</code>基类），同样也需要在你web应用的<code>web.xml</code>配置文件下声明。你需要在<code>web.xml</code>文件中把你希望<code>DispatcherServlet</code>处理的请求映射到对应的URL上去。</p>
<blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.bobo.servlet.helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<img src="/article/4780/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90.jpg" class title="springmvc执行流程解析">
</blockquote>
<img src="/article/4780/1066923-20190307172453210-409890354-20220125171300287.png" class title="img">
<p>实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现</p>
<ol>
<li><p>DispatcherServlet表示前置控制器，使整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求；</p>
<ul>
<li>假设请求为：<a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></li>
<li><a href="http://localhost:8080服务器域名">http://localhost:8080服务器域名</a></li>
<li>SpringMVC表示部署在服务器上的web站点</li>
<li>hello表示控制器</li>
<li>通过分析，如上请求表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器</li>
</ul>
<blockquote>
<img src="/article/4780/image-20220125170144231.png" class title="image-20220125170144231">
</blockquote>
</li>
<li><p>HandlerMapping为处理器映射，DispatcherServlet调用HandlerMapping，HandlerMapping根据请求查找Handler；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Handler 处理器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.Controller.HelloController&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>HandlerExecution表示具体的Handler，其主要作用是根据请求查找控制器，比如 <em>SpringMVC站点的hello控制器</em>；</p>
</li>
<li><p>HandlerExecution将解析后的信息传递给DispatcherServlet，如解析控制器映射等；</p>
<blockquote>
<img src="/article/4780/image-20220125170209664.png" class title="image-20220125170209664">
</blockquote>
</li>
<li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler；</p>
</li>
<li><p>Handler让具体的Controller执行；</p>
<blockquote>
<img src="/article/4780/image-20220125170358415.png" class title="image-20220125170358415">
</blockquote>
</li>
<li><p>controller将具体执行的信息返回给HandlerAdapter，如ModelAndView；</p>
<blockquote>
<img src="/article/4780/image-20220125170447409.png" class title="image-20220125170447409">
</blockquote>
</li>
<li><p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet调用试图解析器（ViewResolver）来解析HandlerAdapter传递的逻辑视图名；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView</span><br><span class="hljs-comment">    1。获取了ModelAndView中的数据</span><br><span class="hljs-comment">    2。解析ModelAndView中的视图名</span><br><span class="hljs-comment">    3。拼接视图名字，找到对应视图</span><br><span class="hljs-comment">    4。将数据渲染到视图上</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<img src="/article/4780/image-20220125170532472.png" class title="image-20220125170532472">
</blockquote>
</li>
<li><p>视图解析器将解析的逻辑视图名传递给DispatcherServlet；</p>
</li>
<li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图；</p>
</li>
<li><p>最终视图呈现给用户。</p>
<blockquote>
<img src="/article/4780/image-20220125170607589.png" class title="image-20220125170607589">
</blockquote>
</li>
</ol>
<h3 id="注解开发SpringMVC"><a href="#注解开发SpringMVC" class="headerlink" title="注解开发SpringMVC"></a>注解开发SpringMVC</h3><p>首先，进行<a href="/article/37040.html" title="SpringMVC基础配置+注解配置">SpringMVC基础配置+注解配置</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bobo.controller&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 让Spring MVC不处理静态资源    .css .js  .html .mp3 .mp4 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 支持mvc注解驱动</span><br><span class="hljs-comment">在spring中一般采用@RequestMapping注解来完成映射关系</span><br><span class="hljs-comment">要想使@RequestMapping注解生效</span><br><span class="hljs-comment">必须向上下文中注册DefaultAnnotationHandlerMapping</span><br><span class="hljs-comment">和一个AnnotationMethodHandlerAdapter实例</span><br><span class="hljs-comment">这两个实例分别在类级别和方法级别处理。</span><br><span class="hljs-comment">而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>pring 2.5以后引入了基于注解的编程模型，你可以在你的控制器实现上添加<code>@RequestMapping</code>、<code>@RequestParam</code>、<code>@ModelAttribute</code>等注解。</p>
<a href="/article/37040.html" title="点击跳转注解，查看SpringMVC相关注解">点击跳转注解，查看SpringMVC相关注解</a>
<p><strong>实例</strong></p>
<blockquote>
<p><code>HelloController</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.controller;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.ui.Model;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/h1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        <span class="hljs-comment">//封装数据</span><br>        model.addAttribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;Hello,SpringMVCAnnotation&quot;</span>);<br><br>        <span class="hljs-comment">//会被视图解析器处理</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>hello.jsp</code></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%--<br>  Created by IntelliJ IDEA.<br>  User: pro<br>  Date: <span class="hljs-number">2021</span>/<span class="hljs-number">10</span>/<span class="hljs-number">14</span><br>  Time: <span class="hljs-number">23</span>:<span class="hljs-number">10</span><br>  To change <span class="hljs-keyword">this</span> template use File | Settings | File Templates.<br>--%&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>  &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>$&#123;msg&#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>控制器Controller</strong></p>
<ol>
<li>控制器负责提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现；</li>
<li>控制器负责解析用户的请求并将其转换为一个模型；</li>
<li>在Spring MVC中一个控制器类可以包含多个方法；</li>
<li>在SpringMVC中，对Controller的配置方法有很多种。</li>
</ol>
<h3 id="Spring-MVC-视图重定向"><a href="#Spring-MVC-视图重定向" class="headerlink" title="Spring MVC 视图重定向"></a>Spring MVC 视图重定向</h3><p>控制器通常都会返回一个逻辑视图名，然后视图解析器会把它解析到一个具体的视图技术上去渲染。</p>
<p><strong>重定向前缀——redirect:</strong></p>
<p><code>redirect:</code>。如果返回的视图名中含有<code>redirect:</code>前缀，那么<code>UrlBasedViewResolver</code>（及它的所有子类）就会接受到这个信号，意识到这里需要发生重定向。然后视图名剩下的部分会被解析成重定向URL。</p>
<p>这种方式与通过控制器返回一个重定向视图<code>RedirectView</code>所达到的效果是一样的，不过这样一来控制器就可以只专注于处理并返回逻辑视图名了。</p>
<p><strong>重定向前缀——forward:</strong></p>
<p>对于最终会被<code>UrlBasedViewResolver</code>或其子类解析的视图名，你可以使用一个特殊的前缀：<code>forward:</code>。这会导致一个<code>InternalResourceView</code>视图对象的创建（它最终会调用<code>RequestDispatcher.forward()</code>方法），后者会认为视图名剩下的部分是一个URL</p>
<h2 id="RestFul风格"><a href="#RestFul风格" class="headerlink" title="RestFul风格"></a>RestFul风格</h2><p>一种软件架构风格、设计风格，而<strong>不是</strong>标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p><strong>特性</strong></p>
<ol>
<li><p><strong>表现层(Representation)</strong>：把资源具体呈现出来的形式，叫做它的表现层(Representation)。</p>
</li>
<li><p><strong>状态转换(State Transfer)</strong>：每发出一个请求，就代表了客户端和服务器的一次交互过程。</p>
<p>HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转换”(State Transfer)。</p>
<p>而这种转换是建立在表现层之上的，所以就是“表现层状态转换”。</p>
<p>具体说，就是HTTP协议里面，四个表示操作方式的动词：<strong>GET、POST、PUT、DELETE</strong>。他们分别对应四种基本操作：GET用来获取资源，POST用来新建资源，PUT用来更新资源，DELETE用来删除资源。</p>
<blockquote>
<p>传统方式操作资源</p>
<p><a href="http://127.0.0.1/item/queryUser.action?id=1">http://127.0.0.1/item/queryUser.action?id=1</a>   查询,GET<br><a href="http://127.0.0.1/item/saveUser.action">http://127.0.0.1/item/saveUser.action</a>         新增,POST<br><a href="http://127.0.0.1/item/updateUser.action">http://127.0.0.1/item/updateUser.action</a>       更新,POST<br><a href="http://127.0.0.1/item/deleteUser.action?id=1">http://127.0.0.1/item/deleteUser.action?id=1</a>  删除,GET或POST</p>
<p>使用RESTful操作资源</p>
<p><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a>     查询,GET</p>
<p><a href="http://127.0.0.1/item">http://127.0.0.1/item</a>       新增,POST </p>
<p><a href="http://127.0.0.1/item">http://127.0.0.1/item</a>       更新,POST </p>
<p><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a>     删除,GET或POST</p>
</blockquote>
</li>
</ol>
<p><strong>SpringMVC对RESTful的支持</strong></p>
<a href="/article/37040.html" title="点击跳转SpringMVC对RESTful的支持">点击跳转SpringMVC对RESTful的支持</a>
<ol>
<li>使路径变得更加简洁</li>
<li>获得参数更加方便，框架会自动进行类型转换</li>
<li>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求</li>
<li>安全</li>
</ol>
<p><strong>API设计风格基本规则</strong></p>
<ol>
<li><p>使用名词而不是动词</p>
</li>
<li><p>Get方法和查询参数不应该涉及状态改变</p>
<p>使用<strong>PUT, POST</strong> 和<strong>DELETE</strong> 方法 而不是 <strong>GET</strong> 方法来改变状态，不要使用<strong>GET</strong> 进行状态改变:</p>
</li>
<li><p>使用复数名词</p>
<p>不要混淆名词单数和复数，为了保持简单，只对所有资源使用复数。</p>
</li>
<li><p>使用子资源表达关系</p>
<p>如果一个资源与另外一个资源有关系，使用子资源</p>
</li>
<li><p>使用Http头声明序列化格式</p>
<p>在客户端和服务端，双方都要知道通讯的格式，格式在HTTP-Header中指定</p>
</li>
<li><p>为集合提供<strong>过滤 排序 选择和分页等功能</strong></p>
</li>
<li><p>使用Http状态码处理错误</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringMVC</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/article/18155.html</url>
    <content><![CDATA[<blockquote>
<p>The grass seeks her crowd in the earth.<br>The tree seeks his solitude of the sky.</p>
<p>绿草求她地上的伴侣。　　　　　　　　　　　　　　　　　　　　　　　<br>树木求他天空的寂寞。　</p>
</blockquote>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring框架是由于<a href="https://baike.baidu.com/item/软件开发/3448966">软件开发</a>的复杂性而创建的。Spring使用的是基本的<a href="https://baike.baidu.com/item/JavaBean/529577">JavaBean</a>来完成以前只可能由<a href="https://baike.baidu.com/item/EJB/144195">EJB</a>完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。</p>
<p><strong>Spring</strong>是一个轻量级控制反转（IOC）哥面向切面（AOP）的容器框架</p>
<p><a href="https://spring.io/projects/spring-framework">点击跳转Spring官方地址</a></p>
<p><a href="https://repo.spring.io/release/org/springframework/spring">点击跳转Spring官方下载地址</a></p>
<p><a href="https://github.com/spring-projects/spring-framework">点击跳转Spring官方GitHub地址</a></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用maven配置<code>spring-webmvc</code> <code>spring-jdbc</code></p>
<a href="/article/37040.html" title="点击跳转Spring-Maven配置">点击跳转Spring-Maven配置</a>
<p><strong>优点</strong></p>
<ol>
<li>Spring是一个开源的免费的框架（容器）</li>
<li>Spring是一个轻量级的、非入侵式框架</li>
<li><strong>AOP编程的支持</strong></li>
<li><strong>IOC编程的支持</strong></li>
<li>支持事务的处理、对框架整合的支持</li>
</ol>
<p><strong>缺点</strong></p>
<p>配置十分繁琐</p>
<p><strong>组成</strong></p>
<img src="/article/18155/Spring%E7%BB%84%E6%88%90.jpg" class title="Spring组成">
<h3 id="IOC理论"><a href="#IOC理论" class="headerlink" title="IOC理论"></a>IOC理论</h3><p>IOC是Inversion of Control的缩写，即为控制反转</p>
<p><strong>IOC 容器</strong>具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作不由程序员来做而是交给Spring容器来做。</p>
<ol>
<li>耦合的对象</li>
</ol>
<img src="/article/18155/1.png" class title="img">
<ol start="2">
<li><p>解耦的过程</p>
<img src="/article/18155/2.png" class title="img">
</li>
<li><p>理想的系统</p>
<img src="/article/18155/3.png" class title="img">
<p>在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度</p>
</li>
</ol>
<p><strong>控制反转是一种通过获得描述（XML或注解）并通过第三方去生产或获取的特定对象的方式，在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入<code>dependency injection(DI)</code></strong></p>
<img src="/article/18155/Spring%E4%B8%8EBean%E7%9A%84%E5%85%B3%E7%B3%BB.png" class title="Spring Bean">
<h4 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h4><blockquote>
<p>  实体类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br> <span class="hljs-keyword">private</span> String str;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStr</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> str;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStr</span><span class="hljs-params">(String str)</span> </span>&#123;<br>     <span class="hljs-keyword">this</span>.str = str;<br> &#125;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&#123;&quot;</span> +<br>             <span class="hljs-string">&quot;str=&#x27;&quot;</span> + str + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>             <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="IOC-XML配置"><a href="#IOC-XML配置" class="headerlink" title="IOC-XML配置"></a><strong>IOC-XML配置</strong></h5><p><code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--使用spring来创建对象，在Spring这些都称为Bean</span><br><span class="hljs-comment">        类型 变量名 = new 类型；</span><br><span class="hljs-comment">        bean = 对象  new Hello();</span><br><span class="hljs-comment">        id = 变量名</span><br><span class="hljs-comment">        class = new 的对象；</span><br><span class="hljs-comment">        property 相当于给对象中的属性设置一个值</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Hello&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;str&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h5 id="实例化容器"><a href="#实例化容器" class="headerlink" title="实例化容器"></a><strong>实例化容器</strong></h5><p>提供给ApplicationContext构造函数的位置路径是资源字符串，允许容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code>等）加载配置元数据。</p>
<p>获取Spring的上下文对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br></code></pre></td></tr></table></figure>
<p><strong>例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.pojo.Hello;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//获取Spring的上下文对象</span><br>    ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>    <span class="hljs-comment">//我们的对象现在都在Spring中管理了，我们要使用，直接去里面取出来</span><br>    Hello hello =(Hello)context.getBean(<span class="hljs-string">&quot;hello&quot;</span>);<br>    System.out.println(hello.toString());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>hello对象是由Spring创建的，hello对象的属性是由Spring设置的</li>
</ul>
<h4 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h4><p>当在 Spring 中定义一个 bean 时，你必须声明该 bean 的作用域的选项。</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton</td>
<td>在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，默认值</td>
</tr>
<tr>
<td>prototype</td>
<td>每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()</td>
</tr>
<tr>
<td>request</td>
<td>每次HTTP请求都会创建一个新的Bean，该作用域<strong>仅适用于WebApplicationContext环境</strong></td>
</tr>
<tr>
<td>session</td>
<td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境</td>
</tr>
<tr>
<td>global-session</td>
<td>一般用于Portlet应用环境，该作用域<strong>仅适用于WebApplicationContext环境</strong></td>
</tr>
</tbody>
</table>
<p><strong>singleton 作用域</strong></p>
<p>singleton 是默认的作用域</p>
<p>当一个bean的作用域为 <code>Singleton</code>，那么 Spring IoC 容器中<strong>只会存在一个共享的 bean 实例</strong>，并且所有对 bean 的请求，只要 id 与该 bean 定义相匹配，则只会返回 bean 的同一实例。</p>
<p>也就是说，当将一个 bean 定义设置为 singleton 作用域的时候，Spring IoC 容器只会创建该 bean 定义的<strong>唯一实例</strong>。</p>
<img src="/article/18155/singleton.png" class title="singleton">
<p>Singleton 是<strong>单例类型</strong>，就是在创建起容器时就同时自动创建了一个 bean 的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton 作用域是 Spring 中的缺省作用域。</p>
<p><strong>prototype 作用域</strong></p>
<p>当一个 bean 的作用域为 <code>Prototype</code>，表示<strong>一个 bean 定义对应多个对象实例</strong>。Prototype 作用域的 bean 会导致在每次对该 bean 请求（将其注入到另一个 bean 中，或者以程序的方式调用容器的 getBean() 方法）时都会创建一个新的 bean 实例。</p>
<img src="/article/18155/prototype.png" class title="prototype">
<p>Prototype 是<strong>原型类型</strong>，<strong>它在我们创建容器的时候并没有实例化</strong>，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的 bean 应该使用 prototype 作用域，而对无状态的bean则应该使用 singleton 作用域。</p>
<h4 id="IOC创建对象的方式"><a href="#IOC创建对象的方式" class="headerlink" title="IOC创建对象的方式"></a>IOC创建对象的方式</h4><p><strong>在创建<code>ApplicationContext</code>实例时，<code>bean</code>已经被注册</strong></p>
<blockquote>
<p>例：</p>
<p><code>User</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br> <span class="hljs-keyword">private</span> String name;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;User的无参构造&quot;</span>);<br> &#125;<br>  <span class="hljs-comment">//有参构造</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span></span>&#123;<br>   <span class="hljs-keyword">this</span>.name=name;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> name;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>   <span class="hljs-keyword">this</span>.name = name;<br> &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>   System.out.println(<span class="hljs-string">&quot;name+&quot;</span> + name);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>MyTest.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//在配置文件加载的时候，容器中管理的对象就已经初始化了</span><br>    ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>    User user = (User) context.getBean(<span class="hljs-string">&quot;user&quot;</span>);<br>    user.show();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>使用无参构造创建对象（默认）</p>
<p><code>beans.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--无参构造创建对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>输出结果</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">User的无参构造<br>name+bobo<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>使用有参构造创建对象</p>
<ol>
<li><p>第一种：下标赋值</p>
<p><code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--第一种：下标赋值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;第一种有参构造 &quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>输出结果</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">name+第一种有参构造<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>第二种：类型赋值 <strong>多个相同类型不建议使用</strong></p>
<p><code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--第二种：类型赋值 多个相同类型不建议使用--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;第二种有参构造&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>基本类型可以直接用，引用类型必须写全限定名</p>
<blockquote>
<p><code>输出结果</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">name+第二种有参构造<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>第三种：直接通过参数名</p>
<p><code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;第三种有参构造&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>输出结果</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">name+第三种有参构造<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
</li>
</ol>
<p><strong>取别名</strong></p>
<ol>
<li><code>alias</code>标签</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--给对象取别名--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;userbobo&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li><p>创建<code>bean</code>时通过<code>name</code>属性取别名，可以取多个别名，用多种方法分割，</p>
<p>u1 u2 u3 u4 都是user的别名</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;u1,u2 u3;u4&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h3><p>Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系。</p>
<h4 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h4><p>当容器调用带有一组参数的类构造函数时，基于构造函数的 DI 就完成了，其中每个参数代表一个对其他类的依赖。</p>
<p>即<strong>使用有参构造创建对象</strong></p>
<p><strong>例</strong></p>
<blockquote>
<p><strong>DI.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.dao;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DI</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> IDI idi;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DI</span><span class="hljs-params">(IDI idi)</span></span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;IDI被注入&quot;</span>);<br>     <span class="hljs-keyword">this</span>.idi = idi;<br>  &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">diCheck</span><span class="hljs-params">()</span></span>&#123;<br>       idi.checkIDI();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>IDI.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.dao;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IDI</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IDI</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;IDI注入&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkIDI</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Inside checkIDI.&quot;</span> );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;di&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.dao.DI&quot;</span>&gt;</span><br>  	<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;idi&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;idi&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.dao.IDI&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p>上面这个例子里，将依赖类 IDI.java注入到DI.java 文件,便称为依赖注入。</p>
<h4 id="基于设值函数的依赖注入（重点）"><a href="#基于设值函数的依赖注入（重点）" class="headerlink" title="基于设值函数的依赖注入（重点）"></a>基于设值函数的依赖注入（重点）</h4><p><strong>依赖：</strong>bean对象的创建依赖于容器</p>
<p><strong>注入：</strong>bean对象的所有属性，由容器来注入</p>
<p><strong>例</strong></p>
<blockquote>
<p><strong>Student.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> Address address;<br>  <span class="hljs-keyword">private</span> String[] books;<br>  <span class="hljs-keyword">private</span> List&lt;String&gt; hobbies;<br>  <span class="hljs-keyword">private</span> Map&lt;String,String&gt; card;<br>  <span class="hljs-keyword">private</span> Set&lt;String&gt; games;<br>  <span class="hljs-keyword">private</span> String wife;<br>  <span class="hljs-keyword">private</span> Properties info;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getWife</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> wife;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWife</span><span class="hljs-params">(String wife)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.wife = wife;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Address <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> address;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(Address address)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.address = address;<br>  &#125;<br>  <span class="hljs-keyword">public</span> String[] getBooks() &#123;<br>    <span class="hljs-keyword">return</span> books;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBooks</span><span class="hljs-params">(String[] books)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.books = books;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getHobbies</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> hobbies;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHobbies</span><span class="hljs-params">(List&lt;String&gt; hobbies)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.hobbies = hobbies;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title">getCard</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> card;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCard</span><span class="hljs-params">(Map&lt;String, String&gt; card)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.card = card;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getGames</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> games;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGames</span><span class="hljs-params">(Set&lt;String&gt; games)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.games = games;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Properties <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> info;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setInfo</span><span class="hljs-params">(Properties info)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.info = info;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, address=&quot;</span> + address.toString() +<br>      <span class="hljs-string">&quot;, books=&quot;</span> + Arrays.toString(books) +<br>      <span class="hljs-string">&quot;, hobbies=&quot;</span> + hobbies +<br>      <span class="hljs-string">&quot;, card=&quot;</span> + card +<br>      <span class="hljs-string">&quot;, games=&quot;</span> + games +<br>      <span class="hljs-string">&quot;, wife=&#x27;&quot;</span> + wife + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&quot;, info=&quot;</span> + info +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Address.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String address;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> address;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.address = address;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Address&#123;&quot;</span> +<br>      <span class="hljs-string">&quot;address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>      <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>注入</strong></p>
<blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Address&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;西安&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--普通注入 value--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--bean注入 ref--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--数组注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;books&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>红楼梦<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>水浒传<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>三国演义<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>西游记<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--List注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>听歌<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>敲代码<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>看电影<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Map--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123123123123123123&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;银行卡&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;456456456456456456&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Set--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;games&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>SCII<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BOB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--null--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wife&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--properites--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;学号&quot;</span>&gt;</span>123123123<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;性别&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="拓展方式注入"><a href="#拓展方式注入" class="headerlink" title="拓展方式注入"></a>拓展方式注入</h4><ol>
<li><p><code>c</code>注入</p>
<p>必须有有参构造器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--c命名空间注入，通过构造器注入 : constructs-args--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span> <span class="hljs-attr">c:age</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">c:name</span>=<span class="hljs-string">&quot;bobo&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>p</code>注入</p>
<p>p 命名空间注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--p命名注入，可以直接注入属性的值 ：property--&gt;</span><br><span class="hljs-comment">&lt;!--scope=&quot;singleton&quot; 单例模式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;bobo&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意</strong></p>
<p>c 、 p 命名空间注入不能直接使用，需要导入约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot; <br>xmlns:c=&quot;http://www.springframework.org/schema/c&quot;<br></code></pre></td></tr></table></figure>
<h3 id="SpringBean-自动装配"><a href="#SpringBean-自动装配" class="headerlink" title="SpringBean 自动装配"></a>SpringBean 自动装配</h3><p>Spring 容器可以在不使用<code>&lt;constructor-arg&gt;</code>和<code>&lt;property&gt;</code> 元素的情况下<strong>自动装配</strong>相互协作的 bean 之间的关系。</p>
<blockquote>
<p><strong>显式装配</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Cat&quot;</span>/&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Dog&quot;</span>/&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.People&quot;</span>&gt;</span>--&gt;<br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>--&gt;<br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dog&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>--&gt;<br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;cat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>--&gt;<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>--&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>Spring 自动装配 byName</p>
<ol>
<li>这种模式由属性名称指定自动装配。Spring 容器看作 beans，在 XML 配置文件中 beans 的 <em>auto-wire</em> 属性设置为 <em>byName</em>。</li>
<li>然后，它尝试将它的属性与配置文件中定义为相同名称的 beans 进行匹配和连接。</li>
<li>如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Dog&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--隐式装配   autowire=&quot;byName&quot;</span><br><span class="hljs-comment">	会在容器中上下文中查找，和自己对象set方法后面的值对应的beanid！</span><br><span class="hljs-comment">	需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.People&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>使用byName，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法一致</strong></p>
</li>
<li><p>Spring 自动装配 byType</p>
<ol>
<li>这种模式由属性类型指定自动装配。Spring 容器看作 beans ，在 XML 配置文件中 beans 的 autowire 属性设置为 byType 。</li>
<li>然后，如果它的 type 恰好与配置文件中 beans 名称中的一个相匹配，它将尝试匹配和连接它的属性。</li>
<li>如果找到匹配项，它将注入这些 beans ，否则，它将抛出异常。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Dog&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--隐式装配   autowire=&quot;byType&quot;</span><br><span class="hljs-comment">	会在容器中上下文中查找，和自己对象属性类型相同的beanid！</span><br><span class="hljs-comment">	要保证类型全局唯一</span><br><span class="hljs-comment">	需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.People&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;bobo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>即使</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog111&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Dog&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>对象名称不匹配，也可以根据类型找到对应的bean</p>
</li>
</ul>
<p><strong>要保证类型全局唯一</strong><br><strong>需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</strong></p>
</li>
<li><p>Spring <strong>注解</strong> 自动装配 </p>
</li>
</ol>
   <a href="/article/37040.html" title="点击跳转注解配置">点击跳转注解配置</a>
<p>   <code>@Autowire</code> 默认通过<code>byType</code>的方式实现 ，如果存在多个类型相同的，通过byname实现，必须要求这个对象存在<br>   <code>@Resource</code> 默认通过<code>byname</code>的方式实现 ，如果找不到名字，则通过byType实现 ！ 如果两个都找不到的情况下报错 </p>
<blockquote>
<p><strong><code>People.java</code>类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br>  <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-comment">//@Qualifier  允许beans 中对象名 与类中id与类型都不同</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(value = &quot;dogdog&quot;)</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>applicationContext.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-comment">&lt;!--context、aop 支持注解装配--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">  &lt;!<span class="hljs-attr">--</span>支持注解装配  开启注解支持<span class="hljs-attr">--</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--注解装配--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Cat&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dogdog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.Dog&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;people&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.pojo.People&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--@Autowired 与 @Resource区别</span><br><span class="hljs-comment">     都是用来自动装配的</span><br><span class="hljs-comment">     @Autowire 默认通过byType的方式实现 ，如果存在多个类型相同的，通过byname实现，必须要求这个对象存在</span><br><span class="hljs-comment">     @Resource 默认通过byname的方式实现 ，如果找不到名字，则通过byType实现 ！ 如果两个都找不到的情况下报错</span><br><span class="hljs-comment">     --&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h3><p>使用注解开发，必须要保证<code>aop</code>的包导入</p>
<a href="/article/37040.html" title="点击跳转使用注解开发">点击跳转使用注解开发</a>
<p>有两种方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--制定扫描包，包下注解会生效--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bobo&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="使用component-scan"><a href="#使用component-scan" class="headerlink" title="使用component-scan"></a>使用<code>component-scan</code></h4><p><code>&lt;context:component-scan base-package=&quot;com.bobo&quot;/&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-comment">//@Component  等价于   &lt;bean id=&quot;user&quot; class=&quot;com.bobo.pojo.User&quot;&gt;&lt;/bean&gt;</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-comment">//@Value(&quot;bobo&quot;) 相当于  &lt;property name=&quot;name&quot; value=&quot;bobo&quot;&gt;&lt;/property&gt;</span><br>  <span class="hljs-meta">@Value(&quot;bobo&quot;)</span><br>  <span class="hljs-keyword">public</span> String name;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-comment">//@Component  等价于   &lt;bean id=&quot;user&quot; class=&quot;com.bobo.pojo.User&quot;&gt;&lt;/bean&gt;</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-comment">//@Value(&quot;bobo&quot;) 相当于  &lt;property name=&quot;name&quot; value=&quot;bobo&quot;&gt;&lt;/property&gt;</span><br>  <span class="hljs-keyword">public</span> String name;<br>  <span class="hljs-comment">//也可以注入在set方法上</span><br>  <span class="hljs-meta">@Value(&quot;bobo&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>@Component</strong>衍生注解</p>
<ol>
<li><p>@Repository   与 @Component功能相似，作用在dao层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.dao;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><span class="hljs-comment">//@Repository 与 @Component功能相似，作用在dao层</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>@Service   与 @Component功能相似，作用在service层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.service;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-comment">//@Service 与 @Component功能相似，作用在service层</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>@Controller   与 @Component功能相似，作用在controller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.controller;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-comment">//@Controller 与 @Component功能相似，作用在controller层</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="使用-Scope"><a href="#使用-Scope" class="headerlink" title="使用@Scope"></a><strong>使用</strong><code>@Scope</code></h4><p>作用就和在bean标签中使用scope属性实现的功能是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope</span><br></code></pre></td></tr></table></figure>
<p>用于指定bean的作用范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br></code></pre></td></tr></table></figure>
<p>指定范围的取值</p>
<h3 id="使用Java的方式配置Spring"><a href="#使用Java的方式配置Spring" class="headerlink" title="使用Java的方式配置Spring"></a>使用Java的方式配置Spring</h3><a href="/article/37040.html" title="点击跳转基于Java注解的配置">点击跳转基于Java注解的配置</a>
<p><strong>@import、@Configuration 和 @Bean 注解</strong></p>
<p><strong>@Configuration</strong> 注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。</p>
<p><strong>@Bean</strong> 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。</p>
<p><strong>@import</strong> 注解允许从另一个配置类中加载 @Bean 定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.config;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Import;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">//@Configuration 相当于&lt;beans&gt;</span><br><span class="hljs-comment">//@Configuration 代表这是一个配置累 与beans.xml是一样的</span><br><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-meta">@ComponentScan(&quot;com.bobo.pojo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">boboConfig</span> </span>&#123;<br><br>  <span class="hljs-comment">//注册一个bean，就相当于我门之前写的一个bean标签</span><br>  <span class="hljs-comment">//这个方法的名字，就相当于bean标签中的id属性</span><br>  <span class="hljs-comment">//这个方法的返回值就相当于bean标签中的class属性</span><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();  <span class="hljs-comment">//就是返回要注入到bean 的对象</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>这个方法的返回值就相当于bean标签中的class属性</strong>,所以在测试类中可以识别到User类</p>
<p>带有 @Bean 注解的方法名称作为 bean 的 ID，它创建并返回实际的 bean。你的配置类可以声明多个 @Bean。</p>
<p>一旦定义了配置类，你就可以使用 <code>AnnotationConfigApplicationContext</code>来加载并把他们提供给 Spring 容器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.config.boboConfig;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">//如果完全使用了配类方式去做，只能通过AnnotationConfig上下文来获取容器，通过配置类的class对象加载</span><br>    ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(boboConfig.class);<br>    User getUser = (User) context.getBean(<span class="hljs-string">&quot;user&quot;</span>);<br>    System.out.println(user.getName());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="AOP框架"><a href="#AOP框架" class="headerlink" title="AOP框架"></a>AOP框架</h3><p>使用AOP织入，需要导入<code>aspectjweaver</code>依赖包</p>
<a href="/article/37040.html" title="点击跳转Spring-AOP配置">点击跳转Spring-AOP配置</a>
<p>Spring 框架的一个关键组件是<strong>面向切面的编程</strong>(AOP)框架。</p>
<p>跨一个应用程序的多个点的功能被称为<strong>横切关注点</strong>，这些横切关注点在概念上独立于应用程序的业务逻辑。在软件开发过程中有各种各样的很好的切面的例子，如日志记录、审计、声明式事务、安全性和缓存等。</p>
<p><strong>AOP 术语</strong></p>
<table>
<thead>
<tr>
<th>项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Aspect（切面）</td>
<td>一个模块具有一组提供横切需求的 APIs。例如，一个日志模块为了记录日志将被 AOP 方面调用。应用程序可以拥有任意数量的方面，这取决于需求。</td>
</tr>
<tr>
<td>Join point（连接点）</td>
<td>在你的应用程序中它代表一个点，你可以在插件 AOP 方面。你也能说，它是在实际的应用程序中，其中一个操作将使用 Spring AOP 框架。</td>
</tr>
<tr>
<td>Advice（通知）</td>
<td>这是实际行动之前或之后执行的方法。这是在程序执行期间通过 Spring AOP 框架实际被调用的代码。</td>
</tr>
<tr>
<td>Pointcut（切入点）</td>
<td>这是一组一个或多个连接点，通知应该被执行。你可以使用表达式或模式指定切入点正如我们将在 AOP 的例子中看到的。</td>
</tr>
<tr>
<td>Introduction</td>
<td>引用允许你添加新方法或属性到现有的类中。</td>
</tr>
<tr>
<td>Target object（被通知对象）</td>
<td>被一个或者多个方面所通知的对象，这个对象永远是一个被代理对象。也称为被通知对象。</td>
</tr>
<tr>
<td>Weaving</td>
<td>Weaving 把方面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时，类加载时和运行时完成。</td>
</tr>
<tr>
<td>Proxy（代理）</td>
<td>向目标对象应用通知之后创建的对象</td>
</tr>
</tbody>
</table>
<p><strong>通知的类型</strong></p>
<table>
<thead>
<tr>
<th>通知</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置通知</td>
<td>在一个方法执行之前，执行通知。</td>
</tr>
<tr>
<td>后置通知</td>
<td>在一个方法执行之后，不考虑其结果，执行通知。</td>
</tr>
<tr>
<td>返回后通知</td>
<td>在一个方法执行之后，只有在方法成功完成时，才能执行通知。</td>
</tr>
<tr>
<td>抛出异常后通知</td>
<td>在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。</td>
</tr>
<tr>
<td>环绕通知</td>
<td>在建议方法调用之前和之后，执行通知。</td>
</tr>
</tbody>
</table>
<h4 id="基于-AOP-的-XML架构"><a href="#基于-AOP-的-XML架构" class="headerlink" title="基于 AOP 的 XML架构"></a><strong>基于 AOP 的 XML架构</strong></h4><p>在xml中使用 aop 命名空间标签，你需要导入 spring-aop 架构</p>
<blockquote>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.service.UserService;<br><span class="hljs-keyword">import</span> com.bobo.service.UserServiceImpl;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>    <span class="hljs-comment">//动态代理 代理的是接口</span><br>    UserService userService = context.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserService.class);<br>    userService.add();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>方式一</strong>  自定义类</p>
<ol>
<li><p><strong>声明一个 aspect</strong></p>
<p>一个 <strong>aspect</strong> 是使用 元素声明的，支持的 bean 是使用 <strong>ref</strong> 属性引用的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>声明一个切入点</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;aBean&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;businessService&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.bobo.service..*.*(..))&quot;</span>/&gt;</span><br>   ...<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>一个切入点表达式决定了我们感兴趣的哪个方法会真正被执行。</li>
<li>一个切入点标签包含一个名称和任意数量的参数。方法的真正内容是不相干的，并且实际上它应该是空的。</li>
</ul>
</li>
<li><p><strong>例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.diy.DiyPointCut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--自定义切面，ref要引用的类--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;diy&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--切入点--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;point&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.bobo.service.UserServiceImpl.*(..) )&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--通知--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;point&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;point&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>Class DiyPointCut</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.diy;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiyPointCut</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;=============方法执行前=============&quot;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;=============方法执行后=============&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>测试结果：</p>
<img src="/article/18155/image-20220119212811856.png" class title="image-20220119212811856">
</li>
</ol>
<p><strong>方式二</strong>   使用原生Spring API接口</p>
<ol>
<li><p>声明一个通知器</p>
<p>定义<code>&lt; aop:advisor &gt;</code>中引用的通知时，通知必须实现Advice接口</p>
</li>
</ol>
<ol start="2">
<li><p><strong>例</strong></p>
<blockquote>
<ol>
<li><p>通知前环绕</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">package</span> com.bobo.log;<br><span class="hljs-keyword">import</span> org.springframework.aop.MethodBeforeAdvice;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;<br>  <span class="hljs-comment">//method   要执行的目标对象的方法</span><br>  <span class="hljs-comment">//Object   参数</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>	System.out.println(target.getClass().getName()+<span class="hljs-string">&quot;的&quot;</span>+method.getName()+<span class="hljs-string">&quot;被执行了&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>通知后环绕</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.log;<br><span class="hljs-keyword">import</span> org.springframework.aop.AfterAdvice;<br><span class="hljs-keyword">import</span> org.springframework.aop.AfterReturningAdvice;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AfterReturningAdvice</span> </span>&#123;<br>    <span class="hljs-comment">//returnValue  返回值</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;执行了&quot;</span>+method.getName()+<span class="hljs-string">&quot;方法，返回结果为：&quot;</span>+returnValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>配置XML</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.log.Log&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.log.AfterLog&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--    配置aop:需要导入aop的约束--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.bobo.service.UserServiceImpl.*(..) )&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--执行环绕增加--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>测试结果：</p>
<img src="/article/18155/image-20220119212737264.png" class title="image-20220119212737264">
</li>
</ol>
<p>​    </p>
<p><strong>方式三</strong>   使用注解配置</p>
<p>配置XML，开启注解支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<ol>
<li><p>声明一个 aspect</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectModule</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>声明一个切入点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-meta">@Pointcut(&quot;execution(* com.bobo.service.UserServiceImpl.*(..))&quot;)</span> <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;AnnotationPointCut&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.diy.AnnotationPointCut&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--开启注解支持   JDK（默认）proxy-target-class=&quot;false&quot;     cglib:proxy-target-class=&quot;true&quot;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.Signature;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><br><span class="hljs-meta">@Aspect</span>   <span class="hljs-comment">//标注这个类是一个切面</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationPointCut</span> </span>&#123;<br><br>  <span class="hljs-meta">@Before(&quot;execution(* com.bobo.service.UserServiceImpl.*(..))&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;=============方法执行前=============&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@After(&quot;execution(* com.bobo.service.UserServiceImpl.*(..))&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;=============方法执行后=============&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Around(&quot;execution(* com.bobo.service.UserServiceImpl.*(..))&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;环绕前&quot;</span>);<br>    <span class="hljs-comment">//执行方法</span><br>    Object proceed = proceedingJoinPoint.proceed();<br>    System.out.println(<span class="hljs-string">&quot;环绕后&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><code>ProceedingJoinPoint proceedingJoinPoint</code>代表当前执行的方法</p>
<p>测试结果：</p>
<img src="/article/18155/image-20220119212640569.png" class title="image-20220119212640569">
</li>
</ol>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li><p><code>aop:aspect</code>与<code>op:advisor</code>不同</p>
<ol>
<li><p>实现方式不同</p>
<p><a href="aop:aspect">aop:aspect</a>定义切面时，只需要定义一般的bean就行，而定义<a href="aop:advisor">aop:advisor</a>中引用的通知时，通知必须实现Advice接口。</p>
</li>
<li><p>使用场景不同</p>
<p><a href="aop:advisor">aop:advisor</a>大多用于事务管理</p>
</li>
</ol>
</li>
<li><p><strong>execution表达式</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">execution(* com.bobo.service..*. *(..))<br></code></pre></td></tr></table></figure>
<ol>
<li>第一个 <code>*</code> 表示返回类型， *号表示所有的类型</li>
<li>包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.bobo.service包、子孙包下所有类的方法 (“..”出现在类名中时，后面必须跟“*”)</li>
<li>第二个 <code>*</code> 号：表示类名，*号表示所有的类</li>
<li><code>*(..)</code>:最后这个星号表示方法名，*号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数</li>
</ol>
</li>
</ol>
<h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><p><a href="http://mybatis.org/spring/zh/index.html">整合Mybatis步骤官方中文文档</a></p>
<a href="/article/13919.html" title="点击跳转Mybatis详解">点击跳转Mybatis详解</a>
<p>导入相关jar包  <a href="/article/37040.html" title="点击跳转Spring-Mybatis Maven配置">点击跳转Spring-Mybatis Maven配置</a></p>
<ol>
<li><p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 <code>SqlSessionFactory</code> 和至少一个数据映射器类。</p>
<p>在 MyBatis-Spring 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>。 </p>
<ol>
<li><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--sqlSessionFactory--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/数据库名?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8<span class="hljs-symbol">&amp;amp;</span>useUnicode=true&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;用户名&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;密码&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="3">
<li><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SqlSessionTemplate 就是我们使用的sqlSession--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--只能使用构造器注入sqlSessionFactory ，因为没有set方法--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<ol>
<li><p><code>SqlSessionTemplate</code> 是 MyBatis-Spring 的核心。作为 <code>SqlSession</code> 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 <code>SqlSession</code>。 <code>SqlSessionTemplate</code> 是线程安全的，可以被多个 DAO 或映射器所共享使用。</p>
</li>
<li><p>当调用 SQL 方法时（包括由 <code>getMapper()</code> 方法返回的映射器中的方法），<code>SqlSessionTemplate</code> 将会保证使用的 <code>SqlSession</code> 与当前 Spring 的事务相关。 此外，它管理 session 的生命周期，包含必要的关闭、提交或回滚操作。另外，它也负责将 MyBatis 的异常翻译成 Spring 中的 <code>DataAccessExceptions</code>。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>现在，这个 sqlSession 就可以直接注入到你的 Mapper bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.mybatis.spring.SqlSessionTemplate;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserMapper</span></span>&#123;<br><br>  <span class="hljs-comment">//我们的所有操作都使用sqlSession来执行，在原来，现在我们都使用SqlSessionTrmplate</span><br>  <span class="hljs-keyword">private</span> SqlSessionTemplate sqlSession;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSqlSession</span><span class="hljs-params">(SqlSessionTemplate sqlSession)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.sqlSession=sqlSession;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>按下面这样，注入 <code>SqlSessionTemplate</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.mapper.UserMapperImpl&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSession&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>现在所有的映射语句可以进行批量操作了，可以在 Mapper.xml 中编写如下的代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.bobo.mapper.UserMapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    select * from mybatis.user;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>  ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>  UserMapper userMapper = context.getBean(<span class="hljs-string">&quot;userMapper&quot;</span>, UserMapper.class);<br><br>  <span class="hljs-keyword">for</span> (User user : userMapper.selectUser()) &#123;<br>    System.out.println(user);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>完整实例</strong></p>
<img src="/article/18155/image-20220120203442870.png" class title="image-20220120203442870">
<blockquote>
<p><strong>pojo.User</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String pwd;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>Mapper.UserMapper</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">selectUser</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Mapper.UserMapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.bobo.mapper.UserMapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>    select * from mybatis.user;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>Mapper.UserMapperImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.mybatis.spring.SqlSessionTemplate;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserMapper</span></span>&#123;<br><br>  <span class="hljs-comment">//我们的所有操作都使用sqlSession来执行，在原来，现在我们都使用SqlSessionTrmplate</span><br>  <span class="hljs-keyword">private</span> SqlSessionTemplate sqlSession;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSqlSession</span><span class="hljs-params">(SqlSessionTemplate sqlSession)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>.sqlSession=sqlSession;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">selectUser</span><span class="hljs-params">()</span> </span>&#123;<br>    UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>    <span class="hljs-keyword">return</span> mapper.selectUser();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>resources.mybatis-config.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.bobo.pojo&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;mappers&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--    &lt;mapper class=&quot;com.bobo.mapper.UserMapper&quot;/&gt;--&gt;</span><br>  <span class="hljs-comment">&lt;!--&lt;/mappers&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>resources.spring-dao.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--DataSource:使用Spring的数据源替换Mybatis的配置</span><br><span class="hljs-comment">        使用Spring提供的JDBC</span><br><span class="hljs-comment">      --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306数据库名?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8<span class="hljs-symbol">&amp;amp;</span>useUnicode=true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>用户名/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;密码&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--sqlSessionFactory--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--绑定Mybatis配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath*:com/bobo/mapper/UserMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--SqlSessionTemplate 就是我们使用的sqlSession--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--只能使用构造器注入sqlSessionFactory ，因为没有set方法--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>resources.applicationContext.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;spring-dao.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.bobo.mapper.UserMapperImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSession&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>MyTest</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.mapper.UserMapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>        UserMapper userMapper = context.getBean(<span class="hljs-string">&quot;userMapper&quot;</span>, UserMapper.class);<br><br>        <span class="hljs-keyword">for</span> (User user : userMapper.selectUser()) &#123;<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>SqlSessionDaoSupport</strong></p>
<p><code>SqlSessionDaoSupport</code> 是一个抽象的支持类，用来为你提供 <code>SqlSession</code>。调用 <code>getSqlSession()</code> 方法你会得到一个 <code>SqlSessionTemplate</code>，之后可以用于执行 SQL 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.mybatis.spring.support.SqlSessionDaoSupport;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SqlSessionDaoSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserMapper</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">selectUser</span><span class="hljs-params">()</span> </span>&#123;<br>        SqlSession sqlSession = getSqlSession();<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-keyword">return</span> mapper.selectUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>一个使用 MyBatis-Spring 的其中一个主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而不是给 MyBatis 创建一个新的专用事务管理器，MyBatis-Spring 借助了 Spring 中的 <code>DataSourceTransactionManager</code> 来实现事务管理。</p>
<p><strong>标准配置</strong></p>
<p>要开启 Spring 的事务处理功能，在 Spring 的配置文件中创建一个 <code>DataSourceTransactionManager</code> 对象：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transcationManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>传入的 <code>DataSource</code> 可以是任何能够与 Spring 兼容的 JDBC <code>DataSource</code>。包括连接池和通过 JNDI 查找获得的 <code>DataSource</code>。</p>
<p>注意：为事务管理器指定的 <code>DataSource</code> <strong>必须</strong>和用来创建 <code>SqlSessionFactoryBean</code> 的是同一个数据源，否则事务管理器就无法工作了。</p>
<h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p>（交由容器管理事务）</p>
<p><strong>配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置声明式事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transcationManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>结合AOP实现事务的织入</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置事务的类 通知--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transcationManager&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--给哪些方法配置事务--&gt;</span><br>  <span class="hljs-comment">&lt;!--配置事务的传播特性--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;query&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br><span class="hljs-comment">&lt;!--配置事务切入--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txPointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.bobo.mapper.*.*(..))&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;txPointCut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/article/41682.html</url>
    <content><![CDATA[<blockquote>
<p>Thank the flame for its light, but do not forget the lampholder<br>standing in the shade with constancy of patience.</p>
<p>谢谢火焰给你光明，但是不要忘了那执灯的人，他是坚忍地站在黑暗当中呢。</p>
</blockquote>
<img src="/article/41682/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg" class title="点击查看源网页">
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p><strong>什么是 GOF?</strong></p>
<p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 的书，该书首次提到了软件开发中设计模式的概念。</p>
<p>四位作者合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong>。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>
<ul>
<li>对接口编程而不是对实现编程。</li>
<li>优先使用对象组合而不是继承。</li>
</ul>
<p>模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。</p>
<p><strong>创建型模式</strong>:这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<blockquote>
<ul>
<li>工厂模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
</blockquote>
<p><strong>结构型模式</strong>:这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<blockquote>
<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>过滤器模式（Filter、Criteria Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ul>
</blockquote>
<p><strong>行为型模式</strong>:这些设计模式特别关注对象之间的通信。</p>
<blockquote>
<ul>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>空对象模式（Null Object Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板模式（Template Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
</ul>
</blockquote>
<img src="/article/41682/the-relationship-between-design-patterns.jpg" class title="设计模式之间的关系">
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p><strong>满足原则</strong></p>
<ul>
<li>开闭原则</li>
<li>依赖倒转原则</li>
<li>迪米特法则</li>
</ul>
<p><strong>实质</strong></p>
<ol>
<li>实例化对象不能new，用工厂方法代替</li>
<li>将选择实现类，创建对象统一管理和控制，从而将调度这跟我们实现类解耦</li>
</ol>
<p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p><strong>主要解决：</strong>主要解决接口选择的问题。</p>
<p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</p>
<p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p><strong>关键代码：</strong>创建过程在其子类执行。</p>
<p><strong>优点：</strong> </p>
<ol>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ol>
<p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p>
<p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<p><strong>实例</strong></p>
<blockquote>
<p>Car接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Car</span> </span>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>TSL实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TSL</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;<br>     System.out.println(<span class="hljs-string">&quot;TSL&quot;</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>WL实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WL</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;WL&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>CarFactory接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><span class="hljs-comment">//工厂方法模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CarFactory</span> </span>&#123;<br>	<span class="hljs-function">Car <span class="hljs-title">getCar</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>TSLFactory工厂实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TSLFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;<br> <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">getCar</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TSL();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p> WLFactory工厂实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WLFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">getCar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WL();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Consumer实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.factory.method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//使用工厂创建</span><br>        Car car = <span class="hljs-keyword">new</span> WLFactory().getCar();<br>        Car car1 = <span class="hljs-keyword">new</span> TSLFactory().getCar();<br>        car.name();<br>        car1.name();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">WL<br>TSL<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例设计模式（Singleton Design Pattern）:一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<blockquote>
<ol>
<li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</li>
<li>考虑对象创建时的线程安全问题；</li>
<li>考虑是否支持延迟加载；</li>
<li>考虑 getInstance() 性能是否高（是否加锁）。</li>
</ol>
</blockquote>
<ol>
<li><p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton1</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton1 INSTANCE = <span class="hljs-keyword">new</span> Singleton1();<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Singleton1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton1 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不支持延迟加载</p>
<p>线程安全</p>
</li>
<li><p>懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton2</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton2 INSTANCE;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Singleton2</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton2 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>)&#123;<br>      INSTANCE = <span class="hljs-keyword">new</span> Singleton2();<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>支持延迟加载</p>
<p>并发度低</p>
</li>
<li><p>双重检测</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton3</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton3 INSTANCE;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Singleton3</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton3 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>)&#123;<br>      <span class="hljs-keyword">synchronized</span> (Singleton3.class)&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>)&#123;<br>          INSTANCE = <span class="hljs-keyword">new</span> Singleton3();<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解决了懒汉式并发度低的问题</p>
</li>
<li><p>静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton4</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Singleton4</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonStatic</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton4 INSTANCE = <span class="hljs-keyword">new</span> Singleton4();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton4 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> SingletonStatic.INSTANCE;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>既保证了线程安全，又能做到延迟加载</p>
</li>
<li><p>枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton5</span> </span>&#123;<br>  INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>保证了实例创建的线程安全性和实例的唯一性</p>
</li>
</ol>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式的英文翻译是 Adapter Design Pattern。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。</p>
<p>ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p>
<ol>
<li><p>类适配器使用继承关系来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITarget</span> </span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>; <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>; <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fc</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span> </span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fa</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125; </span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fb</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125; </span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fc</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITarget</span> </span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">super</span>.fa(); <br>  &#125; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//...重新实现f2()... &#125; </span><br>    <span class="hljs-comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span><br> &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>对象适配器使用组合关系来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITarget</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fc</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fa</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fb</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fc</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//... &#125;</span><br>&#125;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITarget</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> Adaptee adaptee;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adaptor</span><span class="hljs-params">(Adaptee adaptee)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.adaptee = adaptee;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;<br>    adaptee.fa(); <span class="hljs-comment">//委托给Adaptee</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//...重新实现f2()...</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fc</span><span class="hljs-params">()</span> </span>&#123;<br>    adaptee.fc();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>使用判断标准</strong>：一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度。</p>
<ol>
<li>如果 Adaptee 接口并不多，那两种实现方式都可以。</li>
<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</li>
<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/article/13919.html</url>
    <content><![CDATA[<blockquote>
<p>The woodcutter’s axe begged for its handle from the tree.<br>The tree gave it.</p>
<p>樵夫的斧头，问树要斧柄。　　　　　　　　　　　　　　　　　　<br>树便给了他。</p>
</blockquote>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p><a href="https://github.com/mybatis">点击跳转Mybatis-Github官方</a></p>
<p><code>MyBatis</code> 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。</p>
<ul>
<li><strong>持久层：</strong> 可以将业务数据<strong>存储到磁盘，具备长期存储能力</strong>，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。</li>
<li><strong>优点：</strong> 可以<strong>使用巨大的磁盘空间</strong>存储相当量的数据，并且很<strong>廉价</strong></li>
<li><strong>缺点：慢</strong>（相对于内存而言）</li>
</ul>
<p><strong>为什么使用 MyBatis</strong></p>
<p>在我们<strong>传统的 JDBC 中</strong>，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的<strong>繁琐又枯燥</strong>。</p>
<p>而我们在使用了 <strong>MyBatis</strong> 之后，<strong>只需要提供 SQL 语句就好了</strong>，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的<strong>关注点于是可以就此集中在 SQL 语句上</strong>，关注在增删改查这些操作层面上。</p>
<p>并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<p><strong>特点</strong></p>
<ul>
<li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li>
<li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li>
<li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li>
<li>提供映射标签，支持对象与数据库的orm字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供xml标签，支持编写动态sql。 </li>
</ul>
<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>创建maven项目，配置<code>pom.xml</code>依赖包</p>
<a href="/article/37040.html" title="点击跳转Mybatis_Maven环境配置">点击跳转Mybatis_Maven环境配置</a>
<p><a href="https://mybatis.org/mybatis-3/zh/index.html">Mybaitis官方中文配置文件</a></p>
<p><strong>从 XML 中构建 SqlSessionFactory</strong></p>
<p>每个基于 MyBatis 的应用都是以一个 <code>SqlSessionFactory</code> 的实例为核心的。SqlSessionFactory 的实例可以通过 <code>SqlSessionFactoryBuilder</code> 获得。而 SqlSessionFactoryBuilder 则可以从 <code>XML</code> 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p>
<p>在<code>rescouces</code>文件下创建<code>mybatis-config.xml</code>配置文件</p>
<a href="/article/37040.html" title="点击跳转Mybatis_XML环境配置">点击跳转Mybatis_XML环境配置</a>
<p><strong>例</strong></p>
<a href="/article/37040.html" title="点击跳转Mybatis环境配置">点击跳转Mybatis环境配置</a>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--核心配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/数据库名?useSSL=false<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8<span class="hljs-symbol">&amp;amp;</span>useUnicode=true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;用户名&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;密码&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>封装工具类</strong></p>
<p>获取sqlSessionFactory对象，从sqlSessionFactory中获取SqlSession</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.utils;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-comment">//sqlSessionFaction  --&gt; sqlSession</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUtils</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br>  <span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//使用Mybatis的第一步：获取sqlSessionFactory对象</span><br>      String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>      InputStream inputStream = Resources.getResourceAsStream(resource);<br>      sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</span><br>  <span class="hljs-comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</span><br>  <span class="hljs-comment">// 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h4><p><strong>引入配置文件</strong></p>
<blockquote>
<p>通过<code>propertise</code>配置文件实现引用</p>
<p><code>db.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/数据库名?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=true</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">用户名</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">密码</span><br></code></pre></td></tr></table></figure>
<p><code>mybatis-config.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--当在这里配置属性时，优先使用外部配置文件--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载：</p>
<ul>
<li>首先读取在 properties 元素体内指定的属性。</li>
<li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。</li>
<li>最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。</li>
</ul>
<p>因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。</p>
</blockquote>
<p><strong>配置别名</strong></p>
<blockquote>
<p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--别名</span><br><span class="hljs-comment">    用来减少完全限定名的冗余</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--方法一：可以给实体类其别名--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAlias</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">		方法二：</span><br><span class="hljs-comment">    指定一个包名，Mybatis会在包名下搜索所需要的JavaBean</span><br><span class="hljs-comment">    扫描实体类的包，它的默认别名就是这个类的类名</span><br><span class="hljs-comment">		在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名</span><br><span class="hljs-comment">    也可以在实体类上增加注解</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.bobo.pojo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方法一--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    select * from mybatis.user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--方法二--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    select * from mybatis.user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>设置（settings）</strong></p>
<table>
<thead>
<tr>
<th>设置名</th>
<th>描述</th>
<th>有效值</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>cacheEnabled</td>
<td>全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td>
<td>true \</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>mapUnderscoreToCamelCase</td>
<td>是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td>
<td>true \</td>
<td>false</td>
<td>False</td>
</tr>
<tr>
<td>logImpl</td>
<td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td>SLF4J \</td>
<td>LOG4J(deprecated since 3.5.9) \</td>
<td>LOG4J2 \</td>
<td>JDK_LOGGING \</td>
<td>COMMONS_LOGGING \</td>
<td>STDOUT_LOGGING \</td>
<td>NO_LOGGING</td>
<td>未设置</td>
</tr>
<tr>
<td>lazyLoadingEnabled</td>
<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td>
<td>true \</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><strong>映射器（mappers）</strong></p>
<p>可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等告诉 MyBatis 到哪里去找映射文件.</p>
<blockquote>
<p>方式一：resource<br><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><br>方式二：class<br><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure></p>
<p><strong>注意：</strong></p>
<ol>
<li>接口和Mapper配置文件必须同名</li>
<li>接口和Mapper配置文件必须在同一个包下</li>
</ol>
<p>方式三：package</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span><br>&gt;<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis.builder&quot;</span>/&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><p>MyBatis 提供的所有特性都可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行</p>
<img src="/article/13919/image-20220108215520312.png" class title="image-20220108215520312">
<p><strong>例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--命名空间  绑定一个对应的Mapper接口--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.bobo.Mapper.UserMapper&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">id:对应的namespace中的方法名</span><br><span class="hljs-comment">resultType：SQL语句执行的返回值</span><br><span class="hljs-comment">parameterType：参数类型</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.bobo.pojo.User&quot;</span>&gt;</span><br>        select * from mybatis.user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>与之对应的是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.Mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 查询全部用户</span><br><span class="hljs-comment">     * 得到用户列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserList</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>绑定</p>
<p>每一个<code>Mapper.XML</code>都需要在Mybatis核心配置文件中注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/bobo/dao/UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>如果绑定失败，可能是资源目录没有导出成功,<a href="/article/37040.html" title="点击跳转Maven资源导出配置">点击跳转Maven资源导出配置</a></p>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.Mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.User;<br><span class="hljs-keyword">import</span> com.bobo.utils.MybatisUtils;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserMapperTest</span></span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//1.获得SqlSession对象</span><br>        SqlSession sqlSession = MybatisUtils.getSqlSession();<br>        <span class="hljs-comment">//方式一：getMapper</span><br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        List&lt;User&gt; userList = mapper.getUserList();<br><br>        <span class="hljs-comment">//方式二：</span><br><span class="hljs-comment">//        List&lt;User&gt; userList = sqlSession.selectList(&quot;com.bobo.dao.UserMapper.getUserList&quot;);</span><br>        <span class="hljs-keyword">for</span> (User user : userList) &#123;<br>            System.out.println(user);<br>        &#125;<br><br>        <span class="hljs-comment">//关闭SqlSession</span><br>        sqlSession.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>注意：</strong>增删改需要提交事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//提交事务</span><br>        sqlSession.commit();<br>        sqlSession.close();<br></code></pre></td></tr></table></figure>
<h3 id="对命名空间的一点补充"><a href="#对命名空间的一点补充" class="headerlink" title="对命名空间的一点补充"></a><strong>对命名空间的一点补充</strong></h3><p>在之前版本的 MyBatis 中，<strong>命名空间（Namespaces）</strong>的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。</p>
<p>命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p>
<p><strong>命名解析：</strong>为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。</p>
<ol>
<li><p>全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。</p>
</li>
<li><p>短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。</p>
</li>
</ol>
<h3 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h3><p><strong>对象生命周期和依赖注入框架</strong></p>
<p>依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。</p>
<ol>
<li><p><strong>SqlSessionFactoryBuilder</strong></p>
<p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
</li>
<li><p><strong>SqlSessionFactory</strong></p>
<p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。  SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
</li>
<li><p><strong>SqlSession</strong></p>
<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。  <strong>绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中。</strong></p>
</li>
</ol>
<h3 id="XML-映射文件"><a href="#XML-映射文件" class="headerlink" title="XML 映射文件"></a>XML 映射文件</h3><ul>
<li><code>cache</code> – 该命名空间的缓存配置。</li>
<li><code>cache-ref</code> – 引用其它命名空间的缓存配置。</li>
<li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li>
<li><code>resultType</code> - 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</li>
<li><del>parameterMap</del> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。</li>
<li><code>parameterType</code> - 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</li>
<li><code>sql</code> – 可被其它语句引用的可重用语句块。</li>
<li><code>insert</code> – 映射插入语句。</li>
<li><code>update</code> – 映射更新语句。</li>
<li><code>delete</code> – 映射删除语句。</li>
<li><code>select</code> – 映射查询语句</li>
</ul>
<p><strong>结果映射</strong></p>
<p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。</p>
<p>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</p>
<p>举例<br><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;hashed_password&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUsers&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userResultMap&quot;</span>&gt;</span><br>  select user_id, user_name, hashed_password<br>  from some_table<br>  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>复杂查询</strong></p>
<ol>
<li><p>多对一查询（多个同学对应一个老师）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-comment">//学生要关联一个老师</span><br>  <span class="hljs-keyword">private</span> Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.Mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.Student;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentMapper</span> </span>&#123;<br>  <span class="hljs-comment">//查询所有的学生信息，以及对应的老师的信息</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">getStudent</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>方法一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--思路：</span><br><span class="hljs-comment">1。查询所有学生信息</span><br><span class="hljs-comment">2。根据查询出来的学生的tid 寻找对应的老师</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudent&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span>&gt;</span><br>  select * from student<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--复杂的属性需要单独处理</span><br><span class="hljs-comment">       对象：association</span><br><span class="hljs-comment">       集合：collection</span><br><span class="hljs-comment"> javaType 指定的属性类型</span><br><span class="hljs-comment">--&gt;</span><br>   <br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getTeacher&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>  select * from teacher where id = #&#123;tid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>方法二：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--按照结果集嵌套处理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudent&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span>&gt;</span><br>  select s.id sid,s.name sname,t.name tname,t.id tid<br>  from student s,teacher t where s.tid = t.id;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>一对多（一个老师对应多个同学）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.pojo;<br><span class="hljs-keyword">import</span> com.bobo.pojo.Student;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>  <span class="hljs-keyword">private</span> String name;<br><br>  <span class="hljs-comment">//一个老师拥有多个学生</span><br>  <span class="hljs-keyword">private</span> List&lt;Student&gt; students;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.Mapper;<br><span class="hljs-keyword">import</span> com.bobo.pojo.Teacher;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Param;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TeacherMapper</span> </span>&#123;<br>  <span class="hljs-comment">//获取所有老师</span><br>  <span class="hljs-comment">//List&lt;Teacher&gt; getTeacher();</span><br>  <span class="hljs-comment">//获取指定老师下的所有学生以及老师的信息</span><br>  <span class="hljs-function">Teacher <span class="hljs-title">getTeacher</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;tid&quot;)</span> <span class="hljs-keyword">int</span> id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>方法一：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--按照结果嵌套查询--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span>&gt;</span><br>  select s.id sid, s.name sname, t.name tname, t.id tid<br>  from student s,teacher t<br>  where s.tid = t.id and t.id = #&#123;tid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--复杂的属性，我们需要单独处理</span><br><span class="hljs-comment">        javaType 指定的属性类型</span><br><span class="hljs-comment">        集合中的泛型信息，我们使用ofType获取</span><br><span class="hljs-comment">    --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>方法二：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span>&gt;</span><br>  select * from mybatis.teacher where id = #&#123;tid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;ArrayList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getStudentByTeacherId&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentByTeacherId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>  select *<br>  from mybatis.student where tid = #&#123;tid&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>SLF4J | <strong>LOG4J(deprecated since 3.5.9)</strong> | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | <strong>STDOUT_LOGGING</strong> | NO_LOGGING</p>
<p><strong>STDOUT_LOGGING</strong> 标准日志输出</p>
<p><code>mybatis-config.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--标准日志工厂实现--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>LOG4J(deprecated since 3.5.9)</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--LOG4J日志--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>使用LOG4J需要添加propertise配置文件<code>log4j.properties</code>(直接百度)</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">DEBUG,console,file</span><br><br><span class="hljs-meta">log4j.appender.console</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.console.Target</span> = <span class="hljs-string">System.out</span><br><span class="hljs-meta">log4j.appender.console.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.console.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">[%c]-%m%n</span><br><br><span class="hljs-meta">log4j.appender.file</span> = <span class="hljs-string">org.apache.log4j.RollingFileAppender</span><br><span class="hljs-meta">log4j.appender.file.File</span>=<span class="hljs-string">./log/bobo.log</span><br><span class="hljs-meta">log4j.appender.file.MaxFileSize</span>=<span class="hljs-string">10mb</span><br><span class="hljs-meta">log4j.appender.file.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.file.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="hljs-string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><br><span class="hljs-meta">log4j.logger.org.mybatis</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.Statement</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.ResultSet</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="hljs-string">DEBUG</span><br></code></pre></td></tr></table></figure>
<p><strong>log4j使用</strong></p>
<ol>
<li><p>在要使用Log4j的类中，导入包<code>org.apache.log4j.Logger;</code></p>
</li>
<li><p>日志对象，参数为当前类的class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Logger logger = Logger.getLogger(UserDaoTest.class);<br></code></pre></td></tr></table></figure>
</li>
<li><p>日志级别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">logger.info(<span class="hljs-string">&quot;info:进入了testLog4j&quot;</span>);<br>logger.debug(<span class="hljs-string">&quot;debug:进入了testLog4j&quot;</span>);<br>logger.error(<span class="hljs-string">&quot;error:进入了testLog4j&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{} 和 ${} 的区别"></a>#{} 和 ${} 的区别</h3><p>#{}和${}这两个语法是为了动态传递参数而存在的，是Mybatis实现动态SQL的基础，总体上他们的作用是一致的（为了动态传参），但是在编译过程、是否自动加单引号、安全性、使用场景等方面有很多不同，下面详细比较两者间的区别： </p>
<ol>
<li><p>编译过程</p>
<ol>
<li><strong>#{}</strong> <strong>是</strong> <strong>占位符</strong> <strong>：动态解析 -&gt; 预编译 -&gt; 执行</strong></li>
<li><strong>${}</strong> <strong>是</strong> <strong>拼接符</strong> <strong>：动态解析 -&gt; 编译 -&gt; 执行</strong></li>
</ol>
<p>预编译可以类比java类的编译，java类被编译成class文件，载入虚拟机，载入虚拟机的字节码文件可以先被编译成机器吗，那么在执行某行代码的时候就可以直接执行编译后的机器码，而不用从字节码开始编译再执行，那么执行效率就高了。这也是为啥热机状态比冷机状态可以抗更多负载的原因。</p>
<p>sql的预编译也是一样的道理，在执行执行前就编译好，等执行时直接取编译结果去执行。省去编译时间。sql预编译后会在参数位置用<a href="https://so.csdn.net/so/search?q=占位符">占位符</a>表示。 </p>
<p>预编译：数据库驱动在发送sql和参数到DBMS之前，先对sql语句进行编译处理，之后DBMS则可以直接对sql进行处理，不需要再次编译，提高了性能。这一点mybatis 默认情况下，将对所有的 sql 进行预编译处理。</p>
<ul>
<li>预编译可以将多个操作步骤合并成一个步骤，一般而言，越复杂的sql，编译程度也会复杂，难度大，耗时，费性能，而预编译可以合并这些操作，预编译之后DBMS可以省去编译直接运行sql。</li>
<li>预编译语句可以重复利用。<br>把一个 sql 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。</li>
</ul>
</li>
<li><p>是否自动加单引号</p>
<ol>
<li><strong>#{}</strong> 对应的变量会自动加上单引号</li>
<li><strong>${}</strong> 对应的变量不会加上单引号</li>
</ol>
</li>
<li><p>安全性</p>
<ol>
<li><strong>#{} </strong>能防止sql注入</li>
<li><strong>${}</strong> 不能防止sql注入</li>
</ol>
</li>
<li><p>Mybatis默认值不同</p>
<ol>
<li><strong>#{}</strong> 默认值 arg0、arg1、arg2 或 0、 1</li>
<li><strong>${}</strong> 默认值param1、param2、param3</li>
</ol>
</li>
<li><p>如何选择 #{} 和 ${}</p>
<ol>
<li>能用 <strong>#{}</strong> 的地方就用 <strong>#{}</strong>，尽量少用 ${}</li>
<li>表名作参数，或者order by 排序时用 <strong>${}</strong></li>
<li>传参时参数使用<strong>@Param(“”)</strong>注解，<strong>@Param</strong>注解的作用是给参数命名，参数命名后就能根据名字得到参数值（相当于又加了一层密），正确的将参数传入sql语句中（一般通过#{}的方式，${}会有sql注入的问题）。</li>
</ol>
</li>
</ol>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>使用缓存， 我们可以避免频繁的与数据库进行交互， 尤其是在查询越多、缓存命中率越高的情况下， 使用缓存对性能的提高更明显。</p>
<p>mybatis 也提供了对缓存的支持， 分为一级缓存和二级缓存。 但是在默认的情况下， 只开启一级缓存（一级缓存是对同一个 SqlSession 而言的）。</p>
<p><strong>缓存</strong>就是数据交换的缓冲区（称作Cache），是存贮数据（使用频繁的数据）的临时地方。当用户查询数据，首先在缓存中寻找，如果找到了则直接执行。如果找不到，则去数据库中查找。</p>
<p>MyBatis 提供了<strong>一级缓存</strong>和<strong>二级缓存</strong>的支持，默认情况下只有一级缓存</p>
<ol>
<li><p><strong>一级缓存</strong>: 基于PerpetualCache 的 HashMap本地缓存，其<strong>存储作用域为</strong> <strong>Session</strong>，当 <strong>Session flush</strong> <strong>或</strong> <strong>close</strong> 之后，该<strong>Session中的所有 Cache 就将清空</strong>。</p>
<p><strong>增删改也会刷新缓存</strong></p>
<p><strong>手动清理缓存：</strong><code>sqlSession.clearCache();</code></p>
</li>
<li><p><strong>二级缓存</strong>与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，不同在于其<strong>存储作用域为 Mapper(Namespace)</strong>，并且<strong>可自定义存储源</strong>，如 Ehcache。 要启用全局的二级缓存，首先开启全局缓存：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--显示的开启全剧缓存--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>然后只需要在你的 SQL 映射文件中添加一行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>工作机制：</p>
<ol>
<li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li>
<li>如果当前会话关闭了，这个会话对应的一级缓存就没了；</li>
<li>会话关闭之后，一级缓存中的数据会被保存在二级缓存中；</li>
<li>新的会话查询消息，就会从二级缓存中获取内容；</li>
<li>不同的mapper查出 的数据会放在自己对应的缓存（map）中</li>
</ol>
</li>
</ol>
<ul>
<li>映射语句文件中的所有 select 语句的结果将会被缓存。</li>
<li><strong>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</strong></li>
<li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li>
<li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li>
<li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li>
<li><p>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</p>
<p><strong>提示</strong> 缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。</p>
<p><strong>提示</strong> 二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Mybatis</category>
        <category>SSM</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC三层架构</title>
    <url>/article/30326.html</url>
    <content><![CDATA[<blockquote>
<p>God says to man, “I heal you therefore I hurt, love you therefore punish.”</p>
<p>神对人说：“我医治你所以伤害你，爱你所以惩罚你。”</p>
</blockquote>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><strong>MVC模式</strong>是软件工程中常见的一种软件架构模式，该模式把软件系统（项目）分为三个基本部分：<strong>模型（Model）、视图（View）和控制器（Controller）。</strong></p>
<p>具体来讲，MVC模式可以将项目划分为模型（M）、视图（V）和控制器（C）三个部分，并赋予各个部分不同的功能，方便开发人员进行分组。</p>
<p><strong>（1）视图（View）：</strong>负责界面的显示，以及与用户的交互功能，例如表单、网页等。</p>
<p><strong>（2）控制器（Controller）：</strong>可以理解为一个分发器，用来决定对于视图发来的请求，需要用哪一个模型来处理，以及处理完后需要跳回到哪一个视图。即用来连接视图和模型。</p>
<p>实际开发中，通常用控制器对客户端的请求数据进行封装（如将form表单发来的若干个表单字段值，封装到一个实体对象中），然后调用某一个模型来处理此请求，最后再转发请求（或重定向）到视图（或另一个控制器）。</p>
<p><strong>（3）模型（Model）：</strong>模型持有所有的数据、状态和程序逻辑。模型接受视图数据的请求，并返回最终的处理结果。 </p>
<img src="/article/30326/webp-20220104132315604" class title="img">
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>首先来说，三层架构与MVC的目标一致：都是为了解耦和、提高代码复用。</p>
<p><strong>MVC是一种设计模式，而三层架构是一种软件架构。</strong></p>
<p>三层架构分为：</p>
<p>表现层（UI）(web层)、业务逻辑层（BLL）(service层)、数据访问层（DAL）(dao层)，再加上实体类库（Model）</p>
<ol>
<li><p>实体类库（Model），在Java中，往往将其称为Entity实体类。数据库中用于存放数据，而我们通常选择会用一个专门的类来抽象出数据表的结构，类的属性就一对一的对应这表的属性。</p>
<p>一般来说，Model实体类库层需要被DAL层，BIL层和UI层引用。</p>
</li>
<li><p>数据访问层（DAL），主要是存放对数据类的访问，即对数据库的添加、删除、修改、更新等基本操作</p>
<p>DAL就是根据业务需求，构造SQL语句，构造参数，调用帮助类，获取结果，DAL层被BIL层调用</p>
</li>
<li><p>业务逻辑层（BLL）</p>
<p>BLL层好比是桥梁，将UI表示层与DAL数据访问层之间联系起来。所要负责的，就是处理涉及业务逻辑相关的问题，比如在调用访问数据库之前，先处理数据、判断数据。</p>
</li>
</ol>
<img src="/article/30326/webp" class title="img">
<h2 id="MVC与三层架构的关系"><a href="#MVC与三层架构的关系" class="headerlink" title="MVC与三层架构的关系"></a>MVC与三层架构的关系</h2><img src="/article/30326/webp-20220104140153015" class title="img">
<h2 id="SSM与三层架构的关系"><a href="#SSM与三层架构的关系" class="headerlink" title="SSM与三层架构的关系"></a>SSM与三层架构的关系</h2><p>SSM，即 SpringMVC、Spring 与 MyBatis 三个框架。它们在三层架构中所处的位置是不同的，即它们在三层架构中的功能各不相同，各司其职。</p>
<ol>
<li><p>SpringMVC：作为 View 层的实现者，完成用户的请求接收功能。SpringMVC 的 Controller作为整个应用的控制器，完成用户请求的转发及对用户的响应。</p>
</li>
<li><p>MyBatis：作为 Dao 层的实现者，完成对数据库的增、删、改、查功能。</p>
</li>
<li><p>Spring：以整个应用大管家的身份出现。整个应用中所有 Bean 的生命周期行为，均由Spring 来管理。即整个应用中所有对象的创建、初始化、销毁，及对象间关联关系的维护，均由 Spring 进行管理。</p>
</li>
</ol>
<img src="/article/30326/webp-20220104140331755" class title="img">
]]></content>
      <categories>
        <category>Java</category>
        <category>MVC三层架构</category>
        <category>MVC三层架构</category>
      </categories>
      <tags>
        <tag>Java,JavaWeb, MVC三层架构</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP</title>
    <url>/article/6685.html</url>
    <content><![CDATA[<blockquote>
<p>Take my wine in my own cup, friend.<br>It loses its wreath of foam when poured into that of others.</p>
<p>在我自己的杯中，饮了我的酒吧，朋友。一倒在别人的杯里，这酒的腾跳的泡沫便要消失了。</p>
</blockquote>
<h2 id="Java-Server-Pages"><a href="#Java-Server-Pages" class="headerlink" title="Java Server Pages"></a>Java Server Pages</h2><p>JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。</p>
<p>JSP是一种Java servlet，主要用于实现Java web应用程序的用户界面部分。网页开发者们通过结合HTML代码、XHTML代码、XML元素以及嵌入JSP操作和命令来编写JSP。</p>
<p>JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页。</p>
<p>JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。</p>
<h3 id="JSP-处理"><a href="#JSP-处理" class="headerlink" title="JSP 处理"></a>JSP 处理</h3><p>以下步骤表明了 Web 服务器是如何使用JSP来创建网页的：</p>
<ul>
<li>就像其他普通的网页一样，您的浏览器发送一个 HTTP 请求给服务器。</li>
<li>Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成。</li>
<li>JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码。</li>
<li>JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎。</li>
<li>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器。</li>
<li>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中。</li>
<li>最终，Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样。</li>
</ul>
<img src="/article/6685/jsp-processing.jpg" class title="img">
<p>一般情况下，JSP 引擎会检查 JSP 文件对应的 Servlet 是否已经存在，并且检查 JSP 文件的修改日期是否早于 Servlet。如果 JSP 文件的修改日期早于对应的 Servlet，那么容器就可以确定 JSP 文件没有被修改过并且 Servlet 有效。这使得整个流程与其他脚本语言（比如 PHP）相比要高效快捷一些。</p>
<p>总的来说，JSP 网页就是用另一种方式来编写 Servlet 而不用成为 Java 编程高手。除了解释阶段外，JSP 网页几乎可以被当成一个普通的 Servlet 来对待。</p>
<h3 id="JSP-生命周期"><a href="#JSP-生命周期" class="headerlink" title="JSP 生命周期"></a>JSP 生命周期</h3><p>JSP生命周期就是从创建到销毁的整个过程，类似于servlet生命周期，区别在于JSP生命周期还包括将JSP文件编译成servlet。</p>
<p>以下是JSP生命周期中所走过的几个阶段：</p>
<ol>
<li><p>编译阶段：</p>
<p>servlet容器编译servlet源文件，生成servlet类</p>
</li>
<li><p>初始化阶段：</p>
<p>加载与JSP对应的servlet类，创建其实例，并调用它的初始化方法</p>
</li>
<li><p>执行阶段：</p>
<p>调用与JSP对应的servlet实例的服务方法</p>
</li>
<li><p>销毁阶段：</p>
<p>调用与JSP对应的servlet实例的销毁方法，然后销毁servlet实例</p>
<img src="/article/6685/jsp_life_cycle.jpg" class title="img">
</li>
</ol>
<h3 id="JSP编译"><a href="#JSP编译" class="headerlink" title="JSP编译"></a>JSP编译</h3><p>当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。</p>
<p><code>Mac</code>文件地址：<code>~/Library/Caches/JetBrains/IntelliJIdea/tomcat/项目名/work/Catalina/localhost/ROOT/org/apache/jsp/index_jsp.java</code></p>
<p>编译的过程包括三个步骤：</p>
<ul>
<li>解析JSP文件。</li>
<li>将JSP文件转为servlet。</li>
<li>编译servlet。</li>
</ul>
<ol>
<li><p>JSP初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspInit</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">// 初始化代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>一般来讲程序只初始化一次，servlet也是如此。通常情况下您可以在jspInit()方法中初始化数据库连接、打开文件和创建查询表。</p>
</li>
<li><p>JSP执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_jspService</span><span class="hljs-params">(HttpServletRequest request,HttpServletResponse response)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// 服务端处理代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>当JSP网页完成初始化后，JSP引擎将会调用_jspService()方法。</p>
</li>
<li><p>JSP清理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jspDestroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// 清理代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<p>输出页面前新增的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>); <span class="hljs-comment">//设置相应的页面类型</span><br>pageContext = _jspxFactory.getPageContext(<span class="hljs-keyword">this</span>, request, response,<br>         <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-number">8192</span>, <span class="hljs-keyword">true</span>);<br>_jspx_page_context = pageContext;<br>application = pageContext.getServletContext();<br>config = pageContext.getServletConfig();<br>session = pageContext.getSession();<br>out = pageContext.getOut();<br>_jspx_out = out;<br></code></pre></td></tr></table></figure>
<p>以上这些对象可以在jsp对象中直接使用</p>
<h3 id="JSP-隐式对象-内置"><a href="#JSP-隐式对象-内置" class="headerlink" title="JSP 隐式对象(内置)"></a>JSP 隐式对象(内置)</h3><p>JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> javax.servlet.jsp.PageContext pageContext;<br>javax.servlet.http.HttpSession session = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">final</span> javax.servlet.ServletContext application;<br><span class="hljs-keyword">final</span> javax.servlet.ServletConfig config;<br>javax.servlet.jsp.JspWriter out = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">final</span> java.lang.Object page = <span class="hljs-keyword">this</span>;<br>javax.servlet.jsp.JspWriter _jspx_out = <span class="hljs-keyword">null</span>;<br>javax.servlet.jsp.PageContext _jspx_page_context = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>对象</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">request</td>
<td style="text-align:center"><strong>HttpServletRequest</strong> 接口的实例</td>
</tr>
<tr>
<td style="text-align:center">response</td>
<td style="text-align:center"><strong>HttpServletResponse</strong> 接口的实例</td>
</tr>
<tr>
<td style="text-align:center">out</td>
<td style="text-align:center"><strong>JspWriter</strong>类的实例，用于把结果输出至网页上</td>
</tr>
<tr>
<td style="text-align:center">session</td>
<td style="text-align:center"><strong>HttpSession</strong>类的实例</td>
</tr>
<tr>
<td style="text-align:center">application</td>
<td style="text-align:center"><strong>ServletContext</strong>类的实例，与应用上下文有关</td>
</tr>
<tr>
<td style="text-align:center">config</td>
<td style="text-align:center"><strong>ServletConfig</strong>类的实例</td>
</tr>
<tr>
<td style="text-align:center">pageContext</td>
<td style="text-align:center"><strong>PageContext</strong>类的实例，提供对JSP页面所有对象以及命名空间的访问</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">类似于Java类中的this关键字</td>
</tr>
<tr>
<td style="text-align:center">Exception</td>
<td style="text-align:center"><strong>Exception</strong>类的对象，代表发生错误的JSP页面中对应的异常对象</td>
</tr>
</tbody>
</table>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%--内置对象--%&gt;<br>&lt;%<br>    pageContext.setAttribute(<span class="hljs-string">&quot;name1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>);  <span class="hljs-comment">//保存的数据只在一个页面中有效</span><br>    request.setAttribute(<span class="hljs-string">&quot;name2&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>);  <span class="hljs-comment">//保存的数据只在一次请求中有效，请求转发会携带这个数据</span><br>    session.setAttribute(<span class="hljs-string">&quot;name3&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);  <span class="hljs-comment">//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器</span><br>    application.setAttribute(<span class="hljs-string">&quot;name4&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>);  <span class="hljs-comment">//保存的数据只在一次服务器中有效，从打开服务器到关闭服务器</span><br>%&gt;<br><br>&lt;%<br>		<span class="hljs-comment">//通过pageContext取出我们保存的值</span><br>    <span class="hljs-comment">//通过寻找的方式</span><br>    String name1 = (String) pageContext.findAttribute(<span class="hljs-string">&quot;name1&quot;</span>);<br>    String name2 = (String) pageContext.findAttribute(<span class="hljs-string">&quot;name2&quot;</span>);<br>    String name3 = (String) pageContext.findAttribute(<span class="hljs-string">&quot;name3&quot;</span>);<br>    String name4 = (String) pageContext.findAttribute(<span class="hljs-string">&quot;name4&quot;</span>);<br>    String name5 = (String) pageContext.findAttribute(<span class="hljs-string">&quot;name5&quot;</span>);<br>%&gt;<br><br>&lt;%--使用EL表达式输出  $&#123;&#125;--%&gt;<br>&lt;h1&gt;取出的值为：&lt;/h1&gt;<br>&lt;h3&gt;$&#123;name1&#125;&lt;/h3&gt;<br>&lt;h3&gt;$&#123;name2&#125;&lt;/h3&gt;<br>&lt;h3&gt;$&#123;name3&#125;&lt;/h3&gt;<br>&lt;h3&gt;$&#123;name4&#125;&lt;/h3&gt;<br>&lt;%--使用EL表达式输出  不存在不会输出--%&gt;<br>&lt;h3&gt;$&#123;name5&#125;&lt;/h3&gt;<br>&lt;%--原始方式输出 不存在会输出<span class="hljs-keyword">null</span>--%&gt;<br>&lt;h3&gt;&lt;%=name5%&gt;&lt;/h3&gt;<br></code></pre></td></tr></table></figure>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><a href="/article/37040.html" title="JSPMaven导包">JSPMaven导包</a>
<p><strong>JSP注释</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>语法</strong></th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;%– 注释 –%&gt;</td>
<td style="text-align:center">JSP注释，注释内容不会被发送至浏览器甚至不会被编译</td>
</tr>
<tr>
<td style="text-align:center"><!-- 注释 --></td>
<td style="text-align:center">HTML注释，通过浏览器查看网页源代码时可以看见注释内容</td>
</tr>
<tr>
<td style="text-align:center">&lt;\%</td>
<td style="text-align:center">代表静态 &lt;%常量</td>
</tr>
<tr>
<td style="text-align:center">%></td>
<td style="text-align:center">代表静态 %&gt; 常量</td>
</tr>
<tr>
<td style="text-align:center">\’</td>
<td style="text-align:center">在属性中使用的单引号</td>
</tr>
<tr>
<td style="text-align:center">\”</td>
<td style="text-align:center">在属性中使用的双引号</td>
</tr>
</tbody>
</table>
<p><strong>脚本程序</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;% 代码片段 %&gt;<br>&lt;!-- 或 --&gt;<br>&lt;jsp:scriptlet&gt;<br>   代码片段<br>&lt;/jsp:scriptlet&gt;<br></code></pre></td></tr></table></figure>
<p><strong>中文编码问题</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span><br>    pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span>%&gt;<br></code></pre></td></tr></table></figure>
<p><strong>JSP声明</strong></p>
<p>一个声明语句可以声明一个或多个变量、方法，供后面的Java代码使用。在JSP文件中，您必须先声明这些变量和方法然后才能使用它们。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%! declaration; [ declaration; ]+ ... %&gt;<br>&lt;!-- 或 --&gt;<br>&lt;jsp:expression&gt;<br>   代码片段<br>&lt;/jsp:expression&gt;<br></code></pre></td></tr></table></figure>
<p><strong>JSP表达式</strong></p>
<p>将程序结果输出到客户端</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%= 表达式 %&gt;<br>&lt;!-- 或 --&gt;<br>&lt;jsp:declaration&gt;<br>   代码片段<br>&lt;/jsp:declaration&gt;<br></code></pre></td></tr></table></figure>
<p><strong>JSP指令</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ directive attribute=<span class="hljs-string">&quot;value&quot;</span> %&gt;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>指令</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;%@ page … %&gt;</td>
<td style="text-align:center">定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td>
</tr>
<tr>
<td style="text-align:center">&lt;%@ include … %&gt;</td>
<td style="text-align:center">包含其他文件</td>
</tr>
<tr>
<td style="text-align:center">&lt;%@ taglib … %&gt;</td>
<td style="text-align:center">引入标签库的定义，可以是自定义标签</td>
</tr>
</tbody>
</table>
<p><strong>JSP行为</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;jsp:action_name attribute=<span class="hljs-string">&quot;value&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>语法</strong></th>
<th style="text-align:center"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">jsp:include</td>
<td style="text-align:center">用于在当前页面中包含静态或动态资源</td>
</tr>
<tr>
<td style="text-align:center">jsp:useBean</td>
<td style="text-align:center">寻找和初始化一个JavaBean组件</td>
</tr>
<tr>
<td style="text-align:center">jsp:setProperty</td>
<td style="text-align:center">设置 JavaBean组件的值</td>
</tr>
<tr>
<td style="text-align:center">jsp:getProperty</td>
<td style="text-align:center">将 JavaBean组件的值插入到 output中</td>
</tr>
<tr>
<td style="text-align:center">jsp:forward</td>
<td style="text-align:center">从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td>
</tr>
<tr>
<td style="text-align:center">jsp:plugin</td>
<td style="text-align:center">用于在生成的HTML页面中包含Applet和JavaBean对象</td>
</tr>
<tr>
<td style="text-align:center">jsp:element</td>
<td style="text-align:center">动态创建一个XML元素</td>
</tr>
<tr>
<td style="text-align:center">jsp:attribute</td>
<td style="text-align:center">定义动态创建的XML元素的属性</td>
</tr>
<tr>
<td style="text-align:center">jsp:body</td>
<td style="text-align:center">定义动态创建的XML元素的主体</td>
</tr>
<tr>
<td style="text-align:center">jsp:text</td>
<td style="text-align:center">用于封装模板数据</td>
</tr>
</tbody>
</table>
<ul>
<li><code>&lt;%@ include %&gt;</code>将两个页面合为一整个页面</li>
<li><code>&lt;jsp:include&gt;</code>将页面拼接</li>
</ul>
<p><strong>JSTL标签</strong></p>
<p>弥补HTML标签的不足</p>
<ol>
<li><p>核心标签</p>
<p>导入标签库</p>
 <figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ taglib prefix=<span class="hljs-string">&quot;c&quot;</span> uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span>%&gt;<br></code></pre></td></tr></table></figure>
<p> |      标签       |                             描述                             |<br> | :————-: | :———————————————————-: |<br> |    &lt;&lt;c:out&gt;&gt;    |              用于在JSP中显示数据，就像&lt;%= … &gt;              |<br> |    &lt;&lt;c:set&gt;&gt;    |                         用于保存数据                         |<br> |    &lt;&lt;c:if&gt;&gt;     | &lt;&lt;c:if&gt;&gt;标签判断表达式的值，如果表达式的值为 true 则执行其主体内容。 |<br> |  &lt;&lt;c:remove&gt;&gt;   |                         用于删除数据                         |<br> |  &lt;&lt;c:forEach&gt;&gt;  |                基础迭代标签，接受多种集合类型                |<br> |    &lt;&lt;c:url&gt;&gt;    |               使用可选的查询参数来创造一个URL                |<br> |  &lt;&lt;c:choose&gt;&gt;   |        本身只当做&lt;&lt;c:when&gt;&gt;和&lt;&lt;c:otherwise&gt;&gt;的父标签         |<br> |   &lt;&lt;c:when&gt;&gt;    |          &lt;&lt;c:choose&gt;&gt;的子标签，用来判断条件是否成立          |<br> | &lt;&lt;c:otherwise&gt;&gt; | &lt;&lt;c:choose&gt;&gt;的子标签，接在&lt;&lt;c:when&gt;&gt;标签后，当&lt;&lt;c:when&gt;&gt;标签判断为false时被执行 |</p>
</li>
</ol>
<h3 id="JSP-JavaBean"><a href="#JSP-JavaBean" class="headerlink" title="JSP JavaBean"></a>JSP JavaBean</h3><p>JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的<a href="https://baike.baidu.com/item/构造器/9844976"><code>构造器</code></a>。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制(反射机制)发现和操作这些JavaBean 的属性。</p>
<ul>
<li>提供一个默认的无参构造函数。</li>
<li>需要被序列化并且实现了 Serializable 接口。</li>
<li>可能有一系列可读写属性。</li>
<li>可能有一系列的 <strong>getter</strong> 或 <strong>setter</strong> 方法</li>
</ul>
<p><strong>JavaBean 属性</strong></p>
<p>一个 JavaBean 对象的属性应该是可访问的。这个属性可以是任意合法的 Java 数据类型，包括自定义 Java 类。</p>
<p>一个 JavaBean 对象的属性可以是可读写，或只读，或只写。JavaBean 对象的属性通过 JavaBean 实现类中提供的两个方法来访问：</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>方法</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>getPropertyName()</strong></td>
<td style="text-align:left">举例来说，如果属性的名称为 myName，那么这个方法的名字就要写成 getMyName() 来读取这个属性。这个方法也称为访问器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>setPropertyName()</strong></td>
<td style="text-align:left">举例来说，如果属性的名称为 myName，那么这个方法的名字就要写成 setMyName()来写入这个属性。这个方法也称为写入器。</td>
</tr>
</tbody>
</table>
<p>一个只读的属性只提供 getPropertyName() 方法，一个只写的属性只提供 setPropertyName() 方法。</p>
<p><strong>访问JavaBean</strong></p>
<p>&lt;<a href="jsp:useBean">jsp:useBean</a>&gt;标签可以在 JSP 中声明一个 JavaBean，然后使用。声明后，JavaBean 对象就成了脚本变量，可以通过脚本元素或其他自定义标签来访问。&lt;<a href="jsp:useBean">jsp:useBean</a>&gt;标签的语法格式如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;bean 的名字&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.bobo.pojo.类名&quot;</span> scope=<span class="hljs-string">&quot;bean 的作用域&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>
<p>scope 的值可以是 page，request，session 或 application。id值可任意只要不和同一 JSP 文件中其它 &lt;<a href="jsp:useBean">jsp:useBean</a>&gt; 中 id 值一样就行了</p>
<p><strong>访问 JavaBean 对象的属性</strong></p>
<p>在 &lt;<a href="jsp:useBean">jsp:useBean</a>&gt; 标签主体中使用 &lt;<a href="jsp:getProperty/">jsp:getProperty/</a>&gt; 标签来调用 <strong>getter</strong> 方法，使用 &lt;<a href="jsp:setProperty/">jsp:setProperty/</a>&gt; 标签来调用 <strong>setter</strong> 方法，语法格式如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;bean 编译的类&quot;</span> scope=<span class="hljs-string">&quot;bean 作用域&quot;</span>&gt;<br>   &lt;jsp:setProperty name=<span class="hljs-string">&quot;bean 的 id&quot;</span> property=<span class="hljs-string">&quot;属性名&quot;</span>  <br>                    value=<span class="hljs-string">&quot;value&quot;</span>/&gt;<br>   &lt;jsp:getProperty name=<span class="hljs-string">&quot;bean 的 id&quot;</span> property=<span class="hljs-string">&quot;属性名&quot;</span>/&gt;<br>   ...........<br>&lt;/jsp:useBean&gt;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>JavaWeb,JSP,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie_Session</title>
    <url>/article/32177.html</url>
    <content><![CDATA[<blockquote>
<p>Take my wine in my own cup, friend.</p>
<p>It loses its wreath of foam when poured into that of others.</p>
<p>在我自己的杯中，饮了我的酒吧，朋友。</p>
<p>一倒在别人的杯里，这酒的腾跳的泡沫便要消失了。</p>
</blockquote>
<p><strong>会话（Session）</strong>跟踪是Web程序中常用的技术，用来<strong>跟踪用户的整个会话</strong>。常用的会话跟踪技术是Cookie与Session。<strong>Cookie通过在客户端记录信息确定用户身份</strong>，<strong>Session通过在服务器端记录信息确定用户身份</strong>。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><strong>客户端技术</strong></p>
<p>Cookie意为“甜饼”，是<strong>由W3C组织提出</strong>，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。</p>
<p>由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就<strong>给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理</strong>。</p>
<p>Java中把Cookie封装成了<code>javax.servlet.http.Cookie</code>类。每个Cookie都是该Cookie类的对象。服务器通过操作Cookie类对象对客户端Cookie进行操作。通过<strong>request.getCookie()获取客户端提交的所有Cookie</strong>（以Cookie[]数组形式返回），<strong>通过response.addCookie(Cookiecookie)向客户端设置Cookie。</strong></p>
<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ol>
<li><p>创建一个 Cookie 对象：可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>设置最大生存周期：</strong>可以使用 setMaxAge 方法来指定 cookie 能够保持有效的时间（以秒为单位）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">cookie.setMaxAge(<span class="hljs-number">60</span>*<span class="hljs-number">60</span>*<span class="hljs-number">24</span>); <br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>发送 Cookie 到 HTTP 响应头：</strong>可以使用 <strong>response.addCookie</strong> 来添加 HTTP 响应头中的 Cookie.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">response.addCookie(cookie);<br></code></pre></td></tr></table></figure>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>public void setDomain(String pattern)</strong></td>
<td style="text-align:center">该方法设置 cookie 适用的域</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getDomain()</strong></td>
<td style="text-align:center">该方法获取 cookie 适用的域</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setMaxAge(int expiry)</strong></td>
<td style="text-align:center">该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public int getMaxAge()</strong></td>
<td style="text-align:center">该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getName()</strong></td>
<td style="text-align:center">该方法返回 cookie 的名称。名称在创建后不能改变。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setValue(String newValue)</strong></td>
<td style="text-align:center">该方法设置与 cookie 关联的值。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getValue()</strong></td>
<td style="text-align:center">该方法获取与 cookie 关联的值。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setPath(String uri)</strong></td>
<td style="text-align:center">该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getPath()</strong></td>
<td style="text-align:center">该方法获取 cookie 适用的路径。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setSecure(boolean flag)</strong></td>
<td style="text-align:center">该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setComment(String purpose)</strong></td>
<td style="text-align:center">设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getComment()</strong></td>
<td style="text-align:center">获取 cookie 的注释，如果 cookie 没有注释则返回 null。</td>
</tr>
</tbody>
</table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>保存用户上一次访问的时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> javax.xml.crypto.Data;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">//保存用户上一次访问的时间</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cookieLastTime</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//服务器提供访问的时间  封装成一个信件</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><br><br>        PrintWriter out = resp.getWriter();<br>        <span class="hljs-comment">//cookie 服务器端从客户端获取</span><br>        Cookie[] cookies = req.getCookies();  <span class="hljs-comment">//返回数组  说明Cookie可能存在多个</span><br>        <span class="hljs-comment">//判断Cookie是否存在</span><br>        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//如果存在cookie</span><br>            out.write(<span class="hljs-string">&quot;你上一次访问的时间是：&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;cookies.length;i++) &#123;<br>                Cookie cookie = cookies[i];<br>                <span class="hljs-comment">//获得cookie名字</span><br>                <span class="hljs-keyword">if</span> (cookie.getName().equals(<span class="hljs-string">&quot;lastLoginTime&quot;</span>))&#123;<br>                    <span class="hljs-comment">//获取cookie中的值  parseLong()解析成长整型</span><br>                    <span class="hljs-keyword">long</span> lastLoginTime = Long.parseLong(cookie.getValue());<br>                    Date date = <span class="hljs-keyword">new</span> Date(lastLoginTime);<br>                    out.write(date.toLocaleString());<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            out.write(<span class="hljs-string">&quot;这是您第一次访问本站&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//服务给客户端响应一个cookie</span><br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;lastLoginTime&quot;</span>, System.currentTimeMillis()+<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//cookie有效期为1天</span><br>        cookie.setMaxAge(<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>);<br>        resp.addCookie(cookie);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>Cookie功能需要浏览器的支持</li>
</ul>
<img src="/article/32177/image-20220102212000322.png" class title="image-20220102212000322">
<p><strong>删除Cookie</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">//删除Cookie</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cookieDel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//服务器提供访问的时间  封装成一个信件</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><br>        <span class="hljs-comment">//创建一个Cookie，名字必须要和要删除的名字一致</span><br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;lastLoginTime&quot;</span>,System.currentTimeMillis()+<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//有效期设置为0 立马过期</span><br>        cookie.setMaxAge(<span class="hljs-number">0</span>);<br>        resp.addCookie(cookie);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>中文传递数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.URLDecoder;<br><span class="hljs-keyword">import</span> java.net.URLEncoder;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">//中文数据传递</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cookieEncode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//服务器提供访问的时间  封装成一个信件</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><br>        <span class="hljs-comment">//cookie 服务器端从客户端获取</span><br>        Cookie[] cookies = req.getCookies();  <span class="hljs-comment">//返回数组  说明Cookie可能存在多个</span><br>        PrintWriter out = resp.getWriter();<br>        <span class="hljs-comment">//判断Cookie是否存在</span><br>        <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//如果存在cookie</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;cookies.length;i++) &#123;<br>                Cookie cookie = cookies[i];<br>                <span class="hljs-comment">//获得cookie名字</span><br>                <span class="hljs-keyword">if</span> (cookie.getName().equals(<span class="hljs-string">&quot;name&quot;</span>))&#123;<br>                    <span class="hljs-comment">//中文解码  URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;);</span><br>                    String decode = URLDecoder.decode(cookie.getValue(), <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                    out.write(<span class="hljs-string">&quot;你访问名字为：&quot;</span> + decode);<br>                    System.out.println(decode);<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            out.write(<span class="hljs-string">&quot;这是您第一次访问本站&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//中文编码  URLEncoder.encode(&quot;波波&quot;,&quot;utf-8&quot;)</span><br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;name&quot;</span>, URLEncoder.encode(<span class="hljs-string">&quot;波波&quot;</span>,<span class="hljs-string">&quot;utf-8&quot;</span>));<br>        resp.addCookie(cookie);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>cookie的安全属性</strong></p>
<p>HTTP协议不仅是无状态的，而且是不安全的。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。使用HTTP协议传输很机密的内容是一种隐患。如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。下面的代码设置secure属性为true：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">&quot;time&quot;</span>, <span class="hljs-string">&quot;20080808&quot;</span>); <br><span class="hljs-comment">// 新建Cookie</span><br>cookie.setSecure(<span class="hljs-keyword">true</span>);                           <br><span class="hljs-comment">// 设置安全属性</span><br>response.addCookie(cookie);                        <br><span class="hljs-comment">// 输出到客户端</span><br></code></pre></td></tr></table></figure>
<p>提示：secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，<strong>需要在程序中对Cookie内容加密、解密，以防泄密</strong></p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><strong>服务器技术</strong></p>
<p><strong>Session是服务器端使用的一种记录客户端状态的机制</strong></p>
<p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p>Session对应的类为<code>javax.servlet.http.HttpSession</code>类。每个来访者对应一个Session对象，所有该客户的状态信息都保存在这个Session对象里。<strong>Session对象是在客户端第一次请求服务器的时候创建的</strong>。Session也是一种key-value的属性对，通过<code>getAttribute(Stringkey)</code>和<code>setAttribute(String key，Objectvalue)</code>方法读写客户状态信息。Servlet里通过<code>request.getSession()</code>方法获取该客户的Session。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>public Object getAttribute(String name)</strong></td>
<td style="text-align:center">该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public Enumeration getAttributeNames()</strong></td>
<td style="text-align:center">该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public long getCreationTime()</strong></td>
<td style="text-align:center">该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public String getId()</strong></td>
<td style="text-align:center">该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public long getLastAccessedTime()</strong></td>
<td style="text-align:center">该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public int getMaxInactiveInterval()</strong></td>
<td style="text-align:center">该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void invalidate()</strong></td>
<td style="text-align:center">该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public boolean isNew()</strong></td>
<td style="text-align:center">如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void removeAttribute(String name)</strong></td>
<td style="text-align:center">该方法将从该 session 会话移除指定名称的对象。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setAttribute(String name, Object value)</strong></td>
<td style="text-align:center">该方法使用指定的名称绑定一个对象到该 session 会话。</td>
</tr>
<tr>
<td style="text-align:center"><strong>public void setMaxInactiveInterval(int interval)</strong></td>
<td style="text-align:center">该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。</td>
</tr>
</tbody>
</table>
<h3 id="Session的生命周期"><a href="#Session的生命周期" class="headerlink" title="Session的生命周期"></a>Session的生命周期</h3><p>Session保存在服务器端。<strong>为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。</strong></p>
<p><strong>Session在用户第一次访问服务器的时候自动创建</strong>。需要注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。</p>
<p><strong>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session</strong>。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><strong>设置Session</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.*;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sessionLast</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//解决乱码问题</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>      <br>        <span class="hljs-comment">//得到Session</span><br>        HttpSession session = req.getSession();<br>        <span class="hljs-comment">//向Session存东西</span><br>        session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;bobo&quot;</span>);<br>      <br>        <span class="hljs-comment">//获取sessionID</span><br>        String sessionid = session.getId();<br>        <span class="hljs-comment">//判断是不是新创建的Session</span><br>        <span class="hljs-keyword">if</span> (session.isNew())&#123;<br>            resp.getWriter().write(<span class="hljs-string">&quot;Session创建成功，ID：&quot;</span> + sessionid);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            resp.getWriter().write(<span class="hljs-string">&quot;Session已在服务器中存在,ID:&quot;</span> + sessionid);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/32177/image-20220103101453948.png" class title="image-20220103101453948">
<ul>
<li>request还可以使用getSession(boolean create)来获取Session。区别是如果该客户的Session不存在，request.getSession()方法会返回null，而getSession(true)会先创建Session再将Session返回。</li>
</ul>
<p><strong>移除Session</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSession;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionDemo03</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        HttpSession session = req.getSession();<br>        session.removeAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br>        session.invalidate();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>设置 session 会话过期时间：</strong>可以调用 <code>public void setMaxInactiveInterval(int interval)</code> 方法来单独设置 session 会话超时。</li>
</ul>
<p><strong>在web.xml中设置Session默认失效时间</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--设置默认的失效时间--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>	<span class="hljs-comment">&lt;!--15分钟自动Session失效 以分钟为单位--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="Session对浏览器的要求"><a href="#Session对浏览器的要求" class="headerlink" title="Session对浏览器的要求"></a>Session对浏览器的要求</h3><p>虽然Session保存在服务器，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。HTTP协议是无状态的，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为JSESSIONID的Cookie，它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。</p>
<img src="/article/32177/Session-Cookie%E8%AF%86%E5%88%AB%E6%A0%87%E5%BF%97.png" class title="image-20220103103050610">
<p>该Cookie为服务器自动生成的，它的maxAge属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。</p>
<p>因此同一机器的两个浏览器窗口访问服务器时，会生成两个不同的Session。但是由浏览器窗口内的链接、脚本等打开的新窗口（也就是说不是双击桌面浏览器图标等打开的窗口）除外。这类子窗口会共享<strong>父窗口的Cookie</strong>，因此会共享一个Session。</p>
<p><strong>注意</strong>：新开的浏览器窗口会生成新的Session，但子窗口除外。子窗口会共用父窗口的Session。例如，在链接上右击，在弹出的快捷菜单中选择“在新窗口中打开”时，子窗口便可以访问父窗口的Session。</p>
<p>如果客户端浏览器将Cookie功能禁用，或者不支持Cookie怎么办？例如，绝大多数的手机浏览器都不支持Cookie。Java Web提供了另一种解决方案：<a href="#URL 重写">URL地址重写</a>。</p>
<h3 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h3><p>可以在每个 URL 末尾追加一些额外的数据来标识 session 会话，服务器会把该 session 会话标识符与已存储的有关 session 会话的数据相关联。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。</p>
<p>URL 重写是一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的<strong>缺点</strong>是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态 HTML 页面中也会如此。</p>
<p><code>HttpServletResponse</code>类提供了<code>encodeURL(Stringurl)</code>实现URL地址重写</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;td&gt;<br>    &lt;a href=<span class="hljs-string">&quot;&lt;%=response.encodeURL(&quot;</span>index.jsp?c=<span class="hljs-number">1</span>&amp;wd=Java<span class="hljs-string">&quot;) %&gt;&quot;</span>&gt;Homepage&lt;/a&gt;<br>&lt;/td&gt;<br></code></pre></td></tr></table></figure>
<p>该方法会自动判断客户端是否支持Cookie。如果客户端支持Cookie，会将URL原封不动地输出来。如果客户端不支持Cookie，则会将用户Session的id重写到URL中。</p>
<p>重写后的输出可能是这样的：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;td&gt;<br>&lt;ahref=<span class="hljs-string">&quot;index.jsp;jsessionid=0CCD096E7F8D97B0BE608AFDC3E1931E?c=1&amp;wd=Java&quot;</span>&gt;Homepage&lt;/a&gt;<br>&lt;/td&gt;<br></code></pre></td></tr></table></figure>
<p>如果是页面重定向（Redirection），URL地址重写可以这样写：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%<br>   <span class="hljs-keyword">if</span>(“administrator”.equals(userName))&#123;<br>    response.sendRedirect(response.encodeRedirectURL(“administrator.jsp”));<br>    <span class="hljs-keyword">return</span>;<br>   &#125;<br>%&gt;<br></code></pre></td></tr></table></figure>
<p>效果跟<code>response.encodeURL(String url)</code>是一样的：如果客户端支持Cookie，生成原URL地址，如果不支持Cookie，传回重写后的带有jsessionid字符串的地址。</p>
<p><strong>注意</strong>：TOMCAT判断客户端浏览器是否支持Cookie的依据是请求中是否含有Cookie。尽管客户端可能会支持Cookie，但是由于第一次请求时不会携带任何Cookie（因为并无任何Cookie可以携带），URL地址重写后的地址中仍然会带有jsessionid。当第二次访问时服务器已经在浏览器中写入Cookie了，因此URL地址重写后的地址中就不会带有jsessionid了。</p>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><ol>
<li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上</p>
<p>Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个）；</p>
<p>Session是把用户的数据写到用户独占的Session中，服务器保存（保存重要的信息，减少服务器资源的浪费）；</p>
<blockquote>
<p>简单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的session_id，服务器根据当前session_id判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。</p>
<p>由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的session_id，用特殊的浏览器伪造该用户的请求也是能够成功的。</p>
<p>session_id是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性。</p>
<p>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</p>
</blockquote>
</li>
<li><p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session；</p>
</li>
<li>设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话；</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie；</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)；</li>
</ol>
<p><strong>注意</strong>:</p>
<ul>
<li>session很容易失效,用户体验很差;</li>
<li>虽然cookie不安全,但是可以加密 ;</li>
<li>cookie也分为永久和暂时存在的;</li>
<li>浏览器 有禁止cookie功能 ,但一般用户都不会设置;</li>
<li>一定要设置失效时间,要不然浏览器关闭就消失了;</li>
</ul>
<p><strong>两者最大的区别在于生存周期，一个是浏览器启动到浏览器关闭.(浏览器页面一关 ,session就消失了)，一个是预先设置的生存周期，或永久的保存于本地的文件。(cookie)</strong></p>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Servlet</category>
        <category>Servlet</category>
        <category>Cookie_Session</category>
      </categories>
      <tags>
        <tag>Servlet,Cookie,Session</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode小点心</title>
    <url>/article/8368.html</url>
    <content><![CDATA[<blockquote>
<p>在我自己的杯中，饮了我的酒吧，朋友。　　　　　　　　　　　　　　　<br>一倒在别人的杯里，这酒的腾跳的泡沫便要消失了。　　　　　　　　　　<br>Take my wine in my own cup, friend.<br>It loses its wreath of foam when poured into that of others.</p>
</blockquote>
<p><a href="https://blog.csdn.net/syysyf99/article/details/106211336">https://blog.csdn.net/syysyf99/article/details/106211336</a></p>
<ol>
<li><p>Arraylist和数组互相转换</p>
<p>网上搜Arraylist和数组互相转换的方法时，举的例子都是String类型的</p>
<img src="/article/8368/20170629170103520.png" class title="img">
</li>
</ol>
<p>​    但是对于int类型如果这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; a=<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><span class="hljs-keyword">int</span>[] array=(<span class="hljs-keyword">int</span>[])a.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size]);<span class="hljs-comment">//会报错</span><br></code></pre></td></tr></table></figure>
<p>则会报错，这是因为int[]并不等同于Integer[]。因此如果换成Integer[]数组，则能正确运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>Integer[] array = list.toArray(<span class="hljs-keyword">new</span> Integer[list.size()]);<span class="hljs-comment">//能正确运行</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> element:array)&#123;<br>     System.out.println(element);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果非得希望得到int[]的话，只能用循环赋值来得到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;list.size();i++)&#123;<br>    d[i] = list.get(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果既不想用循环，又想要得到int[]，那就只能在jdk8中使用IntStream了。 </p>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>public int <strong>indexOf</strong>(int ch)返回指定<a href="https://baike.baidu.com/item/字符">字符</a>在此<a href="https://baike.baidu.com/item/字符串">字符串</a>中第一次出现处的索引</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/article/55715.html</url>
    <content><![CDATA[<blockquote>
<p>The hurricane seeks the shortest road by the no-road, and suddenly ends its search in the Nowhere.</p>
<p>风于无路之中寻求最短之路，又突然地在“无何有之国”终之了它的追求。</p>
</blockquote>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的<a href="https://baike.baidu.com/item/服务器/100571">服务器</a>端程序，具有独立于平台和<a href="https://baike.baidu.com/item/协议/13020269">协议</a>的特性，主要功能在于交互式地浏览和生成数据，生成动态<a href="https://baike.baidu.com/item/Web/150564">Web</a>内容。</p>
<p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于<a href="https://baike.baidu.com/item/HTTP协议/1276942">HTTP协议</a>的Web服务器。</p>
<p>最早支持Servlet标准的是JavaSoft的Java <a href="https://baike.baidu.com/item/Web Server/9306055">Web Server</a>，此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。</p>
<h3 id="Servlet原理"><a href="#Servlet原理" class="headerlink" title="Servlet原理"></a>Servlet原理</h3><p>Servlet运行过程</p>
<img src="/article/55715/Servlet%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B1.jpg" class title="资源分配图">
<p><strong>Servlet的工作过程</strong></p>
<p>步骤：</p>
<ol>
<li>Web Client 向Servlet容器（Tomcat）发出Http请求</li>
<li>Servlet容器接收Web Client的请求</li>
<li>Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。</li>
<li>Servlet容器创建一个HttpResponse对象</li>
<li>Servlet容器调用HttpServlet对象的doservice方法，把HttpRequest对象与HttpResponse对象作为参数传给HttpServlet 对象。</li>
<li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。</li>
<li>HttpServlet调用HttpResponse对象的有关方法，生成响应数据。</li>
<li>Servlet容器把HttpServlet的响应结果传给Web Client。</li>
</ol>
<blockquote>
<ol>
<li>客户端的网络请求首先会被Http服务器接收（也叫Web服务器、web容器，其需要提供web应用运行所需的环境，接收客户端的Http请求）；</li>
<li>Web服务器根据请求的路径将请求转交给对应的Servlet容器（也称Servlet引擎，为Servlet的运行提供环境支持，可以理解为tomcat或其他服务器）；</li>
<li>Servlet容器根据对应的虚拟路径（@WebServlet中配置的）来加载Servlet，如果Serlvet没有被实例化则创建该Servlet的一个实例（调用init方法）；</li>
<li>Servlet容器根据用户的HTTP请求，创建一个ServletRequest对象（HTTP的请求信息被封装在其中）和一个可以对HTTP请求进行响应的ServletResponse对象（类似于寄信，并在信中说明回信的地址），然后调用HttpServlet中重写的service(ServletRequest req, ServletResponse res)方法，并在这个方法中，将ServletRequest、ServletResponse这两个对象向下转型，得到我们非常熟悉的HttpServletRequest和HttpServletResponse两个对象，然后将客户端的请求转发到HttpServlet中protected修饰的service(HttpServletRequest req, HttpServletResponse resp）；</li>
<li>service(HttpServletRequest req, HttpServletResponse resp)根据请求的method（get、post、put、delete、head、options、trace）来调用不同的方法，如doGet、doPost；</li>
<li>服务端处理完Http的请求后，根据HttpServletResponse对象将处理结果作为Http响应返回给客户端。</li>
</ol>
</blockquote>
<p><strong>Servlet UML关系图</strong></p>
<p><img src="/article/Servlet UML关系图.png"><span class="image-caption">img</span></p>
<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a><strong>ServletContext</strong></h3><p>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；</p>
<ol>
<li><p><strong>共享数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ServletContext context = <span class="hljs-keyword">this</span>.getServletContext(); <br>context.setAttribute(<span class="hljs-string">&quot;数据key&quot;</span>,数据value); <span class="hljs-comment">//将一个数据保存</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>获取初始化参数</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--web.xml--&gt;</span> <br><span class="hljs-comment">&lt;!--配置一些web应用初始化参数--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/javaweb<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123; <br>  ServletContext context = <span class="hljs-keyword">this</span>.getServletContext(); <br>  String url = context.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>); <br>  resp.getWriter().print(url); <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>请求转发</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123; <br>  ServletContext context = <span class="hljs-keyword">this</span>.getServletContext(); <br>  <br>  context.getRequestDispatcher(<span class="hljs-string">&quot;/forwardpath&quot;</span>).forward(req,resp); <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>读取资源文件</strong></p>
<p>Properties</p>
<ul>
<li><p>在java目录下新建properties</p>
</li>
<li><p>在resources目录下新建properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">username</span>=<span class="hljs-string">root12312 </span><br><span class="hljs-attr">password</span>=<span class="hljs-string">zxczxczxc</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>发现：都被打包到了同一个路径下：classes，我们俗称这个路径为classpath:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123; <br>  InputStream is = <span class="hljs-keyword">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">&quot;/WEB- INF/classes/com/bobo/xx.properties&quot;</span>); <br>  Properties prop = <span class="hljs-keyword">new</span> Properties(); <br>  prop.load(is); <br>  String user = prop.getProperty(<span class="hljs-string">&quot;username&quot;</span>); <br>  String pwd = prop.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>  resp.getWriter().print(user+<span class="hljs-string">&quot;:&quot;</span>+pwd);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<img src="/article/55715/Servlet%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B2.jpg" class title="资源分配图">
<h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><ol>
<li><p>简单分类</p>
<p><strong>负责向浏览器发送数据的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">ServletOutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><span class="hljs-function">PrintWriter <span class="hljs-title">getWriter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br></code></pre></td></tr></table></figure>
<p> 从中我们可以看到，getOutputStream()方法返回ServletOutputStream对象，更适合向客户端写入二进制数据，并且Servlet容器不会对这些二进制数据进行编码，因此我们常用ServletOutputStream来向客户端发送如图片、文件等内容；对于getWriter()方法返回的PrintWriter对象，里面封装了更多的写入字符文本的函数，并且我们上文提到的setContentType()方法设置的MIME类型对其输出内容有效，因此也可以很好地解决中文乱码问题。</p>
<ul>
<li><p><strong>还有一点需要注意的是，这两个方法在一个response对象中不可以同时调用，否则会抛出一个IllegalStateException</strong>，也就是非法状态异常，因为输出流只能有一个（如果可以多次获取的话，客户端又如何确认哪个Http响应是最后一个呢）。</p>
<p><a href="https://blog.csdn.net/qq_34666857/article/details/104838171">点击跳转大佬</a></p>
</li>
</ul>
<p><strong>负责向浏览器发送响应头的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCharacterEncoding</span><span class="hljs-params">(String var1)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span> var1)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setContentType</span><span class="hljs-params">(String var1)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDateHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">long</span> var2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDateHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">long</span> var2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(String var1, String var2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addHeader</span><span class="hljs-params">(String var1, String var2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setIntHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">int</span> var2)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addIntHeader</span><span class="hljs-params">(String var1, <span class="hljs-keyword">int</span> var2)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>相应状态码的常量</strong></p>
<p>| Name |       discribtion        |                   释义                    |<br>| :–: | :———————-: | :—————————————: |<br>| 200  |          SC_OK           |             此次请求已经成功              |<br>| 301  |   SC_MOVED_PERMANENTLY   |       请求的网页已永久移动到新位置        |<br>| 302  |   SC_MOVED_TEMPORARILY   |          临时移动、请求地址不变           |<br>| 401  |     SC_UNAUTHORIZED      |            未授权、用户需登录             |<br>| 403  |       SC_FORBIDDEN       |     服务器拒绝了此次请求（权限问题）      |<br>| 404  |       SC_NOT_FOUND       |           服务器没找到URI匹配的           |<br>| 405  |  SC_METHOD_NOT_ALLOWED   |  调用的方法不允许使用（get、post不匹配）  |<br>| 500  | SC_INTERNAL_SERVER_ERROR |       服务器内部发生异常，请求中断        |<br>| 502  |      SC_BAD_GATEWAY      | 网关错误（如Nginx），无法收到服务器的响应 |<br>| 504  |    SC_GATEWAY_TIMEOUT    |  请求超时，在约定时间内没有收到Http响应   |</p>
</li>
<li><p>常见应用</p>
<ol>
<li><p>向浏览器输出信息</p>
</li>
<li><p>下载文件</p>
<ol>
<li>要获取下载文件的路径</li>
<li>下载的文件名</li>
<li>使浏览器可以支持下载 (Content-disposition) 中文文件名用  URLEncoder.encode 编码，否则可能乱码</li>
<li>获取下载文件输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区中的数据输出到客户端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URLEncoder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>      <br>        <span class="hljs-comment">//1.要获取下载文件的路径</span><br>        String realPath = <span class="hljs-string">&quot;绝对路径&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;下载的文件的路径：&quot;</span> + realPath);<br>        <span class="hljs-comment">//2.下载的文件名</span><br>        <span class="hljs-comment">//substring()截取字符串   lastIndexOf()截取/之后的字符串</span><br>        String fileName = realPath.substring(realPath.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//3.使浏览器可以支持下载 (Content-disposition)   attachment：以附件方式下载    中文文件名用  URLEncoder.encode 编码，否则可能乱码</span><br>        resp.setHeader(<span class="hljs-string">&quot;Content-disposition&quot;</span>,<span class="hljs-string">&quot;attachment;filename&quot;</span> + URLEncoder.encode(<span class="hljs-string">&quot;fileName&quot;</span>,<span class="hljs-string">&quot;utf-8&quot;</span>));<br>        <span class="hljs-comment">//4.获取下载文件输入流</span><br>        FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>        <span class="hljs-comment">//5.创建缓冲区</span><br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//6.获取OutputStream对象</span><br>        ServletOutputStream out = resp.getOutputStream();<br>        <span class="hljs-comment">//7.将FileOutputStream流入到buffer缓冲区</span><br>      	<span class="hljs-comment">//in.read(buffer)</span><br>        <span class="hljs-comment">//8.使用OutputStream将缓冲区中的数据输出到客户端</span><br>        <span class="hljs-keyword">while</span> ((len = in.read(buffer))&gt; <span class="hljs-number">0</span>)&#123;<br>            out.write(buffer,<span class="hljs-number">0</span>,len);<br>        &#125;<br>        in.close();<br>        out.close();<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>验证码功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//如何让浏览器5s自动刷新一次</span><br>        resp.setHeader(<span class="hljs-string">&quot;refresh&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-comment">//在内存中创建一个图片</span><br>        BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(<span class="hljs-number">80</span>,<span class="hljs-number">20</span>,BufferedImage.TYPE_INT_RGB);<br>        <span class="hljs-comment">//得到图片</span><br>        Graphics2D g = (Graphics2D) image.getGraphics();<br>        <span class="hljs-comment">//设置图片背景颜色</span><br>        g.setColor(Color.white);<br>        g.fillRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">80</span>,<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">//给图片写数据</span><br>        g.setColor(Color.BLUE);<br>        g.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-keyword">null</span>,Font.BOLD,<span class="hljs-number">20</span>));<br><br>        g.drawString(makeNum(),<span class="hljs-number">0</span>,<span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">//告诉浏览器这个请求用图片方式打开</span><br>        resp.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);<br>        <span class="hljs-comment">//网站存在缓存 不让浏览器缓存</span><br>        resp.setDateHeader(<span class="hljs-string">&quot;expires&quot;</span>,-<span class="hljs-number">1</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;pragma&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br><br>        <span class="hljs-comment">//将图片写给浏览器</span><br>        <span class="hljs-keyword">boolean</span> write = ImageIO.write(image,<span class="hljs-string">&quot;png&quot;</span>, resp.getOutputStream());<br>    &#125;<br><br>    <span class="hljs-comment">//生成随机数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">makeNum</span><span class="hljs-params">()</span></span>&#123;<br>        Random random = <span class="hljs-keyword">new</span> Random();<br>      	<span class="hljs-comment">//6个9 代表6位数</span><br>        String num = random.nextInt(<span class="hljs-number">999999</span>) + <span class="hljs-string">&quot;&quot;</span>;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();  <br>      	<span class="hljs-comment">//保证输出6位数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>-num.length() ; i++) &#123;<br>            sb.append(<span class="hljs-string">&quot;0&quot;</span>);<br>        &#125;<br>        String s = sb.toString() + num;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>实现重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//resp.setHeader(&quot;location&quot;,&quot;/&quot;);</span><br><span class="hljs-comment">//resp.setStatus(302);//重定向常量</span><br><span class="hljs-comment">//重定向一定要注意路径问题</span><br>resp.sendRedirect(<span class="hljs-string">&quot;/img&quot;</span>);   <span class="hljs-comment">//重定向</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><p>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过HttpServletRequest方法，获得客户端的所有信息。</p>
<img src="/article/55715/image-20220102153458150.png" class title="image-20220102153458150">
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Cookie[] getCookies()</strong></td>
<td style="text-align:left">返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</td>
</tr>
<tr>
<td style="text-align:left"><strong>ServletInputStream getInputStream()</strong></td>
<td style="text-align:left">使用 ServletInputStream，以二进制数据形式检索请求的主体。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getCharacterEncoding()</strong></td>
<td style="text-align:left">返回请求主体中使用的字符编码的名称。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getContentType()</strong></td>
<td style="text-align:left">返回请求主体的 MIME 类型，如果不知道类型则返回 null。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getContextPath()</strong></td>
<td style="text-align:left">返回指示请求上下文的请求 URI 部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getHeader(String name)</strong></td>
<td style="text-align:left">以字符串形式返回指定的请求头的值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getMethod()</strong></td>
<td style="text-align:left">返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getParameter(String name)</strong></td>
<td style="text-align:left">以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getPathInfo()</strong></td>
<td style="text-align:left">当请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getProtocol()</strong></td>
<td style="text-align:left">返回请求协议的名称和版本。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getQueryString()</strong></td>
<td style="text-align:left">返回包含在路径后的请求 URL 中的查询字符串。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getRemoteAddr()</strong></td>
<td style="text-align:left">返回发送请求的客户端的互联网协议（IP）地址。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getRemoteHost()</strong></td>
<td style="text-align:left">返回发送请求的客户端的完全限定名称。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getRemoteUser()</strong></td>
<td style="text-align:left">如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getRequestURI()</strong></td>
<td style="text-align:left">从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getRequestedSessionId()</strong></td>
<td style="text-align:left">返回由客户端指定的 session 会话 ID。</td>
</tr>
<tr>
<td style="text-align:left"><strong>String getServletPath()</strong></td>
<td style="text-align:left">返回调用 JSP 的请求的 URL 的一部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>int getContentLength()</strong></td>
<td style="text-align:left">以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。</td>
</tr>
<tr>
<td style="text-align:left"><strong>int getIntHeader(String name)</strong></td>
<td style="text-align:left">返回指定的请求头的值为一个 int 值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>int getServerPort()</strong></td>
<td style="text-align:left">返回接收到这个请求的端口号。</td>
</tr>
<tr>
<td style="text-align:left"><strong>int getParameterMap()</strong></td>
<td style="text-align:left">将参数封装成 Map 类型。</td>
</tr>
</tbody>
</table>
<ol>
<li><p>获取前端参数，请求转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.servlet;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doGet(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//后台接收中文乱码问题  </span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><br>        String username = req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        String password = req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;============================&quot;</span>);<br>        <br>        System.out.println(username);<br>        System.out.println(password);<br>        System.out.println(<span class="hljs-string">&quot;============================&quot;</span>);<br><br>        <span class="hljs-comment">//通过请求转发</span><br>        <span class="hljs-comment">// 这里的/代表当前的web应用</span><br>        req.getRequestDispatcher(<span class="hljs-string">&quot;/success.jsp&quot;</span>).forward(req,resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie_Session"></a>Cookie_Session</h2><p><strong>会话（Session）</strong>跟踪是Web程序中常用的技术，用来<strong>跟踪用户的整个会话</strong>。常用的会话跟踪技术是Cookie与Session。<strong>Cookie通过在客户端记录信息确定用户身份</strong>，<strong>Session通过在服务器端记录信息确定用户身份</strong>。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie意为“甜饼”，是<strong>由W3C组织提出</strong>，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。</p>
<p>　　由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就<strong>给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理</strong>。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。<strong>Session是服务器端使用的一种记录客户端状态的机制</strong>，使用上比Cookie简单一些，相应的也<strong>增加了服务器的存储压力</strong>。</p>
<p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<a href="/article/32177.html" title="点击跳转Cookie_Session详解">点击跳转Cookie_Session详解</a>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>JavaWeb,Java,Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>/article/60206.html</url>
    <content><![CDATA[<blockquote>
<p>My day is done, and I am like a boat drawn on the beach,listening to the dance-music of the tide in the evening.</p>
<p>我的白昼已经完了，我象一只泊在海滩上的小船，谛听着晚潮跳舞的乐声。　</p>
</blockquote>
<p>Java Web，是用Java技术来解决相关web互联网领域的技术栈。web包括：web<a href="https://baike.baidu.com/item/服务端/6492316">服务端</a>和web<a href="https://baike.baidu.com/item/客户端/101081">客户端</a>两部分。Java在客户端的应用有Java Applet，不过<a href="https://baike.baidu.com/item/使用/7741550">使用</a>得很少，Java在<a href="https://baike.baidu.com/item/服务器端/3369401">服务器端</a>的应用非常的丰富，比如<a href="https://baike.baidu.com/item/Servlet/477555">Servlet</a>，<a href="https://baike.baidu.com/item/JSP/141543">JSP</a>、第三方<a href="https://baike.baidu.com/item/框架/1212667">框架</a>等等。Java技术对Web领域的发展注入了强大的动力。</p>
<h2 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h2><p>搭建Java Web应用的开发环境—–部署Tomcat服务器、用eclipse创建Server服务、构建Java Web项目、建立第一个JSP文件、 运行JSP文件。</p>
<p>第一个要点是掌握<a href="https://baike.baidu.com/item/tomcat/255751">tomcat</a>的安装和部署。</p>
<p>第二个要点是在IDEA中添加Server服务。把tomcat与IDEA进行关联，方便IDEA管理tomcat。</p>
<p>第三个要点是构建Java Web项目。Web项目开发的第一步就是要建立项目。</p>
<p>第四个要点是建立的项目如何在<a href="https://baike.baidu.com/item/Server/8873208">Server</a>中运行。</p>
<h3 id="Maven项目管理工具"><a href="#Maven项目管理工具" class="headerlink" title="Maven项目管理工具"></a>Maven项目管理工具</h3><p>Maven的核心思想：<strong>约定大于配置</strong></p>
<a href="/article/37040.html" title="&#96;点击跳转Maven配值&#96;">&#96;点击跳转Maven配值&#96;</a>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><a href="/article/55715.html" title="点击跳转Servlet详解">点击跳转Servlet详解</a>
<p>Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的<a href="https://baike.baidu.com/item/服务器/100571">服务器</a>端程序，具有独立于平台和<a href="https://baike.baidu.com/item/协议/13020269">协议</a>的特性，主要功能在于交互式地浏览和生成数据，生成动态<a href="https://baike.baidu.com/item/Web/150564">Web</a>内容。</p>
<p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于<a href="https://baike.baidu.com/item/HTTP协议/1276942">HTTP协议</a>的Web服务器。</p>
<p>最早支持Servlet标准的是JavaSoft的Java <a href="https://baike.baidu.com/item/Web Server/9306055">Web Server</a>，此后，一些其它的基于Java的Web服务器开始支持标准的Servlet。</p>
<a href="/article/37040.html" title="&#96;点击跳转Servlet配值&#96;">&#96;点击跳转Servlet配值&#96;</a>
<p><strong>写一个Servlet程序</strong></p>
<ol>
<li><p>写一个类去继承父类HttpServlet<br>HttpServlet是一个抽象类，但是没有任何抽象方法<br>HttpServlet类中自定义了很多doXxxx方法，每一种方法都对应了浏览器发送请求的方法，一般常用的浏览器发请求方式为get和post，这两种方式分别对应了这个类中的doGet方法和doPost方法。<br>HttpServlet类中，有两个service方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>      PrintWriter writer = resp.getWriter();   <span class="hljs-comment">//响应流 			   </span><br>      writer.print(<span class="hljs-string">&quot;Hello,Serlvet&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-keyword">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>在web.xml里面添加Servlet配置</p>
<p>Servlet映射</p>
<p><a href="#Mapping问题">点击跳转servlet映射问题</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ServletClass<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.bobo.servlet.ServletClass<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>ServletClass<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/path<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>配置Tomcat</p>
<img src="/article/60206/%E9%85%8D%E7%BD%AEtomcat0.png" class title="配置tomcat0">
<img src="/article/60206/%E9%85%8D%E7%BD%AEtomcat1.png" class title="image-20220101162955274">
<img src="/article/60206/%E9%85%8D%E7%BD%AEtomcat2.png" class title="image-20220101163103863">
<img src="/article/60206/%E9%85%8D%E7%BD%AEtomcat3.png" class title="image-20220101163153053">
</li>
<li><p>启动Tomcat服务</p>
</li>
</ol>
<h4 id="Servlet原理"><a href="#Servlet原理" class="headerlink" title="Servlet原理"></a>Servlet原理</h4><p><strong>Servlet的工作过程</strong></p>
<p>步骤：</p>
<ol>
<li>Web Client 向Servlet容器（Tomcat）发出Http请求</li>
<li>Servlet容器接收Web Client的请求</li>
<li>Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。</li>
<li>Servlet容器创建一个HttpResponse对象</li>
<li>Servlet容器调用HttpServlet对象的doservice方法，把HttpRequest对象与HttpResponse对象作为参数传给HttpServlet 对象。</li>
<li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。</li>
<li>HttpServlet调用HttpResponse对象的有关方法，生成响应数据。</li>
<li>Servlet容器把HttpServlet的响应结果传给Web Client。</li>
</ol>
<h4 id="Mapping问题"><a href="#Mapping问题" class="headerlink" title="Mapping问题"></a>Mapping问题</h4><ul>
<li><p>一个Servlet可以指定一个映射路径</p>
</li>
<li><p>一个Servlet可以指定多个映射路径</p>
</li>
<li><p>一个Servlet可以指定通用映射路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>默认请求路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--默认请求路径--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>指定一些后缀或者前缀</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以自定义后缀实现请求映射 注意点，*前面不能加项目映射的路径--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.bobo<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>优先级问题</p>
<p>指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--404--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.bobo.servlet.ErrorServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p><strong>JSP</strong>（全称<strong>J</strong>ava<strong>S</strong>erver <strong>P</strong>ages）是由<a href="https://baike.baidu.com/item/Sun Microsystems">Sun Microsystems</a>公司主导创建的一种<a href="https://baike.baidu.com/item/动态网页技术/9415956">动态网页技术</a>标准。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成<a href="https://baike.baidu.com/item/HTML">HTML</a>、<a href="https://baike.baidu.com/item/XML">XML</a>或其他格式文档的<a href="https://baike.baidu.com/item/Web">Web</a>网页，然后返回给请求者。JSP技术以<a href="https://baike.baidu.com/item/Java">Java</a>语言作为<a href="https://baike.baidu.com/item/脚本语言">脚本语言</a>，为用户的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。</p>
<p>JSP将Java代码和特定变动内容嵌入到静态的页面中，实现以静态页面为模板，动态生成其中的部分内容。JSP引入了被称为“JSP动作”的XML标签，用来调用内建功能。另外，可以创建JSP标签库，然后像使用标准HTML或XML标签一样使用它们。标签库能增强功能和服务器性能，而且不受<a href="https://baike.baidu.com/item/跨平台">跨平台</a>问题的限制。JSP文件在运行时会被其编译器转换成更原始的<a href="https://baike.baidu.com/item/Servlet">Servlet</a>代码。JSP编译器可以把JSP文件编译成用Java代码写的Servlet，然后再由Java编译器来编译成能快速执行的二进制<a href="https://baike.baidu.com/item/机器码">机器码</a>，也可以直接编译成二进制码。</p>
<a href="/article/6685.html" title="点击跳转JSP">点击跳转JSP</a>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><a href="/article/30326.html" title="点击跳转MVC三层架构">点击跳转MVC三层架构</a>
<p>MVC指MVC模式的某种框架，它强制性地使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。最典型的MVC就是<a href="/article/6685.html" title="JSP">JSP</a> + <a href="/article/55715.html" title="servlet">servlet</a> + <a href="/article/6685.html" title="JavaBean">JavaBean</a>的模式。</p>
<p><strong>视图View</strong></p>
<p>负责页面的显示；与用户的交互。包含各种表单。</p>
<p><strong>控制器Controller</strong></p>
<p>控制器负责将视图与模型一一对应起来。相当于一个模型分发器。所谓分发就是：①接收请求，并将该请求跳转（转发，重定向）到模型进行处理。②模型处理完毕后，再通过控制器，返回给视图中的请求处。建议使用Servlet实现控制器。</p>
<p><strong>模型Model</strong></p>
<p>模型负责各个功能的实现（如登录、增加、删除功能）。模型用JavaBean实现。</p>
<blockquote>
<p>JavaBeans :<br>①是Java中一种特殊的类（换言之：JavaBean就是一个Java类）.<br>一个Java类 ，满足以下要求，则可称为一个JavaBean<br>  a. public修饰的类，提供public 无参构造方法<br>  b. 所有属性 都是private<br>  c. 提供getter和setter方法</p>
<p>②从使用层面来看，JavaBean分为2大类：<br>  a. 封装业务逻辑的JavaBean （eg:LoginDao.java 封装了登录逻辑）<br>  b. 封装数据的JavaBean （实体类：eg：Student.java  Vedio.java 。往往对应于数据库中的一张表，即数据库中有个Student表，项目中就有个Student.java类）</p>
<p>③JavaBean 是一个可以重复使用的组件，通过编写一个组件来实现某种通用功能，“一次编写、任何地方执行、任何地方重用”。</p>
</blockquote>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><img src="/article/60206/%E8%BF%87%E6%BB%A4%E5%99%A8.png" class title="img">
<p><strong>过滤器如何编写</strong></p>
<ol>
<li><p>过滤器(Filter接口)是一个接口，所以需要一个实现这个接口的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>filterChain.doFilter()方法；</strong><br>执行目标资源，或是执行下一个过滤器！如果没有下一个过滤器那么执行的是目标资源，如果有，那么执行下一个过滤器</p>
</li>
</ol>
<ol start="2">
<li><p>配置:在<code>web.xml</code>文件中配置，配置之后才会有效果，就如servlet一样</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>MyFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.bobo.filter.MyFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>MyFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>  	<span class="hljs-comment">&lt;!--只要是/filter下面的任何请求都会经过这个过滤器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/filter/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>多个过滤器的执行顺序</strong></p>
<p>配置顺序决定了过滤器的执行顺序<br>就是哪个文件在第一个，谁就是第一个执行</p>
<p><strong>过滤器的四种拦截方式</strong>：</p>
<ul>
<li>REQUEST 是默认的，当输入其他的，那么默认的将取消（消失）</li>
<li>请求（拦的是直接请求，不拦转发请求）：REQUEST</li>
<li>转发（专门拦转发）：FORWARD</li>
<li>包含（专门拦包含）：INCLUDE</li>
<li>错误（专门拦错误）：ERROR</li>
</ul>
</li>
</ol>
<p><strong>Filter接口的生命周期</strong></p>
<p>初始化(init())到使用（doFilter()）到关闭之前（destroy()）</p>
<ol>
<li>init(FilterConfig)<br>什么执行：创建Filter之后，马上执行；<br>什么时候创建呢：Filter会在服务器启动时就创建</li>
<li>doFilter(ServletRequest,ServletResponse,FilterChain)<br>什么时候执行：每次过滤时都会执行</li>
<li>destroy()<br>什么时候执行：在销毁之前执行<br>什么时候销毁呢：在服务器关闭时销毁</li>
</ol>
<blockquote>
<p>当启动服务器时init方法马上执行了（在还没打开网页前已经执行了）<br>在过滤时(网页刷新时)才运行doFilter方法<br>当关掉服务器时执行destroy方法，就是当你点击关闭服务器是，就在执行了，伴随关闭一起执行</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CharaterEncodingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-comment">//web服务启动就初始化</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;CharaterEncodingFilter初始化&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        servletRequest.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        servletResponse.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>        <span class="hljs-comment">//chain链</span><br>        <span class="hljs-comment">//过滤中的所有代码，在特定请求的时候都会执行</span><br>        <span class="hljs-comment">//必须要让过滤器继续同行</span><br>        System.out.println(<span class="hljs-string">&quot;CharaterEncodingFilter执行前&quot;</span>);<br>        filterChain.doFilter(servletRequest,servletResponse);  <span class="hljs-comment">//让我们的请求继续走，如果不写，程序到这里就会被拦截</span><br>        System.out.println(<span class="hljs-string">&quot;CharaterEncodingFilter执行后&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//注销</span><br>    <span class="hljs-comment">//web服务器关闭时 过滤会注销</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;CharaterEncodingFilter注销&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>通过监听获取Seesion中用户</strong></p>
<p>因为要用到HttpServletRequest中的方法，所以对ServletRequest进行了强转，将<code>ServletRequest servletRequest</code>强制转换为子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">HttpServletRequest req = (HttpServletRequest) servletRequest;<br></code></pre></td></tr></table></figure>
<p>此时有一些困惑：子类除了完全继承父类的方法外还会拓展自己的方法，所以我们在调用子类方法时可能在父类实现中是找不到的，所以向下转型不安全的。</p>
<p>其实<code>doFilter</code>的参数request对象的生成方式不是<code>ServletRequest request = new ServletRequest();</code>这种形式，而是<code>ServletRequest request = new HttpServletRequest();</code>这种形式，参数里的request不是父类ServletRequest的对象，而是HttpServletRequest的上转型对象。</p>
<p>在这篇<a href="https://www.cnblogs.com/gwyy/p/9078135.html">博客</a>中，博主给了很好的解释。</p>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>监听器就是监听某个对象的的状态变化的组件</p>
<ul>
<li>被监听的对象（三个域对象 request，session，servletContext）</li>
<li>监听器：监听事件源对象， 事件源对象的状态的变化都会触发监听器 。</li>
<li>注册监听器：将监听器与事件源进行绑定。</li>
<li>响应行为：监听器监听到事件源的状态变化时，所涉及的功能代码（程序员编写代码）</li>
</ul>
<p>监听器的编写步骤：</p>
<ol>
<li><p>编写一个监听器类去实现监听器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.http.HttpSessionEvent;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSessionListener;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>覆盖监听器的方法</p>
</li>
<li><p>需要在web.xml中进行配置（注册）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    注册监听器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">listenerclass</span>&gt;</span>com.bobo.listenre.MyListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.servlet.ServletContext;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSessionEvent;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpSessionListener;<br><br><span class="hljs-comment">//统计网站在线人数 --统计session</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpSessionListener</span></span>&#123;<br>    <span class="hljs-comment">//创建session的监听</span><br>    <span class="hljs-comment">//一旦创建session就会触发一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;<br>        ServletContext ctx = httpSessionEvent.getSession().getServletContext();<br>        System.out.println(httpSessionEvent.getSession().getId());<br>        Integer onlineCount =(Integer) ctx.getAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>);<br>        <span class="hljs-keyword">if</span> (onlineCount==<span class="hljs-keyword">null</span>)&#123;<br>            onlineCount = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> count = onlineCount.intValue();<br>            onlineCount = <span class="hljs-keyword">new</span> Integer(count+<span class="hljs-number">1</span>);<br>        &#125;<br>        ctx.setAttribute(<span class="hljs-string">&quot;onlineCount&quot;</span>,onlineCount);<br>    &#125;<br>    <span class="hljs-comment">//销毁session的监听</span><br>    <span class="hljs-comment">//一旦销毁session就会触发一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> </span>&#123;<br>        ServletContext ctx = httpSessionEvent.getSession().getServletContext();<br><br>        Integer onlineCount =(Integer) ctx.getAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>);<br>        <span class="hljs-keyword">if</span> (onlineCount==<span class="hljs-keyword">null</span>)&#123;<br>            onlineCount = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> count = onlineCount.intValue();<br>            onlineCount = <span class="hljs-keyword">new</span> Integer(count-<span class="hljs-number">1</span>);<br>        &#125;<br>        ctx.setAttribute(<span class="hljs-string">&quot;onlineCount&quot;</span>,onlineCount);<br>    &#125;<br><br><span class="hljs-comment">//    session销毁：</span><br>    <span class="hljs-comment">//1。手动销毁  httpSessionEvent.getSession().invalidate();</span><br>    <span class="hljs-comment">//2。自动销毁   web.xml中配置</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&lt;%@ page contentType=&quot;text/html; charset=utf-8&quot; language=&quot;java&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.055ex" height="2.176ex" style="vertical-align: -0.338ex;" viewbox="0 -791.3 2176.5 936.9" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">Title</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMATHI-54" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/>
<path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/>
<path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/>
<path stroke-width="1" id="E1-MJMATHI-6C" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/>
<path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMATHI-54" x="0" y="0"/>
 <use xlink:href="#E1-MJMATHI-69" x="704" y="0"/>
 <use xlink:href="#E1-MJMATHI-74" x="1050" y="0"/>
 <use xlink:href="#E1-MJMATHI-6C" x="1411" y="0"/>
 <use xlink:href="#E1-MJMATHI-65" x="1710" y="0"/>
</g>
</svg><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>当前有<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&lt;%=this.getServletConfig().getServletContext().getAttribute(&quot;onlineCount&quot;)%&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>人在线<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>首先导入<code>commons-io-版本.jar</code>与<code>commons-fileupload-版本.jar</code></p>
<p>注意事项：</p>
<ol>
<li>为保证服务器安全，上传文件应该放在外界无法直接访问的目录下，比如放于WEB-INF目录下。</li>
<li>为防止文件覆盖的现象发生，要为上传文件产生一个唯一的文件名。</li>
<li>为防止一个目录下面出现太多文件，要使用hash算法打散存储。</li>
<li>要限制上传文件的最大值。</li>
<li>要限制上传文件的类型，在收到上传文件名时，判断后缀名是否合法。</li>
</ol>
<p><strong>通过表单上传文件</strong></p>
<ul>
<li>get  上传文件大小有限制</li>
<li>post   上传文件大小没有限制</li>
</ul>
<p>必须要用 post 进行提交，这种方式，将会把数据封装在请求体中进行发送。</p>
<p><strong>使用的类</strong></p>
<ol>
<li><p>FileItem类</p>
<p>表单如果包含一个文件上传输入选项，这个表单的<code>enctype</code>属性必须设置为<code>enctype=&quot;multipart/form-date&quot;</code>。</p>
</li>
<li><p>ServletFileUpload类</p>
<p>负责处理上传的文件数据，并将表单中的每个输入项封装成一个<code>FileItem</code>对象，使用parseRequest(HttpServletReqquest)方法可以将通过表单中的每一个HTML标签提交的数据封装成一个FileItem对象，然后以List列表的形式返回。</p>
<p>在使用<code>ServletFileUpload</code>对象解析请求时需要<code>DiskFileItemFactory</code>对象，所以，我们需要在进行解析工作前构造好<code>DiskFileItemFactory</code>对象，并通过<code>ServletFileUpload</code>对象的构造方法或<code>setFileItemFactory()</code>方法设置<code>ServletFileUpload</code>对象的<code>fileItmlFactory</code>属性。</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/linghuainian/article/details/82253247">博文推荐</a></p>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>Java</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>配置</title>
    <url>/article/37040.html</url>
    <content><![CDATA[<blockquote>
<p>You idol is shattered in the dust to prove that God’s dust is greaterthan your idol.</p>
<p>你的偶像委散在尘土中了，这可证明神的尘土比你的偶像还伟大。</p>
</blockquote>
<h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><p><a href="https://mvnrepository.com">Maven仓库</a></p>
<p><strong>Maven头部</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>Maven资源导出配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resources  防止我们资源导出失败的问题--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a><strong>web.xml</strong></h2><p><code>web.xml</code>头文件要保持最新，与maven版本一致</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">metadata-complete</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="Servlet配置"><a href="#Servlet配置" class="headerlink" title="Servlet配置"></a>Servlet配置</h2><h3 id="Servlet依赖包"><a href="#Servlet依赖包" class="headerlink" title="Servlet依赖包"></a>Servlet依赖包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="JSP依赖包"><a href="#JSP依赖包" class="headerlink" title="JSP依赖包"></a>JSP依赖包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Servlet依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- JSP依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--JSTL表达式依赖--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--standard标签库依赖--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="数据库依赖包"><a href="#数据库依赖包" class="headerlink" title="数据库依赖包"></a>数据库依赖包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="Mybatis配置"><a href="#Mybatis配置" class="headerlink" title="Mybatis配置"></a><strong>Mybatis配置</strong></h2><p><strong>Maven导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>从 XML 中构建 SqlSessionFactory</strong></p>
<p>在<code>rescouces</code>文件下创建<code>mybatis-config.xml</code>配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String resource = <span class="hljs-string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;<br>InputStream inputStream = Resources.getResourceAsStream(resource);<br>SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br></code></pre></td></tr></table></figure>
<p><strong>Mybatis日志</strong></p>
<p>SLF4J | <strong>LOG4J(deprecated since 3.5.9)</strong> | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | <strong>STDOUT_LOGGING</strong> | NO_LOGGING</p>
<p><strong>STDOUT_LOGGING</strong> 标准日志输出</p>
<p><code>mybatis-config.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--标准日志工厂实现--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>LOG4J(deprecated since 3.5.9)</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--LOG4J日志--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;LOG4J&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>使用LOG4J需要添加propertise配置文件<code>log4j.properties</code>(直接百度)</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">DEBUG,console,file</span><br><br><span class="hljs-meta">log4j.appender.console</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.console.Target</span> = <span class="hljs-string">System.out</span><br><span class="hljs-meta">log4j.appender.console.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.console.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">[%c]-%m%n</span><br><br><span class="hljs-meta">log4j.appender.file</span> = <span class="hljs-string">org.apache.log4j.RollingFileAppender</span><br><span class="hljs-meta">log4j.appender.file.File</span>=<span class="hljs-string">./log/bobo.log</span><br><span class="hljs-meta">log4j.appender.file.MaxFileSize</span>=<span class="hljs-string">10mb</span><br><span class="hljs-meta">log4j.appender.file.Threshold</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.appender.file.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="hljs-string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><br><br><span class="hljs-meta">log4j.logger.org.mybatis</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.Statement</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.ResultSet</span>=<span class="hljs-string">DEBUG</span><br><span class="hljs-meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="hljs-string">DEBUG</span><br></code></pre></td></tr></table></figure>
<h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><p><strong>maven导入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>IOC配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- more bean definitions go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>AOP配置</strong></p>
<p><code>XML配置</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd </span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/aop </span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;</span>&gt;</span><br><br>   <span class="hljs-comment">&lt;!-- bean definition &amp; AOP specific configuration --&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>Maven配置</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>Spring-Mybatis整合 导入Maven依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--单元测试--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--数据库--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--Mybatis--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--Spring操作数据库的，还需要一个Spring-jdbc--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--AOP--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--mybatis-spring--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--lombok注解--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="Spring-自动装配-注解配置"><a href="#Spring-自动装配-注解配置" class="headerlink" title="Spring 自动装配 注解配置"></a>Spring 自动装配 注解配置</h3><p>从 Spring 2.5 开始就可以使用<strong>注解</strong>来配置依赖注入。而不是采用 XML 来描述一个 bean 连线，你可以使用相关类，方法或字段声明的注解，将 bean 配置移动到组件类本身。</p>
<p>在 XML 注入之前进行注解注入，因此后者的配置将通过两种方式的属性连线被前者重写。</p>
<p>使用注解配置文件 <code>applicaitonContext.xml</code> 导入<code>context</code> 约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">    http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- 开启注解支持 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>注解</th>
<th>注解 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Required</td>
<td>@Required 注解应用于 bean 属性的 setter 方法。</td>
</tr>
<tr>
<td>@Autowired</td>
<td>@Autowired 注解可以应用到 bean 属性的 setter 方法，非 setter 方法，构造函数和属性。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>通过指定确切的将被连线的 bean，@Autowired 和 @Qualifier 注解可以用来删除混乱。</td>
</tr>
<tr>
<td>JSR-250 Annotations</td>
<td>Spring 支持 JSR-250 的基础的注解，其中包括了 @Resource，@PostConstruct 和 @PreDestroy 注解。</td>
</tr>
</tbody>
</table>
<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><ol>
<li><p>首先，我们从所属范围来看，事实上这个注解是属于 Spring 的容器配置的一个注解@Autowired 注解是一个用于容器 ( container ) 配置的注解。</p>
</li>
<li><p>其次，我们可以直接从字面意思来看，@autowired 注解来源于英文单词 autowire,这个单词的意思是自动装配的意思。</p>
</li>
<li><p>自动装配指的就是使用将 Spring 容器中的 bean 自动的和我们需要这个 bean 的类组装在一起。</p>
</li>
</ol>
<ul>
<li>将 @Autowired 注解应用于构造函数</li>
<li>将 @Autowired 注解应用于 setter 方法</li>
<li>将 @Autowired 注解应用于具有任意名称和多个参数的方法</li>
<li>将 @Autowired 注解应用于字段，或者将其与构造函数混合</li>
<li>将 @Autowired 注解添加到需要该类型数组的字段或方法，则 Spring 会从 ApplicationContext 中搜寻符合指定类型的所有 bean</li>
<li>…</li>
</ul>
<h4 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h4><p>可能会有这样一种情况，当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 <strong>@Qualifier</strong> 注解和 <strong>@Autowired</strong> 注解通过指定哪一个真正的 bean 将会被装配来消除混乱。</p>
<h4 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h4><p><strong>@Required</strong> 注解应用于 bean 属性的 setter 方法，它表明受影响的 bean 属性在配置时必须放在 XML 配置文件中，否则容器就会抛出一个 BeanInitializationException 异常。</p>
<h3 id="Java注解配置"><a href="#Java注解配置" class="headerlink" title="Java注解配置"></a>Java注解配置</h3><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>@Resource ，用来激活一个命名资源（namedresource）的依赖注入，在JavaEE应用程序中，该注解被典型地转换为绑定于JNDI context中的一个对象。</p>
<p>spring确实支持使用@Resource通过JNDIlookup来解析对象，默认地，拥有与@Resource注解所提供名字相匹配的“beanname（bean名字）”的Spring管理对象会被注入。</p>
<p>@Resource装配顺序</p>
<ol>
<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常；</li>
<li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常；</li>
<li>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常；</li>
<li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li>
</ol>
<hr>
<h4 id="Configuration-和-Bean-注解"><a href="#Configuration-和-Bean-注解" class="headerlink" title="@Configuration 和 @Bean 注解"></a><strong>@Configuration 和 @Bean 注解</strong></h4><p><strong>@Configuration</strong> 注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。</p>
<p><strong>@Bean</strong> 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.*;<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldConfig</span> </span>&#123;<br>   <span class="hljs-meta">@Bean</span> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> HelloWorld <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloWorld();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Spring使用注解开发"><a href="#Spring使用注解开发" class="headerlink" title="Spring使用注解开发"></a>Spring使用注解开发</h3><p>使用注解开发，必须要保证<code>aop</code>的包导入</p>
<p><code>aop</code>存在于<code>spring-webmvc</code>中</p>
<img src="/article/37040/image-20220117160906000.png" class title="image-20220117160906000">
<p>同样需要导入<code>context</code>约束，增加注解支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">方法一：<br><span class="hljs-comment">&lt;!--制定扫描包，包下注解会生效--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;包&quot;</span>/&gt;</span><br>方法二：<br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>使用<code>component-scan</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br></code></pre></td></tr></table></figure>
<p>用于把当前类对象存入spring容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br></code></pre></td></tr></table></figure>
<p>用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。</p>
<p><strong>@Component</strong>衍生注解</p>
<ol>
<li>@Repository   与 @Component功能相似，作用在dao层</li>
<li>@Service   与 @Component功能相似，作用在service层</li>
<li>@Controller   与 @Component功能相似，作用在controller层</li>
</ol>
<p><strong>使用</strong><code>@Scope</code></p>
<p>作用就和在bean标签中使用scope属性实现的功能是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope</span><br></code></pre></td></tr></table></figure>
<p>可取值：prototype、request、ression、singleton</p>
<p>用于指定bean的作用范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span><br></code></pre></td></tr></table></figure>
<p>指定范围的取值</p>
<h3 id="SpringMVC相关注解"><a href="#SpringMVC相关注解" class="headerlink" title="SpringMVC相关注解"></a>SpringMVC相关注解</h3><h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><p><code>@Controller</code>注解表明了一个类是作为控制器的角色而存在的。Spring不要求你去继承任何控制器基类，也不要求你去实现Servlet的那套API。当然，如果你需要的话也可以去使用任何与Servlet相关的特性和设施。</p>
<p><code>@Controller</code>注解可以认为是被标注类的原型（stereotype），表明了这个类所承担的角色。分派器（<code>DispatcherServlet</code>）会扫描所有注解了<code>@Controller</code>的类，检测其中通过<code>@RequestMapping</code>注解配置的方法。</p>
<p><strong>使用这个注解的类中的所有的方法，如果返回值是<code>String</code>，并且有具体页面可以跳转，那么就会被视图解析器解析</strong></p>
<h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><p>你可以使用<code>@RequestMapping</code>注解来将请求URL，映射到整个类上或某个特定的处理器方法上。</p>
<p>一般来说，类级别的注解负责将一个特定（或符合某种模式）的请求路径映射到一个控制器上，同时通过方法级别的注解来细化映射，即根据特定的HTTP请求方法（“GET”“POST”方法等）、HTTP请求中是否携带特定参数等条件，将请求映射到匹配的方法上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(path = &quot;&quot;, method = )</span><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>method</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>RequestMethod.GET</td>
<td>它仅接受GET方法的请求</td>
</tr>
<tr>
<td>RequestMethod.POST</td>
<td>它仅接受GET方法的请求</td>
</tr>
</tbody>
</table>
<p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-controller">点击跳转官方注解</a></p>
<ol>
<li><p>@RequestMapping 处理多个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &#123;  </span><br><span class="hljs-meta">  &quot;&quot;,  </span><br><span class="hljs-meta">  &quot;/page&quot;,  </span><br><span class="hljs-meta">  &quot;page*&quot;,  </span><br><span class="hljs-meta">  &quot;view/*,**/msg&quot;  </span><br><span class="hljs-meta">&#125;)</span> <br></code></pre></td></tr></table></figure>
</li>
<li><p>带有 @RequestParam 的 @RequestMapping</p>
<p>@RequestParam 注解使用的时候可以有一个值，也可以没有值。这个值指定了需要被映射到处理方法参数的请求参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/id&quot;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getIdByValue</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> String personId)</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;ID is &quot;</span> + personId);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get ID from query string of URL with value element&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/personId&quot;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getId</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String personId)</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;ID is &quot;</span> + personId);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get ID from query string of URL without value element&quot;</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>@RequestParam 注解的 required 这个参数定义了参数值是否是必须要传的。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestParam(value = &quot;person&quot;, required = false)</span><br></code></pre></td></tr></table></figure>
<p>@RequestParam 的 defaultValue 取值就是用来给取值为空的请求参数提供一个默认值的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestParam(value = &quot;person&quot;, defaultValue = &quot;Bobo&quot;)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>@RequestMapping 快捷方式</p>
<p>Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。组合注解可以更好的表达被注解方法的语义。它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。 </p>
<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@DeleteMapping</li>
<li>@PatchMapping</li>
</ul>
</li>
</ol>
<h4 id="ResponseBody注解"><a href="#ResponseBody注解" class="headerlink" title="@ResponseBody注解"></a>@ResponseBody注解</h4><p>注解 @ResponseBody，使用在控制层（controller）的方法上</p>
<p>该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区,进而将数据返回给客户端。</p>
<p>POST模式下，使用@RequestBody绑定请求对象，Spring会帮你进行协议转换，将Json、Xml协议转换成你需要的对象。@ResponseBody可以标注任何对象，由Spring完成对象——协议的转换。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(User user)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>User字段：userName pwd<br>那么在前台接收到的数据为：’{“userName”:”xxx”,”pwd”:”xxx”}’</p>
</blockquote>
<h4 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h4><p>在Spring中@RestController的作用等同于@Controller + @ResponseBody</p>
<p>不会走视图解析器，直接返回一个字符串</p>
<h4 id="SpringMVC对RESTful风格的支持"><a href="#SpringMVC对RESTful风格的支持" class="headerlink" title="SpringMVC对RESTful风格的支持"></a>SpringMVC对RESTful风格的支持</h4><p><strong>@PathVariable</strong></p>
<p>@PathVariable是spring3.0的一个新功能：接收请求路径中占位符的值</p>
<p>当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span><br></code></pre></td></tr></table></figure>
<h3 id="SpringBoot相关注解"><a href="#SpringBoot相关注解" class="headerlink" title="SpringBoot相关注解"></a><strong>SpringBoot相关注解</strong></h3><h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><p>通过 SpringBoot 提供的 @ConfigurationProperties 注解，可以将全局配置文件中的配置数据绑定到 JavaBean 中。</p>
<p>告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定；</p>
<p>prefix = “ClassName”：配置文件中哪个下面的所有属性进行一一映射</p>
<a href="/article/33757.html" title="点击跳转yaml使用注解给属性赋值">点击跳转yaml使用注解给属性赋值</a>
<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><p>只需要读取配置文件中的某一个配置时，可以通过 @Value 注解获取</p>
<a href="/article/33757.html" title="点击跳转yaml使用注解给属性赋值">点击跳转yaml使用注解给属性赋值</a>
<blockquote>
<p><strong>@Value 与 @ConfigurationProperties 对比</strong></p>
<p>@Value 和 @ConfigurationProperties 注解都能读取配置文件中的属性值并绑定到 JavaBean 中，但两者存在以下不同。</p>
<ol>
<li><p>使用位置不同</p>
<ul>
<li><p>@ConfigurationProperties：标注在 JavaBean 的类名上；</p>
</li>
<li><p>@Value：标注在 JavaBean 的属性上。</p>
</li>
</ul>
</li>
<li><p>功能不同</p>
<ul>
<li><p>@ConfigurationProperties：用于批量绑定配置文件中的配置；</p>
</li>
<li><p>@Value：只能一个一个的指定需要绑定的配置。</p>
</li>
</ul>
</li>
<li><p>松散绑定支持不同</p>
<p>@ConfigurationProperties：支持松散绑定（松散语法），例如实体类 Person 中有一个属性为 lastName，那么配置文件中的属性名支持以下写法：</p>
<ul>
<li>person.firstName</li>
<li>person.first-name</li>
<li>person.first_name</li>
<li><p>PERSON_FIRST_NAME</p>
<p>@Vaule：不支持松散绑定。</p>
</li>
</ul>
</li>
<li><p>SpEL 支持不同</p>
<ul>
<li>@ConfigurationProperties：不支持 SpEL 表达式;</li>
<li>@Value：支持 SpEL 表达式。</li>
</ul>
</li>
<li><p>复杂类型封装</p>
<ul>
<li><p>@ConfigurationProperties：支持所有类型数据的封装，例如 Map、List、Set、以及对象等；</p>
</li>
<li><p>@Value：只支持基本数据类型的封装，例如字符串、布尔值、整数等类型。</p>
</li>
</ul>
</li>
<li><p>应用场景不同</p>
<p>@Value 和 @ConfigurationProperties 两个注解之间，并没有明显的优劣之分，它们只是适合的应用场景不同而已。</p>
<ul>
<li>若只是获取配置文件中的某项值，则推荐使用 @Value 注解；</li>
<li>若专门编写了一个 JavaBean 来和配置文件进行映射，则建议使用 @ConfigurationProperties 注解。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h4><p>如果将所有的配置都集中到 application.properties 或 application.yml 中，那么这个配置文件会十分的臃肿且难以维护，因此我们通常会将与 SpringBoot 无关的配置（例如自定义配置）提取出来，写在一个单独的配置文件中，并在对应的 JavaBean 上使用 @PropertySource 注解指向该配置文件。</p>
<a href="/article/33757.html" title="点击跳转给属性赋值的两种方法之一">点击跳转给属性赋值的两种方法之一</a>
<h4 id="Conditional派生注解"><a href="#Conditional派生注解" class="headerlink" title="@Conditional派生注解"></a>@Conditional派生注解</h4><p>spring.factories 文件中的所有自动配置类（xxxAutoConfiguration），都是必须在一定的条件下才会作为组件添加到容器中，配置的内容才会生效。这些限制条件在 SpringBoot 中以 @Conditional 派生注解的形式体现，如下表。</p>
<table>
<thead>
<tr>
<th style="text-align:center">注解</th>
<th style="text-align:center">生效条件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@ConditionalOnJava</td>
<td style="text-align:center">应用使用指定的 Java 版本时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnBean</td>
<td style="text-align:center">容器中存在指定的 Bean 时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnMissingBean</td>
<td style="text-align:center">容器中不存在指定的 Bean 时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnExpression</td>
<td style="text-align:center">满足指定的 SpEL 表达式时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnClass</td>
<td style="text-align:center">存在指定的类时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnMissingClass</td>
<td style="text-align:center">不存在指定的类时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnSingleCandidate</td>
<td style="text-align:center">容器中只存在一个指定的 Bean 或这个 Bean 为首选 Bean 时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnProperty</td>
<td style="text-align:center">系统中指定属性存在指定的值时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnResource</td>
<td style="text-align:center">类路径下存在指定的资源文件时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnWebApplication</td>
<td style="text-align:center">当前应用是 web 应用时生效</td>
</tr>
<tr>
<td style="text-align:center">@ConditionalOnNotWebApplication</td>
<td style="text-align:center">当前应用不是 web 应用生效</td>
</tr>
</tbody>
</table>
<h2 id="SpringMVC配置"><a href="#SpringMVC配置" class="headerlink" title="SpringMVC配置"></a>SpringMVC配置</h2><p><strong>基础配置</strong></p>
<p><code>Maven依赖</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>web.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--配置DispatchServlet：这个是SpringMVC的核心 ：请求分发器、前端控制器--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--DispatchServlet要绑定SpringMVC的配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--启动级别--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- / 只匹配所有的请求，不会去匹配jsp页面--&gt;</span><br>  <span class="hljs-comment">&lt;!-- /* 匹配所有的请求，包括jsp页面--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>app<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/app/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>springmvc-servlet.xml</code></p>
<p><strong>处理器映射器、处理器适配器 可以不用配置，spring默认配置</strong></p>
<p><strong>视图解析器不可以省略</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--处理器映射器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--处理器适配器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter &quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--视图解析器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;InternalResourceViewResolver&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--前缀--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>  <span class="hljs-comment">&lt;!--后缀--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>BeanNameUrlHandlerMapping：根据bean的名字匹配</p>
<p><strong>注解配置相关</strong></p>
<p><code>springmvc-servlet.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><br><br>  <span class="hljs-comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.bobo.controller&quot;</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 让Spring MVC不处理静态资源    .css .js  .html .mp3 .mp4--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 支持mvc注解驱动</span><br><span class="hljs-comment">    在spring中一般采用@RequestMapping注解来完成映射关系</span><br><span class="hljs-comment">    要想使@RequestMapping注解生效</span><br><span class="hljs-comment">    必须向上下文中注册DefaultAnnotationHandlerMapping</span><br><span class="hljs-comment">    和一个AnnotationMethodHandlerAdapter实例</span><br><span class="hljs-comment">    这两个实例分别在类级别和方法级别处理。</span><br><span class="hljs-comment">    而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br>  <br>  <span class="hljs-comment">&lt;!-- 视图解析器 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver &quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;internalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 前缀 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 后缀 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h2><p><code>Maven依赖</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h3><p>使用thymeleaf,<code>Maven依赖</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf.extras<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-extras-java8time<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>在使用 Thymeleaf 之前，首先要在页面的 html 标签中声明名称空间</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">xmlns:th=&quot;http://www.thymeleaf.org&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>在 html 标签中声明此名称空间，可避免编辑器出现 html 验证错误，但这一步并非必须进行的，即使我们不声明该命名空间，也不影响 Thymeleaf 的使用。</p>
</blockquote>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p><code>pom.xml</code></p>
<p>导入 JDBC 场景启动器：spring-boot-starter-data-jdbc</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入JDBC的场景启动器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>JDBC 的场景启动器中并没有导入数据库驱动，我们需要根据自身的需求引入所需的数据库驱动。例如，访问 MySQL 数据库时，需要导入 MySQL 的数据库驱动：mysql-connector-java。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Mysql Driver--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>application.properties/yml</code></p>
<p>在导入了 JDBC 场景启动器和数据库驱动后，接下来我们就可以在配置文件（application.properties/yml）中配置数据源了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#数据源连接信息</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">用户名</span>	<br>    <span class="hljs-attr">password:</span> <span class="hljs-string">密码</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p><code>pom.xml</code></p>
<p>引入 mybatis-spring-boot-starter 的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入 mybatis-spring-boot-starter 的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>application.properties/yml</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">用户名	</span><br><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">密码</span><br><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/数据库名?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#mybatis</span><br><span class="hljs-comment">#扫描实体类的位置,在此处指明扫描实体类的包，在 mapper.xml 中就可以不写实体类的全路径名</span><br><span class="hljs-meta">mybatis.type-aliases-package</span>=<span class="hljs-string">com.bobo.pojo</span><br><span class="hljs-comment"># 指定 mapper.xml 的位置</span><br><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mybatis/mapper/*.xml</span><br></code></pre></td></tr></table></figure>
<h2 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h2><p><code>pom.xml</code>        </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- spring security依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- web模块 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 测试包依赖 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- security测试包 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><p><code>pom.xml</code>    </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Shiro uses SLF4J for logging.  We&#x27;ll use the &#x27;simple&#x27; binding</span><br><span class="hljs-comment">             in this example app.  See http://www.slf4j.org for more info. --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><p><strong>springboot版本使用2.5.6 swagger版本使用3.0.0</strong></p>
<blockquote>
<p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&gt;<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-comment">&lt;!--swagger2--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>config</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-meta">@Configuration</span><br>&gt;<span class="hljs-meta">@EnableOpenApi</span>  <span class="hljs-comment">//开启Swagger2</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>&#123;<br><br>&gt;&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>访问测试 ：<a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a> ，可以看到swagger的界面</p>
<img src="/article/37040/image-20220221135603241.png" class title="image-20220221135603241">
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP的请求和响应</title>
    <url>/article/4338.html</url>
    <content><![CDATA[<blockquote>
<p>The perfect decks itself in beauty for the love of the Imperfect.</p>
<p>“完全”为了对“不全”的爱，把自己装饰得美丽。　　</p>
</blockquote>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a href="https://cloud.tencent.com/developer/doc/1117">参考手册</a></p>
<p>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在<a href="https://baike.baidu.com/item/TCP/33012">TCP</a>之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以<a href="https://baike.baidu.com/item/ASCII/309296">ASCII</a>形式给出；而消息内容则具有一个类似<a href="https://baike.baidu.com/item/MIME/2900607">MIME</a>的格式。这个简单模型是早期<a href="https://baike.baidu.com/item/Web/150564">Web</a>成功的有功之臣，因为它使开发和部署非常地直截了当。</p>
<p><code>HTTP</code>是基于<strong>TCP/IP</strong>协议的，可以使用<code>http</code>进行内容的传输，比如图片，视频，音频，文档等等。</p>
<p>客户端和服务端需要进行通信的话，通常会使用<code>request response cycle</code>的形式。</p>
<p>客户端需要发送<strong>request请求</strong>，这样服务端才知道要通信；之后，服务端对请求进行<strong>response响应</strong>。</p>
<ol>
<li>HTTP是无连接的：在发出请求后，客户端和服务端断开连接，然后当响应准备就绪的时候，服务端再次重新建立连接并发送响应。</li>
<li>HTTP可以提供任何类型的数据，只要客户端和服务端两边的电脑能够读取理解它。</li>
<li>HTTP是无状态的：客户端和服务器只是在<strong>当前请求期间</strong>了解彼此。如果它关闭了，并且两台电脑想要再次连接，它们需要重新提供信息。</li>
</ol>
<h2 id="request请求"><a href="#request请求" class="headerlink" title="request请求"></a>request请求</h2><p><strong>HTTP请求信息由部分组成</strong></p>
<ol>
<li><p>请求方法（GET/POST）、<em>URI</em>、协议<em>/</em>版本</p>
</li>
<li><p>请求头<em>(Request Header)</em></p>
</li>
<li><p>请求正文</p>
</li>
</ol>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/5bU_dTmfKgQFm2e88IuM_a/union.gif</span> <span class="hljs-meta">HTTP/1.1</span><br>-------------------------------------------------<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>XXXxXxxxxxxxxxxxxxxxx<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>image/webp,image/png,image/svg+xml,image/*;q=0.8,video/*;q=0.8,*/*;q=0.5<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>sp1.baidu.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.1 Safari/605.1.15<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh-Hans;q=0.9<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>https://www.baidu.com/s?wd=baidu&amp;tn=84053098_3_dg&amp;ie=utf-8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br></code></pre></td></tr></table></figure>
<p><strong>请求方法、URI、协议版本</strong></p>
<p>根据<em>HTTP</em>标准，HTTP请求可以使用多种请求方法。例如：<em>HTTP1.1</em>目前支持7种请求方</p>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求获取由Request-URI所标识的资源</td>
</tr>
<tr>
<td>POST</td>
<td>在Request-URI所标识的资源后附加新的数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>请求获取由Request-URI所标识的资源的响应消息报头</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>请求查询服务器的性能，或查询与资源相关的选项和需求</td>
</tr>
<tr>
<td>PUT</td>
<td>请求服务器存储一个资源，并用Request-URI作为其标识</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除由Request-URI所标识的资源</td>
</tr>
<tr>
<td>TRACE</td>
<td>请求服务器回送收到的请求信息，主要用语测试或诊断</td>
</tr>
</tbody>
</table>
<p><strong>请求头(Request Header)</strong></p>
<p>请求头包含许多有关的客户端环境和请求正文的有用信息。</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cookie</td>
<td>这是最重要的请求头信息之一</td>
</tr>
<tr>
<td>Accept</td>
<td>浏览器可接受的MIME类型</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间</td>
</tr>
<tr>
<td>Host</td>
<td>指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到</td>
</tr>
<tr>
<td>Referer</td>
<td>包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小</td>
</tr>
<tr>
<td>Referer</td>
<td>包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可接受的字符集</td>
</tr>
<tr>
<td>Authorization</td>
<td>授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中</td>
</tr>
<tr>
<td>From</td>
<td>请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答</td>
</tr>
<tr>
<td>Pragma</td>
<td>指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝</td>
</tr>
</tbody>
</table>
<p><strong>请求正文</strong></p>
<p>请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息</p>
<h2 id="Response响应"><a href="#Response响应" class="headerlink" title="Response响应"></a>Response响应</h2><p><em>HTTP</em>应答与<em>HTTP</em>请求相似，<em>HTTP</em>响应也由<em>3</em>个部分构成，分别是：</p>
<ol>
<li><p>状态行</p>
</li>
<li><p>响应头(Response Header)</p>
</li>
<li><p>响应正文</p>
</li>
</ol>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br>------------------------------------------------------<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>image/gif<br><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>BDORZ=FFFB88E999055A3F8A630C64834BD6D0; max-age=86400; domain=.baidu.com; path=/<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Wed, 07 Nov 2012 16:00:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=315360000<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Keep-Alive<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Fri, 31 Dec 2021 11:14:09 GMT<br><span class="hljs-attribute">Accept-Ranges</span><span class="hljs-punctuation">: </span>bytes<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>0<br><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Mon, 29 Dec 2031 11:14:09 GMT<br><span class="hljs-attribute">ETag</span><span class="hljs-punctuation">: </span>&quot;0-0509a8580&quot;<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache 2.0<br></code></pre></td></tr></table></figure>
<p><strong>状态行</strong></p>
<p>由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p>
<ul>
<li>状态代码：状态代码由<em>3</em>位数字组成，表示请求是否被理解或被满足。</li>
<li>状态描述：状态描述给出了关于状态代码的简短的文字描述。</li>
<li>状态代码的第一个数字定义了响应的类别，后面两位没有具体的分类。<ul>
<li>第一个数字有五种可能的取值：<ul>
<li><em>- 1xx:</em>  指示信息—表示请求已接收，继续处理。</li>
<li><em>- 2xx:</em>  成功—表示请求已经被成功接收、理解、接受。</li>
<li><em>- 3xx:</em>  重定向—要完成请求必须进行更进一步的操作。</li>
<li><em>- 4xx:</em>  客户端错误—请求有语法错误或请求无法实现。</li>
<li><em>- 5xx:</em> 服务器端错误—服务器未能实现合法的请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>状态代码</th>
<th>状态描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>客户端请求成功</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>由于客户端请求有语法错误，不能被服务器所理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthonzed</td>
<td>请求未经授权。这个状态代码必须和<em>WWW-Authenticate</em>报头域一起使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>请求的资源不存在，例如，输入了错误的<em>URL</em>。</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器发生不可预期的错误，导致无法完成客户端的请求。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</td>
</tr>
</tbody>
</table>
<p><strong>响应头</strong></p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content-Type</td>
<td><em>Content-Type</em>实体报头域用语指明发送给接收者的实体正文的媒体类型</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>浏览器会在当前页面所在域名设置cookie字符串</td>
</tr>
<tr>
<td>Last-Modified</td>
<td><em>Last-Modified</em>实体报头域用于指示资源最后的修改日期及时间</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>通用头字段用于指定在两个，请求和响应的缓存机制的指令。缓存指令是单向的，这意味着请求中的给定指令并不意味着将在响应中给出相同的指令</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小</td>
</tr>
<tr>
<td>Date</td>
<td>通用 HTTP 报头包含在该消息起源的日期和时间。</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>响应的 HTTP 标头是由服务器使用以通告其支持部分请求的标志物。此字段的值表示可用于定义范围的单位。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体报头指示该实体主体的大小，以字节为单位的十进制数，发送到接收方</td>
</tr>
<tr>
<td>Expires</td>
<td>标头包含的日期/时间之后，响应被视为失效。</td>
</tr>
<tr>
<td>ETag</td>
<td>HTTP 响应报头为资源的特定版本的标识符。它允许缓存更高效，并节省带宽，因为如果内容没有改变，Web 服务器不需要发送完整的响应。另一方面，如果内容发生了变化，etags 有助于防止资源的同时更新互相覆盖（“空中冲突”）。 如果给定 URL 处的资源发生更改，则<code>Etag</code>必须生成新值。因此，Etags 与指纹相似，也可能用于某些服务器的跟踪目的。它们的比较可以快速确定资源的两个表示是否相同，但它们也可能被设置为无限期地由跟踪服务器持续存在。</td>
</tr>
<tr>
<td>Server</td>
<td>头包含有关用作原始服务器处理请求的软件信息。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>网络编程</category>
        <category>HTTP的请求和响应</category>
        <category>HTTP的请求和响应</category>
      </categories>
      <tags>
        <tag>HTTP的请求和响应</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC加载数据库驱动</title>
    <url>/article/45336.html</url>
    <content><![CDATA[<blockquote>
<p>My day is done, and I am like a boat drawn on the beach, listening to the dance-music of the tide in the evening.</p>
<p>我的白昼已经完了，我象一只泊在海滩上的小船，谛听着晚潮跳舞的乐声。</p>
</blockquote>
<h2 id="JDBC基本使用"><a href="#JDBC基本使用" class="headerlink" title="JDBC基本使用"></a>JDBC基本使用</h2><p>Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的<a href="https://baike.baidu.com/item/应用程序接口/10418844">应用程序接口</a>，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。我们通常说的JDBC是面向关系型数据库的。</p>
<p>导入<code>mysql-connector-java-版本.jar</code>,然后将jar包添加入项目库中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;<br>        <span class="hljs-comment">//固定写法，加载驱动 Mysql 8.0以上</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        <span class="hljs-comment">//2.用户信息和url</span><br>        String url = <span class="hljs-string">&quot;jdbc:mysql://localhost:端口/数据库名?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&quot;</span>;<br>        String username = <span class="hljs-string">&quot;用户名&quot;</span>;  <span class="hljs-comment">//数据库用户名</span><br>        String password = <span class="hljs-string">&quot;密码&quot;</span>;<span class="hljs-comment">//数据库密码</span><br><br>        Connection connection = DriverManager.getConnection(url,username,password);<br>  <br>				<span class="hljs-comment">//执行SQL的对象 statement</span><br>        Statement statement = connection.createStatement();<br>				<span class="hljs-comment">//sql语句</span><br>        String sql = <span class="hljs-string">&quot;SELECT * FROM 数据库名.表名&quot;</span>;<br>  			<span class="hljs-comment">//执行sql</span><br>        ResultSet resultSet = statement.executeQuery(sql);<br><br>  			<span class="hljs-comment">//从获取的结果中输出</span><br>        <span class="hljs-keyword">while</span> (resultSet.next())&#123;<br>            System.out.println(<span class="hljs-string">&quot;variable=&quot;</span>+ resultSet.getObject(<span class="hljs-string">&quot;列名&quot;</span>));<br>        &#125;<br>			<br>  			<span class="hljs-comment">//依次关闭连接</span><br>        resultSet.close();<br>        statement.close();<br>        connection.close();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a><strong>驱动</strong></h4><p><code>com.mysql.cj.jdbc.Driver</code>部分源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">sql</span>.<span class="hljs-title">Driver</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Driver</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            DriverManager.registerDriver(<span class="hljs-keyword">new</span> Driver());<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException var1) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//DriverManager.registerDriver(new Driver());   不推荐使用</span><br><span class="hljs-comment">//因为Drive类中静态代码块中已经注册了</span><br><span class="hljs-comment">//固定写法，加载驱动 Mysql 8.0以上</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);   <span class="hljs-comment">//推荐</span><br></code></pre></td></tr></table></figure>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String url = <span class="hljs-string">&quot;jdbc:mysql://主机地址:3306/数据库名?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&quot;</span>;<br><br>mysql -- <span class="hljs-number">3306</span><br>oralce -- <span class="hljs-number">1521</span><br>jdbc:oralce:thin:<span class="hljs-meta">@localhost</span>:<span class="hljs-number">1521</span>:sid<br></code></pre></td></tr></table></figure>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a><strong>Connection</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Connection connection = DriverManager.getConnection(url,username,password);<br></code></pre></td></tr></table></figure>
<p><code>connection</code>代表数据库，是数据库的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">connection.rollback();<br>connection.commit();<br>connection.setAutoCommit();<br></code></pre></td></tr></table></figure>
<h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a><strong>Statement</strong></h4><p>不能防止sql注入<a href="#PreparedStatement"><code>点击跳转PreparedStatement</code></a></p>
<p><code>statement</code> 具体的执行类，是执行sql的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">statement.executeQuery();  <span class="hljs-comment">//查询操作返回ResultSet</span><br>statement.execute();   <span class="hljs-comment">//查询任何sql</span><br>statement.executeUpdate();  <span class="hljs-comment">//更新 插入  删除  返回一个受影响的行数</span><br></code></pre></td></tr></table></figure>
<h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a><strong>ResultSet</strong></h4><p><code>resultSet</code> 查询的结果集，封装了所有的结果集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">resultSet.getObject();   <span class="hljs-comment">//在不知道列类型的情况下使用</span><br>resultSet.getString();<br>resultSet.getInt();<br><br>resultSet.beforeFirst();  <span class="hljs-comment">//移动到最前面</span><br>resultSet.afterLast();  <span class="hljs-comment">//移动到最后面</span><br>resultSet.next();  <span class="hljs-comment">//移动到下一个数据</span><br>resultSet.previous();  <span class="hljs-comment">//移动到前一行</span><br>resultSet.absolute(row);  <span class="hljs-comment">//移动到制定行</span><br></code></pre></td></tr></table></figure>
<h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a><strong>释放资源</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">resultSet.close();<br>statement.close();<br>connection.close();<br></code></pre></td></tr></table></figure>
<h2 id="提取工具类"><a href="#提取工具类" class="headerlink" title="提取工具类"></a>提取工具类</h2><p>创建<code>db.properties</code>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span> = <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">jdbc:mysql://localhost:端口/数据库名?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=true</span><br><span class="hljs-attr">username</span> = <span class="hljs-string">用户名</span><br><span class="hljs-attr">password</span> = <span class="hljs-string">密码</span><br></code></pre></td></tr></table></figure>
<p><strong>通过反射获取类加载器来拿到资源</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtils</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driver = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String username = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//通过反射获取类加载器来拿到资源（mysql配置文件），返回一个输入流</span><br>            InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;db.properties&quot;</span>);<br>            Properties properties = <span class="hljs-keyword">new</span> Properties();<br>            <span class="hljs-comment">//将配置文件读出</span><br>            properties.load(in);<br>						<br>            driver = properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>            url = properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>            username = properties.getProperty(<span class="hljs-string">&quot;username&quot;</span>);<br>            password = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br><br>            <span class="hljs-comment">//驱动只用加载一次</span><br>            Class.forName(driver);<br><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">//获取连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url,username,password);<br>    &#125;<br><br>    <span class="hljs-comment">//释放连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(Connection conn, Statement st, ResultSet rs)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(rs!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                rs.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(st!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                st.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(conn!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                conn.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Class是当前类的Class对象，Class.getClassLoader()是获取当前类的类加载器。类加载器的大概作用是当需要使用一个类时，加载该类的”.class”文件，并创建对应的class对象，将class文件加载到虚拟机的内存。getResourceAsStream()是获取资源的输入流。类加载器默认是从classPath路径加载资源。</p>
<p>因此，当使用<code>Class.getClassLoader.getResourceAsStream()</code>加载资源时，是从classPath路径下进行加载，放在resources下的文件加载时不能加（“/”）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">InputStream in = PropertiesUtil.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;xx.properties&quot;</span>);<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>Class.getResourceAsStream()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当前类的URI目录，不包括自己</span><br>Class.getResourceAsStream(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//当前的classpath的绝对URI路径</span><br>Class.getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>在使用 Class.getResourceAsStream()时，一定注意要加载的资源路径与当前类所在包的路径是否一致【使用时注意子目录】。</p>
<p>1）要加载的资源路径与当前类所在包的路径一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">InputStream in = PropertiesUtil.class.getResourceAsStream(<span class="hljs-string">&quot;xx.properties&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>2）要加载的资源路径在resources下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">InputStream in = PropertiesUtil.class.getResourceAsStream(<span class="hljs-string">&quot;/xx.properties&quot;</span>);<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>提取插入类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInsert</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>				<span class="hljs-comment">//提高作用域</span><br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        Statement st = <span class="hljs-keyword">null</span>;<br>        ResultSet rs = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            conn = JdbcUtils.getConnection();    <span class="hljs-comment">//获取数据库连接</span><br>            st = conn.createStatement();    <span class="hljs-comment">//获得sql的执行对象</span><br>            String sql = <span class="hljs-string">&quot;插入的sql语句&quot;</span>;<br><br>            <span class="hljs-keyword">int</span> i = st.executeUpdate(sql);<br>            <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;插入成功&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(conn,st,rs);<br>        &#125;	<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h2><p>SQL注入即是指<a href="https://baike.baidu.com/item/web应用程序/2498090">web应用程序</a>对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的<a href="https://baike.baidu.com/item/SQL语句/5714895">SQL语句</a>，在管理员不知情的情况下实现非法操作，以此来实现欺骗<a href="https://baike.baidu.com/item/数据库服务器/613818">数据库服务器</a>执行非授权的任意查询，从而进一步得到相应的数据信息。</p>
<p><strong>注入实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SQL</span>注入 </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//        login(&quot;bobobobo&quot;,&quot;123123&quot;);</span><br>        login(<span class="hljs-string">&quot;&#x27;or&#x27;1=1&quot;</span>,<span class="hljs-string">&quot;&#x27;or&#x27;1=1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//登陆业务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>&#123;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        Statement st = <span class="hljs-keyword">null</span>;<br>        ResultSet rs = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            conn = JdbcUtils.getConnection();<br>            st = conn.createStatement();<br>            <br>            <span class="hljs-comment">//select * from users where `NAME` = &#x27;&#x27; or &#x27;1=1&#x27; and `password` = &#x27;&#x27; or &#x27;1=1&#x27;</span><br>            String sql = <span class="hljs-string">&quot;select * from users where `NAME`=&#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27; AND  `password` = &#x27;&quot;</span> + password + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>            rs = st.executeQuery(sql);<br><br>            <span class="hljs-keyword">while</span>(rs.next())&#123;<br>                    System.out.println(<span class="hljs-string">&quot;查询成功&quot;</span>);<br>                    System.out.println(rs.getString(<span class="hljs-string">&quot;NAME&quot;</span>));<br>                    System.out.println(rs.getString(<span class="hljs-string">&quot;password&quot;</span>));<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(conn,st,rs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>login()</code>方法传递进去的参数会被拼接入sql语句中，称为执行sql语句的一部分，使sql语句保持正确的语法，进而被执行；</p>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p><a href="#Statement"><code>点击跳转Statement</code></a></p>
<p>PreparedStatement可以防止sql注入，效率更好</p>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.bobo.lesson02.utils.JdbcUtils;<br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SQL</span>注入 </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        login(<span class="hljs-string">&quot;&#x27;&#x27; or 1=1&quot;</span>,<span class="hljs-string">&quot;123123&quot;</span>);  <span class="hljs-comment">//防止sql注入</span><br>    &#125;<br><br>    <span class="hljs-comment">//登陆业务</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username,String password)</span></span>&#123;<br>        Connection conn = <span class="hljs-keyword">null</span>;<br>        PreparedStatement st = <span class="hljs-keyword">null</span>;<br>        ResultSet rs = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            conn = JdbcUtils.getConnection();<br><br>						<span class="hljs-comment">//区别</span><br>            <span class="hljs-comment">//使用 ？占位符  代替参数</span><br>            <span class="hljs-comment">//把传递进来的参数当作字符  假设其中存在转义字符 直接忽略 &#x27; 会被直接转义</span><br>            String sql = <span class="hljs-string">&quot;select * from users where `NAME`= ? and `password` = ?&quot;</span>;<br>						<br>          	<span class="hljs-comment">//预编译sql语句</span><br>            st = conn.prepareStatement(sql);<br>          	<br>          	<span class="hljs-comment">//从1开始，1代表第一个占位符 ？ 以此类推，填入参数</span><br>            st.setString(<span class="hljs-number">1</span>,username);<br>            st.setString(<span class="hljs-number">2</span>,password);<br><br>          	<span class="hljs-comment">//与之前不同，不需要sql参数，因为之前已经进行过预编译，直接执行对象</span><br>            rs = st.executeQuery();<br><br>            <span class="hljs-keyword">while</span>(rs.next())&#123;<br>                    System.out.println(<span class="hljs-string">&quot;查询成功&quot;</span>);<br>                    System.out.println(rs.getString(<span class="hljs-string">&quot;NAME&quot;</span>));<br>                    System.out.println(rs.getString(<span class="hljs-string">&quot;password&quot;</span>));<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(conn,st,rs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>login()</code>传递进来的参数会被当作字符串，只相当于参数，而不是sql执行语句中的一部分，字符串的转义字符会被忽略，无法创造满足的条件。</p>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h3><p><strong>概念</strong></p>
<p>池化技术：把一些能够复用的东西（比如说数据库连接、线程）放到池中，避免重复创建、销毁的开销，从而极大提高性能。</p>
<p>在开发过程中我们会用到很多的连接池，像是数据库连接池、HTTP 连接池、Redis 连接池等等。而连接池的管理是连接池设计的核心，我就以数据库连接池为例，来说明一下连接池管理的关键点。</p>
<p><strong>数据库连接池</strong></p>
<p>数据库连接池有两个最重要的配置：最小连接数和最大连接数，它们控制着从连接池中获取连接的流程：</p>
<ul>
<li>如果当前连接数小于最小连接数，则创建新的连接处理数据库请求</li>
<li>如果线程池中有空闲连接，则使用空闲连接</li>
<li>如果没有空闲连接，并且当前连接数小于最大连接数，则继续创建新的连接</li>
<li>如果当前连接数大于等于最大连接数，并且没有空闲连接了，则请求按照超时时间等待旧连接可用。、</li>
<li>超时之后，则获取数据库连接失败</li>
</ul>
<p>对于数据库连接池，根据我的经验，一般在线上我建议最小连接数控制在 10 左右，最大连接数控制在 20～30 左右即可。</p>
<h3 id="IDEA使用DBCP连接池"><a href="#IDEA使用DBCP连接池" class="headerlink" title="IDEA使用DBCP连接池"></a>IDEA使用DBCP连接池</h3><p>导入<code>commons-dbcp-版本号.jar</code> <code>commons-pool-版本号.jar</code> ,然后将jar包添加入项目库中</p>
<p>DBCP2还需要导入<code>commons-logging-版本号.jar</code></p>
<p><strong>提取工具类</strong></p>
<p>创建<code>dbcpconfig.properties</code>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#连接设置</span><br><span class="hljs-attr">driverClassName</span> = <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">jdbc:mysql://localhost:端口/数据库名?useSSL=false&amp;serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=true</span><br><span class="hljs-attr">username</span> = <span class="hljs-string">用户名</span><br><span class="hljs-attr">password</span> = <span class="hljs-string">密码</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#初始化连接</span><br><span class="hljs-attr">initialSize</span>=<span class="hljs-string">10</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#最大连接数量</span><br><span class="hljs-attr">maxActive</span>=<span class="hljs-string">50</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#最大空闲连接</span><br><span class="hljs-attr">maxIdle</span>=<span class="hljs-string">20</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#最小空闲连接</span><br><span class="hljs-attr">minIdle</span>=<span class="hljs-string">5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#超时等待时间以毫秒为单位 6000毫秒/1000等于60秒</span><br><span class="hljs-attr">maxWait</span>=<span class="hljs-string">60000</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;]</span><br><span class="hljs-comment">#注意：“user” 与 “password” 两个属性会被明确地传递，因此这里不需要包含他们。</span><br><span class="hljs-attr">connectionProperties</span>=<span class="hljs-string">useUnicode=true;characterEncoding=UTF8</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#指定由连接池所创建的连接的自动提交（auto-commit）状态。</span><br><span class="hljs-attr">defaultAutoCommit</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#driver default 指定由连接池所创建的连接的只读（read-only）状态。</span><br><span class="hljs-comment">#如果没有设置该值，则&quot;setReadOnly&quot;方法将不被调用。（某些驱动并不支持只读模式，如：Informix）</span><br><span class="hljs-attr">defaultReadOnly</span>=<span class="hljs-string"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。</span><br><span class="hljs-comment">#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE</span><br><span class="hljs-attr">defaultTransactionIsolation</span>=<span class="hljs-string">READ_UNCOMMITTED</span><br></code></pre></td></tr></table></figure>
<p><strong>DBCP工具类</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.dbcp2.BasicDataSource;<br><span class="hljs-keyword">import</span> org.apache.commons.dbcp2.BasicDataSourceFactory;<br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUtils_DBCP</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource dataSource = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            InputStream in = JdbcUtils_DBCP.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;dbcpconfig.properties&quot;</span>);<br>            Properties properties = <span class="hljs-keyword">new</span> Properties();<br>            properties.load(in);<br><br>            <span class="hljs-comment">//创建数据源   工厂模式 =》创建对象   返回一个数据源</span><br>            dataSource = BasicDataSourceFactory.createDataSource(properties);<br><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//获取连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>      	<span class="hljs-comment">//数据源中自带连接，自动连接</span><br>        <span class="hljs-keyword">return</span> dataSource.getConnection();<br>    &#125;<br><br>    <span class="hljs-comment">//释放连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">(Connection conn, Statement st, ResultSet rs)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(rs!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                rs.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(st!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                st.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(conn!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                conn.close();<br>            &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Mysql</category>
        <category>JDBC</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>Mysql,JDBC,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql基础</title>
    <url>/article/33736.html</url>
    <content><![CDATA[<blockquote>
<p>I thank thee that I am none of the wheels of power but I am one with the living creatures that are crushed by it.</p>
<p>谢谢神，我不是一个权力的轮子，而是被压在这轮子下的活人之一。</p>
</blockquote>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>
<p>每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。</p>
<p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</p>
<p>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p>
<p>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：</p>
<ul>
<li>数据以表格的形式出现</li>
<li>每行为各种记录名称</li>
<li>每列为记录名称所对应的数据域</li>
<li>许多的行和列组成一张表单</li>
<li>若干的表单组成database</li>
</ul>
<h2 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h2><ul>
<li><strong>数据库:</strong> 数据库是一些关联表的集合。</li>
<li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>
<li><strong>列:</strong> 一列(数据元素) 包含了相同类型的数据。</li>
<li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据。</li>
<li><strong>冗余</strong>：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>
<li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li><strong>外键：</strong>外键用于关联两个表。</li>
<li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
<li><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li>
</ul>
<ul>
<li>表头(header): 每一列的名称;</li>
<li>列(col): 具有相同数据类型的数据的集合;</li>
<li>行(row): 每一行用来描述某条记录的具体信息;</li>
<li>值(value): 行的具体信息, 每个值必须与该列的数据类型相同;</li>
<li><strong>键(key)</strong>: 键的值在当前列中具有唯一性。</li>
</ul>
<h2 id="Mysql安装与卸载"><a href="#Mysql安装与卸载" class="headerlink" title="Mysql安装与卸载"></a>Mysql安装与卸载</h2><blockquote>
<p>本来网上对Mac Mysql的介绍就参差不齐，换了M1MAX之后更找不到好的教程！</p>
<p>功夫不负有心人，还是被我找到了！</p>
<p>亲测可用！</p>
</blockquote>
<p><code>Mac</code></p>
<img src="/article/33736/image-20211226102545359.png" class title="image-20211226102545359">
<p><strong>安装</strong></p>
<p><a href="https://www.bilibili.com/video/BV1Qf4y1V7Co">B站高人的视频</a></p>
<p><strong>卸载</strong> </p>
<p>可以彻底删除Mac的所有残留Mysql文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini">打开终端：<br>sudo su<br><br>执行代码：<br>sudo rm /usr/local/mysql<br>sudo rm -rf /usr/local/mysql*<br>sudo rm -rf /Library/StartupItems/MySQLCOM<br>sudo rm -rf /Library/PreferencePanes/My*<br>rm -rf ~/Library/PreferencePanes/My*<br>sudo rm -rf /Library/Receipts/mysql*<br>sudo rm -rf /Library/Receipts/MySQL*<br>sudo rm -rf /var/db/receipts/com.mysql.*<br><br>即可彻底卸载<br></code></pre></td></tr></table></figure>
<p><strong>配置</strong></p>
<p><code>/Users/你的用户名/.zshrc</code></p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><code class="hljs zsh"><span class="hljs-comment">#Mysql</span><br><span class="hljs-built_in">alias</span> mysqlstop=<span class="hljs-string">&#x27;sudo /usr/local/mysql/support-files/mysql.server stop&#x27;</span><br><span class="hljs-built_in">alias</span> mysqlstart=<span class="hljs-string">&#x27;sudo /usr/local/mysql/support-files/mysql.server start&#x27;</span><br><span class="hljs-built_in">alias</span> mysql=/usr/<span class="hljs-built_in">local</span>/mysql/bin/mysql<br><span class="hljs-built_in">alias</span> mysqladmin=/usr/<span class="hljs-built_in">local</span>/mysql/bin/mysqladmin<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/<span class="hljs-built_in">local</span>/mysql/bin<br></code></pre></td></tr></table></figure>
<h2 id="命令行操作Mysql"><a href="#命令行操作Mysql" class="headerlink" title="命令行操作Mysql"></a>命令行操作Mysql</h2><ul>
<li><p>检查MySQL服务器是否启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ps -ef | grep mysqld<br></code></pre></td></tr></table></figure>
</li>
<li><p>启动与停止Mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mysqlstart<br>mysqlstop<br></code></pre></td></tr></table></figure>
</li>
<li><p>进入Mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mysql -uroot -p<br></code></pre></td></tr></table></figure>
</li>
<li><p>进入Mysql之后</p>
<p>所有的语句都要使用<code>;</code>结尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">---单行注释<br>/*<br>多行注释<br>*/<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>刷新权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; flush privileges;<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; use mysql;<br>mysql&gt; FLUSH PRIVILEGES;<br>mysql&gt; ALTER user &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;newpassward&#x27;<br></code></pre></td></tr></table></figure>
</li>
<li><p>列出 MySQL 数据库管理系统的数据库列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW DATABASES;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| DB01               |<br>| information_schema |<br>| jdbc               |<br>| mybatis            |<br>| mysql              |<br>| performance_schema |<br>| smbms              |<br>| ssmbuild           |<br>| sys                |<br>+--------------------+<br>9 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
</li>
<li><p>选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; use smbms;<br>Database changed<br></code></pre></td></tr></table></figure>
</li>
<li><p>显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW TABLES;<br>+-----------------+<br>| Tables_in_smbms |<br>+-----------------+<br>| smbms_address   |<br>| smbms_bill      |<br>| smbms_provider  |<br>| smbms_role      |<br>| smbms_user      |<br>+-----------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
</li>
<li><p>显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW COLUMNS FROM smbms_address;<br>+--------------+-------------+------+-----+---------+----------------<br>| Field        | Type        | Null | Key | Default | Extra          <br>+--------------+-------------+------+-----+---------+----------------<br>| id           | bigint      | NO   | PRI | NULL    | auto_increment <br>| contact      | varchar(15) | YES  |     | NULL    |                <br>| addressDesc  | varchar(50) | YES  |     | NULL    |                <br>| postCode     | varchar(15) | YES  |     | NULL    |                <br>| tel          | varchar(20) | YES  |     | NULL    |                <br>| createdBy    | bigint      | YES  |     | NULL    |                <br>| creationDate | datetime    | YES  |     | NULL    |                <br>| modifyBy     | bigint      | YES  |     | NULL    |                <br>| modifyDate   | datetime    | YES  |     | NULL    |                <br>| userId       | bigint      | YES  |     | NULL    |                <br>+--------------+-------------+------+-----+---------+----------------<br>10 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure>
</li>
<li><p>显示数据表的详细索引信息，包括PRIMARY KEY（主键）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW INDEX FROM smbms_address;<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE DATABASE [IF NOT EXISTS] 数据库名;<br></code></pre></td></tr></table></figure>
</li>
<li><p>删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; drop database [IF EXISTS] 数据库名;<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建Mysql数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE TABLE table_name (column_name column_type);<br></code></pre></td></tr></table></figure>
</li>
<li><p>删除MySQL数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; DROP TABLE [IF EXISTS] `表名` ;<br></code></pre></td></tr></table></figure>
</li>
<li><p>向MySQL数据表插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; INSERT INTO `表名` ( `字段1`, `字段2`,...`字段N` )<br>                       VALUES<br>                       ( value1, value2,...valueN );<br></code></pre></td></tr></table></figure>
</li>
<li><p>在MySQL数据库中查询数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT[ALL|DISTINCT|DISTINCTROW|TOP]<br>&#123;*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]&#125;<br>FROM tableexpression[,…][IN externaldatabase]<br>[WHERE…]<br>[GROUP BY…]<br>[HAVING…]<br>[ORDER BY…]<br></code></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>&gt; - 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。
&gt; - SELECT 命令可以读取一条或者多条记录。
&gt; - 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据
&gt; - 你可以使用 WHERE 语句来包含任何条件。
&gt; - 你可以使用 LIMIT 属性来设定返回的记录数。
&gt; - 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。
&gt; - 可以将使用`CONCAT(&quot;拼接的字符串：&quot; ，字段1)` 查询出来的结果将被拼接字符串

* SQL SELECT 语句使用 DISTINCT 将读取出来的数据去重

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT DISTINCT `字段1` <br>FROM `表名`<br>[WHERE Clause]<br>[LIMIT 查询起始下标,pageSize][ OFFSET M];<br></code></pre></td></tr></table></figure>

* SQL SELECT 语句使用 WHERE 子句从数据表中读取数据

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT `字段1`, `字段2`,...`字段N` FROM `表名1`, `表名2`...<br>[WHERE condition1 [AND [OR]] condition2.....<br></code></pre></td></tr></table></figure>

* SQL SELECT 语句使用 LIKE 子句从数据表中读取数据

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT `字段1`, `字段2`,...`字段N` <br>FROM `表名`<br>WHERE `字段1` LIKE condition1 [AND [OR]] `字段2` = &#x27;somevalue&#x27;<br></code></pre></td></tr></table></figure>

  `%`代表0～任意个字符  `__`代表一个字符

* MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT expression1, expression2, ... expression_n<br>FROM tables<br>[WHERE conditions]<br>UNION [ALL | DISTINCT]<br>SELECT expression1, expression2, ... expression_n<br>FROM tables<br>[WHERE conditions];<br></code></pre></td></tr></table></figure>

* SQL SELECT 语句使用 ORDER BY 子句将查询数据排序后再返回数据

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT `字段1`, `字段2`,...`字段N` FROM `表名1`, `表名2`...<br>ORDER BY `字段1` [ASC [DESC][默认 ASC]], [`字段2...`] [ASC [DESC][默认 ASC]<br></code></pre></td></tr></table></figure>

* GROUP BY 语句根据一个或多个列对结果集进行分组

  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; SELECT `字段`, function(`字段`)<br>FROM table_name<br>WHERE `字段` operator value<br>GROUP BY column_name;<br></code></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>UPDATE 命令修改 MySQL 数据表数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; UPDATE `表名` SET `字段1`=&#x27;new-value1&#x27;, `字段2`=&#x27;new-value2&#x27;<br>[WHERE Clause]<br></code></pre></td></tr></table></figure>
</li>
<li><p>SQL DELETE 语句从 MySQL 数据表中删除数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; DELETE FROM `表名` [WHERE Clause]<br></code></pre></td></tr></table></figure>
<p>TRUNCATE完全清空一个数据库表，表的结构和索引约束不会变！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; TRUNCATE `表名`<br></code></pre></td></tr></table></figure>
<ul>
<li>相同点：都能删除数据，不会删除表结构</li>
<li>不同点：<ul>
<li>TRUNCATE 重新设置自增列，计数器会归零</li>
<li>TRUNCATE不会影响事务 </li>
</ul>
</li>
</ul>
</li>
<li><p>修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令</p>
<ul>
<li><p>修改表名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `旧表名` RENAME <span class="hljs-keyword">TO</span> `新表名`;<br></code></pre></td></tr></table></figure>
</li>
<li><p>删除，添加或修改表字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE `表名` DROP `字段`;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE 表`名` ADD `字段` 字段数据类型;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE `表名` ADD `字段` INT FIRST;<br>mysql&gt; ALTER TABLE `表名` ADD `字段A` INT AFTER `字段B`;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE `表名` MODIFY `字段` 新字段数据类型;<br>mysql&gt; ALTER TABLE `表名` CHANGE `旧字段名` `新字段名` 新字段数据类型;<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; alter table `表名` engine=myisam;<br></code></pre></td></tr></table></figure>
</li>
<li><p>添加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; ALTER TABLE `表名` ADD CONSTRAINT `约束名` FOREIGN KEY(`作为外键的列`) REFERENCES `被引用的表名`(`被引用表的字段`)<br></code></pre></td></tr></table></figure>
</li>
<li><p>MySQL 连接的使用</p>
<ul>
<li><strong>INNER JOIN（内连接,或等值连接）</strong>：获取两个表中字段匹配关系的记录。</li>
<li><strong>LEFT JOIN（左连接）：</strong>获取左表所有记录，即使右表没有对应匹配的记录。</li>
<li><strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>退出Mysql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">mysql&gt; exit<br>Bye<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><p>MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>MySQL 支持所有标准 SQL 数值数据类型。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">范围（有符号）</th>
<th style="text-align:center">范围（无符号）</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TINYINT</td>
<td style="text-align:center">1 Bytes</td>
<td style="text-align:center">(-128，127)</td>
<td style="text-align:center">(0，255)</td>
<td style="text-align:center">小整数值</td>
</tr>
<tr>
<td style="text-align:center">SMALLINT</td>
<td style="text-align:center">2 Bytes</td>
<td style="text-align:center">(-32 768，32 767)</td>
<td style="text-align:center">(0，65 535)</td>
<td style="text-align:center">大整数值</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMINT</td>
<td style="text-align:center">3 Bytes</td>
<td style="text-align:center">(-8 388 608，8 388 607)</td>
<td style="text-align:center">(0，16 777 215)</td>
<td style="text-align:center">大整数值</td>
</tr>
<tr>
<td style="text-align:center">INT或INTEGER</td>
<td style="text-align:center">4 Bytes</td>
<td style="text-align:center">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:center">(0，4 294 967 295)</td>
<td style="text-align:center">大整数值</td>
</tr>
<tr>
<td style="text-align:center">BIGINT</td>
<td style="text-align:center">8 Bytes</td>
<td style="text-align:center">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td style="text-align:center">(0，18 446 744 073 709 551 615)</td>
<td style="text-align:center">极大整数值</td>
</tr>
<tr>
<td style="text-align:center">FLOAT</td>
<td style="text-align:center">4 Bytes</td>
<td style="text-align:center">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td style="text-align:center">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td style="text-align:center">单精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:center">DOUBLE</td>
<td style="text-align:center">8 Bytes</td>
<td style="text-align:center">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:center">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:center">双精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:center">DECIMAL</td>
<td style="text-align:center">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td style="text-align:center">依赖于M和D的值</td>
<td style="text-align:center">依赖于M和D的值</td>
<td style="text-align:center">小数值</td>
</tr>
</tbody>
</table>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CHAR</td>
<td style="text-align:center">0-255 bytes</td>
<td style="text-align:center">定长字符串</td>
</tr>
<tr>
<td style="text-align:center">VARCHAR（常用）</td>
<td style="text-align:center">0-65535 bytes</td>
<td style="text-align:center">变长字符串</td>
</tr>
<tr>
<td style="text-align:center">TINYBLOB</td>
<td style="text-align:center">0-255 bytes</td>
<td style="text-align:center">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:center">TINYTEXT</td>
<td style="text-align:center">0-255 bytes</td>
<td style="text-align:center">短文本字符串</td>
</tr>
<tr>
<td style="text-align:center">BLOB</td>
<td style="text-align:center">0-65535 bytes</td>
<td style="text-align:center">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:center">TEXT</td>
<td style="text-align:center">0-65535 bytes</td>
<td style="text-align:center">长文本数据</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMBLOB</td>
<td style="text-align:center">0-16777 215 bytes</td>
<td style="text-align:center">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMTEXT</td>
<td style="text-align:center">0-16777 215 bytes</td>
<td style="text-align:center">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:center">LONGBLOB</td>
<td style="text-align:center">0-4294967295 bytes</td>
<td style="text-align:center">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:center">LONGTEXT</td>
<td style="text-align:center">0-4294967295 bytes</td>
<td style="text-align:center">极大文本数据</td>
</tr>
</tbody>
</table>
<ul>
<li>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数</li>
<li>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</li>
<li>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</li>
<li>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</li>
<li>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</li>
</ul>
<h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小 ( bytes)</th>
<th style="text-align:center">范围</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DATE</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1000-01-01/9999-12-31</td>
<td style="text-align:center">YYYY-MM-DD</td>
<td style="text-align:center">日期值</td>
</tr>
<tr>
<td style="text-align:center">TIME</td>
<td style="text-align:center">3</td>
<td style="text-align:center">‘-838:59:59’/‘838:59:59’</td>
<td style="text-align:center">HH:MM:SS</td>
<td style="text-align:center">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:center">YEAR</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1901/2155</td>
<td style="text-align:center">YYYY</td>
<td style="text-align:center">年份值</td>
</tr>
<tr>
<td style="text-align:center">DATETIME（常用）</td>
<td style="text-align:center">8</td>
<td style="text-align:center">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td style="text-align:center">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:center">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:center">TIMESTAMP</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1970-01-01 00:00:00/2038 结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td style="text-align:center">YYYYMMDD HHMMSS</td>
<td style="text-align:center">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p>
<p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p>
<p>缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。</p>
<p><strong>普通索引：</strong>这是最基本的索引，它没有任何限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE INDEX indexName ON table_name (column_name)<br></code></pre></td></tr></table></figure>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<ul>
<li><strong>修改表结构(添加索引)</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)<br>#该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。<br>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list)<br>#这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。<br>ALTER TABLE tbl_name ADD INDEX index_name (column_list)<br>#添加普通索引，索引值可出现多次。<br>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)<br>#该语句指定了索引为 FULLTEXT ，用于全文索引。<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>创建表的时候直接指定</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE mytable(  <br>ID INT NOT NULL,   <br>username VARCHAR(16) NOT NULL,  <br>INDEX [indexName] (username(length))  <br>);  <br></code></pre></td></tr></table></figure>
<ul>
<li>删除索引的语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">DROP INDEX [indexName] ON mytable; <br></code></pre></td></tr></table></figure>
<p><strong>主键索引：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">PRIMARY KEY<br></code></pre></td></tr></table></figure>
<p><strong>唯一索引:</strong>索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">UNIQUE KEY<br></code></pre></td></tr></table></figure>
<p><strong>全文索引：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">FULLTEXT<br></code></pre></td></tr></table></figure>
<h2 id="MySQL字段属性"><a href="#MySQL字段属性" class="headerlink" title="MySQL字段属性"></a>MySQL字段属性</h2><table>
<thead>
<tr>
<th style="text-align:center">MySQL关键字</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NULL</td>
<td style="text-align:center">数据列可包含NULL值</td>
</tr>
<tr>
<td style="text-align:center">NOT NULL</td>
<td style="text-align:center">数据列不允许包含NULL值</td>
</tr>
<tr>
<td style="text-align:center">DEFAULT</td>
<td style="text-align:center">默认值</td>
</tr>
<tr>
<td style="text-align:center">PRIMARY KEY</td>
<td style="text-align:center">主键</td>
</tr>
<tr>
<td style="text-align:center">AUTO_INCREMENT</td>
<td style="text-align:center">自动递增，适用于整数类型（通常用于主键）</td>
</tr>
<tr>
<td style="text-align:center">UNSIGNED</td>
<td style="text-align:center">无符号的整数（不能为负数）</td>
</tr>
<tr>
<td style="text-align:center">CHARACTER SET name</td>
<td style="text-align:center">指定一个字符集</td>
</tr>
<tr>
<td style="text-align:center">ZEROFILL</td>
<td style="text-align:center">如果值长度不够，在前面补0表示</td>
</tr>
<tr>
<td style="text-align:center">COMMENT</td>
<td style="text-align:center">注释</td>
</tr>
</tbody>
</table>
<ul>
<li>表的名称和字段尽量使用 <code>`</code> `括起来</li>
<li>字符串使用单引号<code>&#39;&#39;</code>括起来</li>
<li>所有的语句后面 <code>,</code>,最后一个不用加</li>
</ul>
<h3 id="Mysql数据库引擎"><a href="#Mysql数据库引擎" class="headerlink" title="Mysql数据库引擎"></a>Mysql数据库引擎</h3><p><strong>InnoDB存储引擎</strong></p>
<p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，上图也看到了，InnoDB是默认的MySQL引擎。InnoDB主要特性有：</p>
<ol>
<li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</li>
<li>InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的</li>
<li>InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的**操作系统上</li>
<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</li>
<li>InnoDB被用在众多需要高性能的大型数据库站点上</li>
</ol>
<p>InnoDB不创建目录，使用InnoDB时，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件</p>
<p><strong>MyISAM存储引擎</strong></p>
<p>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但<strong>不支持事物务</strong>。MyISAM主要特性有：</p>
<ol>
<li>大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持</li>
<li>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成</li>
<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>
<li>最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</li>
<li>BLOB和TEXT列可以被索引</li>
<li>NULL被允许在索引的列中，这个值占每个键的0~1个字节</li>
<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li>
<li>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快</li>
<li>可以把数据文件和索引文件放在不同目录</li>
<li>每个字符列可以有不同的字符集</li>
<li>有VARCHAR的表可以固定或动态记录长度</li>
<li>VARCHAR和CHAR列可以多达64KB</li>
</ol>
<p>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：.frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）</p>
<p><strong>MEMORY存储引擎</strong></p>
<p>MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。MEMORY主要特性有：</p>
<ol>
<li>MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度</li>
<li>MEMORY存储引擎执行HASH和BTREE缩影</li>
<li>可以在一个MEMORY表中有非唯一键值</li>
<li>MEMORY表使用一个固定的记录长度格式</li>
<li>MEMORY不支持BLOB或TEXT列</li>
<li>MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引</li>
<li>MEMORY表在所由客户端之间共享（就像其他任何非TEMPORARY表）</li>
<li>MEMORY表内存被存储在内存中，内存是MEMORY表和服务器在查询处理时的空闲中，创建的内部表共享</li>
<li>当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）</li>
</ol>
<img src="/article/33736/1200.png" class title="img">
<h3 id="MySQL-运算符"><a href="#MySQL-运算符" class="headerlink" title="MySQL 运算符"></a>MySQL 运算符</h3><p><strong>比较运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">等于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt;, !=</td>
<td style="text-align:center">不等于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">BETWEEN AND</td>
<td style="text-align:center">在两值之间</td>
<td style="text-align:center">&gt;=min&amp;&amp;&lt;=max</td>
</tr>
<tr>
<td style="text-align:center">NOT BETWEEN</td>
<td style="text-align:center">不在两值之间</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IN</td>
<td style="text-align:center">在集合中</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">NOT IN</td>
<td style="text-align:center">不在集合中</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">&lt;=&gt;</td>
<td style="text-align:center">严格比较两个NULL值是否相等</td>
<td style="text-align:center">两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0</td>
</tr>
<tr>
<td style="text-align:center">LIKE</td>
<td style="text-align:center">模糊匹配</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">REGEXP 或 RLIKE</td>
<td style="text-align:center">正则式匹配</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IS NULL</td>
<td style="text-align:center">为空</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">IS NOT NULL</td>
<td style="text-align:center">不为空</td>
</tr>
</tbody>
</table>
<p><strong>算术运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加法</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减法</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘法</td>
</tr>
<tr>
<td style="text-align:center">/ 或 DIV</td>
<td style="text-align:center">除法</td>
</tr>
<tr>
<td style="text-align:center">% 或 MOD</td>
<td style="text-align:center">取余</td>
</tr>
</tbody>
</table>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符号</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NOT 或 !</td>
<td style="text-align:center">逻辑非</td>
</tr>
<tr>
<td style="text-align:center">AND</td>
<td style="text-align:center">逻辑与</td>
</tr>
<tr>
<td style="text-align:center">OR</td>
<td style="text-align:center">逻辑或</td>
</tr>
<tr>
<td style="text-align:center">XOR</td>
<td style="text-align:center">逻辑异或</td>
</tr>
</tbody>
</table>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</li>
<li>事务用来管理 insert,update,delete 语句</li>
</ul>
<p>一般来说，事务是必须满足4个条件（ACID）：：原子性（<strong>A</strong>tomicity，或称不可分割性）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation，又称独立性）、持久性（<strong>D</strong>urability）。</p>
<ul>
<li><strong>原子性：</strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>一致性：</strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li><strong>隔离性：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性：</strong>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p><strong>事务控制语句</strong></p>
<ul>
<li>BEGIN 或 START TRANSACTION 显式地开启一个事务；</li>
<li>COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；</li>
<li>ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</li>
<li>SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；</li>
<li>RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；</li>
<li>ROLLBACK TO identifier 把事务回滚到标记点；</li>
<li>SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</li>
</ul>
<p><strong>MYSQL 事务处理主要有两种方法</strong></p>
<p>1、用 BEGIN, ROLLBACK, COMMIT来实现</p>
<ul>
<li><strong>BEGIN</strong> 开始一个事务</li>
<li><strong>ROLLBACK</strong> 事务回滚</li>
<li><strong>COMMIT</strong> 事务确认</li>
</ul>
<p>2、直接用 SET 来改变 MySQL 的自动提交模式: </p>
<ul>
<li><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li>
<li><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li>
</ul>
<h2 id="关系数据库中的几种设计范式"><a href="#关系数据库中的几种设计范式" class="headerlink" title="关系数据库中的几种设计范式"></a>关系数据库中的几种设计范式</h2><p><strong>1 第一范式（1NF）</strong></p>
<p>在任何一个<a href="https://baike.baidu.com/item/关系数据库">关系数据库</a>中，第一范式（1NF） 是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>
<p>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>
<p>简而言之，第一范式就是无重复的列。</p>
<p><strong>2 第二范式（2NF）</strong></p>
<p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。这个唯一属性列被称为<a href="https://baike.baidu.com/item/主关键字">主关键字</a>或主键、主码。</p>
<p>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。</p>
<p>简而言之，第二范式就是非主属性完全依赖于主关键字。</p>
<p><strong>3 第三范式（3NF）</strong></p>
<p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</p>
<p>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在图3-2的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p>
<p>简而言之，第三范式就是属性不依赖于其它非主属性。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>注解与反射</title>
    <url>/article/1621.html</url>
    <content><![CDATA[<blockquote>
<p>Shadow, with her veil drawn, follows Light in secret meekness,with her silent steps of love.</p>
<p>阴影戴上她的面幕，秘密地，温顺地，用她的沉默的爱的脚步，跟在“光”后边。</p>
</blockquote>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p>
<p>Java 语言中的类、方法、变量、参数和包等都可以被标注。</p>
<p><strong>Annotation作用</strong></p>
<ul>
<li>不是程序本身，可以对程序作出解释</li>
<li>可以被其他程序（如编译器等）读取</li>
</ul>
<p><strong>Annotation格式</strong></p>
<ul>
<li>注解是以”@注释名”在代码中存在，还可以添加一些参数值</li>
</ul>
<p><strong>Annotation在哪里使用？</strong></p>
<p>可以附加在package，class，method，field等上面相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问</p>
<h3 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h3><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p>
<p><strong>作用在代码的注解是</strong></p>
<ul>
<li><code>@Override</code> - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li>
<li><code>@Deprecated</code> - 标记过时方法。如果使用该方法，会报编译警告。表示不鼓励程序员</li>
<li><code>@SuppressWarnings</code> - 指示编译器去忽略注解中声明的警告。</li>
</ul>
<p><strong>作用在其他注解的注解(或者说 元注解)是</strong></p>
<ul>
<li><p><code>@Retention</code> - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。(SOURCE &lt; CLASS &lt; RUNTIME)</p>
<blockquote>
<ul>
<li>a) 若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li>
<li>b) 若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li>
<li>c) 若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。</li>
</ul>
</blockquote>
</li>
<li><p><code>@Documented</code> - 标记这些注解是否包含在用户文档中。</p>
</li>
<li><p><code>@Target</code> - 标记这个注解应该是哪种 Java 成员。(被描述的注解可以用在什么地方)</p>
</li>
<li><p><code>@Inherited</code> - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</p>
</li>
<li><p><strong>使用元注解自定义一个简单注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation1 &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>@interface</li>
</ol>
<p>使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。</p>
<p><strong>定义 Annotation 时，@interface 是必须的。</strong></p>
<p>注意：它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。</p>
<ol start="2">
<li>@Documented*</li>
</ol>
<p>类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。</p>
<p>定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。</p>
<ol start="3">
<li>@Target(ElementType.TYPE)</li>
</ol>
<p>前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。</p>
<p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p>
<p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p>
<ol start="4">
<li>@Retention(RetentionPolicy.RUNTIME)</li>
</ol>
<p>前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。</p>
<p>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。</p>
<p>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p>
</blockquote>
</li>
</ul>
<p><strong>从 Java 7 开始，额外添加了 3 个注解</strong></p>
<ul>
<li><code>@SafeVarargs</code> - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li>
<li><code>@FunctionalInterface</code> - Java 8 开始支持，标识一个匿名函数或函数式接口。</li>
<li><code>@Repeatable</code> - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li>
</ul>
<p><strong>Annotation 架构</strong></p>
<img src="/article/1621/Annotation%E6%9E%B6%E6%9E%84.jpg" class title="img">
<p>从中，我们可以看出：</p>
<ol>
<li><p>1 个 Annotation 和 1 个 RetentionPolicy 关联。</p>
<p>每1个Annotation对象，都会有唯一的RetentionPolicy属性。</p>
</li>
<li><p>1 个 Annotation 和 1~n 个 ElementType 关联。</p>
<p>对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。</p>
</li>
<li><p>Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</p>
<p>Annotation 的每一个实现类，都 “和 1 个 RetentionPolicy 关联” 并且 “ 和 1~n 个 ElementType 关联”。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Deprecated</span>  -- <span class="hljs-meta">@Deprecated</span> 所标注内容，不再被建议使用。<br><span class="hljs-meta">@Override</span>    -- <span class="hljs-meta">@Override</span> 只能标注方法，表示该方法覆盖父类中的方法。<br><span class="hljs-meta">@Documented</span>  -- <span class="hljs-meta">@Documented</span> 所标注内容，可以出现在javadoc中。<br><span class="hljs-meta">@Inherited</span>   -- <span class="hljs-meta">@Inherited</span>只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性。<br><span class="hljs-meta">@Retention</span>   -- <span class="hljs-meta">@Retention</span>只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。<br><span class="hljs-meta">@Target</span>      -- <span class="hljs-meta">@Target</span>只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。<br><span class="hljs-meta">@SuppressWarnings</span> -- <span class="hljs-meta">@SuppressWarnings</span> 所标注内容产生的警告，编译器会对这些警告保持静默。<br></code></pre></td></tr></table></figure>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a><strong>自定义注解</strong></h3><p>使用@interface自定义注解时，自动继承 java.lang.annotation.Annotation接口</p>
<p>分析：</p>
<ul>
<li>@interface用来声明一个注解，格式<code>public @interface 注解名&#123;定义内容&#125;</code></li>
<li>其中每一个方法实际上是声明了一个参数配置；</li>
<li>方法的名称就是参数的名称；</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型，Class，String，enum）；</li>
<li>可以通过default来声明参数的默认值；</li>
<li>如果只有一个参数成员，一般参数名为value；</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义注解类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAnnotation</span></span>&#123;<br>  <span class="hljs-meta">@MyAnnotation(name = &quot;bobo&quot;)</span><span class="hljs-comment">// name没有默认值，所以必须赋值，age有默认值可以不赋值</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-meta">@MyAnnotation0(&quot;bobo&quot;)</span>  <span class="hljs-comment">//当只有一个参数并且参数名为value时，可以直接写参数值，省略参数名</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test0</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> MyAnnotation&#123;<br>  <span class="hljs-comment">//注解的参数  :  参数类型 + 参数名();</span><br>  <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span></span>;  <span class="hljs-comment">//如果默认值为 -1 ，代表不存在</span><br>&#125;<br><br><span class="hljs-meta">@interface</span> MyAnnotation0&#123;<br>  <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">//当只有一个参数时，参数名可以默认为value</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Annotation-的作用"><a href="#Annotation-的作用" class="headerlink" title="Annotation 的作用"></a>Annotation 的作用</h3><ol>
<li>编译检查</li>
<li>在反射中使用 Annotation</li>
<li>根据 Annotation 生成帮助文档</li>
<li>能够帮忙查看查看代码</li>
</ol>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p><code>Class c = Class.forName(&quot;java.lang.String&quot;)</code></p>
<p>反射指的是我们可以在运行期间加载、探知、使用编译期间完全未知的类。是一个动态的机制，允许我们通过字符串来指挥程序实例化，操作属性、调用方法。使得代码提高了灵活性，但是同时也带来了更多的资源开销。</p>
<p>加载完类之后，在堆内存中，就产生了一个 Class 类型的对象（一个 类只有一个 Class 对象），这个对象就包含了完整的类的结构信息。 我们可以通过这个对象看到类的结构。</p>
<p>正常方式：<code>引入需要的“包类”名称</code>—&gt;<code>通过new实例化</code>—&gt;<code>取的实例化对象</code></p>
<p>反射方式：<code>实例化对象</code>—&gt;<code>getCLass()方法</code>—&gt;<code>得到完整的“包类”名称</code></p>
<h3 id="Java中为什么需要反射？反射要解决什么问题？"><a href="#Java中为什么需要反射？反射要解决什么问题？" class="headerlink" title="Java中为什么需要反射？反射要解决什么问题？"></a>Java中为什么需要反射？反射要解决什么问题？</h3><p>Java中编译类型有两种：</p>
<ul>
<li><strong>静态编译</strong>：在编译时确定类型，绑定对象即通过。</li>
<li><strong>动态编译</strong>：运行时确定类型，绑定对象。动态编译最大限度地发挥了Java的灵活性，体现了多态的应用，可以减低类之间的耦合性。</li>
</ul>
<p>反射是Java被视为动态（或准动态）语言的关键，反射机制允许程序在执行期借助Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。包括其modifiers（诸如public、static等）、superclass（例如Object）、实现之interfaces（例如Cloneable），也包括fields和methods的所有信息，并可于运行时改变fields内容或唤起methods。</p>
<p>Reflection可以在运行时加载、探知、使用编译期间完全未知的classes。即Java程序可以加载一个运行时才得知名称的class，获取其完整构造，并生成其对象实体、或对其fields设值、或唤起其methods。</p>
<p>反射（reflection）允许静态语言在运行时（runtime）检查、修改程序的结构与行为。<br>在静态语言中，使用一个变量时，必须知道它的类型。在Java中，变量的类型信息在编译时都保存到了class文件中，这样在运行时才能保证准确无误。</p>
<p>实现Java反射机制的类都位于java.lang.reflect包中：</p>
<ol>
<li>Class类：代表一个类</li>
<li>Field类：代表类的成员变量（类的属性）</li>
<li>Method类：代表类的方法</li>
<li>Constructor类：代表类的构造方法</li>
<li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法</li>
</ol>
<p><strong>优点</strong> ：可以实现动态创建对象和编译，体现出很大的灵活性</p>
<p><strong>缺点</strong> ：对性能有影响，使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且他满足我们的要求，这类操作总是慢于直接执行相同的操作。</p>
<h3 id="获取Class类的对象"><a href="#获取Class类的对象" class="headerlink" title="获取Class类的对象"></a>获取Class类的对象</h3><p><strong>举例</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-comment">//什么叫反射</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        <span class="hljs-comment">//通过反射获取类的class对象</span><br>        Class&lt;?&gt; c1 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br>        System.out.println(c1);<br><br>        Class&lt;?&gt; c2 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br>        Class&lt;?&gt; c3 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br>        Class&lt;?&gt; c4 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">//一个类在内存中只有一个class对象</span><br>        <span class="hljs-comment">//一个类被加载后，类的整个结构都会被封装在class对象</span><br>        System.out.println(c2.hashCode());<br>        System.out.println(c3.hashCode());<br>        System.out.println(c4.hashCode());<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//实体类  Pojo</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">class com.bobo.reflection.User   //得到类的全类名</span><br><span class="hljs-comment">789451787</span><br><span class="hljs-comment">789451787</span><br><span class="hljs-comment">789451787</span><br><span class="hljs-comment">//说明一个类在内存中只有一个class对象 ， 因为创建三个对象的hashcode相同</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ol>
<li><p>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高</p>
<p><code>Class c2 = Class.forName(&quot;com.bobo.reflection.Student&quot;);</code></p>
</li>
<li><p>一直某个类的实例，调用该实例的getClass()方法获取Class对象</p>
<p><code>Class c1 = person.getClass();</code></p>
</li>
<li><p>一直一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException异常</p>
<p><code>Class&lt;Student&gt; c3 = Student.class;</code></p>
</li>
<li><p>内置基本数据类型可以直接用<code>类名.Type</code></p>
<p><code>Class&lt;Integer&gt; c4 = Integer.TYPE;</code></p>
</li>
<li><p>还可以利用ClassLoader</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-comment">//测试Class类的创建方式有哪些</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>        Person person = <span class="hljs-keyword">new</span> Student();<br>        System.out.println(<span class="hljs-string">&quot;这个人是：&quot;</span>+person.name);<br><br>        <span class="hljs-comment">//方式一：通过对象获得</span><br>        Class c1 = person.getClass();<br>        System.out.println(c1.hashCode());<br><br>        <span class="hljs-comment">//方式二：通过forName获得</span><br>        Class c2 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.Student&quot;</span>);<br>        System.out.println(c2.hashCode());<br><br>        <span class="hljs-comment">//方式三：通过类名.class获得</span><br>        Class&lt;Student&gt; c3 = Student.class;<br>        System.out.println(c3.hashCode());<br><br>        <span class="hljs-comment">//方式四：基本内置类型的包装类都有一个Type属性</span><br>        Class&lt;Integer&gt; c4 = Integer.TYPE;<br>        System.out.println(c4);<br><br>        <span class="hljs-comment">//获得父类类型</span><br>        Class c5 = c1.getSuperclass();<br>        System.out.println(c5);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=<span class="hljs-string">&quot;学生&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Teacher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=<span class="hljs-string">&quot;学生&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">这个人是：学生</span><br><span class="hljs-comment">1950409828</span><br><span class="hljs-comment">1950409828</span><br><span class="hljs-comment">1950409828</span><br><span class="hljs-comment">int</span><br><span class="hljs-comment">class com.bobo.reflection.Person</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>所有类型的class对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><br><span class="hljs-comment">//所有类型的Class</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Class c1 = Object.class;   <span class="hljs-comment">//类</span><br>        Class c2 = Comparable.class;   <span class="hljs-comment">//接口</span><br>        Class c3 = String[].class;   <span class="hljs-comment">//一维数组</span><br>        Class c4 = <span class="hljs-keyword">int</span>[][].class;   <span class="hljs-comment">//二维数组</span><br>        Class c5 = Override.class;   <span class="hljs-comment">//注解</span><br>        Class c6 = ElementType.class;   <span class="hljs-comment">//枚举类型</span><br>        Class c7 = Integer.class;   <span class="hljs-comment">//基本数据类型</span><br>        Class c8 = <span class="hljs-keyword">void</span>.class;    <span class="hljs-comment">//void</span><br>        Class c9 = Class.class;   <span class="hljs-comment">//Class</span><br><br>        System.out.println(c1);<br>        System.out.println(c2);<br>        System.out.println(c3);<br>        System.out.println(c4);<br>        System.out.println(c5);<br>        System.out.println(c6);<br>        System.out.println(c7);<br>        System.out.println(c8);<br>        System.out.println(c9);<br><br><br>        <span class="hljs-comment">//只要是元素类型与维度一样，就是同一个Class</span><br>        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];<br><br>        System.out.println(a.getClass().hashCode());<br>        System.out.println(b.getClass().hashCode());<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">class java.lang.Object</span><br><span class="hljs-comment">interface java.lang.Comparable</span><br><span class="hljs-comment">class [Ljava.lang.String;</span><br><span class="hljs-comment">class [[I</span><br><span class="hljs-comment">interface java.lang.Override</span><br><span class="hljs-comment">class java.lang.annotation.ElementType</span><br><span class="hljs-comment">class java.lang.Integer</span><br><span class="hljs-comment">void</span><br><span class="hljs-comment">class java.lang.Class</span><br><span class="hljs-comment">580220585</span><br><span class="hljs-comment">580220585</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>只要是元素类型与维度一样，就是同一个Class</li>
</ul>
<h3 id="类加载内存分析"><a href="#类加载内存分析" class="headerlink" title="类加载内存分析"></a>类加载内存分析</h3><img src="/article/1621/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84.png" class title="img">
<p>JVM把class文件加载到内存，并对数据进行校验、准备、解析、初始化，最终形成JVM可以直接使用的Java类型的过程。</p>
<ol>
<li><p>加载</p>
<p>将class字节码文件加载到内存中，并将这些数据转换成方法区中的运行时数据（静态变量、静态代码块、常量池等），在堆中生成一个Class类对象代表这个类（反射原理），作为方法区类数据的访问入口。</p>
</li>
<li><p>链接</p>
<p>将Java类的二进制代码合并到JVM的运行状态之中(JRE)。</p>
<ul>
<li>验证<br>确保加载的类信息符合JVM规范，没有安全方面的问题。</li>
<li>准备<br>正式为类变量(static变量)分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。注意此时的设置初始值为默认值，具体赋值在初始化阶段完成</li>
<li>解析<br>虚拟机常量池内的符号引用替换为直接引用（地址引用）的过程。</li>
</ul>
</li>
<li><p>初始化</p>
<p>初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的<strong>赋值</strong>动作和<strong>静态语句块(static块)</strong>中的语句合并产生的。</clinit></clinit></p>
<ul>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</clinit></li>
</ul>
</li>
</ol>
<p><strong>类的初始化</strong></p>
<p><code>父类</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类被加载&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>子类</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子类被加载&quot;</span>);<br>        m = <span class="hljs-number">300</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>主动引用（一定会初始化）</li>
</ol>
<ul>
<li><p>new一个类的对象；</p>
</li>
<li><p>当虚拟启动时，先初始化main方法所在的类；</p>
</li>
<li><p>调用类的静态成员(除了final常量)和静态方法；</p>
</li>
<li><p>使用java.lang.reflect包的方法对类进行反射调用；</p>
</li>
<li><p>当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类</p>
</li>
</ul>
<p><code>实现类</code>new一个类的对象主动引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-comment">//测试类什么时候会初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//主动引用</span><br>        Son son = <span class="hljs-keyword">new</span> Son();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main类被加载</span><br><span class="hljs-comment">父类被加载</span><br><span class="hljs-comment">子类被加载</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><code>实现类</code>反射产生主动引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-comment">//测试类什么时候会初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br>      <span class="hljs-comment">//反射产生主动引用</span><br>      Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.Son&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main类被加载</span><br><span class="hljs-comment">父类被加载</span><br><span class="hljs-comment">子类被加载</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li>被动引用</li>
</ol>
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。例如：通过子类引用父类的静态变量，不会导致子类初始化。</li>
<li>通过数组定义类引用，不会触发此类的初始化。</li>
<li>引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）。</li>
</ul>
<p><code>实现类</code>子类引用父类的静态变量，不会导致子类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-comment">//测试类什么时候不会初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">//不会产生类的引用的方法</span><br>        <span class="hljs-comment">//子类引用父类的静态变量，不会导致子类的初始化</span><br>        System.out.println(Son.b);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main类被加载</span><br><span class="hljs-comment">父类被加载</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><code>实现类</code>只是为一片内存赋名，不会初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-comment">//测试类什么时候不会初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//只是为一片内存赋名，不会初始化</span><br>        Son[] array = <span class="hljs-keyword">new</span> Son[<span class="hljs-number">5</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main类被加载</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><code>实现类</code>只是为一片内存赋名，不会初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-comment">//测试类什么时候不会初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//引用常量不会触发此类的初始化</span><br>        System.out.println(Son.M);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">main类被加载</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="类加载器的原理"><a href="#类加载器的原理" class="headerlink" title="类加载器的原理"></a>类加载器的原理</h3><p><strong>类缓存</strong></p>
<p>标准的Java SE类加载器可以按要求查找类，一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过，JVM垃圾收集器可以回收这些Class对象。</p>
<p><strong>类加载的作用</strong></p>
<p>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</p>
<img src="/article/1621/1516208-20200126152957474-364815257.png" class title="img">
<p><strong>类加载器分类</strong></p>
<img src="/article/1621/376.png" class title="img">
<ul>
<li><p>自底向上检查类是否已装载</p>
</li>
<li><p>自顶向下尝试加载类</p>
</li>
</ul>
<ol>
<li><p>引导类加载器（bootstrap class loader）</p>
<ol>
<li>它用来加载 Java 的核心库(JAVA_HOME/jre/lib/rt.jar,sun.boot.class.path路径下的内容)，是用原生代码（C语言）来实现的，并不继承自 java.lang.ClassLoader。</li>
<li>加载扩展类和应用程序类加载器。并指定他们的父类加载器。</li>
</ol>
</li>
<li><p>扩展类加载器（extensions class loader）</p>
<ol>
<li>用来加载 Java 的扩展库(JAVA_HOME/jre/ext/*.jar，或java.ext.dirs路径下的内容) 。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java类。</li>
<li>由sun.misc.Launcher$ExtClassLoader实现。</li>
</ol>
</li>
<li><p>应用程序类加载器（application class loader）</p>
<ol>
<li>它根据 Java 应用的类路径（classpath，java.class.path 路径下的内容）来加载 Java 类。<strong>一般来说，Java 应用的类都是由它来完成加载的。</strong></li>
<li>由sun.misc.Launcher$AppClassLoader实现。</li>
</ol>
</li>
<li><p>自定义类加载器</p>
<ol>
<li>开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test06</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;<br><br>        <span class="hljs-comment">//获取系统类的加载器</span><br>        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);<br><br>        <span class="hljs-comment">//获取系统类加载起的父类加载器 --&gt; 扩展类加载器</span><br>        ClassLoader parent = systemClassLoader.getParent();<br>        System.out.println(parent);<br><br>        <span class="hljs-comment">//获取扩展类加载起的父类加载器 --&gt; 根类加载器（C/C++）</span><br>        ClassLoader grandparent = parent.getParent();<br>        <span class="hljs-comment">//用来装载核心类库，改加载类无法直接获取</span><br>        System.out.println(grandparent);<br><br>        <span class="hljs-comment">//测试当前类是哪个加载起加载的</span><br>        ClassLoader classLoader = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.Test06&quot;</span>).getClassLoader();<br>        System.out.println(classLoader);<br><br>        <span class="hljs-comment">//测试jdk内置的类是哪个加载起加载的</span><br>        classLoader = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getClassLoader();<br>        System.out.println(classLoader);<br><br>        <span class="hljs-comment">//如何获得系统类加载器可以加载的路径</span><br>        System.out.println(System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">jdk.internal.loader.ClassLoaders$AppClassLoader@55054057</span><br><span class="hljs-comment">jdk.internal.loader.ClassLoaders$PlatformClassLoader@2f0e140b</span><br><span class="hljs-comment">null</span><br><span class="hljs-comment">jdk.internal.loader.ClassLoaders$AppClassLoader@55054057</span><br><span class="hljs-comment">null</span><br><span class="hljs-comment">/Users/renbo/Desktop/研究生/学习笔记/编程/JAVA/狂神/relfection/target/classes</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>使用JDK11编译结果如上</p>
</li>
<li><p>使用JDK8编译结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">sun.misc.Launcher$AppClassLoader@18b4aac2<br>sun.misc.Launcher$ExtClassLoader@1b6d3586<br><span class="hljs-keyword">null</span><br>sun.misc.Launcher$AppClassLoader@18b4aac2<br><span class="hljs-keyword">null</span><br> /Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/charsets.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/deploy.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/cldrdata.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/dnsns.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/jaccess.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/jfxrt.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/localedata.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/nashorn.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/sunec.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/ext/zipfs.ja;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/javaws.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/jce.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/jfr.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/jfxswt.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/jsse.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/management-agent.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/plugin.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/resources.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/jre/lib/rt.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/ant-javafx.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/dt.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/javafx-mx.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/jconsole.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/packager.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/sa-jdi.jar;<br>/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>.jdk/Contents/Home/lib/tools.jar;<br>/Users/renbo/Desktop/研究生/学习笔记/编程/JAVA/狂神/relfection/target/classes<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>双亲委派机制</strong></p>
<img src="/article/1621/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E5%9B%BE%E8%A7%A3.png" class title="img">
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己先加载，而是把这个请求委托给父类的加载器去执行</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的引导类加载器；</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制</li>
<li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li>
</ol>
<p><strong>优势</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改<ul>
<li>自定义类：java.lang.String (没用)</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li>
</ul>
</li>
</ul>
<h3 id="获得类的运行时结构"><a href="#获得类的运行时结构" class="headerlink" title="获得类的运行时结构"></a>获得类的运行时结构</h3><p>Java中反射获取类的成员时需要调用getFields()、getDeclaredFields()；getMethods()、getDeclaredMethods()；getConstructors()、getDeclaredConstructoers()等方法获取Field、Method、Constructor对象，这几对方法的主要区别如下： </p>
<ol>
<li><p>getFields()与getDeclaredFields()</p>
<p>getFields()返回类中所有public的字段,包括从父类或接口继承的public字段；<br>getDeclaredFields()返回本类中声明的所有字段，包括public、protected、private字段，不包括从父类或接口继承的字段 </p>
</li>
<li><p>getMethods()与getDeclaredMethods()<br> getMethods()返回类中所有public的方法，包括从父类或接口继承的public方法<br> getDeclaredMethods()返回本类中声明的所有方法，包括public、protected、private方法，不包括从父类或接口继承的方法 </p>
</li>
<li><p>getConstructors()与getDeclaredConstructors()<br> getConstructors()返回类中所有public的构造方法；<br> getDeclaredConstructors()返回类中声明的所有构造方法，包括public、protected、private构造方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">//获得类的信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test07</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException </span>&#123;<br>        Class c1 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br>        User user = <span class="hljs-keyword">new</span> User();<br>        c1 = user.getClass();<br><br>        <span class="hljs-comment">//获得类的名字</span><br>        System.out.println(c1.getName());    <span class="hljs-comment">//获得包名+类名</span><br>        System.out.println(c1.getSimpleName());   <span class="hljs-comment">//获得类名</span><br><br>        <span class="hljs-comment">//获得类得属性</span><br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        Field[] fields = c1.getFields();  <span class="hljs-comment">//getFields()只能找到public属性</span><br>        fields = c1.getDeclaredFields();<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field);<br>        &#125;<br>        Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br><br>        <span class="hljs-comment">//获得类的方法</span><br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        Method[] methods = c1.getMethods();   <span class="hljs-comment">//获得本类及其父类的全部public方法</span><br>        Method[] declaredMethods = c1.getDeclaredMethods();   <span class="hljs-comment">//获得本类的全部方法</span><br><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;正常的：&quot;</span>+method);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Method declaredMethod : declaredMethods) &#123;<br>            System.out.println(<span class="hljs-string">&quot;declaredMethod:&quot;</span>+declaredMethod);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        <span class="hljs-comment">//获得指定方法</span><br>        <span class="hljs-comment">//重载</span><br>        Method getName = c1.getMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-keyword">null</span>);<br>        Method setName = c1.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        System.out.println(getName);<br>        System.out.println(setName);<br><br>        <span class="hljs-comment">//获得指定的构造器</span><br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        Constructor[] constructors = c1.getConstructors();<br>        Constructor[] declaredConstructors = c1.getDeclaredConstructors();<br><br>        <span class="hljs-keyword">for</span> (Constructor constructor : constructors) &#123;<br>            System.out.println(constructor);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Constructor declaredConstructor : declaredConstructors) &#123;<br>            System.out.println(<span class="hljs-string">&quot;#&quot;</span>+declaredConstructor);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;====================================&quot;</span>);<br>        <span class="hljs-comment">//获得指定的构造器</span><br>        Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, <span class="hljs-keyword">int</span>.class);<br>        System.out.println(<span class="hljs-string">&quot;指定+&quot;</span>+declaredConstructor);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">com.bobo.reflection.User</span><br><span class="hljs-comment">User</span><br><span class="hljs-comment">====================================</span><br><span class="hljs-comment">private java.lang.String com.bobo.reflection.User.name</span><br><span class="hljs-comment">private int com.bobo.reflection.User.id</span><br><span class="hljs-comment">private int com.bobo.reflection.User.age</span><br><span class="hljs-comment">private java.lang.String com.bobo.reflection.User.name</span><br><span class="hljs-comment">====================================</span><br><span class="hljs-comment">正常的：public java.lang.String com.bobo.reflection.User.getName()</span><br><span class="hljs-comment">正常的：public java.lang.String com.bobo.reflection.User.toString()</span><br><span class="hljs-comment">正常的：public void com.bobo.reflection.User.setName(java.lang.String)</span><br><span class="hljs-comment">正常的：public int com.bobo.reflection.User.getId()</span><br><span class="hljs-comment">正常的：public void com.bobo.reflection.User.setId(int)</span><br><span class="hljs-comment">正常的：public int com.bobo.reflection.User.getAge()</span><br><span class="hljs-comment">正常的：public void com.bobo.reflection.User.setAge(int)</span><br><span class="hljs-comment">正常的：public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="hljs-comment">正常的：public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="hljs-comment">正常的：public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="hljs-comment">正常的：public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="hljs-comment">正常的：public native int java.lang.Object.hashCode()</span><br><span class="hljs-comment">正常的：public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="hljs-comment">正常的：public final native void java.lang.Object.notify()</span><br><span class="hljs-comment">正常的：public final native void java.lang.Object.notifyAll()</span><br><span class="hljs-comment">declaredMethod:public java.lang.String com.bobo.reflection.User.getName()</span><br><span class="hljs-comment">declaredMethod:public java.lang.String com.bobo.reflection.User.toString()</span><br><span class="hljs-comment">declaredMethod:public void com.bobo.reflection.User.setName(java.lang.String)</span><br><span class="hljs-comment">declaredMethod:public int com.bobo.reflection.User.getId()</span><br><span class="hljs-comment">declaredMethod:public void com.bobo.reflection.User.setId(int)</span><br><span class="hljs-comment">declaredMethod:public int com.bobo.reflection.User.getAge()</span><br><span class="hljs-comment">declaredMethod:public void com.bobo.reflection.User.setAge(int)</span><br><span class="hljs-comment">====================================</span><br><span class="hljs-comment">public java.lang.String com.bobo.reflection.User.getName()</span><br><span class="hljs-comment">public void com.bobo.reflection.User.setName(java.lang.String)</span><br><span class="hljs-comment">====================================</span><br><span class="hljs-comment">public com.bobo.reflection.User()</span><br><span class="hljs-comment">public com.bobo.reflection.User(java.lang.String,int,int)</span><br><span class="hljs-comment">#public com.bobo.reflection.User()</span><br><span class="hljs-comment">#public com.bobo.reflection.User(java.lang.String,int,int)</span><br><span class="hljs-comment">====================================</span><br><span class="hljs-comment">指定+public com.bobo.reflection.User(java.lang.String,int,int)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>invoke()方法：用于调用指定的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj,Object... args)</span></span><br></code></pre></td></tr></table></figure>
<ul>
<li>第一个Object对应原方法的返回值，若原方法无返回值则返回null</li>
<li>括号里的第一个Object代表调用这个方法的对象</li>
<li>若原方法形参列表为空，Object[] args为null</li>
<li>如果原方法声明为private，需要在调用invoke()之前调用setAccessible()方法</li>
</ul>
<p><strong>setAccessible()方法：用于启动和禁止访问安全检查的开关</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAccessible</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> flag)</span></span><br></code></pre></td></tr></table></figure>
<p>参数为false表示反射的对象应该实施访问检查，参数为true则关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">//动态的创建对象，通过反射</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test08</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException </span>&#123;<br>        <span class="hljs-comment">//获得Class对象</span><br>        Class c1 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.User&quot;</span>);<br><br>        <span class="hljs-comment">//构造一个对象</span><br>        <span class="hljs-comment">//User user = (User) c1.newInstance();   //本质是调用了类无参构造器</span><br>        <span class="hljs-comment">//System.out.println(user);</span><br>        Constructor constructor = (Constructor) c1.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class, <span class="hljs-keyword">int</span>.class);<br>        User user2 = (User) constructor.newInstance(<span class="hljs-string">&quot;bobo&quot;</span>, <span class="hljs-number">001</span>, <span class="hljs-number">18</span>);<br>        System.out.println(user2);<br><br>        <span class="hljs-comment">//通过反射调用普通方法</span><br>        User user3 = (User) c1.newInstance();<br>        <span class="hljs-comment">//通过反射获取一个方法</span><br>        Method setName = c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>        <span class="hljs-comment">//invoke() 激活</span><br>        <span class="hljs-comment">//(对象，&quot;方法的值&quot;)</span><br>        setName.invoke(user3,<span class="hljs-string">&quot;bobo&quot;</span>);<br>        System.out.println(user3.getName());<br><br>        <span class="hljs-comment">//通过反射操作属性</span><br>        System.out.println(<span class="hljs-string">&quot;================================&quot;</span>);<br>        User user4 = (User) c1.newInstance();<br>        Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">//不能直接操作私有属性，我们需要关闭程序的安全检测   属性或者方法的 setAccessible(true)</span><br>        name.setAccessible(<span class="hljs-keyword">true</span>);<br>        name.set(user4,<span class="hljs-string">&quot;bobo2&quot;</span>);<br>        System.out.println(user4.getName());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">User&#123;name=&#x27;bobo&#x27;, id=1, age=18&#125;</span><br><span class="hljs-comment">bobo</span><br><span class="hljs-comment">================================</span><br><span class="hljs-comment">bobo2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="性能对比分析"><a href="#性能对比分析" class="headerlink" title="性能对比分析"></a>性能对比分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">//分析性能问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test09</span> </span>&#123;<br><br>    <span class="hljs-comment">//普通方式调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        <span class="hljs-comment">//获取开始时间</span><br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            user.getName();<br>        &#125;<br>        <span class="hljs-comment">//获取结束时间</span><br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;普通方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//反射方式调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        Class c1 = user.getClass();<br>        Method getName = c1.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//获取开始时间</span><br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            getName.invoke(user, <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-comment">//获取结束时间</span><br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;反射方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//反射方式调用  关闭检测</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        Class c1 = user.getClass();<br>        Method getName = c1.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>, <span class="hljs-keyword">null</span>);<br>        getName.setAccessible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//获取开始时间</span><br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) &#123;<br>            getName.invoke(user, <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-comment">//获取结束时间</span><br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;关闭检测，反射方式执行10亿次：&quot;</span>+(endTime-startTime)+<span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, NoSuchMethodException, IllegalAccessException </span>&#123;<br>        test01();<br>        test02();<br>        test03();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">普通方式执行<span class="hljs-number">10</span>亿次：5ms<br>反射方式执行<span class="hljs-number">10</span>亿次：2470ms<br>关闭检测，反射方式执行<span class="hljs-number">10</span>亿次：1169ms<br></code></pre></td></tr></table></figure>
<p><strong>反射操作泛型</strong></p>
<p>Java采用泛型擦除机制来引入泛型。Java中的泛型仅仅是给编译器Javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是编译一旦完成，所有和泛型有关的类型全部被擦除。</p>
<p>为了通过反射操作这些类型以迎合实际开发的需要，Java新增了ParameterizedType,GenericArrayType,TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。 </p>
<ul>
<li><code>ParameterizedType</code>:表示一种参数化的类型，比如<code>Collection&lt;String&gt;</code></li>
<li><code>GenericArrayType</code>:表示一种元素类型是参数化类型或者类型变量的数组类型</li>
<li><code>TypeVariable</code>:是各种类型变量的公共父接口</li>
<li><code>WildcardType</code>:代表一种通配符类型表达式，比如<code>？</code>、<code>？ extends Number</code>、<code>？ super Integer</code>。（wildcard是一个单词：就是”通配符“）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Parameter;<br><span class="hljs-keyword">import</span> java.lang.reflect.ParameterizedType;<br><span class="hljs-keyword">import</span> java.lang.reflect.Type;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">//通过反射获取泛型</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">(Map&lt;String,User&gt; map, List&lt;User&gt; list)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test01&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String ,User&gt; <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test02&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException </span>&#123;<br>        <span class="hljs-comment">//参数是泛型</span><br>        Method method = Test.class.getMethod(<span class="hljs-string">&quot;test01&quot;</span>, Map.class, List.class);<br>        Type[] genericParameterTypes = method.getGenericParameterTypes();<br>        <span class="hljs-keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;<br>          System.out.println(<span class="hljs-string">&quot;genericParameterType:&quot;</span>+genericParameterType);<br>            <span class="hljs-keyword">if</span> (genericParameterType <span class="hljs-keyword">instanceof</span> ParameterizedType)&#123;<br>                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();<br>                <span class="hljs-keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;<br>                    System.out.println(actualTypeArgument);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//返回值是泛型</span><br>        method = Test.class.getMethod(<span class="hljs-string">&quot;test02&quot;</span>, <span class="hljs-keyword">null</span>);<br>        Type genericReturnType = method.getGenericReturnType();<br>        <span class="hljs-keyword">if</span> (genericReturnType <span class="hljs-keyword">instanceof</span> ParameterizedType)&#123;<br>            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();<br>            <span class="hljs-keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;<br>                System.out.println(actualTypeArgument);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">返回结果：<br>genericParameterType:java.util.Map&lt;java.lang.String,com.bobo.reflection.User&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span></span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">bobo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span></span><br><span class="hljs-class"><span class="hljs-title">genericParameterType</span>:<span class="hljs-title">java</span>.<span class="hljs-title">util</span>.<span class="hljs-title">List</span>&lt;<span class="hljs-title">com</span>.<span class="hljs-title">bobo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span>&gt;</span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">bobo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span></span><br><span class="hljs-class">  </span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span></span><br><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">bobo</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">User</span></span><br></code></pre></td></tr></table></figure>
<h2 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h2><p><strong>获取注解的方法：</strong></p>
<ul>
<li>Class.getAnnotations() 获取所有的注解，包括自己声明的以及继承的</li>
<li>Class.getAnnotation(Class&lt; A &gt; annotationClass) 获取指定的注解，该注解可以是自己声明的，也可以是继承的</li>
<li>Class.getDeclaredAnnotations() 获取自己声明的注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.reflection;<br><span class="hljs-keyword">import</span> java.lang.annotation.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-comment">//练习反射操作注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test11</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException </span>&#123;<br>        Class c1 = Class.forName(<span class="hljs-string">&quot;com.bobo.reflection.Students&quot;</span>);<br><br>        <span class="hljs-comment">//通过反射获取注解</span><br>        Annotation[] annotations = c1.getAnnotations();<br>        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;<br>            System.out.println(annotation);<br>        &#125;<br><br>        <span class="hljs-comment">//获得注解的value的值</span><br>        Tablebobo tablebobo = (Tablebobo) c1.getAnnotation(Tablebobo.class);<br>        String value = tablebobo.value();<br>        System.out.println(value);<br><br>        <span class="hljs-comment">//获得类指定的注解</span><br>        Field name = c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        Filebobo annotation = name.getAnnotation(Filebobo.class);<br>        System.out.println(annotation.columnName());<br>        System.out.println(annotation.type());<br>        System.out.println(annotation.length());<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Tablebobo(&quot;db_students&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Students</span></span>&#123;<br>    <span class="hljs-meta">@Filebobo(columnName = &quot;db_id&quot;,type = &quot;int&quot;,length = 10)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-meta">@Filebobo(columnName = &quot;db_age&quot;,type = &quot;int&quot;,length = 10)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-meta">@Filebobo(columnName = &quot;db_name&quot;,type = &quot;varcher&quot;,length = 3)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Students</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Students</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> age, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Students&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//@Target  注解作用域</span><br><span class="hljs-comment">//@Rtention  在什么级别可以获取</span><br><span class="hljs-comment">//类名的注解</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> Tablebobo&#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//属性的注解</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@interface</span> Filebobo&#123;<br>    <span class="hljs-function">String <span class="hljs-title">columnName</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">type</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">运行结果：<br><span class="hljs-meta">@com</span>.bobo.reflection.Tablebobo(<span class="hljs-string">&quot;db_students&quot;</span>)<br>db_students<br>db_name<br>varcher<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>注解与反射</category>
      </categories>
      <tags>
        <tag>Java,注解与反射</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/article/52560.html</url>
    <content><![CDATA[<p>　　　　　　　　　　</p>
<blockquote>
<p>The world rushes on over the strings of the lingering heart making<br>the music of sadness.</p>
<p>世界在踌躇之心的琴弦上跑过去，奏出忧郁的乐声。</p>
</blockquote>
<h2 id="Java-网络编程"><a href="#Java-网络编程" class="headerlink" title="Java 网络编程"></a>Java 网络编程</h2><p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。</p>
<p>java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p>
<p>java.net 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><strong>TCP</strong>：TCP（英语：Transmission Control Protocol，传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP 层是位于 IP 层之上，应用层之下的中间层。TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。</li>
<li><strong>UDP</strong>：UDP （英语：User Datagram Protocol，用户数据报协议），位于 OSI 模型的传输层。一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。</li>
</ul>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>为了便于寻址以及层次化构造网络，每个IP地址包括两个标识码（ID），即<strong>网络ID和主机ID</strong>。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。Internet委员会定义了5种IP地址类型以适合不同容量的网络，即A类~E类。</p>
<img src="/article/52560/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.jpg" class title="IP地址分类">
<h3 id="IPV4与IPV6"><a href="#IPV4与IPV6" class="headerlink" title="IPV4与IPV6"></a>IPV4与IPV6</h3><table>
<thead>
<tr>
<th style="text-align:left">描述</th>
<th style="text-align:left">IPv4</th>
<th style="text-align:left">IPv6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>地址</strong></td>
<td style="text-align:left">长度为 32 位（4 个字节）。地址由网络和主机部分组成，这取决于地址类。根据地址的前几位，可定义各种地址类：A、B、C、D 或 E。IPv4 地址的总数为 4 294 967 296。IPv4 地址的文本格式为 nnn.nnn.nnn.nnn，其中 0&lt;=nnn&lt;=255，而每个 n 都是十进制数。可省略前导零。最大打印字符数为 15 个，不计掩码。</td>
<td style="text-align:left">长度为 128 位（16 个字节）。基本体系结构的网络数字为 64 位，主机数字为 64 位。通常，IPv6 地址（或其部分）的主机部分将派生自 MAC 地址或其他接口标识。根据子网前缀，IPv6 的体系结构比 IPv4 的体系结构更复杂。IPv6 地址的数目比 IPv4 地址的数目大 1028（79 228 162 514 264 337 593 543 950 336）倍。IPv6 地址的文本格式为xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx，其中每个 x 都是十六进制数，表示 4 位。可省略前导零。可在地址的文本格式中使用一次双冒号（::），用于指定任意数目的 0 位。例如，::ffff:10.120.78.40 表示 IPv4 映射的 IPv6 地址。</td>
</tr>
<tr>
<td style="text-align:left"><strong>地址分配</strong></td>
<td style="text-align:left">最初，按网络类分配地址。随着地址空间的消耗，使用“无类域间路由”（CIDR）进行更小的分配。没有在机构和国家或地区之间平均分配地址。</td>
<td style="text-align:left">分配尚处于早期阶段。“因特网工程任务组织”（IETF ）和“因特网体系结构委员会”（IAB）建议基本上为每个组织、家庭或实体分配一个 /48 子网前缀长度。它将保留 16 位供组织进行子网划分。地址空间是足够大的，可为世界上每个人提供一个其自己的 /48 子网前缀长度。</td>
</tr>
</tbody>
</table>
<h3 id="公网IP与私网IP"><a href="#公网IP与私网IP" class="headerlink" title="公网IP与私网IP"></a>公网IP与私网IP</h3><ul>
<li>Public IP : 公共 IP ，经由 INTERNIC 所统一规划的 IP，有这种 IP 才可以连上 Internet ；</li>
<li>Private IP : 私有 IP 或保留 IP，不能直接连上 Internet 的 IP ，主要用于局域网络内的主机联机规划。</li>
</ul>
<p>公网IP在全球内是唯一的。也就是说在同一时间一个IP(除了一些特别的IP，如:154.0.0.0等)只代表一能设备，所以通只要找得到IP，也就可以找到特定的设备了。如果A是公网IP，且没有防火墙等Ban连接的话，那么B电脑上的EM就可以找并连接上A了。私网IP是专门给一些局域网内用的。也就是说在网络上是不唯一-的， 公网上是不能通这个私有IP来找到对应的设备的。</p>
<p>以下范围内的IP地址属于内网保留地址，即不是公网IP，而是属于私有IP:</p>
<ul>
<li>10.0.0.0 - 10.255.255.255</li>
<li>172.16.0.0 - 172.31.255.255</li>
<li>192.168.0.0 - 192. 168.255.255</li>
</ul>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>TCP/IP的<code>传输层</code>用一个16位端口号来标志一个端口（port）。</p>
<p>虽然通信的终点是应用程序，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作（即最后交付的进程）就由TCP或UDP来完成。</p>
<p>TCP和UDP的首部格式中，它们都有<code>源端口</code>和<code>目的端口</code>这两个重要字段。当<code>传输层</code>收到<code>网络层</code>交上来的<code>传输层报文</code>时，就能够根据其首部中的<code>目的端口号</code>把数据交付应用层的<code>目的应用进程</code>。</p>
<p>两个计算机中的进程要互相通信，不仅必须知道对方的IP地址，而且要知道对方的<code>端口号</code>（为了找到对方计算机中的应用程序）。互联网上的计算机通信是采用<code>客户端-服务器</code>方式。客户端在发起通信请求时，必须先知道对方的服务器的<code>IP地址</code>和<code>端口号</code>。</p>
<p>因此传输层的端口号分为下面的两大类：</p>
<p><strong><code>服务器端</code>使用的端口号:</strong></p>
<p>熟知端口号或系统端口号：数值为<code>0 ~ 1023</code>。</p>
<p>UDP 知名端口：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">协议</th>
<th style="text-align:center">数值端口号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center"><strong>ECHO（回声协议）</strong></td>
<td style="text-align:center"><strong>7</strong></td>
<td style="text-align:center"><strong>将收到的数据包会送给发送端</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"><strong>DNS</strong></td>
<td style="text-align:center"><strong>53</strong></td>
<td style="text-align:center"><strong>域名服务</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>3</strong></td>
<td style="text-align:center"><strong>DHCP</strong></td>
<td style="text-align:center"><strong>67</strong></td>
<td style="text-align:center"><strong>动态 主机 设置 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>4</strong></td>
<td style="text-align:center"><strong>TFTP</strong></td>
<td style="text-align:center"><strong>69</strong></td>
<td style="text-align:center"><strong>简单 文件 传输 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>5</strong></td>
<td style="text-align:center"><strong>SNMP</strong></td>
<td style="text-align:center"><strong>161，162</strong></td>
<td style="text-align:center"><strong>简单 网络 管理 协议</strong></td>
</tr>
</tbody>
</table>
<p>TCP 知名端口：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">应用程序</th>
<th style="text-align:center">数值端口号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center"><strong>ECHO（回声协议）</strong></td>
<td style="text-align:center"><strong>7</strong></td>
<td style="text-align:center"><strong>将收到的数据包会送给发送端</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"><strong>FTP</strong></td>
<td style="text-align:center"><strong>20，21</strong></td>
<td style="text-align:center"><strong>20端口 用于 数据传输 21端口 用于 控制信令的传输 控制信息 和 数据 能够同时传输，这是FTP的特殊之处</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>3</strong></td>
<td style="text-align:center"><strong>SSH</strong></td>
<td style="text-align:center"><strong>22</strong></td>
<td style="text-align:center"><strong>安全 外壳 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>4</strong></td>
<td style="text-align:center"><strong>TELNET</strong></td>
<td style="text-align:center"><strong>23</strong></td>
<td style="text-align:center"><strong>远程 终端 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>5</strong></td>
<td style="text-align:center"><strong>SMTP</strong></td>
<td style="text-align:center"><strong>25</strong></td>
<td style="text-align:center"><strong>简单 邮件 传输 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>6</strong></td>
<td style="text-align:center"><strong>DNS</strong></td>
<td style="text-align:center"><strong>53</strong></td>
<td style="text-align:center"><strong>域名服务</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>7</strong></td>
<td style="text-align:center"><strong>HTTP</strong></td>
<td style="text-align:center"><strong>80</strong></td>
<td style="text-align:center"><strong>超文本传送协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>8</strong></td>
<td style="text-align:center"><strong>HTTPS</strong></td>
<td style="text-align:center"><strong>443</strong></td>
<td style="text-align:center"><strong>超文本 传输 安全 协议</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>9</strong></td>
<td style="text-align:center"><strong>POP3</strong></td>
<td style="text-align:center"><strong>110</strong></td>
<td style="text-align:center"><strong>邮件传送协议</strong></td>
</tr>
</tbody>
</table>
<p><strong><code>客户端</code>使用的端口号：</strong></p>
<p>数值为<code>49152 ~ 65535</code></p>
<p>由于这类端口号仅在客户进程运行时才动态选择，因此又叫做<code>短暂端口号</code>。这类端口号留给客户进程选择暂时使用。</p>
<p>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的<code>端口号</code>，因而可以把数据发送给客户进程。</p>
<p>通信结束后，刚才已使用过的客户端口号就不存在了，这个端口号就可以供其他客户进程使用。</p>
<p><strong>常见端口号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">21端口：FTP 文件传输服务<br>22端口：SSH 端口<br>23端口：TELNET 终端仿真服务<br>25端口：SMTP 简单邮件传输服务<br>53端口：DNS 域名解析服务<br>80端口：HTTP 超文本传输服务<br>110端口：POP3 “邮6局协议版本3”使用的端口<br>443端口：HTTPS 加密的超文本传输服务<br>8080端口：Tomcat<br>3306端口：Mysql<br>1521端口: Oracle<br></code></pre></td></tr></table></figure>
<h2 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h2><p>端口号与IP地址的组合，得出一个网络套接字：Socket，所以说一些网络编程也被称为Socket编程</p>
<p>套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。</p>
<p>当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。</p>
<p>java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。</p>
<p>以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：</p>
<ul>
<li>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</li>
<li>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li>
<li>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</li>
<li>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</li>
<li>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</li>
</ul>
<p>连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。</p>
<p>TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送</p>
<p><strong>ServerSocket 类的方法</strong></p>
<p>服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。</p>
<p>ServerSocket 类有四个构造方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>序号</strong></th>
<th style="text-align:left"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left"><strong>public ServerSocket(int port) throws IOException</strong> 创建绑定到特定端口的服务器套接字。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left"><strong>public ServerSocket(int port, int backlog) throws IOException</strong> 利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left"><strong>public ServerSocket(int port, int backlog, InetAddress address) throws IOException</strong> 使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left"><strong>public ServerSocket() throws IOException</strong> 创建非绑定服务器套接字。</td>
</tr>
</tbody>
</table>
<p>创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。</p>
<p>这里有一些 ServerSocket 类的常用方法：</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>public int getLocalPort()</strong>  返回此套接字在其上侦听的端口。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public Socket accept() throws IOException</strong> 侦听并接受到此套接字的连接。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public void setSoTimeout(int timeout)</strong>  通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public void bind(SocketAddress host, int backlog)</strong> 将 ServerSocket 绑定到特定地址（IP 地址和端口号）。</td>
</tr>
</tbody>
</table>
<p><strong>Socket 类的方法</strong></p>
<p>java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。</p>
<p>Socket 类有五个构造方法.</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>序号</strong></th>
<th style="text-align:left"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left"><strong>public Socket(String host, int port) throws UnknownHostException, IOException.</strong> 创建一个流套接字并将其连接到指定主机上的指定端口号。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left"><strong>public Socket(InetAddress host, int port) throws IOException</strong> 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left"><strong>public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.</strong> 创建一个套接字并将其连接到指定远程主机上的指定远程端口。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left"><strong>public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException.</strong> 创建一个套接字并将其连接到指定远程地址上的指定远程端口。</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left"><strong>public Socket()</strong> 通过系统默认类型的 SocketImpl 创建未连接套接字</td>
</tr>
</tbody>
</table>
<p>当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。</p>
<p>下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td><strong>public void connect(SocketAddress host, int timeout) throws IOException</strong> 将此套接字连接到服务器，并指定一个超时值。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td><strong>public InetAddress getInetAddress()</strong>  返回套接字连接的地址。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td><strong>public int getPort()</strong> 返回此套接字连接到的远程端口。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td><strong>public int getLocalPort()</strong> 返回此套接字绑定到的本地端口。</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td><strong>public SocketAddress getRemoteSocketAddress()</strong> 返回此套接字连接的端点的地址，如果未连接则返回 null。</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td><strong>public InputStream getInputStream() throws IOException</strong> 返回此套接字的输入流。</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td><strong>public OutputStream getOutputStream() throws IOException</strong> 返回此套接字的输出流。</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td><strong>public void close() throws IOException</strong> 关闭此套接字。</td>
</tr>
</tbody>
</table>
<p><strong>InetAddress 类的方法</strong></p>
<p>这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>序号</strong></th>
<th style="text-align:left"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:left"><strong>static InetAddress getByAddress(byte[] addr)</strong> 在给定原始 IP 地址的情况下，返回 InetAddress 对象。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:left"><strong>static InetAddress getByAddress(String host, byte[] addr)</strong> 根据提供的主机名和 IP 地址创建 InetAddress。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:left"><strong>static InetAddress getByName(String host)</strong> 在给定主机名的情况下确定主机的 IP 地址。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:left"><strong>String getHostAddress()</strong>  返回 IP 地址字符串（以文本表现形式）。</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:left"><strong>String getHostName()</strong>   获取此 IP 地址的主机名。</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:left"><strong>static InetAddress getLocalHost()</strong> 返回本地主机。</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:left"><strong>String toString()</strong> 将此 IP 地址转换为 String。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.InetAddress; <br><span class="hljs-keyword">import</span> java.net.UnknownHostException; <br><span class="hljs-comment">//IP 这个东西，怎么用Java对象表示 </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InetAddressTest</span> </span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//获得IP地址 </span><br>    InetAddress inetAddresses1 = InetAddress.getByName(<span class="hljs-string">&quot;192.168.8.123&quot;</span>); <br>    System.out.println(inetAddresses1); <br>    InetAddress inetAddresses2 = InetAddress.getByName(<span class="hljs-string">&quot;www.baidu.com&quot;</span>); <br>    System.out.println(inetAddresses2); <br>    <span class="hljs-comment">//获取本地IP </span><br>    InetAddress inetAddresses3 = InetAddress.getByName(<span class="hljs-string">&quot;127.0.0.1&quot;</span>); <br>    System.out.println(inetAddresses3); <br>    InetAddress inetAddresses4 = InetAddress.getByName(<span class="hljs-string">&quot;localhost&quot;</span>); <br>    System.out.println(inetAddresses4); <br>    InetAddress inetAddresses5 = InetAddress.getLocalHost(); <br>    System.out.println(inetAddresses5); <br>    <span class="hljs-comment">//getHostName </span><br>    System.out.println(inetAddresses2.getHostName()); <br>    <span class="hljs-comment">//getHostAddress </span><br>    System.out.println(inetAddresses2.getHostAddress()); <br>    <span class="hljs-comment">//Canonical : 规范的 S</span><br>    ystem.out.println(inetAddresses2.getCanonicalHostName()); <br>    &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123; <br>    e.printStackTrace(); <br>    &#125; <br>  &#125; <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">/192.168.8.123</span><br><span class="hljs-comment">www.baidu.com/182.61.200.6</span><br><span class="hljs-comment">/127.0.0.1</span><br><span class="hljs-comment">localhost/127.0.0.1</span><br><span class="hljs-comment">GMagic-Pro.local/127.0.0.1</span><br><span class="hljs-comment">www.baidu.com</span><br><span class="hljs-comment">182.61.200.6</span><br><span class="hljs-comment">182.61.200.6</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>InetSocketAddress类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.InetSocketAddress; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InetSocketAddressTest</span> </span>&#123; <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123; <br>    InetSocketAddress socketAddress = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">8080</span>);<br>    InetSocketAddress socketAddress2 = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-number">9000</span>); 		<br>    System.out.println(socketAddress.getHostName()); <br>    System.out.println(socketAddress.getAddress()); <br>    System.out.println(socketAddress.getPort()); <br>    System.out.println(socketAddress2.getHostName()); <br>    System.out.println(socketAddress2.getAddress()); <span class="hljs-comment">//返回地址 </span><br>    System.out.println(socketAddress2.getPort()); <span class="hljs-comment">//返回端口 </span><br>  &#125; <br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">返回结果：</span><br><span class="hljs-comment">localhost</span><br><span class="hljs-comment">localhost/127.0.0.1</span><br><span class="hljs-comment">8080</span><br><span class="hljs-comment">localhost</span><br><span class="hljs-comment">localhost/127.0.0.1</span><br><span class="hljs-comment">9000</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>Socket 客户端实例</strong></p>
<p>如下的 GreetingClient 是一个客户端程序，该程序通过 socket 连接到服务器并发送一个请求，然后等待一个响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件名 GreetingClient.java</span><br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingClient</span></span><br><span class="hljs-class"></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span></span><br><span class="hljs-function">   </span>&#123;<br>      String serverName = args[<span class="hljs-number">0</span>];<br>      <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">1</span>]);<br>      <span class="hljs-keyword">try</span><br>      &#123;<br>         System.out.println(<span class="hljs-string">&quot;连接到主机：&quot;</span> + serverName + <span class="hljs-string">&quot; ，端口号：&quot;</span> + port);<br>         Socket client = <span class="hljs-keyword">new</span> Socket(serverName, port);<br>         System.out.println(<span class="hljs-string">&quot;远程主机地址：&quot;</span> + client.getRemoteSocketAddress());<br>         OutputStream outToServer = client.getOutputStream();<br>         DataOutputStream out = <span class="hljs-keyword">new</span> DataOutputStream(outToServer);<br> <br>         out.writeUTF(<span class="hljs-string">&quot;Hello from &quot;</span> + client.getLocalSocketAddress());<br>         InputStream inFromServer = client.getInputStream();<br>         DataInputStream in = <span class="hljs-keyword">new</span> DataInputStream(inFromServer);<br>         System.out.println(<span class="hljs-string">&quot;服务器响应： &quot;</span> + in.readUTF());<br>         client.close();<br>      &#125;<span class="hljs-keyword">catch</span>(IOException e)<br>      &#123;<br>         e.printStackTrace();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Socket 服务端实例</strong></p>
<p>如下的GreetingServer 程序是一个服务器端应用程序，使用 Socket 来监听一个指定的端口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 文件名 GreetingServer.java</span><br> <br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span><br><span class="hljs-class"></span>&#123;<br>   <span class="hljs-keyword">private</span> ServerSocket serverSocket;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GreetingServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function">   </span>&#123;<br>      serverSocket = <span class="hljs-keyword">new</span> ServerSocket(port);<br>      serverSocket.setSoTimeout(<span class="hljs-number">10000</span>);<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">   </span>&#123;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)<br>      &#123;<br>         <span class="hljs-keyword">try</span><br>         &#123;<br>            System.out.println(<span class="hljs-string">&quot;等待远程连接，端口号为：&quot;</span> + serverSocket.getLocalPort() + <span class="hljs-string">&quot;...&quot;</span>);<br>            Socket server = serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;远程主机地址：&quot;</span> + server.getRemoteSocketAddress());<br>            DataInputStream in = <span class="hljs-keyword">new</span> DataInputStream(server.getInputStream());<br>            System.out.println(in.readUTF());<br>            DataOutputStream out = <span class="hljs-keyword">new</span> DataOutputStream(server.getOutputStream());<br>            out.writeUTF(<span class="hljs-string">&quot;谢谢连接我：&quot;</span> + server.getLocalSocketAddress() + <span class="hljs-string">&quot;\nGoodbye!&quot;</span>);<br>            server.close();<br>         &#125;<span class="hljs-keyword">catch</span>(SocketTimeoutException s)<br>         &#123;<br>            System.out.println(<span class="hljs-string">&quot;Socket timed out!&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>         &#125;<span class="hljs-keyword">catch</span>(IOException e)<br>         &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">break</span>;<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span></span><br><span class="hljs-function">   </span>&#123;<br>      <span class="hljs-keyword">int</span> port = Integer.parseInt(args[<span class="hljs-number">0</span>]);<br>      <span class="hljs-keyword">try</span><br>      &#123;<br>         Thread t = <span class="hljs-keyword">new</span> GreetingServer(port);<br>         t.run();<br>      &#125;<span class="hljs-keyword">catch</span>(IOException e)<br>      &#123;<br>         e.printStackTrace();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先启动服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">$ javac GreetingServer.java <br>$ java GreetingServer <span class="hljs-number">6066</span><br>等待远程连接，端口号为：<span class="hljs-number">6066.</span>..<br></code></pre></td></tr></table></figure>
<p>在启动服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">$ javac GreetingClient.java <br>$ java GreetingClient localhost <span class="hljs-number">6066</span><br>连接到主机：localhost ，端口号：<span class="hljs-number">6066</span><br>远程主机地址：localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6066</span><br>服务器响应： 谢谢连接我：/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6066</span><br>Goodbye!<br></code></pre></td></tr></table></figure>
<h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a><strong>网络通信协议</strong></h2><p><strong>网络通信协议：</strong></p>
<p>网络通信协议是一种网络通用语言，为连接不同操作系统和不同硬件体系结构的互联网络引提供通信支持，是一种网络通用语言。</p>
<p><strong>通信协议分层的思想</strong></p>
<p>在制定协议时，把复杂成份分解成一些简单的成份，再将他们复合起来。最常用的复合方式是层次方</p>
<p>式，即同层间可以通信，上一层调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开</p>
<p>发和扩展。</p>
<p><strong>网络通信协议由三要素</strong></p>
<ul>
<li>语义，解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</li>
<li>语法，用户数据与控制信息的结构与格式，以及数据出现的顺序。</li>
<li>时序，对事件发生顺序的详细说明。</li>
</ul>
<p><strong>TCP/IP协议簇</strong></p>
<p>传输层协议中有两个非常重要的协议：</p>
<ul>
<li>用户传输协议 TCP （Transmission Control Protocol）</li>
<li>用户数据报协议UDP（User Datagram Protocol） </li>
</ul>
<p>Tcp/IP 以其两个主要协议：</p>
<ul>
<li>传输控制协议：TCP</li>
<li>网络互联协议：IP</li>
</ul>
<p>实际上是一组协议，包括多个具有不同功能且互为关联的协议。</p>
<p>IP（Internet Protocol）协议是网络层的主要协议，支持网间互联的数据通信。</p>
<p>TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层，IP层，传输层和应用层。</p>
<h3 id="UPD与TCP区别"><a href="#UPD与TCP区别" class="headerlink" title="UPD与TCP区别"></a>UPD与TCP区别</h3><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><strong>UDP</strong></h4><p><strong>特点</strong></p>
<ol>
<li><p>面向无连接首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<ol start="2">
<li><p>有单播，多播，广播的功能</p>
<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
</li>
</ol>
</li>
<li><p>UDP是面向报文的</p>
<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
</li>
<li><p>不可靠性</p>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
</li>
</ol>
<blockquote>
<img src="/article/52560/UDP%E5%8C%85%E5%A4%B4.jpg" class title="UDP 包头">
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
</blockquote>
<ul>
<li>沟通简单，不需要大量的数据结构，处理逻辑和包头字段</li>
<li>轻信他人。它不会建立连接，但是会监听这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以同时传给多个人数据。</li>
<li>愣头青，做事不懂变通。不会根据网络的情况进行拥塞控制，无论是否丢包，它该怎么发还是怎么发</li>
</ul>
<p><strong>主要应用场景</strong></p>
<ul>
<li>需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。</li>
<li>不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。</li>
<li>需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候</li>
</ul>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p><strong>特点</strong></p>
<ol>
<li><p>面向连接</p>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
</li>
<li><p>仅支持单播传输</p>
<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
</li>
<li><p>面向字节流</p>
<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
</li>
<li><p>可靠传输</p>
<p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
</li>
<li><p>提供拥塞控制</p>
<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p>
</li>
<li><p>TCP提供全双工通信</p>
<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
</li>
</ol>
<blockquote>
<img src="/article/52560/a795461effcce686a43f48e094c9adbf.jpg" class title="TCP 包头">
<ul>
<li>首先，源端口和目标端口是不可少的；</li>
<li>接下来是包的序号。主要是为了解决乱序问题；</li>
<li>确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题；</li>
<li>状态位。SYN 是发起一个链接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更；</li>
<li>窗口大小，TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。</li>
</ul>
</blockquote>
<p><strong>TCP 的三次握手</strong></p>
<img src="/article/52560/666d7d20aa907d8317af3770411f5aa2.jpg" class title="状态变化时序图">
<p><strong>TCP 四次挥手</strong></p>
<img src="/article/52560/1f6a5e17b34f00d28722428b7b8ccb11.jpg" class title="断开连接状态时序图">
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">UDP</th>
<th style="text-align:center">TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">是否连接</td>
<td style="text-align:center">无连接</td>
<td style="text-align:center">面向连接</td>
</tr>
<tr>
<td style="text-align:center">是否可靠</td>
<td style="text-align:center">不可靠传输，不使用流量控制和拥塞控制</td>
<td style="text-align:center">可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td style="text-align:center">连接对象个数</td>
<td style="text-align:center">支持一对一，一对多，多对一和多对多交互通信</td>
<td style="text-align:center">只能是一对一通信</td>
</tr>
<tr>
<td style="text-align:center">传输方式</td>
<td style="text-align:center">面向报文</td>
<td style="text-align:center">面向字节流</td>
</tr>
<tr>
<td style="text-align:center">首部开销</td>
<td style="text-align:center">首部开销小，仅8字节</td>
<td style="text-align:center">首部最小20字节，最大60字节</td>
</tr>
<tr>
<td style="text-align:center">适用场景</td>
<td style="text-align:center">适用于实时应用（IP电话、视频会议、直播等）</td>
<td style="text-align:center">适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者消费者问题</title>
    <url>/article/19877.html</url>
    <content><![CDATA[<blockquote>
<p>The world puts off its mask of vastness to its lover.</p>
<p>世界对着它的爱人，把它浩翰的面具揭下了。　　</p>
<p>It becomes small as one song, as one kiss of the eternal.</p>
<p>它变小了，小如一首歌，小如一回永恒的接吻。　　　　　　　　　　　</p>
</blockquote>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>生产者消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
<p>要解决该问题，就必须让生产者在缓冲区满时休眠（要么干脆就放弃数据），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。同样，也可以让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。通常采用进程间通信的方法解决该问题。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己。该问题也能被推广到多个生产者和消费者的情形。</p>
<p><strong>该问题需要注意的几点：</strong></p>
<ul>
<li>在缓冲区为空时，消费者不能再进行消费</li>
<li>在缓冲区为满时，生产者不能再进行生产</li>
<li>在一个线程进行生产或消费时，其余线程不能再进行生产或消费等操作，即保持线程间的同步</li>
<li>注意条件变量与互斥锁的顺序</li>
</ul>
<p>由于前两点原因，因此需要保持线程间的同步，即一个线程消费（或生产）完，其他线程才能进行竞争CPU，获得消费（或生产）的机会。对于这一点，可以使用条件变量进行线程间的同步：生产者线程在product之前，需要wait直至获取自己所需的信号量之后，才会进行product的操作；同样，对于消费者线程，在consume之前需要wait直到没有线程在访问共享区（缓冲区），再进行consume的操作，之后再解锁并唤醒其他可用阻塞线程。<br>在访问共享区资源时，为避免多个线程同时访问资源造成混乱，需要对共享资源加锁，从而保证某一时刻只有一个线程在访问共享资源。</p>
<h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试：生产者消费者模型---&gt;利用缓冲区解决：管程法</span><br><span class="hljs-comment">//生产者，消费者，产品，缓冲区</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPC</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		SynContainer container = <span class="hljs-keyword">new</span> SynContainer();<br>		<span class="hljs-keyword">new</span> Productor(container).start();<br>		<span class="hljs-keyword">new</span> Consumer(container).start();<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//生产者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Productor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>	SynContainer container;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Productor</span><span class="hljs-params">(SynContainer container)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.container = container;<br>	&#125;<br><br>	<span class="hljs-comment">// 生产</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>			container.push(<span class="hljs-keyword">new</span> Chicken(i));<br>			System.out.println(<span class="hljs-string">&quot;生产了&quot;</span> + i + <span class="hljs-string">&quot;只鸡&quot;</span>);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//消费者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br><br>	SynContainer container;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(SynContainer container)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.container = container;<br>	&#125;<br><br>	<span class="hljs-comment">// 消费</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>			System.out.println(<span class="hljs-string">&quot;消费了--&gt;&quot;</span> + container.pop().id + <span class="hljs-string">&quot;只鸡&quot;</span>);<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//产品</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chicken</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> id;<span class="hljs-comment">// 产品编号</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Chicken</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.id = id;<br>	&#125;<br><br>&#125;<br><br><span class="hljs-comment">//缓冲区</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynContainer</span> </span>&#123;<br><br>	<span class="hljs-comment">// 需要一个容器大小</span><br>	Chicken[] chickens = <span class="hljs-keyword">new</span> Chicken[<span class="hljs-number">10</span>];<br>	<span class="hljs-comment">// 容器计数器</span><br>	<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">// 生产者放入产品</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Chicken chicken)</span> </span>&#123;<br>		<span class="hljs-comment">// 如果容器满了，就需要等待消费者消费</span><br>		<span class="hljs-keyword">if</span> (count == chickens.length) &#123;<br>			<span class="hljs-comment">// 通知消费者消费，生产者等待</span><br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-keyword">this</span>.wait();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				<span class="hljs-comment">// TODO Auto-generated catch block</span><br>				e.printStackTrace();<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">// 如果没有满，我们就放入产品</span><br>		chickens[count] = chicken;<br>		count++;<br>		<span class="hljs-comment">//通知消费者消费了</span><br>		<span class="hljs-keyword">this</span>.notifyAll();<br>	&#125;<br><br>	<span class="hljs-comment">// 消费者消费产品</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Chicken <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 判断是否能消费</span><br>		<span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-comment">// 等待生产者生产，消费者等待</span><br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-keyword">this</span>.wait();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				<span class="hljs-comment">// TODO Auto-generated catch block</span><br>				e.printStackTrace();<br>			&#125;<br><br>		&#125; <span class="hljs-comment">// 如果可以消费</span><br>		count--;<br>		Chicken chicken = chickens[count];<br>		<span class="hljs-comment">// 吃完了，通知生产者生产</span><br>		<span class="hljs-keyword">this</span>.notifyAll();<br>		<span class="hljs-keyword">return</span> chicken;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h3><p>通过标志位解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.Thread;<br><span class="hljs-comment">//解决生产者消费者问题方法2：信号灯法</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPC2</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TV tv =<span class="hljs-keyword">new</span> TV();<br>        <span class="hljs-keyword">new</span> Player(tv).start();<br>        <span class="hljs-keyword">new</span> Watcher(tv).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//生产者：演员</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    TV tv;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Player</span><span class="hljs-params">(TV tv)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tv = tv;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">this</span>.tv.play(<span class="hljs-string">&quot;快乐大本营&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">this</span>.tv.play(<span class="hljs-string">&quot;斗鱼&quot;</span>);<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//消费者：观众</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    TV tv;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Watcher</span><span class="hljs-params">(TV tv)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tv = tv;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            tv.watch();<br><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//产品：电视节目</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TV</span></span>&#123;<br>    <span class="hljs-comment">//演员表演，观众等待 T</span><br>    <span class="hljs-comment">//观众观看，演员等待 F</span><br>    String voice;<br>    <span class="hljs-keyword">boolean</span> flag =<span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String voice)</span></span>&#123;<br>        <span class="hljs-comment">//观众观看，演员等待</span><br>        <span class="hljs-keyword">if</span> (!flag)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//若观众没看，演员表演</span><br>        System.out.println(<span class="hljs-string">&quot;演员表演了&quot;</span>+voice);<br>        <span class="hljs-comment">//通知观众看</span><br>        <span class="hljs-keyword">this</span>.notifyAll();<br>        <span class="hljs-keyword">this</span>.voice=voice;<br>        <span class="hljs-keyword">this</span>.flag=!<span class="hljs-keyword">this</span>.flag;<br><br>    &#125;<br>    <span class="hljs-comment">//观看方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">watch</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//演员表演观众等待</span><br>        <span class="hljs-keyword">if</span>(flag)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">this</span>.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;观看了：&quot;</span>+voice);<br>        <span class="hljs-comment">//通知演员表演</span><br>        <span class="hljs-keyword">this</span>.notifyAll();<br>        <span class="hljs-keyword">this</span>.flag=!<span class="hljs-keyword">this</span>.flag;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
        <category>多线程</category>
        <category>生产者消费者问题</category>
      </categories>
      <tags>
        <tag>Java,多线程,操作系统,生产者消费者问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Java函数式接口</title>
    <url>/article/49002.html</url>
    <content><![CDATA[<blockquote>
<p> The world rushes on over the strings of the lingering heart making  the music of sadness. </p>
<p>世界在踌躇之心的琴弦上跑过去，奏出忧郁的乐声。 </p>
</blockquote>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>
<p>函数式接口可以被隐式转换为<a href="/article/4774.html" title="Java-Lambda表达式">Java-Lambda表达式</a>。</p>
<p>Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。</p>
<p>如定义了一个函数式接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingService</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayMessage</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么就可以使用<a href="/article/4774.html" title="Java-Lambda表达式">Java-Lambda表达式</a>来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">GreetingService greetService1 = message -&gt; System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);<br></code></pre></td></tr></table></figure>
<p><strong>函数式接口实例</strong></p>
<p>Predicate <T> 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。</T></p>
<p>该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。</p>
<p>该接口用于测试对象是 true 或 false。</p>
<p>我们可以通过以下实例（Java8Tester.java）来了解函数式接口 Predicate <T> 的使用：</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Java8Tester</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>        <br>      <span class="hljs-comment">// Predicate&lt;Integer&gt; predicate = n -&gt; true</span><br>      <span class="hljs-comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span><br>      <span class="hljs-comment">// n 如果存在则 test 方法返回 true</span><br>        <br>      System.out.println(<span class="hljs-string">&quot;输出所有数据:&quot;</span>);<br>        <br>      <span class="hljs-comment">// 传递参数 n</span><br>      eval(list, n-&gt;<span class="hljs-keyword">true</span>);<br>        <br>      <span class="hljs-comment">// Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0</span><br>      <span class="hljs-comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span><br>      <span class="hljs-comment">// 如果 n%2 为 0 test 方法返回 true</span><br>        <br>      System.out.println(<span class="hljs-string">&quot;输出所有偶数:&quot;</span>);<br>      eval(list, n-&gt; n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> );<br>        <br>      <span class="hljs-comment">// Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3</span><br>      <span class="hljs-comment">// n 是一个参数传递到 Predicate 接口的 test 方法</span><br>      <span class="hljs-comment">// 如果 n 大于 3 test 方法返回 true</span><br>        <br>      System.out.println(<span class="hljs-string">&quot;输出大于 3 的所有数字:&quot;</span>);<br>      eval(list, n-&gt; n &gt; <span class="hljs-number">3</span> );<br>   &#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;<br>      <span class="hljs-keyword">for</span>(Integer n: list) &#123;<br>        <br>         <span class="hljs-keyword">if</span>(predicate.test(n)) &#123;<br>            System.out.println(n + <span class="hljs-string">&quot; &quot;</span>);<br>         &#125;<br>      &#125;<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$ javac Java8Tester.java </span><br><span class="hljs-comment">$ java Java8Tester</span><br><span class="hljs-comment">输出所有数据:</span><br><span class="hljs-comment">1 </span><br><span class="hljs-comment">2 </span><br><span class="hljs-comment">3 </span><br><span class="hljs-comment">4 </span><br><span class="hljs-comment">5 </span><br><span class="hljs-comment">6 </span><br><span class="hljs-comment">7 </span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment">9 </span><br><span class="hljs-comment">输出所有偶数:</span><br><span class="hljs-comment">2 </span><br><span class="hljs-comment">4 </span><br><span class="hljs-comment">6 </span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment">输出大于 3 的所有数字:</span><br><span class="hljs-comment">4 </span><br><span class="hljs-comment">5 </span><br><span class="hljs-comment">6 </span><br><span class="hljs-comment">7 </span><br><span class="hljs-comment">8 </span><br><span class="hljs-comment">9 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>函数式接口</category>
      </categories>
      <tags>
        <tag>Java,函数式接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Lambda表达式</title>
    <url>/article/4774.html</url>
    <content><![CDATA[<blockquote>
<p>You smiled and talked to me of nothing and I felt that for this  I had been waiting long. </p>
<p>你微微地笑着，不同我说什么话。而我觉得，为了这个，我已等待得久了。  </p>
</blockquote>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>理解Functional Interface（<a href="/article/49002.html" title="函数式接口">函数式接口</a>）是学习Java8 Lambda表达式的关键所在。</p>
<p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<p>使用 Lambda 表达式可以</p>
<ul>
<li>使代码变的更加简洁紧凑。</li>
<li>避免匿名内部类定义过多</li>
<li>只有核心逻辑，没有无用代码</li>
</ul>
<p><strong>语法</strong></p>
<p>lambda 表达式的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">(parameters) -&gt; expression<br><span class="hljs-comment">//或</span><br>(parameters) -&gt;&#123; statements; &#125;<br></code></pre></td></tr></table></figure>
<p>以下是lambda表达式的重要特征:</p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值；</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号；</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号；</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 不需要参数,返回值为 5  </span><br>() -&gt; <span class="hljs-number">5</span>  <br><span class="hljs-comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span><br>x -&gt; <span class="hljs-number">2</span> * x  <br><span class="hljs-comment">// 3. 接受2个参数(数字),并返回他们的差值  </span><br>(x, y) -&gt; x – y  <br><span class="hljs-comment">// 4. 接收2个int型整数,返回他们的和  </span><br>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) -&gt; x + y  <br><span class="hljs-comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span><br>(String s) -&gt; System.out.print(s)<br></code></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Java8Tester</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>      Java8Tester tester = <span class="hljs-keyword">new</span> Java8Tester();<br>        <br>      <span class="hljs-comment">// 类型声明</span><br>      MathOperation addition = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; a + b;<br>        <br>      <span class="hljs-comment">// 不用类型声明</span><br>      MathOperation subtraction = (a, b) -&gt; a - b;<br>        <br>      <span class="hljs-comment">// 大括号中的返回语句</span><br>      MathOperation multiplication = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; &#123; <span class="hljs-keyword">return</span> a * b; &#125;;<br>        <br>      <span class="hljs-comment">// 没有大括号及返回语句</span><br>      MathOperation division = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) -&gt; a / b;<br>        <br>      System.out.println(<span class="hljs-string">&quot;10 + 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, addition));<br>      System.out.println(<span class="hljs-string">&quot;10 - 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, subtraction));<br>      System.out.println(<span class="hljs-string">&quot;10 x 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, multiplication));<br>      System.out.println(<span class="hljs-string">&quot;10 / 5 = &quot;</span> + tester.operate(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, division));<br>        <br>      <span class="hljs-comment">// 不用括号</span><br>      GreetingService greetService1 = message -&gt;<br>      System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);<br>        <br>      <span class="hljs-comment">// 用括号</span><br>      GreetingService greetService2 = (message) -&gt;<br>      System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);<br>        <br>      greetService1.sayMessage(<span class="hljs-string">&quot;Bobo&quot;</span>);<br>      greetService2.sayMessage(<span class="hljs-string">&quot;Google&quot;</span>);<br>   &#125;<br>    <br>   <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MathOperation</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<br>   &#125;<br>    <span class="hljs-comment">//定义一个函数式接口</span><br>   <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingService</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayMessage</span><span class="hljs-params">(String message)</span></span>;<br>   &#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">operate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, MathOperation mathOperation)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> mathOperation.operation(a, b);<br>   &#125;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">$ javac Java8Tester.java </span><br><span class="hljs-comment">$ java Java8Tester</span><br><span class="hljs-comment">10 + 5 = 15</span><br><span class="hljs-comment">10 - 5 = 5</span><br><span class="hljs-comment">10 x 5 = 50</span><br><span class="hljs-comment">10 / 5 = 2</span><br><span class="hljs-comment">Hello Bobo</span><br><span class="hljs-comment">Hello Google</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。</li>
<li>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Java8Tester</span> </span>&#123;<br> <br>   <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String salutation = <span class="hljs-string">&quot;Hello! &quot;</span>;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>      GreetingService greetService1 = message -&gt; <br>      System.out.println(salutation + message);<br>      greetService1.sayMessage(<span class="hljs-string">&quot;Bobo&quot;</span>);<br>   &#125;<br>    <br>   <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingService</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sayMessage</span><span class="hljs-params">(String message)</span></span>;<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">$ javac Java8Tester.java </span><br><span class="hljs-comment">$ java Java8Tester</span><br><span class="hljs-comment">Hello! Bobo</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>我们也可以直接在 lambda 表达式中访问外层的局部变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Java8Tester</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;<br>        Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));<br>        s.convert(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 输出结果为 3</span><br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt; </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <br>Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));<br>s.convert(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//不可以在后面篡改 num</span><br>num = <span class="hljs-number">5</span>;  <br><span class="hljs-comment">//报错信息：Local variable num defined in an enclosing scope must be final or effectively </span><br> <span class="hljs-keyword">final</span><br></code></pre></td></tr></table></figure>
<ul>
<li>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String first = <span class="hljs-string">&quot;&quot;</span>;  <br>Comparator&lt;String&gt; comparator = (first, second) -&gt; Integer.compare(first.length(), second.length());  <span class="hljs-comment">//编译会出错</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Lambda表达式</category>
      </categories>
      <tags>
        <tag>Java,Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理模式</title>
    <url>/article/21345.html</url>
    <content><![CDATA[<blockquote>
<p>The trees, like the longings of the earth, stand atiptoe to peep  at the heaven.  </p>
<p>群树如表示大地的愿望似的，踮起脚来向天空窥望。</p>
</blockquote>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假设现在有一个人（person接口），他的名字叫A（class A implement person），小A 40岁了必须要找对象，但是呢自己比较害羞不好意思开口，这样就需要一个媒婆来帮他找对象（MeiPo 代理类），至此就是静态代理模式，下面我们用代理来实现下：</p>
<p><code>Class Person</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findLove</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Class A</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findLove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//个人条件</span><br>		System.out.println(<span class="hljs-string">&quot;高富帅&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;有房有车的&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Class Meipo</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meipo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> XiaoA xiaoA;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Meipo2</span><span class="hljs-params">(XiaoA xa)</span> </span>&#123;<br>		<span class="hljs-comment">// TODO Auto-generated constructor stub</span><br>		<span class="hljs-keyword">this</span>.xiaoA = xa;<br>	&#125;<br>	<br>	 <span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findLove</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// TODO Auto-generated method stub</span><br>		System.out.println(<span class="hljs-string">&quot;我是媒婆，要帮小A找对象，小A的条件为：&quot;</span>);<br>		xiaoA.findLove();<br>		System.out.println(<span class="hljs-string">&quot;寻找中...&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;寻找到仙女一枚！&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Main</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFindLove</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		Meipo2 meipo2 = <span class="hljs-keyword">new</span> Meipo2(<span class="hljs-keyword">new</span> XiaoA());<br>		meipo2.findLove();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/21345/20190508103432666.png" class title="img">
<p> 静态代理模式总结 </p>
<ul>
<li>真实对象和代理对象都要实现同一接口 </li>
<li>代理对象要代理真实角色 </li>
</ul>
<p>好处：</p>
<ol>
<li>代理对象可以做很多真实对象做不了的事情 、</li>
<li>真实对象可以专注做自己的事情</li>
</ol>
<p>缺点：</p>
<p>一个真实角色会产生一个代理角色</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="实现代理对象的步骤"><a href="#实现代理对象的步骤" class="headerlink" title="实现代理对象的步骤"></a>实现代理对象的步骤</h3><ol>
<li>创建接口，定义目标类要完成的功能</li>
<li>创建目标类，实现接口</li>
<li>创建InvocationHandler接口的实现类，在invoke方法中完成代理类的功能<ol>
<li>调用目标方法</li>
<li>增强功能</li>
</ol>
</li>
<li>使用Proxy类的静态方法，创建代理对象，并把返回值转为接口类型</li>
</ol>
<ul>
<li>动态代理角色和静态代理角色一样</li>
<li>动态代理的代理类时动态生成的，不是我们直接写好的</li>
<li>分为两类<ul>
<li>基于接口的动态的代理：<strong>基于JDK的动态代理</strong></li>
<li>基于类的动态代理：cglib</li>
<li>java字节码实现：javasist</li>
</ul>
</li>
</ul>
<p><strong>基于JDK的动态代理</strong></p>
<p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合</p>
<ol>
<li>Proxy：代理</li>
<li>InvocationHandler：调用处理程序</li>
</ol>
<p><strong>例</strong></p>
<p>上面的静态代理是每来一个人就创建一个媒婆代理他，这样的话工作过于繁琐，这时我们为何我开一个媒婆公司呢？将找对象的人交给媒婆公司，让媒婆公司创建媒婆代理他传宗接代的任务！</p>
<p><code>Class B</code></p>
<p><strong>目标接口的实现类</strong>，也就是接下来的目标类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findLove</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;矮穷矬&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;屌丝一枚&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>findLove</code>目标类中目标方法</p>
<p>媒婆 改为 媒婆公司：<code>Class MeipoCompany</code></p>
<p><strong>代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MeipoCompany</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>	<span class="hljs-keyword">private</span> Person target; <span class="hljs-comment">//被代理对象的引用作为一个成员变量保存下来了</span><br>  <span class="hljs-comment">//传入对象</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.target = target;<br>  &#125;<br>  <br>	<span class="hljs-comment">//获取被代理人的个人资料</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getInstance</span><span class="hljs-params">(Person target)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>		<span class="hljs-keyword">this</span>.target = target;<br>		Class clazz = target.getClass();<br>		System.out.println(<span class="hljs-string">&quot;被代理对象的class是:&quot;</span>+clazz);<br>		<span class="hljs-keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), <span class="hljs-keyword">this</span>);<br>	&#125;<br>	<br> <br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>		<br>		System.out.println(<span class="hljs-string">&quot;我是媒婆公司：&quot;</span> + <span class="hljs-string">&quot;得给你找个异性才行&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;说下你的条件：&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>		<span class="hljs-comment">//反射调用方法</span><br>		method.invoke(target, args);<br>		System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;开始进行海选...&quot;</span>);<br>		System.out.println(<span class="hljs-string">&quot;找到啦&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>在invoke()方法中，我们没有创建对象，所以，我们使用<code>method.invoke</code></strong></p>
<p>两个参数：</p>
<ol>
<li>对象，这个对象是动态的，不是固定的，所以我们需要传入进来，可以通过调用该类的构造方法<code>setTarget()</code>进行传入</li>
<li>参数，调用方法的参数，即args</li>
</ol>
<p><code>Main</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFindLove</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br> 			Person handler = (Person)<span class="hljs-keyword">new</span> MeipoCompany().getInstance(<span class="hljs-keyword">new</span> XiaoA());<br> 			System.out.println(<span class="hljs-string">&quot;代理类：&quot;</span>+A.getClass());<br> 			handler.findLove();<br>      System.out.println(<span class="hljs-string">&quot;************************&quot;</span>);<br>      <span class="hljs-comment">//1. 创建目标对象</span><br>      Person B = <span class="hljs-keyword">new</span> XiaoB();<br>      <span class="hljs-comment">//2. 创建 InvocationHandler 对象</span><br>      InvocationHandler handler1 = <span class="hljs-keyword">new</span> MeipoCompany(B);<br>      <span class="hljs-comment">//3.创建代理对象</span><br>      Person proxy = (Person)Proxy.newProxyInstance(B.getClassLoader(), B.getInterfaces(), handler1)<br> 			System.out.println(<span class="hljs-string">&quot;代理类：&quot;</span>+B.getClass());<br>      <span class="hljs-comment">//4.通过代理执行方法</span><br> 			B.findLove();<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 创建目标对象</span><br>Person B = <span class="hljs-keyword">new</span> XiaoB();<br><span class="hljs-comment">//2. 创建 InvocationHandler 对象</span><br>InvocationHandler handler1 = <span class="hljs-keyword">new</span> MeipoCompany(B);<br><span class="hljs-comment">//3.创建代理对象</span><br>Person proxy = hander.getInstance(handler);<br>Person proxy = (Person)Proxy.newProxyInstance(B.getClassLoader(), B.getInterfaces(), handler1)<br>System.out.println(<span class="hljs-string">&quot;代理类：&quot;</span>+B.getClass());<br><span class="hljs-comment">//4.通过代理执行方法</span><br>proxy.findLove();<br></code></pre></td></tr></table></figure>
<p>这段代码中不需要<code>MeipoCompany</code>中有<code>getInstance</code>方法，直接在main类中实现，等价于A的动态代理</p>
</blockquote>
<p>这里调用方法时，就会自动跳转到invoke方法，将方法名与参数传递给invoke中的method.invoke方法</p>
<h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><p><strong>实现InvocationHandler，重写invoke方法</strong></p>
<p>处理代理实例，并且返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;	<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong><code>invoke</code>表示代理对象要执行的功能代码，代理类要完成的功能就写在invoke中。</strong></p>
<ol>
<li><p><strong>调用目标方法，执行目标方法的功能</strong></p>
</li>
<li><p><strong>功能增强，在目标方法调用时，增加功能</strong></p>
</li>
<li><p><strong>参数</strong></p>
<blockquote>
<ol>
<li><p>Object proxy</p>
<p>jdk创建的代理对象，无需赋值</p>
</li>
<li><p>Method method</p>
<p>目标类中的方法，jdk提供，无需赋值</p>
</li>
<li><p>Object[] args</p>
<p>目标类中方法的参数，jdk提供，无需赋值</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<hr>
<p><code>Method类</code>：表示方法的类，确切的说就目标类中的方法</p>
<p><strong>作用</strong>：通过Method可以执行某个目标类的方法，<code>method.invoke()</code></p>
<p>method.invoke(目标对象，方法的参数)</p>
<h3 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h3><p>核心对象，创建代理对象</p>
<p>之前的创建对象都是new类的构造方法，现在我们是使用Proxy类的对象，代替new的使用.</p>
<p>静态方法<code>newProxyInstance</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      InvocationHandler h)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>作用：创建代理对象，等同于静态代理中的new</strong></p>
<p><strong>参数</strong></p>
<blockquote>
<ol>
<li><p>ClassLoader loader</p>
<p>类加载器，负责向内存中加载对象，使用反射获取对象的ClassLoader</p>
<p><strong>是目标对象的类加载器</strong></p>
</li>
<li><p>Class&lt;?&gt;[] interfaces</p>
<p>是接口，目标对象所实现的接口，也是反射获取的</p>
</li>
<li><p>InvocationHandler h</p>
<p>是我们自己写的，代理类要完成的功能</p>
</li>
</ol>
</blockquote>
<p><strong>返回值</strong>：就是目标对象的代理对象</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>代理模式</category>
      </categories>
      <tags>
        <tag>Java,代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/article/58846.html</url>
    <content><![CDATA[<blockquote>
<p>  I cannot tell why this heart languishes in silence.</p>
<p>我说不出这心为什么那样默默地颓丧着。   </p>
<p> It is for small needs it never asks, or knows or remembers.  </p>
<p>是为了它那不曾要求，不曾知道，不曾记得的小小的需要。</p>
</blockquote>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p><strong>进程（Process）</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<p><strong>线程（thread）</strong> 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<img src="/article/58846/1629488-20190622115300479-2129397443.png" class title="进程">
<h2 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h2><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p>
<img src="/article/58846/java-thread.jpg" class title="java-thread">
<p><strong>线程五大状态</strong></p>
<ul>
<li><p>新建状态:</p>
<p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
</li>
<li><p>就绪状态:</p>
<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
</li>
<li><p>运行状态:</p>
<p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</li>
<li><p>阻塞状态:</p>
<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： </p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
</li>
<li><p>死亡状态: </p>
<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态，<strong>无法再起启动</strong>。</p>
</li>
</ul>
<img src="/article/58846/2.png" class title="img">
<h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><ul>
<li>线程就是独立的执行路径；</li>
<li>在程序运行时，即使没有自己创建线程，后台也会有很多个线程；</li>
<li><code>main()</code>称之为主线程，为系统的入口，用于执行整个程序；</li>
<li>在一个进程中，如果开辟了多个线程，线程的运行是由调度器安排调度，调度器与操作系统是紧密相关的，先后顺序是不能人为干预的；</li>
<li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；</li>
<li>线程会带来额外的开销；</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致。</li>
</ul>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>Java 提供了三种创建线程的方法：</p>
<ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<p><strong>通过继承Thread来创建线程</strong></p>
<p>创建一个线程的第一种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。</p>
<p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。</p>
<p>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.demo01;<br><span class="hljs-comment">//创建线程方式一：继承Thread类，重写run()方法，调用star开启线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在看代码---&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建一个线程对象</span><br>        TestThread1 testThread1 = <span class="hljs-keyword">new</span> TestThread1();<br>        <span class="hljs-comment">//调用start方法,开启线程</span><br>        testThread1.start();<br>        <span class="hljs-comment">//main线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程---&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">截取部分输出结果：</span><br><span class="hljs-comment">我在学习多线程---49</span><br><span class="hljs-comment">我在看代码---71</span><br><span class="hljs-comment">我在看代码---72</span><br><span class="hljs-comment">我在学习多线程---50</span><br><span class="hljs-comment">我在看代码---73</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>序号</strong></th>
<th style="text-align:center"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center"><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center"><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center"><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:center"><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:center"><strong>public void interrupt()</strong> 中断线程。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:center"><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td>
</tr>
</tbody>
</table>
<p>上述方法是被 Thread 对象调用的，下面表格的方法是 Thread 类的静态方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>序号</strong></th>
<th style="text-align:center"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center"><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center"><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center"><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center"><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center"><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td>
</tr>
</tbody>
</table>
<p><strong>线程停止：</strong>（stop）</p>
<ul>
<li>不推荐JDK提供的stop()\destory()方法；</li>
<li>建议使用表示为进行终止变量。</li>
</ul>
<p><strong>线程休眠：</strong>(sleep)</p>
<ul>
<li>sleep（时间）指定当前线程阻塞的毫秒数；</li>
<li>sleep存在异常 InterruptedException；</li>
<li>sleep时间达到后线程进入就绪状态；</li>
<li>色了可以模拟网络延时，倒计时等；</li>
<li>每一个对象都有一个锁，sleep不会释放锁。</li>
</ul>
<p><strong>线程礼让：</strong>(yield)</p>
<ul>
<li>让当前正在执行的线程暂停，但不阻塞；</li>
<li>让线程从运行状态转为就绪状态；</li>
<li>让CPU重新调度。礼让不一定成功。</li>
</ul>
<p><strong>线程强制执行：</strong>(join)</p>
<ul>
<li>Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</li>
</ul>
<p><strong>线程优先级：</strong> </p>
<ul>
<li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度那个线程来执行；</li>
<li>线程优先级用数字表示，范围1～10；</li>
<li>使用<code>getPriority()</code> <code>setPriority(int xxx)</code>改变或获取优先级；</li>
<li><strong>优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看cpu的调度。</strong></li>
</ul>
<p><strong>守护（daemon）线程</strong></p>
<ul>
<li>线程分为<strong>用户线程</strong>和<strong>守护线程；</strong></li>
<li>虚拟机必须确保用户线程（比如main）执行完毕；</li>
<li>虚拟机不用等待守护线程（比如gcc）执行完毕。</li>
</ul>
<p><strong>通过实现 Runnable 接口来创建线程</strong></p>
<p>创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。</p>
<p>为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：<code>public void run()</code></p>
<p>在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.demo01;<br><span class="hljs-comment">//创建线程方式二 实现runnable接口 重写run方法，执行线程需要丢入runnable接口实现类，调用start方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在看代码---&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建runnable接口的实现对象</span><br>        TestThread3 testThread3 = <span class="hljs-keyword">new</span> TestThread3();<br>        <span class="hljs-comment">//创建线程对象，通过线程对象来开启线程</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(testThread3);<br>        thread.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我在学习多线程---&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">截取部分输出结果：</span><br><span class="hljs-comment">我在看代码---122</span><br><span class="hljs-comment">我在学习多线程---189</span><br><span class="hljs-comment">我在看代码---123</span><br><span class="hljs-comment">我在学习多线程---190</span><br><span class="hljs-comment">我在看代码---124</span><br><span class="hljs-comment">我在学习多线程---191</span><br><span class="hljs-comment">我在看代码---125</span><br><span class="hljs-comment">我在看代码---126</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>通过 Callable 和 Future 创建线程</strong></p>
<ul>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableThreadTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        CallableThreadTest ctt = <span class="hljs-keyword">new</span> CallableThreadTest();  <br>        FutureTask&lt;Integer&gt; ft = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(ctt);  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">100</span>;i++)  <br>        &#123;  <br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 的循环变量i的值&quot;</span>+i);  <br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">20</span>)  <br>            &#123;  <br>                <span class="hljs-keyword">new</span> Thread(ft,<span class="hljs-string">&quot;有返回值的线程&quot;</span>).start();  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">try</span>  <br>        &#123;  <br>            System.out.println(<span class="hljs-string">&quot;子线程的返回值：&quot;</span>+ft.get());  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e)  <br>        &#123;  <br>            e.printStackTrace();  <br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e)  <br>        &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>  <br>    &#125;<br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception  </span><br><span class="hljs-function">    </span>&#123;  <br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">100</span>;i++)  <br>        &#123;  <br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> i;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><a href="/article/21345.html" title="点击跳转静态代理">点击跳转静态代理</a>
<p>静态代理即线程底部实现原理</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>多个线程操作同一个资源</p>
<p><strong>锁机制</strong></p>
<p>由于同一进程的多个线程共享同一快存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问的正确性，在访问时加入锁机制(synchronized)，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起；</li>
<li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题；</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。</li>
</ul>
<p>synchronized有两种用法，synchronized方法与synchronized块。</p>
<p><strong>synchronized方法</strong></p>
<p>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的进程才能获得这个锁，继续执行。</p>
<p>有一个<strong>缺陷：</strong>若将一个大的方法声明为synchronized将会影响效率</p>
<ul>
<li>方法里面需要修改的内容才需要锁，锁的太多，浪费资源</li>
</ul>
<p><strong>synchronized同步块</strong></p>
<p><code>synchronized(obj)&#123;&#125;</code></p>
<p>obj称为<strong>同步监视器</strong></p>
<ul>
<li>obj可以是任何对象，但是推荐使用共享资源作为同步监视器；</li>
<li>同步方法中无需指定同步监视器，因为同步方法中的同步监视器就是 this，就是这个对象本身</li>
<li>同步监视器的执行过程<ol>
<li>第一个线程访问，锁定同步监视器，执行其中代码；</li>
<li>第二个线程访问，发现同步监视器被锁定，无法访问；</li>
<li>第一个线程访问完毕，解锁同步监视器；</li>
<li>第二个线程访问，发现同步监视器没有锁，然后锁定并访问。</li>
</ol>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p>死锁的规范定义：</p>
<blockquote>
<p> 集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。</p>
</blockquote>
<p>死锁的发生必须具备以下四个必要条件:</p>
<p><strong>1）互斥条件：</strong>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p>
<p><strong>2）请求和保持条件：</strong>指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
<p><strong>3）不剥夺条件：</strong>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>
<p><strong>4）环路等待条件：</strong>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>从JDK 5.0之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock，通过显示定义同步锁对象来实现同步，同步锁使用Lock对象充当。</p>
<p>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应该先获得Lock对象。</p>
<p>ReentrantLock 类实现了Lock，拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Lock lock = ...;<br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//处理任务</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br>     <br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    lock.unlock();   <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>synchronized与Lock对比：</p>
<ul>
<li>Lock是显式锁（手动开启和关闭锁），synchronized是隐式锁，除了作用域自动释放；</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁；</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多的子类）；</li>
<li>优先使用顺序：<ul>
<li>Lock &gt; 同步代码块（已经进入了方法题，分配了相应资源）&gt; 同步方法（在方法体之外）</li>
</ul>
</li>
</ul>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>Java提供了几个方法解决线程之间的通信问题</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait()</td>
<td>表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</td>
</tr>
<tr>
<td>wait(long timeout)</td>
<td>指定等待的毫秒数</td>
</tr>
<tr>
<td>notify()</td>
<td>唤醒一个处于等待状态的线程</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度</td>
</tr>
</tbody>
</table>
<p>均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IIIegalMonitorStateException</p>
<h2 id="线程实例"><a href="#线程实例" class="headerlink" title="线程实例"></a>线程实例</h2><a href="/article/19877.html" title="生产者消费者问题">生产者消费者问题</a>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在一个应用程序中，我们需要多次使用线程，也就意味着，我们需要多次创建并销毁线程。而创建并销毁线程的过程势必会消耗内存。而在Java中，内存资源是及其宝贵的，所以，我们就提出了线程池的概念。</p>
<img src="/article/58846/937.png" class title="img">
<p><strong>线程池</strong></p>
<p>Java中开辟出了一种管理线程的概念，这个概念叫做线程池，从概念以及应用场景中，我们可以看出，线程池的好处，就是可以方便的管理线程，也可以减少内存的消耗。</p>
<p><strong>线程池的优势</strong></p>
<ol>
<li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li>
<li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</li>
<li>方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。</li>
<li>提供更强大的功能，延时定时线程池。</li>
</ol>
<p><strong>线程池的主要参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,<br>         Executors.defaultThreadFactory(), defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>1、corePoolSize（线程池基本大小）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</p>
<p>2、maximumPoolSize（线程池最大大小）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</p>
<p>3、keepAliveTime（线程存活保持时间）当线程池中线程数大于核心线程数时，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</p>
<p>4、workQueue（任务队列）：用于传输和保存等待执行任务的阻塞队列。</p>
<p>5、threadFactory（线程工厂）：用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</p>
<p>5、handler（线程饱和策略）：当线程池和队列都满了，再加入线程会执行此策略。</p>
</blockquote>
<p>假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。</p>
<p>如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。</p>
<p>一个线程池包括以下四个基本组成部分：</p>
<pre><code>1. 线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
1. 工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
1. 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
1. 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。
</code></pre><p>线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</p>
<p>线程池不仅调整T1,T3产生的时间段，而且它还显著减少了创建线程的数目，看一个例子：</p>
<blockquote>
<p>假设一个服务器一天要处理50000个请求，并且每个请求需要一个单独的线程完成。在线程池中，线程数一般是固定的，所以产生线程总数不会超过线程池中线程的数目，而如果服务器不利用线程池来处理这些请求则线程总数为50000。一般线程池大小是远小于50000。所以利用线程池的服务器程序不会为了创建50000而在处理请求时浪费时间，从而提高效率。</p>
</blockquote>
<p><strong>比较重要的几个类</strong></p>
<table>
<thead>
<tr>
<th>ExecutorService</th>
<th>真正的线程池接口。</th>
</tr>
</thead>
<tbody>
<tr>
<td>ScheduledExecutorService</td>
<td>能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td>
</tr>
<tr>
<td>ThreadPoolExecutor</td>
<td>ExecutorService的默认实现。</td>
</tr>
<tr>
<td>ScheduledThreadPoolExecutor</td>
<td>继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td>
</tr>
</tbody>
</table>
<p><strong>java中提供的线程池</strong></p>
<img src="/article/58846/1200.png" class title="img">
<p>1、newCachedThreadPool：用来创建一个可以无限扩大的线程池，适用于负载较轻的场景，执行短期异步任务。（可以使得任务快速得到执行，因为任务时间执行短，可以很快结束，也不会造成cpu过度切换）</p>
<p>2、newFixedThreadPool：创建一个固定大小的线程池，因为采用无界的阻塞队列，所以实际线程数量永远不会变化，适用于负载较重的场景，对当前线程数量进行限制。（保证线程数可控，不会造成线程过多，导致系统负载更为严重）</p>
<p>3、newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行各个任务。</p>
<p>4、newScheduledThreadPool：适用于执行延时或者周期性任务。</p>
<p><strong>execute()和submit()方法</strong></p>
<p>1、execute()，执行一个任务，没有返回值。</p>
<p>2、submit()，提交一个线程任务，有返回值。</p>
<p>submit(Callable<T> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。一般使用FutureTask+Callable配合使用（IntentService中有体现）。</T></p>
<p>submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值。<br>submit(Runnable task)则是没有返回值的，就算获取它的返回值也是null。</p>
<p>Future.get方法会使取结果的线程进入阻塞状态，知道线程执行完成之后，唤醒取结果的线程，然后返回结果。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java,多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java引用类型</title>
    <url>/article/40363.html</url>
    <content><![CDATA[<blockquote>
<p>The mystery of creation is like the darkness of night–it is great. </p>
<p>创造的神秘，有如夜间的黑暗－－是伟大的。</p>
<p>Delusions of knowledge are like the fog of the morning. </p>
<p>而知识的幻影却不过如晨间 之雾。 </p>
</blockquote>
<p>java中的4种引用类型，它们从强到弱分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:center">引用类型</th>
<th style="text-align:center">对象是否可引用</th>
<th style="text-align:center">回收时间</th>
<th style="text-align:center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强引用</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">从不回收</td>
<td style="text-align:center">普遍对象的状态</td>
</tr>
<tr>
<td style="text-align:center">软引用</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">内存不足时</td>
<td style="text-align:center">内存敏感的高速缓存</td>
</tr>
<tr>
<td style="text-align:center">弱引用</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">下一次GC</td>
<td style="text-align:center">对象缓存</td>
</tr>
<tr>
<td style="text-align:center">虚引用</td>
<td style="text-align:center">不可以</td>
<td style="text-align:center">下一次GC，不影响对象生命周期</td>
<td style="text-align:center">必须和引用队列(ReferenceQueue)一起使用，一般用于追踪垃圾收集器的回收动作。相比对象的finalize方法，虚引用的方式更加灵活和安全。</td>
</tr>
</tbody>
</table>
<h2 id="对象可达性判断"><a href="#对象可达性判断" class="headerlink" title="对象可达性判断"></a>对象可达性判断</h2><p>目前，大多数JVM都是使用可达性分析算法来判断对象的是否可达。可达性分析算法以GC Roots对象作为起始点进行搜索。当一个对象与GC Roots对象没有任何引用链相连时(也即引用有向图中从GC Roots对象到这个对象是不连通的)，则表明该对象是不可用的（不可用的对象不一定被判定为可以回收的对象）。当对象与GC Roots对象有引用链相连时，则需要根据引用链的类型来判断对象是否可达。</p>
<blockquote>
<p>不可用的对象不一定被判定为可以回收的对象：判定对象为”死亡”至少需要经历两次标记的过程。第一次标记：对象可达性分析，如果发现对象没有与GC Roots相连接的引用链，且对象需要执行finalize方法，将会被加入F-Queue队列中。第二次标记：由一个优先级低的Finalizer线程去取F-Queue队列的对象，“尝试执行”对象的finalize方法。<br>JVM会保证触发满足条件的对象的finalize方法，但是并不承诺会等待方法执行结束。finalize方法是对象逃脱死亡命运的最后一次机会。</p>
</blockquote>
<h2 id="GC-Roots对象"><a href="#GC-Roots对象" class="headerlink" title="GC Roots对象"></a>GC Roots对象</h2><p>GC Roots对象包含以下四类：</p>
<ul>
<li>虚拟机栈(栈桢中的本地变量表)中的引用的对象；</li>
<li>方法区中的类静态属性引用的对象；</li>
<li>方法区中的常量引用的对象；</li>
<li>本地方法栈中JNI（Native方法）引用的对象；</li>
</ul>
<h2 id="可达性判断"><a href="#可达性判断" class="headerlink" title="可达性判断"></a>可达性判断</h2><h3 id="可达性状态类型"><a href="#可达性状态类型" class="headerlink" title="可达性状态类型"></a>可达性状态类型</h3><p>Java有5种类型的可达性状态：</p>
<ul>
<li>强可达(Strongly Reachable)：与GC Roots对象之间有强引用相连通，则为强可达的；</li>
<li>软可达(Soft Reachable)：与GC Roots对象之间没有强引用相连通，但有软引用相连通，则为软可达的；</li>
<li>弱可达(Weak Reachable)：与GC Roots对象之间没有强引用或软引用相连通，但有弱引用相连通，则为弱可达的；</li>
<li>虚可达(Phantom Reachable)：与GC Roots对象之间没有强引用、软引用或弱引用相连通，然后该对象finalize方法已执行，并且有虚引用相连通，则为虚可达的；</li>
<li>不可达(Unreachable)：如果对象finalize方法已执行并且没有任何引用相连通，则对象是不可达的，可以被回收。</li>
</ul>
<h3 id="可达性判断规则"><a href="#可达性判断规则" class="headerlink" title="可达性判断规则"></a>可达性判断规则</h3><p>从GC Roots对象到一个对象的引用链可能存在多条，那么此时会依据两个原则来判断对象的可达性：</p>
<ul>
<li>单个引用链中，以最弱的引用类型为准；</li>
<li>多引用链联合看时，以最强的引用类型为准；</li>
</ul>
<img src="/article/40363/%E5%8F%AF%E8%BE%BE%E6%80%A7%E8%A7%84%E5%88%99%E5%88%A4%E6%96%AD.jpeg" class title="可达性判断">
<p>首先，单个引用链中，以最弱的引用类型为准：则GC Roots-&gt;Obj1-&gt;Obj4是软引用连通的，GC Roots-&gt;Obj2-&gt;Obj4是弱引用连通的，GC Roots-&gt;Obj3-&gt;Obj5是弱引用连通的。然后多引用链联合看时，以最强的引用类型为准：则GC Roots到Obj4对象的引用联合来看是弱引用连通的。</p>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>对象可达性状态是随着程序运行而不断变化的，对象可达性状态转换图可参考下图。</p>
<ul>
<li>对象创建后一般是强可达的。</li>
<li>当GC Roots对象到该对象的强引用被清除后：如果剩余引用链最高为软引用，则状态转换为软可达的；反之如果最高为弱引用，则状态转换为弱可达的，反之则把对象标记为可执行finalize方法状态。</li>
<li>当软可达对象重新被强引用连接时，则转换为强可达状态；当软可达对象的软引用被清除后，如果剩余引用链最高为弱引用，则状态转换为弱可达；反之则把对象标记为可执行finalize方法状态。</li>
<li>当弱可达对象重新被强引用或者软引用连接时，则可转换为强可达或者软可达；当弱可达对象的弱引用被清除后，则把对象标记为可执行finalize方法状态。</li>
<li>可对象被标记为可执行finalize方法状态，如果对象finalize从未被执行，则执行finalize方法，并标记对象的finalize方法已经被执行（在finalize方法可能会重新生成强/软/弱引用等，对象状态会重新转换为强/软/弱可达，不过并不推荐这么做，因为可能会导致对象状态紊乱，无法被正常回收）；反之当对象有虚引用连接时，则转换为虚可达状态，否则转换为不可达状态。</li>
<li>虚可达对象在垃圾回收后状态转换为不可达（不能通过虚引用获取对象引用，所以对象状态不会再转换为强/软/弱可达）；</li>
</ul>
<img src="/article/40363/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpeg" class title="可达性状态转换图">
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Reference类是所有引用类型的基类，定义了reference对象的通用操作，用来保存对象引用及引用的内部状态。Reference抽象类初始化时，会启动一个ReferenceHandler线程。Reference的referent被回收前，垃圾回收器会把reference添加到pending这个链表里（如果注册了ReferenceQueue），然后ReferenceHandler线程不断的读取pending中的reference，把它加入到对应的ReferenceQueue中（如果Reference是Cleaner类的实例，即虚引用对象，则调用其注册的预处理钩子方法）。</p>
<blockquote>
<p>ReferenceQueue提供了两个静态字段NULL，ENQUEUED。这两个字段的主要功能：NULL是当我们构造Reference实例时queue传入null时，会默认使用NULL，这样在enqueue时判断queue是否为NULL,如果为NULL直接返回，入队失败。ENQUEUED的作用是防止重复入队，reference后会把其queue字段赋值为ENQUEUED,当再次入队时会直接返回失败。</p>
</blockquote>
<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>Reference对象的基类。该类定义了reference对象的通用操作。因为reference对象是和垃圾回收器密切配合实现的，因此该类不能直接进行子类化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>	<span class="hljs-comment">// 用于保存对象的引用，GC会特别对待该变量</span><br>    <span class="hljs-keyword">private</span> T referent; <br>	<span class="hljs-comment">// 如果注册了ReferenceQueue（需要通知机制），用来保存对象引用的队列，</span><br>    <span class="hljs-keyword">volatile</span> ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; queue;<br><br>  <span class="hljs-comment">// 保存需要由ReferenceHandler处理的引用</span><br>    <span class="hljs-keyword">volatile</span> Reference next;<br><br>	<span class="hljs-comment">// 被JVM使用，保存需要被JVM处理的下一个引用</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">private</span> Reference&lt;T&gt; discovered;<br><br>    <span class="hljs-comment">// 同步锁，用于同步pending队列的进队和出队</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span> </span>&#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Lock lock = <span class="hljs-keyword">new</span> Lock();<br><br>    <span class="hljs-comment">// 一个PENDING队列，配合上述next一起使用，实现类单向循环链表的操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Reference&lt;Object&gt; pending = <span class="hljs-keyword">null</span>;<br><br>	<span class="hljs-comment">// 高优先级线程，用于将pending队列里面的Reference实例依次添加到不同的ReferenceQueue中</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;...&#125;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="状态变化"><a href="#状态变化" class="headerlink" title="状态变化"></a>状态变化</h2><p>一个对象引用有四种内部状态:</p>
<ul>
<li><p>Active: 新创建的实例的状态，当对象引用被垃圾回收器回收前：如果Reference注册了ReferenceQueue，则会切换为Pending，并且Reference会加入pending链表中，如果没有注册ReferenceQueue，会切换为Inactive。</p>
</li>
<li><p>Pending: 在pending链表中的Reference的状态，这些Reference等待被ReferenceHandler内部线程加入ReferenceQueue中。</p>
</li>
<li><p>Enqueued: 在ReferenceQueue队列中的Reference的状态，如果Reference从队列中移除，会进入Inactive状态。未注册ReferenceQueue的实例不会到达该状态。</p>
</li>
<li><p>Inactive: Reference的最终状态，该状态不会再改变。</p>
</li>
</ul>
<p>  其状态转换图如下：<br>  <img src="/article/40363/%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.jpeg" class title="img"></p>
<h2 id="四种引用类型实现"><a href="#四种引用类型实现" class="headerlink" title="四种引用类型实现"></a>四种引用类型实现</h2><img src="/article/40363/%E4%B8%8D%E5%90%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84UML%E7%B1%BB%E5%9B%BE.jpeg" class title="Reference UML类图">
<h3 id="强引用FinalReference"><a href="#强引用FinalReference" class="headerlink" title="强引用FinalReference"></a>强引用FinalReference</h3><p>对象新建后默认为强引用类型的，是普遍对象引用的类型。查看FinalReference在JDK中的源码发现其只有一个空实现，这也说明强引用是“默认引用类型”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Final references, used to implement finalization</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FinalReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(referent, q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a>软引用SoftReference</h3><p>软引用是用来描述一些“还有用但是非必须”的对象。软引用的回收策略在不同的JVM实现会略有不同，JVM不仅仅只会考虑当前内存情况，还会考虑软引用所指向的referent最近的使用情况和创建时间来综合决定是否回收该referent。软引用保存了两个变量：</p>
<ul>
<li>timestamp：每次调用get方法都会更新时间戳。JVM可以利用该字段来选择要清除的软引用，但不是必须要这样做。</li>
<li>clock：时间锁，由垃圾收集器更新。    </li>
</ul>
<p>因此，任何GC都可以使用这些字段并定义清除软引用的策略，例如：最后清除最近创建的或最近使用的软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 软引用对象由垃圾收集器根据内存需要决定是否清除。软引用经常用于实现内存敏感的缓存。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 假如垃圾收集器在某个时间确定对象是软可达的，此时它可以选择原地清除</span><br><span class="hljs-comment"> * 指向该对象的所有软引用，以及从该对象通过强引用链连接的其他软可达对象的所有软引用。</span><br><span class="hljs-comment"> * 与时同时或者之后的某个时间，它会将注册了reference queues的新清除的软引用加入队列。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在虚拟机抛出OutOfMemoryError异常之前，将保证清除对软可达对象的所有软引用。</span><br><span class="hljs-comment"> * 不过，并没有对清除软引用的时间以及清除顺序施加强制约束。</span><br><span class="hljs-comment"> * 但是，鼓励虚拟机实现偏向不清除最近创建或最近使用的软引用。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 该类的直接实例可用于实现简单的缓存。</span><br><span class="hljs-comment"> * 该类或其派生子类也可用于更大的数据结构以实现更复杂的高速缓存。</span><br><span class="hljs-comment"> * 只要软引用的引用对象还是强可达的，即还在实际使用中，软引用就不会被清除。</span><br><span class="hljs-comment"> * 因此，复杂的高速缓存可以通过持有对最近使用缓存对象的强引用来防止其被清除，</span><br><span class="hljs-comment"> * 而不常使用的剩余缓存对象由垃圾收集器决定是否清除。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SoftReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>	<span class="hljs-comment">// 时间锁，由垃圾收集器更新。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> clock;<br><br>	<span class="hljs-comment">// 每次调用get方法都会更新该时间戳。JVM可能会在选择要清除的软引用时使用该字段，</span><br>	<span class="hljs-comment">// 但这不是强制必须的。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> timestamp;<br>	<br>	<span class="hljs-comment">// 返回对象的引用。如果该引用对象已经被程序或者垃圾收集器清除，则返回null。</span><br>	<span class="hljs-comment">// 把最近一次垃圾回收时间赋值给timestamp</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        T o = <span class="hljs-keyword">super</span>.get();<br>        <span class="hljs-keyword">if</span> (o != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.timestamp != clock)<br>            <span class="hljs-keyword">this</span>.timestamp = clock;<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="弱引用WeakReference"><a href="#弱引用WeakReference" class="headerlink" title="弱引用WeakReference"></a>弱引用WeakReference</h3><p>当一个对象没有被强引用或者软引用连接，但被弱引用连接时，则处于弱可达状态。只要发生GC，弱可达的对象就会被清除，同时会把弱引用加入到注册的引用队列中(如果存在的话)。弱引用对GC几乎是没有影响的，它不影响对应的referent被终结(finalized)和回收(reclaimed)。因此，弱引用最常用于实现规范化映射(canonicalizing mappings)，例如哈希表，如果它们在程序中未被引用，则其键和值将从映射中删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 弱引用对象不能阻止自身的引用被回收。</span><br><span class="hljs-comment"> * 弱引用常用于实现规范化映射(对象实例可以在程序的多个地方同时使用)。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 假如垃圾收集器在某个时间点确定对象是弱可达的。那时它将原子地清除对该对象的所有弱引用</span><br><span class="hljs-comment"> * 以及该引用通过强引用或者软引用连接的所有其他弱可达对象的所有弱引用。</span><br><span class="hljs-comment"> * 同时，它将表明前面所指的所有弱可达对象都可以执行finalize方法。</span><br><span class="hljs-comment"> * 与此同时或之后某一个时间，它将注册了reference queues的那些新清除弱引用加入队列。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>	<span class="hljs-comment">// 创建没有注册ReferenceQueue的弱引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeakReference</span><span class="hljs-params">(T referent)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(referent);<br>    &#125;<br><br>	<span class="hljs-comment">// 创建注册了ReferenceQueue的弱引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeakReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(referent, q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="虚引用PhantomReference"><a href="#虚引用PhantomReference" class="headerlink" title="虚引用PhantomReference"></a>虚引用PhantomReference</h3><p>虚引用是所有引用类型中最弱的一种。一个对象是否关联到虚引用，完全不会影响该对象的生命周期，也无法通过虚引用来获取一个对象的实例。为对象设置一个虚引用的唯一目的是：能在此对象被垃圾收集器回收的时候收到一个系统通知，它就是利用ReferenceQueue实现的。当referent被gc回收时，JVM自动把虚引用对象本身加入到ReferenceQueue中，表明该reference指向的referent被回收。然后可以通过去queue中取到reference，可以通过这个来做额外的清理工作。可以用虚引用代替对象finalize方法来实现资源释放，这样更加灵活和安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虚引用对象在被垃圾收集器检查到后加入reference queues队列，否则会被回收。</span><br><span class="hljs-comment"> * 虚引用最常用于实现比Java finalization机制更灵活的安排额外的清理工作。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 如果垃圾收集器在某个时间点确定虚引用对象是虚可达的，那么在那个时间或之后某个时间它会将引用加入reference queues队列。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 为了确保可回收对象保持不变，虚引用的引用无法使用：虚引用对象的get方法始终返回null。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 与软引用和弱引用不同，当虚引用加入reference queues队列后垃圾收集器不会被自动清除。</span><br><span class="hljs-comment"> * 只通过虚引用可达的对象将保持不变，直到所有此类引用都被清除或自已变为不可达。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhantomReference</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Reference</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">// 由于不能通过虚引用访问对象，因此此方法始终返回null。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>  <span class="hljs-comment">// 使用空ReferenceQueue队列创建一个虚引用没有意义：它的get方法总是返回null，</span><br>	<span class="hljs-comment">// 并且由于它没有注册队列，所以也不会被加入队列有任何清理前的预处理操作。</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PhantomReference</span><span class="hljs-params">(T referent, ReferenceQueue&lt;? <span class="hljs-keyword">super</span> T&gt; q)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(referent, q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>引用类型</category>
      </categories>
      <tags>
        <tag>Java,引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈循环不变量</title>
    <url>/article/41380.html</url>
    <content><![CDATA[<h2 id="循环不变量（loop-invariant）"><a href="#循环不变量（loop-invariant）" class="headerlink" title="循环不变量（loop invariant）"></a>循环不变量（loop invariant）</h2><p>在使用循环的算法里，可以通过循环不变量证明其正确性。</p>
<p>所谓循环不变量是指一种在整个循环过程中保持不变的性质，它必须在以下3种情况下均保持不变，且该性质在循环终止后能证明算法的正确性。</p>
<ol>
<li>初始化（循环初始化后，循环条件测试前）</li>
<li>迭代（第 n 次迭代后，第 n+1 次迭代前）</li>
<li>结束（循环终止即循环条件判断为 false 时）</li>
</ol>
<h3 id="二分法理解循环不变量"><a href="#二分法理解循环不变量" class="headerlink" title="二分法理解循环不变量"></a>二分法理解循环不变量</h3><p>题目：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。<br><br>示例 1:<br>输入: nums = [1,3,5,6], target = 5<br>输出: 2<br><br>示例 2:<br>输入: nums = [1,3,5,6], target = 2<br>输出: 1<br><br>示例 3:<br>输入: nums = [1,3,5,6], target = 7<br>输出: 4<br><br>示例 4:<br>输入: nums = [1,3,5,6], target = 0<br>输出: 0<br><br>示例 5:<br>输入: nums = [1], target = 0<br>输出: 0<br><br>提示:<br>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 为无重复元素的升序排列数组<br>-104 &lt;= target &lt;= 104<br><br>Related Topics<br>数组<br>二分查找<br></code></pre></td></tr></table></figure>
<p>我自己的理解：使用二分法一直盯着right，保持循环不变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>      	<span class="hljs-comment">//定义target在左闭右闭合的区间范围里。</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//由于target在一个闭合区间里，那么left=right的时候式子也成立，当left&gt;right的时候式子不成立，则可以推出，while()循环条件是</span><br>        <span class="hljs-comment">//left&lt;=right（取补集）。注意这里很容易错，一定要注意推到。</span><br>        <span class="hljs-comment">//就是循环不变式满足：如果在循环的每一步，这个式子都是正确的，那么循环结束后，这个式子也正确。</span><br>        <span class="hljs-comment">//此问题中初始化时定义区间为[0,nums.length - 1],那么根据循环不变量原理则在循环的整个过程中这种模式是不变的</span><br>        <span class="hljs-comment">//都是闭区间的模式。我们可以根据此检验代码的正确性。</span><br>        <span class="hljs-comment">//因为left，right是闭合区间，所以left和right是可以取到的</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">int</span> middle = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &gt;nums[middle] )&#123;<br>                <span class="hljs-comment">//如果要找的数比中间值大，说明在区间右边。根据循环不变式，那么当改变left指针的时候，其也是左边闭合的</span><br>                <span class="hljs-comment">//此时left的值应该能被取到，因此left=middle+1</span><br>                left=middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(target &lt; nums[middle] )&#123;<br>                right=middle-<span class="hljs-number">1</span>;<span class="hljs-comment">//同理，right的值也能被取到</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(target == nums[middle] )&#123;<br>                <span class="hljs-keyword">return</span>  middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  right+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.length;<span class="hljs-comment">//注意此处定义的右边为数组的长度，因此其右端点的值是取不到的</span><br>        <span class="hljs-comment">//也就是左闭右开区间[left,right)，因此left!=right，当left大于等于right的时候循环结束</span><br>        <span class="hljs-comment">//循环中的条件为left&lt;right</span><br>        <span class="hljs-keyword">while</span>(left &lt;right)&#123;<br>            <span class="hljs-keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(target &gt;nums[middle] )&#123;<br>                <span class="hljs-comment">//如果要找的数比中间值大，说明在区间右边。根据循环不变式，那么当改变left指针的时候，其也是左边闭合的</span><br>                <span class="hljs-comment">//此时left的值应该能被取到，因此left=middle+1</span><br>                left=middle+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(target &lt; nums[middle] )&#123;<br>                <span class="hljs-comment">//当要找的值比中间值小的时候，说明区间在左边，由于是左闭右开的区间，所以右端点</span><br>                <span class="hljs-comment">//不能被取到，如果当right=middle-1时候，值是有可能取到的，当right=middle时候</span><br>                <span class="hljs-comment">//由于要找的值是比middle小的，所以是不能被取到的，根据循环不变量原理区间是[0,right)</span><br>                <span class="hljs-comment">//right为middle时候取不到</span><br>                right=middle;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(target == nums[middle] )&#123;<br>                <span class="hljs-keyword">return</span>  middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//注意此时返回的是right</span><br>        <span class="hljs-keyword">return</span>  right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>循环不变量</category>
      </categories>
      <tags>
        <tag>循环不变量</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/article/34455.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java异常处理</title>
    <url>/article/28277.html</url>
    <content><![CDATA[<blockquote>
<p>My wishes are fools, they shout across thy song, my Master. </p>
<p>神呀，我的那些愿望真是愚傻呀，它们杂在你的歌声中喧叫着呢。 </p>
<p>Let me but listen. </p>
<p>让我只是静听着吧。</p>
</blockquote>
<h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><p>异常发生的原因有很多，通常包含以下几大类：</p>
<ul>
<li>用户输入了非法数据；</li>
<li>要打开的文件不存在；</li>
<li>网络通信时连接中断，或者JVM内存溢出。</li>
</ul>
<p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p>
<ul>
<li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的；</li>
<li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略；</li>
<li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。</li>
</ul>
<img src="/article/28277/exception-hierarchy.png" class title="exception-hierarchy">
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作<strong>无关</strong></p>
<p>Java虚拟机运行错误（Virtual MachineError），当JVM不再继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机一般会选择线程终止。</p>
<p>还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为他们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</p>
<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p>
<p>这些已成一般是由于程序逻辑错误引起的，程序应该从逻辑的角度尽可能避免这些类异常的发生。</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>Mac快捷键：<code>Command + option + T</code></p>
<p><strong>try-catch</strong></p>
<ul>
<li>使用 try 和 catch 关键字可以捕获异常；</li>
<li>try-catch 代码块放在异常可能发生的地方。</li>
</ul>
<p>try-catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>   <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 异常的变量名<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">//Catch 块</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">2</span> 异常的变量名<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-comment">//Catch 块</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">3</span> 异常的变量名<span class="hljs-number">3</span>)&#123;<br>  <span class="hljs-comment">//Catch 块</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p>
<p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p>
<p>捕获<strong>多个异常</strong>时，顺序要由小到大！</p>
<p><strong>finally</strong></p>
<ul>
<li>finally 关键字用来创建在 try 代码块后面执行的代码块；</li>
<li><strong>无论是否发生异常，finally 代码块中的代码总会被执行；</strong><ul>
<li>有一种特殊情况finally不执行：当程序没进入try就报错的情况下不执行；</li>
</ul>
</li>
<li>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</li>
<li>finally 代码块出现在 catch 代码块最后，语法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">1</span> 异常的变量名<span class="hljs-number">1</span>)&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型<span class="hljs-number">2</span> 异常的变量名<span class="hljs-number">2</span>)&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>  <span class="hljs-comment">// 程序代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>catch 不能独立于 try 存在；</li>
<li>在 try-catch 后面添加 finally 块并非强制性要求的；</li>
<li>try 代码后不能既没 catch 块也没 finally 块；</li>
<li>try, catch, finally 块之间不能添加任何代码。</li>
</ul>
<p><strong>throws/throw </strong></p>
<p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p>
<p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p>
<p>下面方法的声明抛出一个 RemoteException 异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">className</span></span><br><span class="hljs-class"></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span> <span class="hljs-keyword">throws</span> RemoteException</span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// Method implementation</span><br>    <span class="hljs-comment">//主动抛出异常，一般在方法中使用</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemoteException();<br>  &#125;<br>  <span class="hljs-comment">//Remainder of class definition</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点：</p>
<ul>
<li>所有异常都必须是 Throwable 的子类；</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。只继承Exception 类来创建的异常类是检查性异常类;</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="通用异常"><a href="#通用异常" class="headerlink" title="通用异常"></a>通用异常</h2><p>在Java中定义了两种类型的异常和错误。</p>
<ul>
<li><strong>JVM(Java虚拟机)</strong> <strong>异常：</strong>由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</li>
<li><strong>程序级异常：</strong>由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</li>
</ul>
<h2 id="Java异常合集"><a href="#Java异常合集" class="headerlink" title="Java异常合集"></a>Java异常合集</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>Java, 异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/article/50722.html</url>
    <content><![CDATA[<blockquote>
<p>The mystery of creation is like the darkness of night–it is great.</p>
<p>Delusions of knowledge are like the fog of the morning.</p>
</blockquote>
<p><a href="https://www.cnblogs.com/l199616j/p/10742603.html#_label0_0">https://www.cnblogs.com/l199616j/p/10742603.html#_label0_0</a></p>
<img src="/article/50722/sort.png" class title="sort">
<img src="/article/50722/%E5%88%86%E7%B1%BB.jpg" class title="分类">
<h2 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h2><h3 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h3><ol>
<li>最好情况、最坏情况、平均情况时间复杂度</li>
<li>时间复杂度的系数、常数 、低阶</li>
<li>比较次数和交换（或移动）次数</li>
</ol>
<h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p><strong>原地排序（Sorted in place）</strong></p>
<p>原地排序算法，就是特指空间复杂度是 O(1) 的排序算法</p>
<p>原地排序算法：冒泡排序、插入排序、选择排序</p>
<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<h3 id="“有序度”和“逆序度”"><a href="#“有序度”和“逆序度”" class="headerlink" title="“有序度”和“逆序度”"></a>“有序度”和“逆序度”</h3><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。</p>
<p>完全有序的数组的有序度叫作<strong>满有序度</strong>：<strong>n*(n-1)/2</strong></p>
<p><strong>逆序度</strong>是数组中不具有有序关系的元素对的个数。</p>
<p><strong>逆序度 = 满有序度 - 有序度</strong></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以<strong>冒泡排序是稳定的排序算法</strong>。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们的位置；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<img src="/article/50722/bubbleSort.gif" class title="bubbleSort">
<h3 id="Java算法实现"><a href="#Java算法实现" class="headerlink" title="Java算法实现"></a>Java算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] bubbleSort(<span class="hljs-keyword">int</span>[] array)&#123;<br>  <span class="hljs-comment">//外层循环 判断循环走多少次</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length - <span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-comment">//比较相邻的元素。如果第一个比第二个大，就交换他们的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span> - i; j++)&#123;<br>      <span class="hljs-keyword">if</span>(array[j+<span class="hljs-number">1</span>] &lt; array[j])&#123;<br>        <span class="hljs-keyword">int</span> temp = array[j];<br>        array[j] = array[j+<span class="hljs-number">1</span>];<br>        array[j+<span class="hljs-number">1</span>] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="算法增加标志位改进"><a href="#算法增加标志位改进" class="headerlink" title="算法增加标志位改进"></a>算法增加标志位改进</h4><ul>
<li>增加标志位，减少没有意义的比较</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] bubbleSort(<span class="hljs-keyword">int</span>[] array)&#123;<br>  <span class="hljs-comment">//外层循环 判断循环走多少次</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length - <span class="hljs-number">1</span>; i++)&#123;<br>    <span class="hljs-comment">//设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成</span><br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">//比较相邻的元素。如果第一个比第二个大，就交换他们的位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; array.length - <span class="hljs-number">1</span> - i; j++)&#123;<br>      <span class="hljs-keyword">if</span>(array[j+<span class="hljs-number">1</span>] &lt; array[j])&#123;<br>        <span class="hljs-keyword">int</span> temp = array[j];<br>        array[j] = array[j+<span class="hljs-number">1</span>];<br>        array[j+<span class="hljs-number">1</span>] = temp;<br>        <span class="hljs-comment">//相邻数字排序完成后，置为true</span><br>        flag = <span class="hljs-keyword">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果其中一轮完全没有进入第二次循环中的置换顺序，说明没有需要置换的相邻元素，那么说明已经不需要再次进行排序，flag为true，可以直接跳出循环</span><br>    <span class="hljs-keyword">if</span>(flag)&#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  reyurn array;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个<strong>原地排序算法</strong>。</p>
<p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<strong>稳定的排序算法</strong>。</p>
<p>选择排序是一种<strong>不稳定的排序算法</strong></p>
<img src="/article/50722/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" class title="img">
<ol>
<li>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。</li>
<li>初始已排序区间只有一个元素，就是数组的第一个元素。</li>
<li>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。</li>
<li>重复这个过程，直到未排序区间中元素为空，算法结束。</li>
</ol>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 插入排序，a表示数组，n表示数组大小</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> value = a[i];<br>    <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 查找插入的位置</span><br>    <span class="hljs-keyword">for</span> (; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>      <span class="hljs-keyword">if</span> (a[j] &gt; value) &#123;<br>        a[j+<span class="hljs-number">1</span>] = a[j];  <span class="hljs-comment">// 数据移动</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    a[j+<span class="hljs-number">1</span>] = value; <span class="hljs-comment">// 插入数据</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>
<p>选择排序空间复杂度为 O(1)，是一种<strong>原地排序算法</strong></p>
<h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li><p>第一个跟后面的所有数相比较，如果小于（或等于）第一个数的时候，暂存较小数的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）</p>
</li>
<li><p>下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数</p>
</li>
<li>重复以上步骤，直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。</li>
</ol>
<img src="/article/50722/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" class title="img">
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] n = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">33</span>,<span class="hljs-number">27</span>,<span class="hljs-number">66</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">88</span>&#125;;<br>    <span class="hljs-keyword">int</span> temp,index = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n.length-<span class="hljs-number">1</span>; i++) &#123;<br>      index=i;<br>      <span class="hljs-comment">//如果大于，暂存较小的数的下标</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt;n.length; j++) &#123;<br>        <span class="hljs-keyword">if</span>(n[index]&gt;n[j])&#123;<br>          index = j;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">////将一趟下来求出的最小数，与这个数交换</span><br>      <span class="hljs-keyword">if</span>(index&gt;<span class="hljs-number">0</span>)&#123;<br>        temp = n[i];<br>        n[i] = n[index];<br>        n[index] = temp;<br>      &#125;<br>      System.out.println(Arrays.toString(n));<br>    &#125;<br>    System.out.println(Arrays.toString(n));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>核心思想:如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>
<p>在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素，先把 A[p…q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，<strong>归并排序是一个稳定的排序算法</strong>。</p>
<p><strong>时间复杂度：</strong></p>
<blockquote>
<p><strong>T(a) = T(b) + T(c) + K</strong></p>
<p>其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。</p>
<p>我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。我们知道，merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</p>
<p><strong>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</strong><br><strong>T(n) = 2*T(n/2) + n； n&gt;1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs txt">T(n) = 2*T(n/2) + n<br>     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n<br>     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n<br>     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n<br>     ......<br>     = 2^k * T(n/2^k) + k * n<br>     ......<br></code></pre></td></tr></table></figure>
<p>通过这样一步一步分解推导，我们可以得到 <strong>T(n) = 2^kT(n/2^k)+kn</strong>。当 <strong>T(n/2^k)=T(1)</strong> 时，也就是 n/2^k=1，我们得到 <strong>k=log2n</strong> 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。</p>
<p>如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以<strong>归并排序的时间复杂度是 O(nlogn)</strong>。</p>
<p>归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)</p>
</blockquote>
<p><strong>空间复杂度</strong>是 O(n)</p>
<blockquote>
<img src="/article/50722/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%88%86%E8%A7%A3%E5%9B%BE.jpg" class title="归并排序分解图">
</blockquote>
<p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。</p>
<blockquote>
<p>分治是一种解决问题的处理思想，递归是一种编程技巧</p>
</blockquote>
<img src="/article/50722/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" class title="img">
<blockquote>
<p>递推公式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递推公式：</span><br>merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+<span class="hljs-number">1</span>…r))<br><br><span class="hljs-comment">//终止条件：</span><br>p &gt;= r 不用再继续分解<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>&#125;;<br>    merge(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>);<br>    System.out.println(Arrays.toString(arr));<br>  &#125;<br><br>  <span class="hljs-comment">//归并</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> center = (high+low)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(low&lt;high)&#123;<br>      <span class="hljs-comment">//递归，直到low==high，也就是数组已不能再分了，</span><br>      merge(arr,low,center);<br>      merge(arr,center+<span class="hljs-number">1</span>,high);<br><br>      <span class="hljs-comment">//当数组不能再分，开始归并排序</span><br>      mergeSort(arr,low,center,high);<br>      System.out.println(Arrays.toString(arr));<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">//排序</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> center,<span class="hljs-keyword">int</span> high)</span></span>&#123;<br>    <span class="hljs-comment">//用于暂存排序后的数组的临时数组</span><br>    <span class="hljs-keyword">int</span>[] tempArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<br>    <span class="hljs-keyword">int</span> i = low,j = center+<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//临时数组的下标</span><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//循环遍历两个数组的数字，将小的插入到临时数组里</span><br>    <span class="hljs-keyword">while</span>(i&lt;=center &amp;&amp; j&lt;= high)&#123;<br><br>      <span class="hljs-comment">//左边数组的数小，插入到新数组</span><br>      <span class="hljs-keyword">if</span>(arr[i]&lt;arr[j])&#123;<br>        tempArr[index] = arr[i];<br>        i++;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//右边数组的数小，插入到新数组</span><br>        tempArr[index] = arr[j];<br>        j++;<br>      &#125;<br>      index++;<br>    &#125;<br><br>    <span class="hljs-comment">//处理左半边数组多余的数据，将左半边多余的数据直接追加的临时数组的后面</span><br>    <span class="hljs-keyword">while</span>(i&lt;=center)&#123;<br>      tempArr[index] = arr[i];<br>      i++;<br>      index++;<br>    &#125;<br><br>    <span class="hljs-comment">//处理右半边数组多余的数据，将右半边多余的数据直接追加的临时数组的后面</span><br>    <span class="hljs-keyword">while</span>(j&lt;= high)&#123;<br>      tempArr[index] = arr[j];<br>      j++;<br>      index++;<br>    &#125;<br><br>    <span class="hljs-comment">//将临时数组中的数据重新放进原数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; index; k++) &#123;<br>      arr[k+low] = tempArr[k];<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p>
<p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p>
<p><strong>快排是一种原地、不稳定的排序算法</strong></p>
<p><strong>时间复杂度：</strong></p>
<blockquote>
<p>快排的时间复杂度递推求解公式跟归并是相同的。所以，<strong>快排的时间复杂度也是 O(nlogn)</strong>。</p>
<p>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。<br>T(n) = 2*T(n/2) + n； n&gt;1</p>
<p>公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p>
<p><strong>最坏情况时间复杂度:O(n2)</strong></p>
<p>T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)</p>
</blockquote>
<img src="/article/50722/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" class title="快速排序">
<img src="/article/50722/quickSort.gif" class title="img">
<blockquote>
<p>递推公式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//递推公式：</span><br>quick_sort(p…r) = quick_sort(p…q-<span class="hljs-number">1</span>) + quick_sort(q+<span class="hljs-number">1</span>… r)<br><br><span class="hljs-comment">//终止条件：</span><br>p &gt;= r<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;<br><br>  <span class="hljs-comment">// 快速排序，a是数组，n表示数组的大小</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    quickSortInternally(a, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 快速排序递归函数，p,r为下标</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSortInternally</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">int</span> q = partition(a, p, r); <span class="hljs-comment">// 获取分区点</span><br>    quickSortInternally(a, p, q-<span class="hljs-number">1</span>);<br>    quickSortInternally(a, q+<span class="hljs-number">1</span>, r);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pivot = a[r];<br>    <span class="hljs-keyword">int</span> i = p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = p; j &lt; r; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (a[j] &lt; pivot) &#123;<br>        <span class="hljs-keyword">if</span> (i == j) &#123;<br>          ++i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">int</span> tmp = a[i];<br>          a[i++] = a[j];<br>          a[j] = tmp;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> tmp = a[i];<br>    a[i] = a[r];<br>    a[r] = tmp;<br><br>    System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="优化快速排序"><a href="#优化快速排序" class="headerlink" title="优化快速排序"></a>优化快速排序</h3><blockquote>
<p>为什么最坏情况下快速排序的时间复杂度是 O(n<sup>2</sup>) 呢？</p>
<p>如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n<sup>2</sup>)。实际上，<strong>这种 O(n<sup>2</sup>) 时间复杂度出现的主要原因还是因为我们分区点选得不够合理。</strong></p>
</blockquote>
<p>最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多。</strong></p>
<ol>
<li><p>三数取中法</p>
<p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。</p>
<p>这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。</p>
<p>但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p>
</li>
<li><p>随机法</p>
<p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。</p>
</li>
</ol>
<h3 id="警惕堆栈溢出"><a href="#警惕堆栈溢出" class="headerlink" title="警惕堆栈溢出"></a>警惕堆栈溢出</h3><p>为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：</p>
<ol>
<li>第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。</li>
<li>第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</li>
</ol>
<hr>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p><strong>桶排序的时间复杂度是 O(n)</strong></p>
<blockquote>
<p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。</p>
<p>每个桶内部使用快速排序，时间复杂度为 O(k <em> logk)。m 个桶排序的时间复杂度就是 O(m </em> k <em> logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n</em>log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p>
</blockquote>
<p>桶排序对要排序数据的要求是非常苛刻的:</p>
<ol>
<li>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</li>
<li>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了</li>
</ol>
<img src="/article/50722/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpeg" class title="桶排序">
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BucketSort</span> </span>&#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 桶排序</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr 数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketSize 桶容量</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> bucketSize)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 数组最小值</span><br>    <span class="hljs-keyword">int</span> minValue = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 数组最大值</span><br>    <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[i] &lt; minValue) &#123;<br>        minValue = arr[i];<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &gt; maxValue) &#123;<br>        maxValue = arr[i];<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 桶数量</span><br>    <span class="hljs-keyword">int</span> bucketCount = (maxValue - minValue) / bucketSize + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketCount][bucketSize];<br>    <span class="hljs-keyword">int</span>[] indexArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketCount];<br><br>    <span class="hljs-comment">// 将数组中值分配到各个桶里</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>      <span class="hljs-keyword">int</span> bucketIndex = (arr[i] - minValue) / bucketSize;<br>      <span class="hljs-keyword">if</span> (indexArr[bucketIndex] == buckets[bucketIndex].length) &#123;<br>        ensureCapacity(buckets, bucketIndex);<br>      &#125;<br>      buckets[bucketIndex][indexArr[bucketIndex]++] = arr[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 对每个桶进行排序，这里使用了快速排序</span><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buckets.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (indexArr[i] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      quickSortC(buckets[i], <span class="hljs-number">0</span>, indexArr[i] - <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; indexArr[i]; j++) &#123;<br>        arr[k++] = buckets[i][j];<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数组扩容</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> buckets</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bucketIndex</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] buckets, <span class="hljs-keyword">int</span> bucketIndex)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] tempArr = buckets[bucketIndex];<br>    <span class="hljs-keyword">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[tempArr.length * <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; tempArr.length; j++) &#123;<br>      newArr[j] = tempArr[j];<br>    &#125;<br>    buckets[bucketIndex] = newArr;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 快速排序递归函数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSortC</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p &gt;= r) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> q = partition(arr, p, r);<br>    quickSortC(arr, p, q - <span class="hljs-number">1</span>);<br>    quickSortC(arr, q + <span class="hljs-number">1</span>, r);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分区函数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 分区点位置</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pivot = arr[r];<br>    <span class="hljs-keyword">int</span> i = p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = p; j &lt; r; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) &#123;<br>        swap(arr, i, j);<br>        i++;<br>      &#125;<br>    &#125;<br><br>    swap(arr, i, r);<br>    <span class="hljs-keyword">return</span> i;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> j</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == j) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p><strong>计数排序其实是桶排序的一种特殊情况</strong></p>
<p>当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>
<p><strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong></p>
<img src="/article/50722/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif" class title="img">
<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 查找数组中数据的范围</span><br>  <span class="hljs-keyword">int</span> max = a[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (max &lt; a[i]) &#123;<br>      max = a[i];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 申请一个计数数组c，下标大小[0,max]</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= max; ++i) &#123;<br>    c[i] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 计算每个元素的个数，放入c中</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    c[a[i]]++;<br>  &#125;<br><br>  <span class="hljs-comment">// 依次累加</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= max; ++i) &#123;<br>    c[i] = c[i-<span class="hljs-number">1</span>] + c[i];<br>  &#125;<br><br>  <span class="hljs-comment">// 临时数组r，存储排序之后的结果</span><br>  <span class="hljs-keyword">int</span>[] r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>  <span class="hljs-comment">// 计算排序的关键步骤，有点难理解</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>    <span class="hljs-keyword">int</span> index = c[a[i]]-<span class="hljs-number">1</span>;<br>    r[index] = a[i];<br>    c[a[i]]--;<br>  &#125;<br><br>  <span class="hljs-comment">// 将结果拷贝给a数组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    a[i] = r[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。</p>
<p><strong>这里按照每位来排序的排序算法要是稳定的</strong></p>
<p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</strong></p>
<img src="/article/50722/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" class title="img">
<h3 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> </span>&#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基数排序</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radixSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;<br>        max = arr[i];<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 从个位开始，对数组arr按&quot;指数&quot;进行排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> exp = <span class="hljs-number">1</span>; max / exp &gt; <span class="hljs-number">0</span>; exp *= <span class="hljs-number">10</span>) &#123;<br>      countingSort(arr, exp);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计数排序-对数组按照&quot;某个位数&quot;进行排序</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exp 指数</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> exp)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算每个元素的个数</span><br>    <span class="hljs-keyword">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>      c[(arr[i] / exp) % <span class="hljs-number">10</span>]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算排序后的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; c.length; i++) &#123;<br>      c[i] += c[i - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 临时数组r，存储排序之后的结果</span><br>    <span class="hljs-keyword">int</span>[] r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      r[c[(arr[i] / exp) % <span class="hljs-number">10</span>] - <span class="hljs-number">1</span>] = arr[i];<br>      c[(arr[i] / exp) % <span class="hljs-number">10</span>]--;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>      arr[i] = r[i];<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><img src="/article/50722/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" class title="img">
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><img src="/article/50722/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" class title="img">
<h2 id="排序优化：如何实现一个通用的、高性能的排序函数？"><a href="#排序优化：如何实现一个通用的、高性能的排序函数？" class="headerlink" title="排序优化：如何实现一个通用的、高性能的排序函数？"></a>排序优化：如何实现一个通用的、高性能的排序函数？</h2><img src="/article/50722/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg" class title="排序算法总结">
<p>线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p>
<p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n<sup>2</sup>) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。</p>
<h3 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h3><p>qsort() 会<strong>优先使用归并排序</strong>来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序问题不大。</p>
<p>但要排序的数据量比较大的时候，qsort() 会改为用<strong>快速排序算法</strong>来排序。qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的。</p>
<p>实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为<strong>插入排序</strong>，不再继续用递归来做快速排序，<strong>因为在小规模数据面前，O(n<sup>2</sup>) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。</strong></p>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
        <category>数据结构与算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>Java,数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存</title>
    <url>/article/33962.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>语言</category>
        <category>Java</category>
        <category>内存</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：梦开始的地方</title>
    <url>/article/33685.html</url>
    <content><![CDATA[<blockquote>
<p>What language is thine, o sea?</p>
<p>The language of eternal question.</p>
<p>What language is thy answer, o sky?</p>
<p>The language of eternal silence.</p>
</blockquote>
<blockquote>
<p>记性越来越差！能怎么办！</p>
<p>做个博客记录记录吧～</p>
<p>虽然整个java相关都快学完了，但总是觉得看了后面忘了前面，所以决定写个博客，正好感觉之前基础学的感觉不扎实，那就把容易忘记的东西复习一遍吧，准备明年的实习，在实习之前把所有的java相关再来一次～</p>
<p>永不放弃！</p>
</blockquote>
<img src="/article/33685/image-20211210124950047-9111795.png" class="slug">
<h2 id="编译型语言和解释型语言的区别"><a href="#编译型语言和解释型语言的区别" class="headerlink" title="编译型语言和解释型语言的区别"></a>编译型语言和解释型语言的区别</h2><img src="/article/33685/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class="slug">
<h3 id="解释性语言和编译型语言的优缺点"><a href="#解释性语言和编译型语言的优缺点" class="headerlink" title="解释性语言和编译型语言的优缺点"></a><strong>解释性语言和编译型语言</strong>的优缺点</h3><p><a href="https://blog.csdn.net/xwx_100/article/details/83212067">原文链接</a> <a href="本文为CSDN博主「xwx_100」的原创文章，遵循CC4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。">版权声明</a></p>
<p><strong>编译型语言</strong></p>
<ul>
<li>编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%；</li>
<li>编译型程序比解释型程序消耗的内存更少；</li>
<li>不利的一面——编译器比解释器要难写得多；</li>
<li>编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置；</li>
<li>可执行的编译型代码要比相同的解释型代码大许多。例如C/C++的.exe文件要比同样功能的Java的.class文件大很多；</li>
<li>编译型程序是面向特定平台的因而是平台依赖的；</li>
<li>编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的）；</li>
<li>由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。</li>
</ul>
<p><strong>解释型语言</strong></p>
<ul>
<li>解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的；</li>
<li>另一个优势是解释器比编译器容易实现；</li>
<li>解释型语言最大的优势之一是其平台独立性</li>
<li>解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的；</li>
<li>中间语言代码的大小比编译型可执行代码小很多；</li>
<li>平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素；</li>
<li>解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存；</li>
<li>由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多；</li>
<li>解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>类型</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>编译型语言</td>
<td>通过专门的编译器，将所有源代码一次性转换成特定平台（Windows、Linux 等）执行的机器码（以可执行文件的形式存在）。</td>
<td>编译一次后，脱离了编译器也可以运行，并且运行效率高。</td>
<td>可移植性差，不够灵活。</td>
</tr>
<tr>
<td>解释型语言</td>
<td>由专门的解释器，根据需要将部分源代码临时转换成特定平台的机器码。</td>
<td>跨平台性好，通过不同的解释器，将相同的源代码解释成不同平台下的机器码。</td>
<td>一边执行一边转换，效率很低。</td>
</tr>
</tbody>
</table>
<h2 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h2><ol>
<li><p>单行注释</p>
<p>以双斜杠“//”标识，只能注释一行内容，用在注释信息内容少的地方；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这是单行注释</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>多行注释</p>
<p>包含在“/<em>”和“</em>/”之间，能注释很多行的内容。为了可读性比较好，一般首行和尾行不写注释信息（这样也比较美观好看）；</p>
<ul>
<li>多行注释可以嵌套单行注释，但是不能嵌套多行注释和文档注释。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">这是多行注释</span><br><span class="hljs-comment">这里也是</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>文档注释</p>
<p>包含在“/*<em>”和“</em>/”之间，也能注释多行内容，一般用在类、方法和变量上面，用来描述其作用；</p>
<p>注释后，鼠标放在类和变量上面会自动显示出我们注释的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*这是文档注释</span><br><span class="hljs-comment">*<span class="hljs-doctag">@Description</span> HelloWorld</span><br><span class="hljs-comment">*这是有功能的注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Java命名规范"><a href="#Java命名规范" class="headerlink" title="Java命名规范"></a>Java命名规范</h2><ul>
<li><p><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</p>
</li>
<li><p><strong>常量：</strong>大写字母和下划线组成。例如<strong>MAX_VALUE</strong></p>
</li>
<li><p><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong>。</p>
</li>
<li><p><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。例如 <strong>myFirstJavaMethod</strong>。</p>
<p><strong>类成员变量、局部变量</strong>同样遵守这个规则</p>
<p><strong>方法名</strong>不使用连接符,但下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如 <code>testPop_emptyStack</code></p>
</li>
<li><p><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</p>
</li>
<li><p><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</p>
</li>
<li><p><strong>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符：</strong></p>
<ul>
<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>
<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
<li>合法标识符举例：age、$salary、_value、__1_value</li>
<li>非法标识符举例：123abc、-salary</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><a href="https://www.runoob.com/java/java-tutorial.html">部分内容引用菜鸟教程</a></p>
<blockquote>
<p>程序员就要知道CV ， CV完了千万记得理解呀！！！</p>
</blockquote>
<p>Java是一种强类型语言</p>
<ul>
<li>要求变量的使用要严格符合规定，所有变量都必须先定义以后才能使用</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><strong>byte：</strong></p>
<ul>
<li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是 <strong>-128（-2^7）</strong>；</li>
<li>最大值是 <strong>127（2^7-1）</strong>；</li>
<li>默认值是 <strong>0</strong>；</li>
<li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li>
</ul>
<p><strong>short：</strong></p>
<ul>
<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 <strong>-32768（-2^15）</strong>；</li>
<li>最大值是 <strong>32767（2^15 - 1）</strong>；</li>
<li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
<li>默认值是 <strong>0</strong>；</li>
</ul>
<p><strong>int：</strong></p>
<ul>
<li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li>
<li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li>
<li>一般地整型变量默认为 int 类型；</li>
<li>默认值是 <strong>0</strong> ；</li>
</ul>
<p><strong>long：</strong></p>
<ul>
<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li>
<li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是 <strong>0L</strong>；</li>
<li>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li>
</ul>
<p><strong>float：</strong></p>
<ul>
<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
<li>float 在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是 <strong>0.0f</strong>；</li>
<li>浮点数不能用来表示精确的值，如货币；</li>
<li>最好完全避免使用浮点数进行比较；</li>
</ul>
<p><strong>double：</strong></p>
<ul>
<li><p>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；</p>
</li>
<li><p>浮点数的默认类型为 double 类型；</p>
</li>
<li><p>double类型同样不能表示精确的值，如货币；</p>
</li>
<li><p>默认值是 <strong>0.0d</strong>；</p>
</li>
<li><p>最好完全避免使用浮点数进行比较；</p>
</li>
<li><p>例子：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">double</span>   d<span class="hljs-number">1</span>  = <span class="hljs-number">7</span>D ;<br><span class="hljs-attribute">double</span>   d<span class="hljs-number">2</span>  = <span class="hljs-number">7</span>.; <br><span class="hljs-attribute">double</span>   d<span class="hljs-number">3</span>  =  <span class="hljs-number">8</span>.<span class="hljs-number">0</span>; <br><span class="hljs-attribute">double</span>   d<span class="hljs-number">4</span>  =  <span class="hljs-number">8</span>.D; <br><span class="hljs-attribute">double</span>   d<span class="hljs-number">5</span>  =  <span class="hljs-number">12</span>.<span class="hljs-number">9867</span>; <br></code></pre></td></tr></table></figure>
<p>7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。</p>
</li>
</ul>
<p><strong>boolean：</strong></p>
<ul>
<li>boolean数据类型表示一位的信息；</li>
<li>只有两个取值：true 和 false；</li>
<li>这种类型只作为一种标志来记录 true/false 情况；</li>
<li>默认值是 <strong>false</strong>；</li>
</ul>
<p><strong>char：</strong></p>
<ul>
<li>char 类型是一个单一的 16 位 Unicode 字符；</li>
<li>最小值是 <strong>\u0000</strong>（十进制等效值为 0）；</li>
<li>最大值是 <strong>\uffff</strong>（即为 65535）；</li>
<li>char 数据类型可以储存任何字符；</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><strong>自动类型转换：整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">低  ------------------------------------&gt;  高<br><br><span class="hljs-keyword">byte</span>,<span class="hljs-keyword">short</span>,<span class="hljs-keyword">char</span>—&gt; <span class="hljs-keyword">int</span> —&gt; <span class="hljs-keyword">long</span>—&gt; <span class="hljs-keyword">float</span> —&gt; <span class="hljs-keyword">double</span> <br></code></pre></td></tr></table></figure>
<p>数据类型转换必须满足如下规则：</p>
<ul>
<li>不能对boolean类型进行类型转换</li>
<li>不能把对象类型转换成不相关类的对象</li>
<li>在把容量大的类型转换为容量小的类型时必须使用<strong>强制类型转换</strong></li>
<li>转换过程中可能导致溢出或损失精度</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZiDongLeiZhuan</span></span>&#123;<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    		<span class="hljs-keyword">char</span> c1=<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//定义一个char类型</span><br>        <span class="hljs-keyword">int</span> i1 = c1;<span class="hljs-comment">//char自动类型转换为int</span><br>        System.out.println(<span class="hljs-string">&quot;char自动类型转换为int后的值等于&quot;</span>+i1);<br>        <span class="hljs-keyword">char</span> c2 = <span class="hljs-string">&#x27;A&#x27;</span>;<span class="hljs-comment">//定义一个char类型</span><br>        <span class="hljs-keyword">int</span> i2 = c2+<span class="hljs-number">1</span>;<span class="hljs-comment">//char 类型和 int 类型计算</span><br>        System.out.println(<span class="hljs-string">&quot;char类型和int计算后的值等于&quot;</span>+i2);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">char自动类型转换为int后的值等于97</span><br><span class="hljs-comment">char类型和int计算后的值等于66</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>强制类型转换：</strong></p>
<ul>
<li>条件是转换的数据类型必须是兼容的</li>
<li>格式：(type)value type是要强制类型转换后的数据类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QiangZhiZhuanHuan</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">123</span>;<br>        <span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>)i1;<span class="hljs-comment">//强制类型转换为byte</span><br>        System.out.println(<span class="hljs-string">&quot;int强制类型转换为byte后的值等于&quot;</span>+b);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">int强制类型转换为byte后的值等于123</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>隐含强制类型转换：</strong></p>
<ul>
<li>整数的默认类型是 int</li>
<li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f</li>
</ul>
<hr>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul>
<li>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时候被指定为一个特定的类型，声明之后不能改变。</li>
<li>引用数据类型包括：类（对象）、接口、数组</li>
<li>所有引用类型默认值都是null.</li>
<li>一个引用变量可以用于引用任何与之兼容的类型。</li>
</ul>
<img src="/article/33685/%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98.png" class title="引用数据类型内存">
<hr>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上</li>
<li>引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。</li>
</ul>
<h2 id="Java变量类型"><a href="#Java变量类型" class="headerlink" title="Java变量类型"></a>Java变量类型</h2><p><strong>Java语言支持的变量类型有：</strong></p>
<ul>
<li>类变量：独立于方法之外的变量，用 static 修饰。</li>
<li>实例变量：独立于方法之外的变量，不过没有 static 修饰。 </li>
<li>局部变量：类的方法中的变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Variable</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> allClicks=<span class="hljs-number">0</span>;    <span class="hljs-comment">// 类变量</span><br>    String str=<span class="hljs-string">&quot;hello world&quot;</span>;  <span class="hljs-comment">// 实例变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;  <span class="hljs-comment">// 局部变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul>
<li>局部变量声明在方法、构造方法或者语句块中</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，<strong>当它们执行完成后，变量将会被销毁</strong></li>
<li>访问修饰符不能用于局部变量(<strong>default</strong> <strong>private</strong>  <strong>public</strong> <strong>protected</strong>)</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见</li>
<li>局部变量是在<strong>栈</strong>上分配的</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123; <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pupAge</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>;<br>      age = age + <span class="hljs-number">7</span>;<br>      System.out.println(<span class="hljs-string">&quot;小狗的年龄是: &quot;</span> + age);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      Test test = <span class="hljs-keyword">new</span> Test();<br>      test.pupAge();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">小狗的年龄是: 7</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁</li>
<li>实例变量的值应该<strong>至少</strong>被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息</li>
<li>实例变量可以声明在使用前或者使用后</li>
<li>访问修饰符可以修饰实例变量(<strong>default</strong> <strong>private</strong>  <strong>public</strong> <strong>protected</strong>)</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见</li>
<li>实例变量具有默认值。<strong>数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。</strong>变量的值可以在声明时指定，也可以在构造方法中指定</li>
<li><strong>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;<br>   <span class="hljs-comment">// 这个实例变量对子类可见</span><br>   <span class="hljs-keyword">public</span> String name;<br>   <span class="hljs-comment">// 私有变量，仅在该类可见</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<br>   <span class="hljs-comment">//在构造器中对name赋值</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span> <span class="hljs-params">(String empName)</span></span>&#123;<br>      name = empName;<br>   &#125;<br>   <span class="hljs-comment">//设定salary的值</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> empSal)</span></span>&#123;<br>      salary = empSal;<br>   &#125;  <br>   <span class="hljs-comment">// 打印信息</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printEmp</span><span class="hljs-params">()</span></span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;名字 : &quot;</span> + name );<br>      System.out.println(<span class="hljs-string">&quot;薪水 : &quot;</span> + salary);<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>      Employee empOne = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;BOBO&quot;</span>);<br>      empOne.setSalary(<span class="hljs-number">1000.0</span>);<br>      empOne.printEmp();<br>   &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">$ javac Employee.java </span><br><span class="hljs-comment">$ java Employee</span><br><span class="hljs-comment">名字 : BOBO</span><br><span class="hljs-comment">薪水 : 1000.0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p><a href="#静态变量"><code>点击跳转静态变量</code></a></p>
<ul>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外</li>
<li>无论一个类创建了多少个对象，<strong>类只拥有类变量的一份拷贝</strong></li>
<li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li>
<li><strong>静态变量在第一次被访问时创建，在程序结束时销毁</strong></li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型</li>
<li>默认值和实例变量相似。<strong>数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。</strong>变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化</li>
<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问</li>
<li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-comment">//salary是静态的私有变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> salary;<br>    <span class="hljs-comment">// DEPARTMENT是一个常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEPARTMENT = <span class="hljs-string">&quot;开发人员&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    salary = <span class="hljs-number">10000</span>;<br>        System.out.println(DEPARTMENT+<span class="hljs-string">&quot;平均工资:&quot;</span>+salary);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">开发人员平均工资:10000.0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h2 id="Java方法"><a href="#Java方法" class="headerlink" title="Java方法"></a>Java方法</h2><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>
<p>方法的可变参数的声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">typeName... parameterName<br></code></pre></td></tr></table></figure>
<p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p>
<p>一个方法中只能指定一个可变参数，它<strong>必须是方法的最后一个参数</strong>。任何普通的参数必须在它之前声明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VarargsDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-comment">// 调用可变参数的方法</span><br>        printMax(<span class="hljs-number">34</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">56.5</span>);<br>        printMax(<span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMax</span><span class="hljs-params">( <span class="hljs-keyword">double</span>... numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (numbers.length == <span class="hljs-number">0</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;No argument passed&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">double</span> result = numbers[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;  numbers.length; i++)&#123;<br>            <span class="hljs-keyword">if</span> (numbers[i] &gt;  result) &#123;<br>                result = numbers[i];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;The max value is &quot;</span> + result);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">The max value is 56.5</span><br><span class="hljs-comment">The max value is 3.0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>构造方法也称为构造器</li>
<li><strong>当一个对象被创建时候，构造方法用来初始化该对象</strong></li>
<li><strong>构造方法和它所在类的名字相同</strong>，但构造方法没有返回值，也不能写void</li>
<li>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象</li>
<li>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)</li>
<li>一旦你定义了自己的构造方法，默认构造方法就会失效</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个简单的构造函数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> x;<br> <br>  <span class="hljs-comment">// 以下是构造函数</span><br>  MyClass() &#123;<br>    x = <span class="hljs-number">10</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Java-静态类、静态方法和静态变量"><a href="#Java-静态类、静态方法和静态变量" class="headerlink" title="Java 静态类、静态方法和静态变量"></a>Java 静态类、静态方法和静态变量</h2><p><strong>static</strong> 是Java中的一个关键字，我们不能声明普通外层类或者包为静态的</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p><a href="#类变量"><code>点击跳转类变量</code></a></p>
<p>静态变量即类变量，静态变量是属于类的，而不是属于类创建的对象或实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态变量的例子</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String str;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DB_USER = <span class="hljs-string">&quot;myuser&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>类似于静态变量</li>
<li>静态方法也属于类，不属于实例</li>
<li>静态方法只能访问类的静态变量，或调用类的静态方法</li>
<li>通常静态方法作为工具方法，被其它类使用，而不需要创建类的实例</li>
<li>通常java程序的开始就是一个<code>main()</code>方法，它就是个静态方法</li>
<li>静态方法只会在第一次执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态方法的例子</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>)<br>    StaticExample.count = count;<br>&#125;<br><br><span class="hljs-comment">//静态工具方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">addInts</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span>...js)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : js) sum+=x;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="静态块"><a href="#静态块" class="headerlink" title="静态块"></a>静态块</h3><ul>
<li>静态块就是类加载器加载对象时，要执行的一组语句</li>
<li>用于初始化静态变量</li>
<li>通常用于类加载的时候创建静态资源</li>
<li>我们在静态块中不能访问非静态变量</li>
<li>我们可以在一个类中有多个静态块，尽管这么做没什么意义</li>
<li>静态块只会在类加载到内存中的时候执行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br>    <span class="hljs-comment">//在类被加载的时候用于初始化资源</span><br>    System.out.println(<span class="hljs-string">&quot;StaticExample static block&quot;</span>);<br>    <span class="hljs-comment">//仅能访问静态变量和静态方法</span><br>    str=<span class="hljs-string">&quot;Test&quot;</span>;<br>    setCount(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><p><a href="#内部类"><code>点击跳转内部类</code></a></p>
<ul>
<li>我们对嵌套类使用static关键字</li>
<li>static不能用于最外层的类</li>
<li>静态的嵌套类和其它外层的类别无二致，嵌套只是为了方便打包</li>
</ul>
<h3 id="静态导入包"><a href="#静态导入包" class="headerlink" title="静态导入包"></a>静态导入包</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.random;<br></code></pre></td></tr></table></figure>
<p>可以在类中直接使用random方法</p>
<h2 id="Java数组"><a href="#Java数组" class="headerlink" title="Java数组"></a>Java数组</h2><h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><p>数组是<strong>相同类型数据</strong>的<strong>有序集合</strong></p>
<ul>
<li>长度确定，一旦被创建，大小就不可以被改变</li>
<li>其元素必须是相同类型，不允许出现混合类型</li>
<li>数组中的元素可以是任何数据类型</li>
<li>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量</li>
</ul>
<p>初始化数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 首选的方法</span><br>dataType[] arrayRefVar;  <br><span class="hljs-comment">//或</span><br><span class="hljs-comment">// 效果相同，但不是首选方法 </span><br><span class="hljs-comment">// 来自 C/C++ 语言 </span><br>dataType arrayRefVar[];  <br></code></pre></td></tr></table></figure>
<p>初始化多维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接为每一维分配空间</span><br><span class="hljs-comment">//type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数</span><br>type[][] typeName = <span class="hljs-keyword">new</span> type[typeLength1][typeLength2];<br><span class="hljs-comment">//或</span><br><span class="hljs-comment">//为最高维分配引用空间</span><br><span class="hljs-comment">//再为其每个数组元素单独分配空间</span><br>String[][] s = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>][];<br>s[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>];<br>s[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>];<br>s[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Good&quot;</span>);<br>s[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Luck&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;to&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;you&quot;</span>);<br>s[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;!&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>稀疏矩阵（英语：sparse matrix）指的是在数值分析中绝大多数数值为零的矩阵。反之，如果大部分元素都非零，则这个矩阵是稠密的(Dense)。</p>
<img src="/article/33685/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%A8%A0%E5%AF%86%E7%9F%A9%E9%98%B5.png" class title="稀疏矩阵与稠密矩阵">
<blockquote>
<p> 上图中左边就是一个稀疏矩阵，可以看到包含了很多 0 元素，右边是稠密的矩阵，大部分元素不是 0</p>
</blockquote>
<p>转化为稀疏数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] sparseMatrix(<span class="hljs-keyword">int</span>[][] array)&#123;<br>  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; array.length; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; array[i].length)&#123;<br>      <span class="hljs-keyword">if</span>(array[i][j] != <span class="hljs-number">0</span>)<br>        sum++;<br>    &#125;<br>  &#125;<br>  System.out.println(<span class="hljs-string">&quot;有效值的个数：&quot;</span> + sum);<br>  <br>  <span class="hljs-comment">//创建一个稀疏数组</span><br>  <span class="hljs-keyword">int</span>[][] sparse = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>  sparse[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = array.length;<br>  sparse[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = array[<span class="hljs-number">0</span>].length;<br>  sparse[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = sum;<br>  <br>  <span class="hljs-comment">//遍历二维数组，将非零的值，存放数组中</span><br>  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; array.length ; i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; array[<span class="hljs-number">0</span>].length ; j++)&#123;<br>      <span class="hljs-keyword">if</span>(array[i][j] != <span class="hljs-number">0</span>)&#123;<br>        count++;<br>        sparse[count][<span class="hljs-number">0</span>] = i;<br>        sparse[count][<span class="hljs-number">1</span>] = j;<br>        sparse[count][<span class="hljs-number">2</span>] = array[i][j];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sparse;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Java类"><a href="#Java类" class="headerlink" title="Java类"></a>Java类</h2><h3 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Scanner s = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure>
<p>通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据.</p>
<p><strong>next方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner; <br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScannerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">// 从键盘接收数据</span><br> <br>        <span class="hljs-comment">// next方式接收字符串</span><br>        System.out.println(<span class="hljs-string">&quot;next方式接收：&quot;</span>);<br>        <span class="hljs-comment">// 判断是否还有输入</span><br>        <span class="hljs-keyword">if</span> (scan.hasNext()) &#123;<br>            String str1 = scan.next();<br>            System.out.println(<span class="hljs-string">&quot;输入的数据为：&quot;</span> + str1);<br>        &#125;<br>        scan.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">$ javac ScannerDemo.java</span><br><span class="hljs-comment">$ java ScannerDemo</span><br><span class="hljs-comment">next方式接收：</span><br><span class="hljs-comment">bobo com</span><br><span class="hljs-comment">输入的数据为：bobo</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>nextLine 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScannerDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-comment">// 从键盘接收数据</span><br> <br>        <span class="hljs-comment">// nextLine方式接收字符串</span><br>        System.out.println(<span class="hljs-string">&quot;nextLine方式接收：&quot;</span>);<br>        <span class="hljs-comment">// 判断是否还有输入</span><br>        <span class="hljs-keyword">if</span> (scan.hasNextLine()) &#123;<br>            String str2 = scan.nextLine();<br>            System.out.println(<span class="hljs-string">&quot;输入的数据为：&quot;</span> + str2);<br>        &#125;<br>        scan.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">$ javac ScannerDemo.java</span><br><span class="hljs-comment">$ java ScannerDemo</span><br><span class="hljs-comment">nextLine方式接收：</span><br><span class="hljs-comment">bobo com</span><br><span class="hljs-comment">输入的数据为：bobo com</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>next() 与 nextLine() 区别</strong></p>
<p>next():</p>
<ul>
<li>一定要读取到有效字符后才可以结束输入。</li>
<li>对输入有效字符之前遇到的空白，next() 方法会自动将其去。</li>
<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 </li>
<li>next() 不能得到带有空格的字符串。</li>
</ul>
<p>nextLine()： </p>
<ul>
<li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 </li>
<li>可以获得空白。</li>
</ul>
<blockquote>
<p><strong>相较于 hasnext()</strong>，针对int、float等其他基本数据类型，还有scan.hasNextInt()、hasNextFloat()等方法，返回布尔值；</p>
</blockquote>
<blockquote>
<p> <strong>相较于 nextLine()</strong>，针对int、float等其他基本数据类型，还有、scan.nextInt()、scan.nextFloat()等方法，返回输出类型值；</p>
</blockquote>
<h3 id="Java-Arrays-类"><a href="#Java-Arrays-类" class="headerlink" title="Java Arrays 类"></a>Java Arrays 类</h3><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法 ,将指定的值分配给数组的每个元素</li>
<li>对数组排序：通过 sort 方法,按升序</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p>
<p><strong>成员内部类</strong></p>
<p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">double</span> radius = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.radius = radius;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Draw</span> </span>&#123;     <span class="hljs-comment">//内部类</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawSahpe</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;drawshape&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以<strong>无条件访问外部类的所有成员属性和成员方法</strong>（包括private成员和静态成员）。</p>
<hr>
<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">外部类.<span class="hljs-keyword">this</span>.成员变量<br>外部类.<span class="hljs-keyword">this</span>.成员方法<br></code></pre></td></tr></table></figure>
<hr>
<p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.radius = radius;<br>        getDrawInstance().drawSahpe();   <span class="hljs-comment">//必须先创建成员内部类的对象，再进行访问</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Draw <span class="hljs-title">getDrawInstance</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//创建成员内部类的对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Draw();<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Draw</span> </span>&#123;     <span class="hljs-comment">//内部类</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawSahpe</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(radius);  <span class="hljs-comment">//外部类的private成员</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        <span class="hljs-comment">//第一种方式：</span><br>        Outter outter = <span class="hljs-keyword">new</span> Outter();<br>        Outter.Inner inner = outter.<span class="hljs-function">new <span class="hljs-title">Inner</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//必须通过Outter对象来创建</span><br>         <br>        <span class="hljs-comment">//第二种方式：</span><br>        Outter.Inner inner1 = outter.getInnerInstance();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Inner inner = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Outter</span><span class="hljs-params">()</span> </span>&#123;<br>         <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Inner <span class="hljs-title">getInnerInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(inner == <span class="hljs-keyword">null</span>)<br>            inner = <span class="hljs-keyword">new</span> Inner();<br>        <span class="hljs-keyword">return</span> inner;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Inner</span><span class="hljs-params">()</span> </span>&#123;    <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。</p>
<hr>
<p><strong>局部内部类</strong></p>
<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">People</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Man</span><span class="hljs-params">()</span></span>&#123;    <br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> People <span class="hljs-title">getWoman</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">People</span></span>&#123;   <span class="hljs-comment">//局部内部类</span><br>            <span class="hljs-keyword">int</span> age =<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Woman();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意</strong>: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p>
<hr>
<p><strong>匿名内部类</strong></p>
<p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。</p>
<p>下面是一段匿名内部类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面这段代码是一段 Android 事件监听代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">scan_bt.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;);<br> <br>history_bt.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>     <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>这就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。</p>
<hr>
<p><strong>静态内部类</strong></p>
<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</p>
<p>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        Outter.Inner inner = <span class="hljs-keyword">new</span> Outter.Inner();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Outter</span><span class="hljs-params">()</span> </span>&#123;<br>         <br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Inner</span><span class="hljs-params">()</span> </span>&#123;<br>             <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p><strong>静态内部类与内部类的区别</strong></p>
<p><strong>内部类</strong></p>
<ul>
<li>内部类拥有普通类的所有特性，也拥有类成员变量的特性 </li>
<li>内部类可以访问其外部类的成员变量，属性，方法，其它内部类</li>
</ul>
<p><strong>静态内部类</strong></p>
<ul>
<li>只有内部类才能声明为static，也可以说是静态内部类 </li>
<li>只有静态内部类才能拥有静态成员，普通内部类只能定义普通成员 </li>
<li>静态类跟静态方法一样，只能访问其外部类的静态成员 </li>
<li>如果在外部类的静态方法中访问内部类，这时候只能访问静态内部类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 外部类，不能声明为 static</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ab = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sab = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 普通内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NormalInnerClass</span> </span>&#123;<br>        <span class="hljs-comment">// private static int age = 22;</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">22</span>; <span class="hljs-comment">// 不能声明为static</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NormalInnerClass</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// 可以访问外部类静态与非静态成员</span><br>            System.out.println(ab);<br>            System.out.println(sab);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 静态内部类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> </span>&#123;<br>        <span class="hljs-comment">// 定义静态与非静态成员都是可以的</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> age = <span class="hljs-number">22</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age2 = <span class="hljs-number">22</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">echo</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">// System.out.println(ab);</span><br>            System.out.println(sab);<span class="hljs-comment">// 只能访问外部类的静态成员</span><br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>
<hr>
<p><strong>练习</strong></p>
<p>1.根据注释填写(1)，(2)，(3)处的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>           <span class="hljs-comment">// 初始化Bean1</span><br>           (<span class="hljs-number">1</span>)<br>           bean1.I++;<br>           <span class="hljs-comment">// 初始化Bean2</span><br>           (<span class="hljs-number">2</span>)<br>           bean2.J++;<br>           <span class="hljs-comment">//初始化Bean3</span><br>           (<span class="hljs-number">3</span>)<br>           bean3.k++;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bean1</span></span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> I = <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bean2</span></span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> J = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bean</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bean3</span></span>&#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>
<p>创建静态内部类对象的一般形式为：<code>外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</code></p>
<p>创建成员内部类对象的一般形式为： <code>外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</code></p>
<p>因此，（1），（2），（3）处的代码分别为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Test test = <span class="hljs-keyword">new</span> Test();    <br>Test.Bean1 bean1 = test.n<span class="hljs-function">ew <span class="hljs-title">Bean1</span><span class="hljs-params">()</span></span>;<br>---------------------------------------<br>Test.Bean2 b2 = <span class="hljs-keyword">new</span> Test.Bean2();<br>Bean bean = <span class="hljs-keyword">new</span> Bean();     <br>---------------------------------------<br>Bean.Bean3 bean3 =  bean.n<span class="hljs-function">ew <span class="hljs-title">Bean3</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<p>2.下面这段代码的输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        Outter outter = <span class="hljs-keyword">new</span> Outter();<br>        outter.n<span class="hljs-function">ew <span class="hljs-title">Inner</span><span class="hljs-params">()</span>.<span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;<br> <br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outter</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">2</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br>            System.out.println(<span class="hljs-string">&quot;局部变量：&quot;</span> + a);<br>            System.out.println(<span class="hljs-string">&quot;内部类变量：&quot;</span> + <span class="hljs-keyword">this</span>.a);<br>            System.out.println(<span class="hljs-string">&quot;外部类变量：&quot;</span> + Outter.<span class="hljs-keyword">this</span>.a);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">局部变量：3</span><br><span class="hljs-comment">内部类变量：2</span><br><span class="hljs-comment">外部类变量：1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<hr>
<p>关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>
<ul>
<li>成员内部类的引用方式必须为 Outter.Inner </li>
<li>构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WithInner</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<br>         <br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritInner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WithInner</span>.<span class="hljs-title">Inner</span> </span>&#123;<br>      <br>    <span class="hljs-comment">// InheritInner() 是不能通过编译的，一定要加上形参</span><br>    InheritInner(WithInner wi) &#123;<br>        wi.<span class="hljs-keyword">super</span>(); <span class="hljs-comment">//必须有这句调用</span><br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        WithInner wi = <span class="hljs-keyword">new</span> WithInner();<br>        InheritInner obj = <span class="hljs-keyword">new</span> InheritInner(wi);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样</p>
</li>
<li><p>抽象方法必须在抽象类中</p>
<ul>
<li><p>如果一个类包含抽象方法，那么该类必须是抽象类</p>
</li>
<li><p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类</p>
</li>
</ul>
</li>
<li><p>由于抽象类不能实例化对象，所以<strong>抽象类必须被继承</strong>，才能被使用</p>
</li>
<li><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法</p>
</li>
<li><p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而<strong>一个类却可以实现多个<a href="#接口"><code>接口</code></a></strong>,接口可以多继承</p>
</li>
<li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p>
</li>
<li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能</p>
</li>
<li><p><strong>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</strong></p>
</li>
<li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</p>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>普通类：只有具体实现</li>
<li>抽象类：具体实现和规范（抽象方法）都有</li>
<li>接口：只有规范！</li>
</ul>
<ol>
<li>是抽象方法的集合，接口通常以interface来声明；</li>
<li>一个类通过继承接口的方式，从而来继承接口的抽象方法；</li>
<li>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法；</li>
<li>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法；</li>
<li>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类；</li>
<li>在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或<strong>是被绑定在一个以此接口实现的对象</strong>。</li>
</ol>
<p><strong>接口与类相似点</strong></p>
<ul>
<li>一个接口可以有多个方法；</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名；</li>
<li>接口的字节码文件保存在 .class 结尾的文件中；</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<p><strong>接口与类的区别</strong></p>
<ul>
<li>接口不能用于实例化对象；</li>
<li>接口没有构造方法；</li>
<li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法；</li>
<li>接口不能包含成员变量，除了 static 和 final 变量；</li>
<li>接口不是被类继承了，而是要被类实现；</li>
<li>接口支持多继承。</li>
</ul>
<p><strong>接口特性</strong></p>
<ul>
<li>接口与接口中的每一个方法都是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）；</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）；</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法；</li>
<li>接口中的方法都是公有的。</li>
</ul>
<p><strong>抽象类和接口的区别</strong></p>
<ul>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的；</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名称 [<span class="hljs-keyword">extends</span> 其他的接口名] </span>&#123;<br>  <span class="hljs-comment">// 声明变量</span><br>  <span class="hljs-comment">// 抽象方法</span><br>&#125;<br><br>...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...<br></code></pre></td></tr></table></figure>
<p><strong>重写接口中声明的方法时，需要注意以下规则</strong></p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常；</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型；</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法；</li>
</ul>
<p><strong>在实现接口的时候，也要注意一些规则</strong></p>
<ul>
<li>一个类可以同时实现多个接口；</li>
<li>一个类只能继承一个类，但是能实现多个接口；</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<p><strong>标记接口</strong></p>
<ul>
<li>最常用的继承接口是没有包含任何方法的接口；</li>
<li>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情；</li>
<li>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</li>
</ul>
<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EventListener</span></span><br><span class="hljs-class"></span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>
<ul>
<li><p>建立一个公共的父接口：</p>
<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li><p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>
</li>
</ul>
<h2 id="值传递-引用传递"><a href="#值传递-引用传递" class="headerlink" title="值传递-引用传递"></a>值传递-引用传递</h2><p><strong>值传递</strong></p>
<p>实参传递给形参的是值 形参和实参在内存上是两个<strong>独立</strong>的变量,对<strong>形参做任何修改不会影响实参</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> b =<span class="hljs-number">20</span>;<br>        change(b);<span class="hljs-comment">// 实参 实际上的参数</span><br>        System.out.println(b);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<span class="hljs-comment">//形参 形式上的参数</span><br>        a=<span class="hljs-number">100</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>引用传递</strong></p>
<p>实参传递给形参的是参数对于堆内存上的引用地址，实参和形参在内存上指向了同一块区域，对<strong>形参的修改会影响实参</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> [] a=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        System.out.println(a[<span class="hljs-number">0</span>]);<br>        change(a);<br>        System.out.println(a[<span class="hljs-number">0</span>]);<br>    &#125;<br>   <span class="hljs-comment">//实参和形参在内存上指向了同一块区域</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a )</span></span>&#123;<br>        a[<span class="hljs-number">0</span>]=<span class="hljs-number">100</span>;  <span class="hljs-comment">//形参的修改会影响实参</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote>
<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法;</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制;</p>
</blockquote>
<p><strong>优点</strong></p>
<ul>
<li>良好的封装能够减少耦合；</li>
<li>类内部的结构可以自由修改；</li>
<li>可以对成员变量进行更精确的控制；</li>
<li>隐藏信息，实现细节。</li>
</ul>
<p><strong>实现步骤</strong></p>
<ol>
<li>修改属性的可见性来限制对属性的访问（一般限制为private）</li>
<li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问（get、set方法）</li>
<li>采用 <strong>this</strong> 关键字是为了解决实例变量和局部变量之间发生的同名的冲突</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类;</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类的继承格式</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> 父类 </span>&#123;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> 子类 <span class="hljs-keyword">extends</span> 父类 </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/article/33685/java-extends.png" class title="java-extends">
<p><strong>特性</strong></p>
<ul>
<li>子类拥有父类<strong>非 private </strong>的属性、方法；</li>
<li>final修饰的类，不能被继承；</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展；</li>
<li>子类可以用自己的方式实现父类的方法；</li>
<li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li>
<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li>
</ul>
<p><strong>关键字</strong></p>
<p><strong>super 与 this 关键字</strong></p>
<p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类</p>
<p>this关键字：指向自己的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;animal : eat&quot;</span>);<br>  &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;dog : eat&quot;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eatTest</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.eat();   <span class="hljs-comment">// this 调用自己的方法</span><br>    <span class="hljs-keyword">super</span>.eat();  <span class="hljs-comment">// super 调用父类方法</span><br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Animal a = <span class="hljs-keyword">new</span> Animal();<br>    a.eat();<br>    Dog d = <span class="hljs-keyword">new</span> Dog();<br>    d.eatTest();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果为：</span><br><span class="hljs-comment">animal : eat</span><br><span class="hljs-comment">dog : eat</span><br><span class="hljs-comment">animal : eat</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<ul>
<li>super调用父类的构造方法，必须在构造方法的第一个</li>
<li>super必须只能出现在子类的方法或者构造方法中</li>
<li>super和this不能同时调用构造方法</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote>
<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作.</p>
</blockquote>
<p><strong>注意</strong></p>
<ul>
<li>对象能执行哪些方法，主要看左边的类型，和右边关系不大</li>
<li>父类可以指向子类，但是不能调用子类<strong>独有</strong>的方法</li>
<li></li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ul>
<p><strong>多态存在的三个必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写 <a href="#Java重写与重载"><code>点击跳转重写与重载</code></a></li>
<li>父类引用指向子类对象：<strong>Parent p = new Child();</strong></li>
</ul>
<img src="/article/33685/Java%E5%A4%9A%E6%80%81.jpg" class title="Java多态">
<p><em>简单的多态实例</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      show(<span class="hljs-keyword">new</span> Cat());  <span class="hljs-comment">// 以 Cat 对象调用 show 方法</span><br>      show(<span class="hljs-keyword">new</span> Dog());  <span class="hljs-comment">// 以 Dog 对象调用 show 方法</span><br>                <br>      Animal a = <span class="hljs-keyword">new</span> Cat();  <span class="hljs-comment">// 向上转型  </span><br>      a.eat();               <span class="hljs-comment">// 调用的是 Cat 的 eat</span><br>      Cat c = (Cat)a;        <span class="hljs-comment">// 向下转型  </span><br>      c.work();        <span class="hljs-comment">// 调用的是 Cat 的 work</span><br>  &#125;  <br>            <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Animal a)</span>  </span>&#123;<br>      a.eat();  <br>        <span class="hljs-comment">// 类型判断</span><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Cat)  &#123;  <span class="hljs-comment">// 猫做的事情 </span><br>            Cat c = (Cat)a;  <br>            c.work();  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> Dog) &#123; <span class="hljs-comment">// 狗做的事情 </span><br>            Dog c = (Dog)a;  <br>            c.work();  <br>        &#125;  <br>    &#125;  <br>&#125;<br> <br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;  <br>&#125;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;看家&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>稍微复杂的多态</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> String address;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, String address, <span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;Employee 构造函数&quot;</span>);<br>      <span class="hljs-keyword">this</span>.name = name;<br>      <span class="hljs-keyword">this</span>.address = address;<br>      <span class="hljs-keyword">this</span>.number = number;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailCheck</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;邮寄支票给： &quot;</span> + <span class="hljs-keyword">this</span>.name<br>       + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-keyword">this</span>.address);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot; &quot;</span> + address + <span class="hljs-string">&quot; &quot;</span> + number;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> name;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> address;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String newAddress)</span> </span>&#123;<br>      address = newAddress;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> number;<br>   &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Salary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span><br><span class="hljs-class"></span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary; <span class="hljs-comment">// 全年工资</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Salary</span><span class="hljs-params">(String name, String address, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">double</span> salary)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>(name, address, number);<br>       setSalary(salary);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailCheck</span><span class="hljs-params">()</span> </span>&#123;<br>       System.out.println(<span class="hljs-string">&quot;Salary 类的 mailCheck 方法 &quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;邮寄支票给：&quot;</span> + getName()<br>       + <span class="hljs-string">&quot; ，工资为：&quot;</span> + salary);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> salary;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> newSalary)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(newSalary &gt;= <span class="hljs-number">0.0</span>) &#123;<br>          salary = newSalary;<br>       &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">computePay</span><span class="hljs-params">()</span> </span>&#123;<br>      System.out.println(<span class="hljs-string">&quot;计算工资，付给：&quot;</span> + getName());<br>      <span class="hljs-keyword">return</span> salary/<span class="hljs-number">52</span>;<br>   &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualDemo</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String [] args)</span> </span>&#123;<br>      Salary s = <span class="hljs-keyword">new</span> Salary(<span class="hljs-string">&quot;员工 A&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3600.00</span>);<br>      Employee e = <span class="hljs-keyword">new</span> Salary(<span class="hljs-string">&quot;员工 B&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2400.00</span>);<br>      System.out.println(<span class="hljs-string">&quot;使用 Salary 的引用调用 mailCheck -- &quot;</span>);<br>      s.mailCheck();<br>      System.out.println(<span class="hljs-string">&quot;\n使用 Employee 的引用调用 mailCheck--&quot;</span>);<br>      e.mailCheck();<br>    &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Employee 构造函数</span><br><span class="hljs-comment">Employee 构造函数</span><br><span class="hljs-comment">使用 Salary 的引用调用 mailCheck -- </span><br><span class="hljs-comment">Salary 类的 mailCheck 方法 </span><br><span class="hljs-comment">邮寄支票给：员工 A ，工资为：3600.0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">使用 Employee 的引用调用 mailCheck--</span><br><span class="hljs-comment">Salary 类的 mailCheck 方法 </span><br><span class="hljs-comment">邮寄支票给：员工 B ，工资为：2400.0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>理解：</p>
<ol>
<li>主函数初始化<code>new Salary</code>时，因为继承关系，所以执行父类构造方法，初始化两次，执行了两次</li>
<li><code>s.mailCheck();</code>正常调用类Salary中的方法</li>
<li><code>e.mailCheck();</code> 父类的引用指向了子类的对象，因为类Salary重写了父类的方法，所以，调用类Salary中的方法</li>
</ol>
<h2 id="Java重写与重载"><a href="#Java重写与重载" class="headerlink" title="Java重写与重载"></a>Java重写与重载</h2><h2 id="⚠️⚠️⚠️注意细节⚠️⚠️⚠️"><a href="#⚠️⚠️⚠️注意细节⚠️⚠️⚠️" class="headerlink" title="⚠️⚠️⚠️注意细节⚠️⚠️⚠️"></a>⚠️⚠️⚠️注意细节⚠️⚠️⚠️</h2><h3 id="类中方法加载顺序"><a href="#类中方法加载顺序" class="headerlink" title="类中方法加载顺序"></a>类中方法加载顺序</h3><p>静态代码块——匿名代码块——构造方法</p>
<h3 id="字符输出问题"><a href="#字符输出问题" class="headerlink" title="字符输出问题"></a>字符输出问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZiDongLeiZhuan</span></span>&#123;<br>		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    		<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<br>      	<span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;<br>      	System.out.println(<span class="hljs-string">&quot;&quot;</span> + a + b);<br>      	System.out.println(a + b + <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">1020</span><br><span class="hljs-comment">30</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>如果<code>&quot;&quot;</code>在前 则字符串拼接！如果<code>&quot;&quot;</code>在后 则为数学相加！</p>
<h3 id="关于调用静态方法与非静态方法的区别"><a href="#关于调用静态方法与非静态方法的区别" class="headerlink" title="关于调用静态方法与非静态方法的区别"></a><strong>关于调用静态方法与非静态方法的区别</strong></h3><p><strong>例子</strong>：注意看 输出是不同的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主启动类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <span class="hljs-comment">//调用静态方法时 方法的调用只和  左边  定义的数据类型有关</span><br>    A a = <span class="hljs-keyword">new</span> A();<br>    a.test();<br>    <span class="hljs-comment">//父类的引用指向了子类</span><br>    B b = <span class="hljs-keyword">new</span> A();  <span class="hljs-comment">//子类重写了父类的方法  只和非静态方法有关</span><br>    b.test()<br>  &#125;<br>&#125;  <br><br>---非静态方法---<br><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;B=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;A=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">A=&gt;test()</span><br><span class="hljs-comment">A=&gt;test()</span><br><span class="hljs-comment">*/</span><br>---静态方法---<br><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;B=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;A=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">A=&gt;test()</span><br><span class="hljs-comment">B=&gt;test()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><strong>理解</strong>：</p>
<p>静态方法属于类的方法，非静态方法属于对象的方法</p>
<p>调用静态方法时，b调用了B类的方法，因为b是B类定义的，只和 <code>**左边**</code>  定义的数据类型有关</p>
<p>调用非静态方法时，b调用的是对象的方法，而b这个对象是用A类new的，所以调用A的方法</p>
<h3 id="Java程序初始化顺序"><a href="#Java程序初始化顺序" class="headerlink" title="Java程序初始化顺序"></a>Java程序初始化顺序</h3><ol>
<li>父类的静态变量</li>
<li>父类的静态代码块</li>
<li>子类的静态变量</li>
<li>子类的静态代码块</li>
<li>父类的非静态变量</li>
<li>父类的非静态代码块</li>
<li>父类的构造方法</li>
<li>子类的非静态变量</li>
<li>子类的非静态代码块</li>
<li>子类的构造方法</li>
</ol>
]]></content>
      <categories>
        <category>语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/article/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo clean &amp;&amp; hexo server<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
