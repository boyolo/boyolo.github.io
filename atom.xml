<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Boyolo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://boyolo.github.io/"/>
  <updated>2024-04-10T14:32:25.913Z</updated>
  <id>https://boyolo.github.io/</id>
  
  <author>
    <name>bobo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARM</title>
    <link href="https://boyolo.github.io/article/16813.html"/>
    <id>https://boyolo.github.io/article/16813.html</id>
    <published>2024-04-10T14:32:00.000Z</published>
    <updated>2024-04-10T14:32:25.913Z</updated>
    
    <content type="html"><![CDATA[<p>1111</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1111&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://boyolo.github.io/article/33708.html"/>
    <id>https://boyolo.github.io/article/33708.html</id>
    <published>2022-08-18T01:40:38.000Z</published>
    <updated>2024-04-10T14:20:53.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。</p><p><strong>AMQP</strong>（Advanced Message Queuing Protocol）高级消息队列协议，一个提供统一消息服务的应用层标准协议，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP是一个进程间传递异步消息的网络协议。</p><img src="/article/33708/AMQP%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90.png" class title="AMQP核心组成"><blockquote><p><strong>Producer(生产者)</strong>:生产消息</p><p><strong>ConnectionFactory(连接工厂)</strong>:生产Connection的的工厂</p><p><strong>Connection(连接)</strong>:连接，应用程序与Broker的网络连接TCP/IP/三次握手和四次挥手。</p><p>AMQP连接通常是长连接。AMQP是一个使用 TCP提供可靠投递的应用层协议。AMQP 使用认证机制并且提供 TLS（SSL）保护。当一个应用不再需要连接到 AMQP 代理的时候，需要优雅的释放掉 AMQP 连接，而不是直接将 TCP 连接关闭。</p><p><strong>Channel(信道)</strong>:网络信道，是建立在Connection连接之上的一种轻量级的连接。几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立多各Channel，每个Channel代表一个会话任务。</p><p>大部分的业务操作是在Channel这个接口中完成的，包括:</p><p>队列的声明queueDeclare<br>交换机的声明exchangeDeclare<br>队列的绑定queueBind<br>发布消息basicPublish<br>消费消息basicConsume等。<br>Broker(中间件)</p><p><strong>VirtualHost(虚拟主机)</strong>:虚拟主机，用于进行逻辑隔离，一个虚拟主机理由可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名字的Exchange。</p><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP 提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟 Web servers虚拟主机概念非常相似，这为 AMQP 实体提供了完全隔离的环境。当连接被建立的时候，AMQP 客户端来指定使用哪个虚拟主机。</p><p><strong>Exchange(交换机)</strong>:交换机，接受消息，根据路由键发送消息到绑定的队列（不具备消息存储的能力）。</p><p>交换机是用来发送消息的 AMQP 实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和绑定（Bindings）规则所决定的。</p><p><strong>Consumer(消费者)</strong>:消费者消费消息。在AMQP中，消费者获取待消费消息的途径有两种：</p><ul><li>消息中间件将消息投递给消费者（push API）</li><li>消费者主动获取消息 (pull API)</li></ul><p><strong>需要注意：多个消费者监听同一个队列时，队列中的消息只会被其中一个消费者消费（并不会每个消费者都消费一次）</strong></p><p><strong>Message(消息)</strong>:消息，服务与应用程序之间传送的数据，由Properties（属性）和body（主体）组成。属性是对消息进行修饰，比如消息的优先级，延迟等高级特性，主体则就是消息体的内容。</p></blockquote><p>优点：</p><ol><li>应用耦合</li><li>异步处理</li><li>流量削峰</li></ol><h3 id="RabbitMQ优势"><a href="#RabbitMQ优势" class="headerlink" title="RabbitMQ优势"></a><strong>RabbitMQ优势</strong></h3><ol><li>基于AMQP协议</li><li>高并发（是一个容量的概念，服务器可以接受的最大任务数量）</li><li>高性能（是一个速度的概念，单位时间内服务器可以处理的任务数）</li><li>高可用（是一个持久的概念，单位时间内服务器可以正常工作的时间比例）</li><li>强大的社区支持</li><li>支持插件</li><li>支持多语言</li></ol><h3 id="RabbitMQ界面"><a href="#RabbitMQ界面" class="headerlink" title="RabbitMQ界面"></a><strong>RabbitMQ界面</strong></h3><ol><li><p>概要</p><img src="/article/33708/%E6%A6%82%E8%A6%81.png" class title="概要"></li><li><p>连接</p><img src="/article/33708/%E8%BF%9E%E6%8E%A5.png" class title="连接"></li><li><p>通道</p><img src="/article/33708/%E9%80%9A%E9%81%93.png" class title="通道"><ol><li>一个连接可以创建多个通道</li><li>一个应用或者一个线程，都是一个通道</li><li>在通道中创建队列，生产者的通道一般立马关闭，消费者是一只在监听，通道一直存在</li></ol></li><li><p>交换机</p><img src="/article/33708/%E4%BA%A4%E6%8D%A2%E6%9C%BA.png" class title="交换机"><p>| Type              | 解释                                                         |<br>| —————– | ———————————————————— |<br>| direct            | 它会把消息路由到那些 binding key 与 routing key 完全匹配的 Queue 中 |<br>| fanout            | 它会把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中 |<br>| headers           | headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。（headers 类型的交换器性能差，不实用，基本不会使用。） |<br>| topic             | 与direct模型相比，多了个可以使用通配符                       |<br>| x-delayed-message | 延迟交换机，可以延迟接收消息                                 |</p><p>| <strong>Features</strong> | <strong>解释</strong>                                                     |<br>| ———— | ———————————————————— |<br>| D            | d 是 durable 的缩写，代表这个队列中的消息支持持久化          |<br>| AD           | ad 是 autoDelete 的缩写。代表当前队列的最后一个消费者退订时被自动删除。注意：此时不管队列中是否还存在消息，队列都会删除。 |<br>| excl         | 是 exclusive 的缩写。代表这是一个排他队列。如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。这里需要注意三点：其一，排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一个连接创建的排他队列的。其二，“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同。其三，即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的。这种队列适用于只限于一个客户端发送读取消息的应用场景。 |<br>| Args         | 是 arguments 的缩写。代表该队列配置了 arguments 参数。       |<br>| TTL          | 是 x-message-ttl 的缩写。设置队列中的所有消息的生存周期(统一为整个队列的所有消息设置生命周期), 也可以在发布消息的时候单独为某个消息指定剩余生存时间，单位毫秒。 |<br>| Exp          | Auto Expire，是 x-expires 配置的缩写。当队列在指定的时间没有被访问(consume, basicGet, queueDeclare…)就会被删除，Features=Exp。注意这里是删除队列，不是队列中的消息。 |<br>| Lim          | 说明该队列配置了 x-max-length。限定队列的消息的最大值长度，超过指定长度将会把最早的几条删除掉。 |<br>| Lim B        | 说明队列配置了 x-max-length-bytes。限定队列最大占用的空间大小， 一般受限于内存、磁盘的大小。 |<br>| DLX          | 说明该队列配置了 x-dead-letter-exchange。当队列消息长度大于最大长度、或者过期的等，将从队列中删除的消息推送到指定的交换机中去而不是丢弃掉。 |<br>| DLK          | x-dead-letter-routing-key 的缩写，将删除的消息推送到指定交换机的指定路由键的队列中去。 |<br>| Pri          | x-max-priority 的缩写，优先级队列。表明该队列支持优先级，先定义最大优先级值(定义最大值一般不要太大)，在发布消息的时候指定该消息的优先级， 优先级更高（数值更大的）的消息先被消费。 |<br>| Ovfl         | x-overflow 的缩写。队列中的消息溢出时，如何处理这些消息。要么丢弃队列头部的消息，要么拒绝接收后面生产者发送过来的所有消息。有两个配置项：drop-head，代表丢弃队列头部的消息，默认行为；reject-publish 设置队列中的消息溢出后,该队列的行为:”拒绝接收”(所有消息)。 |<br>| ha-all       | 镜像队列。all 表示镜像到集群上的所有节点，ha-params 参数忽略。 |</p></li></ol><h3 id="七大示例"><a href="#七大示例" class="headerlink" title="七大示例"></a>七大示例</h3><ol><li><p>Hello World</p></li><li><p>工作队列</p><p>假如一共20条消息，A处理时间1s，B处理时间2s</p><ol><li><p>轮询</p><p>A，B同时拿到各自的10条消息，然后再处理，所以A经过10s处理完，B要经过20s才能处理完</p></li><li><p>公平</p><p>A和B不能直接拿到所有消息，设置<strong>int prefetchCount = 1</strong>表示消费者每次只能接收一条消息，只有处理完这条消息，才能处理下一条</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicQos(prefetchCount);<br></code></pre></td></tr></table></figure></li></ol></li></ol><pre><code>这样A处理的快，所以A可以不断从信道中得到消息，B处理的比A慢，间隔2s才可以获得一条消息**没有资源浪费**</code></pre><ol start="3"><li><p>发布订阅（使用交换机，使用广播模式<strong>fanout</strong>）</p><ol><li>生产者绑定交换机，将消息发送至交换机</li><li>交换机生成<strong>排他队列</strong>，然后将交换机与队列进行绑定</li><li>消费者监听对应队列的消息</li></ol><p>交换机将消息转发至队列，消费者可以收到生产发布的消息。 </p></li><li><p>路由队列（使用交换机，使用路由模式<strong>direct</strong>）</p><ol><li>生产者绑定交换机，并且定义不同的<strong>routingKey</strong>，生产者将携带不同<strong>routingKey</strong>的消息发送至交换机</li><li>交换机生成<strong>排他队列</strong>，同时将队列与交换机进行绑定，此时不同的队列绑定不同的<strong>routingKey</strong></li><li>消费者监听对应队列的消息</li></ol><p>交换机将携带不同的<strong>routingKey</strong>的消息转发至对应<strong>routingKey</strong>的队列，消费者可以收到生产发布的消息</p></li><li><p>主题队列（使用交换机，使用主题模式<strong>topic</strong>）</p><p>* 匹配一个字符串</p><p># 匹配0个或多个</p><p><strong>队列和交换机绑定才可以使用通配符，发送消息时必须使用具体的路由名称</strong></p></li><li><p>PRC模式</p><p>客户端同时是生产者和消费者，服务端者同时是生产者和消费者</p><p>客户端发送请求携带 <strong>reply_to</strong> 表示服务端收到消息后转发的队列名 以及 <strong>correlation_id</strong> 表示该消息的唯一id</p></li></ol><h3 id="RabbitMQ消息的事务机制"><a href="#RabbitMQ消息的事务机制" class="headerlink" title="RabbitMQ消息的事务机制"></a>RabbitMQ消息的事务机制</h3><ol><li>通过AMQP事务机制实现；</li><li>通过将channel设置成confirm模式来实现</li></ol><p><strong>两种事务控制形式不能同时开启</strong></p><h4 id="通过AMQP事务机制实现"><a href="#通过AMQP事务机制实现" class="headerlink" title="通过AMQP事务机制实现"></a>通过AMQP事务机制实现</h4><ol><li>txSelect() 将当前channel设置成transaction模式，即开启事务</li><li>txCommit() 提交事务</li><li>txRollback() 回滚事务</li></ol><p>在通过 txSelect() 开启事务之后，便可以发布消息给 broker 代理服务器了，如果 txCommit() 提交成功了，则消息一定到达了 broker 了,如果在 txCommit() 执行之前 broker 异常崩溃或者由于其他原因抛出异常，这个时候便可以捕获异常通过 txRollback() 回滚事务。</p><p><strong>缺点：降低RabbitMQ的性能</strong></p><h4 id="confirm确认模式"><a href="#confirm确认模式" class="headerlink" title="confirm确认模式"></a>confirm确认模式</h4><p>生产者将信道设置成 <strong>confirm</strong> 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个<strong>唯一的ID(从1开始)</strong>，<strong>一旦消息被投递到所有匹配的队列之后</strong>，broker 就会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了；</p><p>如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basicAck 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm模式最大的好处在于它是可以 异步 的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><p>在 channel 被设置成 confirm 模式之后，所有被 publish 的后续消息都将被 confirm（即 ack）或者 nack 一次，但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm 又被 nack。</p><p><strong>实现方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 开启确认发布</span><br>channel.confirmSelect();<br></code></pre></td></tr></table></figure><ol><li><p>普通 confirm 模式</p><p>这是一种简单的确认方式，它是一种 <strong>同步</strong> 确认发布的方式，也就是发布一个消息之后，只有收到了确认发布，后续的消息才能继续发布，waitForConfirms() 这个方法在消息被确认的时候返回true，如果在指定时间范围内，这个消息没有被确认那么它将返回false。</p><p>waitForConfirmsOrDie() 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内，这个消息没有被确认那么它将抛出异常。</p><p>这种确认方式有一个最大的缺点就是：发布速度特别的慢，因为如果没有收到确认发布的消息，就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。</p></li><li><p>批量 confirm 模式</p><p>先发布一批消息，然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：<strong>当发生故障导致发布出现问题时，不知道是哪个消息出现问题了</strong>，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是 同步的，也一样阻塞消息的发布。</p></li><li><p>异步 confirm 模式</p><p>channel 利用回调函数 ConfirmListener() 来达到消息可靠性传递的，这个回调函数只包含 deliveryTag(当前Channel发出的消息序号) ，需要自己手动维护一个 unconfirm 的消息序号集合，每发布一条消息，集合中元素+1 ， 每回调一次 <code>handleAck</code> 方法，unconfirm集合删除相应的一条或多条记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//信道添加监听回调函数</span><br>channel.addConfirmListener(<span class="hljs-keyword">new</span> ConfirmListener()&#123;<br>  <span class="hljs-comment">//重写 handleAck 回调方法</span><br>  <span class="hljs-comment">//deliveryTag 消息发送序号</span><br>  <span class="hljs-comment">//multiple 是否是多条</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleAck</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deliveryTag , <span class="hljs-keyword">boolean</span> multiple)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>    处理逻辑<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h2 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h2><p>Spring AMQP 是对 Spring 基于 AMQP 的消息收发解决方案，它是一个抽象层，不依赖于特定的 AMQP Broker 实现和客户端的抽象，所以可以很方便地替换。</p><h2 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h2><p><strong>邮箱中开启SMTP服务</strong></p><blockquote><p><strong>依赖</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;<br>  &lt;dependency&gt;<br> &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">2.6</span><span class="hljs-number">.4</span>&lt;/version&gt;<br>  &lt;/dependency&gt;<br>  &lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">2.6</span><span class="hljs-number">.0</span>&lt;/version&gt;<br>  &lt;/dependency&gt;<br>  &lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">2.6</span><span class="hljs-number">.4</span>&lt;/version&gt;<br>  &lt;/dependency&gt;<br>  &lt;dependency&gt;<br>  &lt;groupId&gt;com.boyolo&lt;/groupId&gt;<br>  &lt;artifactId&gt;yeb-server&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">0.0</span><span class="hljs-number">.1</span>-SNAPSHOT&lt;/version&gt;<br>  &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>application.yml</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java">server:<br>  #端口<br>  port: <span class="hljs-number">8082</span><br>spring:<br>  #邮件配置<br>  mail:<br>    #邮件服务器地址<br>    host: smtp<span class="hljs-number">.163</span>.com<br>    #协议<br>    protocol: smtp<br>    #编码格式<br>    <span class="hljs-keyword">default</span>-encoding: utf-<span class="hljs-number">8</span><br>    #授权码（在邮箱开通服务时获取）<br>    password: NBFXNQFSTKVDEBTN<br>    #发送者邮箱地址<br>    username: beau_renbo@<span class="hljs-number">163.</span>com<br>    #端口（不同邮箱端口号不同）<br>    port: <span class="hljs-number">25</span><br><br>  #rabbitmq配置<br>  rabbitmq:<br>    #用户名<br>    username: guest<br>    #密码<br>    password: guest<br>    #服务器地址<br>    host: localhost<br>    #端口<br>    port: <span class="hljs-number">5672</span><br>    listener:<br>      simple:<br>        #开启手动确认<br>        acknowledge-mode: manual<br><br>  redis:<br>    #超时时间<br>    timeout: 10000ms<br>    #服务器地址<br>    host: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>    #服务器端口<br>    port: <span class="hljs-number">6379</span><br>    #数据库<br>    database: <span class="hljs-number">0</span><br>    password: buzhidao<br>    lettuce:<br>      pool:<br>        #最大连接数<br>        max-active: <span class="hljs-number">1024</span><br>        #最大连接阻塞等待时间<br>        max-wait: 10000ms<br>        #最大空闲连接<br>        max-idle: <span class="hljs-number">200</span><br>        #最小空闲连接<br>        min-idle: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>设置邮件发送常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.pojo;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailConstants</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息投递中</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer DELIVERING = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息投递成功</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer SUCCESS = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息投递失败</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer FAILURE = <span class="hljs-number">2</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最大尝试次数</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer MAX_TRY_COUNT = <span class="hljs-number">3</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息超时时间</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer MSG_TIMEOUT = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对列</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAIL_QUEUE_NAME = <span class="hljs-string">&quot;mail.queue&quot;</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换机</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAIL_EXCHANGE_NAME = <span class="hljs-string">&quot;mail.exchange&quot;</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 路由键</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MAIL_ROUTING_KEY_NAME = <span class="hljs-string">&quot;mail.routing.key&quot;</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>邮件接收</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.mail;<br><br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.Employee;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.MailConstants;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.amqp.support.AmqpHeaders;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.mail.MailProperties;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.HashOperations;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.mail.javamail.JavaMailSender;<br><span class="hljs-keyword">import</span> org.springframework.mail.javamail.MimeMessageHelper;<br><span class="hljs-keyword">import</span> org.springframework.messaging.Message;<br><span class="hljs-keyword">import</span> org.springframework.messaging.MessageHeaders;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.thymeleaf.TemplateEngine;<br><span class="hljs-keyword">import</span> org.thymeleaf.context.Context;<br><span class="hljs-keyword">import</span> javax.mail.internet.MimeMessage;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailReceiver</span> </span>&#123;<br>  <span class="hljs-comment">//日志</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MailReceiver.class);<br><br>  <span class="hljs-comment">//邮件发送</span><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> JavaMailSender javaMailSender;<br>  <span class="hljs-comment">//邮件配置</span><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> MailProperties mailProperties;<br>  <span class="hljs-comment">//模版引擎 负责把对象数据呈现成文本数据</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  1. 指令简单 - 内置不超过10个常用的指令.</span><br><span class="hljs-comment">2. 基于XPath - 直接使用XPath查找对象,并且可以使用XPath强大的语法和函数.</span><br><span class="hljs-comment">3. 容易扩展 - 无论是指令还是XPath函数都可以自定义.</span><br><span class="hljs-comment">4. 解析超快 - 基于其语法特点,解析模板结构非常快.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> TemplateEngine templateEngine;<br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>  <span class="hljs-meta">@RabbitListener(queues = MailConstants.MAIL_QUEUE_NAME)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Message message, Channel channel)</span> </span>&#123;<br>    Employee employee = (Employee) message.getPayload();<br>    MessageHeaders headers = message.getHeaders();<br>    <span class="hljs-comment">//消息序号</span><br>    <span class="hljs-keyword">long</span> tag = (<span class="hljs-keyword">long</span>) headers.get(AmqpHeaders.DELIVERY_TAG);<br>    String msgId = (String) headers.get(<span class="hljs-string">&quot;spring_returned_message_correlation&quot;</span>);<br>    HashOperations hashOperations = redisTemplate.opsForHash();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (hashOperations.entries(<span class="hljs-string">&quot;mail_log&quot;</span>).containsKey(msgId)) &#123;<br>        LOGGER.error(<span class="hljs-string">&quot;消息已经被消费==========&gt;&#123;&#125;&quot;</span>, msgId);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 手动确认消息</span><br><span class="hljs-comment">                 * tag：消息序号</span><br><span class="hljs-comment">                 * multiple:是否确认多条</span><br><span class="hljs-comment">                 */</span><br>        channel.basicAck(tag, <span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <br>      MimeMessage msg = javaMailSender.createMimeMessage();<br>      MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(msg);<br>      <span class="hljs-comment">//发件人</span><br>      helper.setFrom(mailProperties.getUsername());<br>      <span class="hljs-comment">//收件人</span><br>      helper.setTo(employee.getEmail());<br>      <span class="hljs-comment">//主题</span><br>      helper.setSubject(<span class="hljs-string">&quot;入职欢迎邮件&quot;</span>);<br>      <span class="hljs-comment">//发送日期</span><br>      helper.setSentDate(<span class="hljs-keyword">new</span> Date());<br>      <br>      <span class="hljs-comment">//邮件内容</span><br>      Context context = <span class="hljs-keyword">new</span> Context();<br>      context.setVariable(<span class="hljs-string">&quot;name&quot;</span>, employee.getName());<br>      context.setVariable(<span class="hljs-string">&quot;posName&quot;</span>, employee.getPosition().getName());<br>      context.setVariable(<span class="hljs-string">&quot;jobLevelName&quot;</span>, employee.getJoblevel().getName());<br>      context.setVariable(<span class="hljs-string">&quot;departmentName&quot;</span>, employee.getDepartment().getName());<br><br>      String mail = templateEngine.process(<span class="hljs-string">&quot;mail&quot;</span>, context);<br>      helper.setText(mail, <span class="hljs-keyword">true</span>);<br><br>      javaMailSender.send(msg);<br>      LOGGER.info(<span class="hljs-string">&quot;邮件发送成功&quot;</span>);<br>      <span class="hljs-comment">//将消息Id存入redis</span><br>      hashOperations.put(<span class="hljs-string">&quot;mail_log&quot;</span>, msgId, <span class="hljs-string">&quot;OK&quot;</span>);<br>      <span class="hljs-comment">//手动确认消息</span><br>      channel.basicAck(tag, <span class="hljs-keyword">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 手动确认消息</span><br><span class="hljs-comment">                 * tag：消息序号</span><br><span class="hljs-comment">                 * multiple:是否确认多条</span><br><span class="hljs-comment">                 * requeue:是否退回队列</span><br><span class="hljs-comment">                 */</span><br>        channel.basicNack(tag, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (IOException ioException) &#123;<br>        LOGGER.error(<span class="hljs-string">&quot;邮件发送失败========&gt;&#123;&#125;&quot;</span>, e.getMessage());<br>      &#125;<br>      LOGGER.error(<span class="hljs-string">&quot;邮件发送失败========&gt;&#123;&#125;&quot;</span>, e.getMessage());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>EmployeeServiceImpl.java</strong> 添加员工发送消息时消息可靠性–消息落库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == employeeMapper.insert(employee)) &#123;<br><br>  Employee emp = employeeMapper.getEmployee(employee.getId()).get(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">//数据库记录发送的消息</span><br>  String msgId = UUID.randomUUID().toString();<br>  <span class="hljs-comment">//            String msgId = &quot;123456&quot;;</span><br>  MailLog mailLog = <span class="hljs-keyword">new</span> MailLog();<br>  mailLog.setMsgId(msgId);<br>  mailLog.setEid(employee.getId());<br>  mailLog.setStatus(<span class="hljs-number">0</span>);<br>  mailLog.setRouteKey(MailConstants.MAIL_ROUTING_KEY_NAME);<br>  mailLog.setExchange(MailConstants.MAIL_EXCHANGE_NAME);<br>  mailLog.setCount(<span class="hljs-number">0</span>);<br>  mailLog.setTryTime(LocalDateTime.now().plusMinutes(MailConstants.MSG_TIMEOUT));<br>  mailLog.setCreateTime(LocalDateTime.now());<br>  mailLog.setUpdateTime(LocalDateTime.now());<br>  mailLogMapper.insert(mailLog);<br><br>  <span class="hljs-comment">//发送信息</span><br>  rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME, MailConstants.MAIL_ROUTING_KEY_NAME, emp, <span class="hljs-keyword">new</span> CorrelationData(msgId));<br><br>  <span class="hljs-keyword">return</span> RespBean.success(<span class="hljs-string">&quot;添加成功！&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote><blockquote><p>RabbitMQ配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.config;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.MailConstants;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.MailLog;<br><span class="hljs-keyword">import</span> com.boyolo.server.service.IMailLogService;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Binding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.BindingBuilder;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.DirectExchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.connection.CachingConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RabbitMq 配置类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMqConfig</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(RabbitMqConfig.class);<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> CachingConnectionFactory cachingConnectionFactory;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> IMailLogService mailLogService;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> RabbitTemplate <span class="hljs-title">rabbitTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>    RabbitTemplate rabbitTemplate = <span class="hljs-keyword">new</span> RabbitTemplate(cachingConnectionFactory);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消息确认回调，确认消息是否到达broker</span><br><span class="hljs-comment">         * data:消息唯一标识</span><br><span class="hljs-comment">         * ack：确认结果</span><br><span class="hljs-comment">         * cause：失败原因</span><br><span class="hljs-comment">         */</span><br>    rabbitTemplate.setConfirmCallback((data, ack, cause) -&gt; &#123;<br>      String msgId = data.getId();<br>      <span class="hljs-keyword">if</span> (ack) &#123;<br>        LOGGER.info(<span class="hljs-string">&quot;&#123;&#125;========&gt;消息发送成功&quot;</span>, msgId);<br>        mailLogService.update(<span class="hljs-keyword">new</span> UpdateWrapper&lt;MailLog&gt;().set(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">1</span>).eq(<span class="hljs-string">&quot;msgID&quot;</span>, msgId));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        LOGGER.error(<span class="hljs-string">&quot;&#123;&#125;========&gt;消息发送失败&quot;</span>, msgId);<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消息失败回调  比如route不到queue</span><br><span class="hljs-comment">         * smg：消息主题</span><br><span class="hljs-comment">         * repCode：响应码</span><br><span class="hljs-comment">         * repTExt：响应，描述</span><br><span class="hljs-comment">         * exchange：交换机</span><br><span class="hljs-comment">         * routingkey：路由键</span><br><span class="hljs-comment">         */</span><br><br>    <span class="hljs-comment">//        rabbitTemplate.setReturnCallback((msg, repCode, repText, exchange, routingkey)</span><br>    rabbitTemplate.setReturnsCallback((msg) -&gt; &#123;<br>      LOGGER.error(<span class="hljs-string">&quot;&#123;&#125;========&gt;消息发送queue时失败&quot;</span>,msg.getMessage().getBody());<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> rabbitTemplate;<br>  &#125;<br><br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(MailConstants.MAIL_QUEUE_NAME);<br>  &#125;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(MailConstants.MAIL_EXCHANGE_NAME);<br>  &#125;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">binding</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> BindingBuilder.bind(queue()).to(directExchange()).with(MailConstants.MAIL_ROUTING_KEY_NAME);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>邮件发送定时任务–失败重传</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.task;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.Employee;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.MailConstants;<br><span class="hljs-keyword">import</span> com.boyolo.server.pojo.MailLog;<br><span class="hljs-keyword">import</span> com.boyolo.server.service.IEmployeeService;<br><span class="hljs-keyword">import</span> com.boyolo.server.service.IMailLogService;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Scheduled;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 邮件发送定时任务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailTask</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> IMailLogService mailLogService;<br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> IEmployeeService employeeService;<br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 邮件发送定时任务</span><br><span class="hljs-comment">     * 10s一次</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-meta">@Scheduled(cron = &quot;0/10 * * * * ?&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailTask</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;MailLog&gt; list = mailLogService.list(<span class="hljs-keyword">new</span> QueryWrapper&lt;MailLog&gt;().eq(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">0</span>).lt(<span class="hljs-string">&quot;tryTime&quot;</span>, LocalDateTime.now()));<br>    list.forEach(mailLog -&gt; &#123;<br>      <span class="hljs-comment">//如果重试次数超过三次，更新状态为投递失败，不再重试</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">3</span> &lt;= mailLog.getCount())&#123;<br>        mailLogService.update(<span class="hljs-keyword">new</span> UpdateWrapper&lt;MailLog&gt;().set(<span class="hljs-string">&quot;status&quot;</span>,<span class="hljs-number">2</span>).eq(<span class="hljs-string">&quot;msgId&quot;</span>,mailLog.getMsgId()));<br>      &#125;<br>      mailLogService.update(<span class="hljs-keyword">new</span> UpdateWrapper&lt;MailLog&gt;().set(<span class="hljs-string">&quot;count&quot;</span>,mailLog.getCount()+<span class="hljs-number">1</span>).set(<span class="hljs-string">&quot;updateTime&quot;</span>,LocalDateTime.now()).set(<span class="hljs-string">&quot;tryTime&quot;</span>,LocalDateTime.now().plusMinutes(MailConstants.MSG_TIMEOUT)).eq(<span class="hljs-string">&quot;msgId&quot;</span>,mailLog.getMsgId()));<br>      Employee employee = employeeService.getEmployee(mailLog.getEid()).get(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">//重新发送消息</span><br>      rabbitTemplate.convertAndSend(MailConstants.MAIL_EXCHANGE_NAME,MailConstants.MAIL_ROUTING_KEY_NAME,employee,<span class="hljs-keyword">new</span> CorrelationData(mailLog.getMsgId()));<br><br>    &#125;);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><h2 id="RabbitMQ消息可靠性"><a href="#RabbitMQ消息可靠性" class="headerlink" title="RabbitMQ消息可靠性"></a>RabbitMQ消息可靠性</h2><p>保证消息百分百发送到消息队列中去</p><ul><li>保证mq节点成功接受消息</li><li>消息发送端需要接受到mq服务端接受到消息的确认应答</li><li>完善的消息补偿机制，发送失败的消息可以再感知并⼆次处理</li></ul><img src="/article/33708/%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%8F%AF%E8%83%BD%E7%9A%84%E6%83%85%E5%86%B5.png" class title="消息丢失可能的情况"><ol><li><p>确保生产者发送的消息被rabbitmq接收了；</p><p><a href="#RabbitMQ消息的事务机制">RabbitMQ事务</a></p></li><li><p>确保队列中的消息能够持久化；</p><ol><li><p>创建 queue 的时候将其设置为持久化</p><p>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</p></li><li><p>第二个是发送消息的时候将消息的 deliveryMode 设置为 2</p><p>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</p></li></ol><p><strong>必须要同时设置这两个持久化才行</strong></p></li><li><p>确保消费者已经把消息处理完了。</p><p>RabbitMQ提供了<strong>消息确认机制</strong></p><p>消费者在订阅队列时，可以指定autoAck参数，</p><ol><li><p>当autoAck等于false时，RabbitMQ 会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。</p></li><li><p>当autoAck等于true时，RabbitMQ会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正的消费到了这些消息。</p></li><li><p>RabbitMQ不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开，这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;是实现了高级消息队列协议（AMQP）的开源
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="https://boyolo.github.io/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="https://boyolo.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Spring集成谷歌验证码</title>
    <link href="https://boyolo.github.io/article/54334.html"/>
    <id>https://boyolo.github.io/article/54334.html</id>
    <published>2022-08-14T02:18:30.000Z</published>
    <updated>2024-04-10T14:20:53.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- google kaptcha依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.axet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kaptcha<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>配置类 CaptchaConfig.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.config;<br><br><span class="hljs-keyword">import</span> com.google.code.kaptcha.impl.DefaultKaptcha;<br><span class="hljs-keyword">import</span> com.google.code.kaptcha.util.Config;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaptchaConfig</span> </span>&#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultKaptcha <span class="hljs-title">defaultKaptcha</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//验证码生成器</span><br>    DefaultKaptcha defaultKaptcha = <span class="hljs-keyword">new</span> DefaultKaptcha();<br>    <span class="hljs-comment">//配置</span><br>    Properties properties = <span class="hljs-keyword">new</span> Properties();<br>    <span class="hljs-comment">//是否有边框</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.border&quot;</span>, <span class="hljs-string">&quot;yes&quot;</span>);<br>    <span class="hljs-comment">//设置边框颜色</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.border.color&quot;</span>, <span class="hljs-string">&quot;105,179,90&quot;</span>);<br>    <span class="hljs-comment">//边框粗细度，默认为1</span><br>    <span class="hljs-comment">// properties.setProperty(&quot;kaptcha.border.thickness&quot;,&quot;1&quot;);</span><br>    <span class="hljs-comment">//验证码</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.session.key&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>);<br>    <span class="hljs-comment">//验证码文本字符颜色 默认为黑色</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.color&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>);<br>    <span class="hljs-comment">//设置字体样式</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.names&quot;</span>, <span class="hljs-string">&quot;宋体,楷体,微软雅黑&quot;</span>);<br>    <span class="hljs-comment">//字体大小，默认40</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.font.size&quot;</span>, <span class="hljs-string">&quot;30&quot;</span>);<br>    <span class="hljs-comment">//验证码文本字符内容范围 默认为abced2345678gfynmnpwx</span><br>    <span class="hljs-comment">// properties.setProperty(&quot;kaptcha.textproducer.char.string&quot;, &quot;&quot;);</span><br>    <span class="hljs-comment">//字符长度，默认为5</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.char.length&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);<br>    <span class="hljs-comment">//字符间距 默认为2</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.textproducer.char.space&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);<br>    <span class="hljs-comment">//验证码图片宽度 默认为200</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.image.width&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>    <span class="hljs-comment">//验证码图片高度 默认为40</span><br>    properties.setProperty(<span class="hljs-string">&quot;kaptcha.image.height&quot;</span>, <span class="hljs-string">&quot;40&quot;</span>);<br>    Config config = <span class="hljs-keyword">new</span> Config(properties);<br>    defaultKaptcha.setConfig(config);<br>    <span class="hljs-keyword">return</span> defaultKaptcha;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>CaptchaController</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.controller;<br><span class="hljs-keyword">import</span> com.google.code.kaptcha.impl.DefaultKaptcha;<br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiOperation;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> javax.imageio.ImageIO;<br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaptchaController</span> </span>&#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> DefaultKaptcha defaultKaptcha;<br><br>  <span class="hljs-meta">@ApiOperation(value = &quot;验证码&quot;)</span><br>  <span class="hljs-meta">@GetMapping(value = &quot;/captcha&quot;, produces = &quot;image/jpeg&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">captcha</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    <span class="hljs-comment">// 定义response输出类型为image/jpeg类型</span><br>    response.setDateHeader(<span class="hljs-string">&quot;Expires&quot;</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// Set standard HTTP/1.1 no-cache headers.</span><br>    response.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-store, no-cache, must-revalidate&quot;</span>);<br>    <span class="hljs-comment">// Set IE extended HTTP/1.1 no-cache headers (use addHeader).</span><br>    response.addHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;post-check=0, pre-check=0&quot;</span>);<br>    <span class="hljs-comment">// Set standard HTTP/1.0 no-cache header.</span><br>    response.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);<br>    <span class="hljs-comment">// return a jpeg</span><br>    response.setContentType(<span class="hljs-string">&quot;image/jpeg&quot;</span>);<br>    <span class="hljs-comment">//-------------------生成验证码 begin ------------------------</span><br>    <span class="hljs-comment">//获取验证码文本内容</span><br>    String text = defaultKaptcha.createText();<br>    System.out.println(<span class="hljs-string">&quot;验证码内容：&quot;</span> + text);<br>    <span class="hljs-comment">//将验证码放入session中</span><br>    request.getSession().setAttribute(<span class="hljs-string">&quot;captcha&quot;</span>, text);<br>    <span class="hljs-comment">//根据文本内容创建图形验证码</span><br>    BufferedImage image = defaultKaptcha.createImage(text);<br>    ServletOutputStream outputStream = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      outputStream = response.getOutputStream();<br>      <span class="hljs-comment">//输出流输出图片，格式jpg</span><br>      ImageIO.write(image, <span class="hljs-string">&quot;jpg&quot;</span>, outputStream);<br>      outputStream.flush();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != outputStream) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          outputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//-------------------生成验证码 end --------------------------</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;添加依赖&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
      <category term="Java" scheme="https://boyolo.github.io/categories/Java/"/>
    
      <category term="验证码" scheme="https://boyolo.github.io/categories/Java/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
    
      <category term="Java,Spring,验证码" scheme="https://boyolo.github.io/tags/Java-Spring-%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>位图</title>
    <link href="https://boyolo.github.io/article/9386.html"/>
    <id>https://boyolo.github.io/article/9386.html</id>
    <published>2022-06-09T07:48:52.000Z</published>
    <updated>2022-07-11T13:10:18.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>位图是通过将数组下标与应用中的一些值关联映射，数组中该下标所指定的位置上的元素可以用来标识应用中值的情况（是否存在或者数目 或者计数等），位图数组中每个元素在内存中占用1位，所以可以节省存储空间。位图是一种非常简洁快速的数据结构，它能同时使存储空间和速度最优化。</p><blockquote><p>有 1 千万个整数，整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？</p></blockquote><blockquote><p>可以使用一种比较“特殊”的散列表，那就是位图。</p><p>申请一个大小为 1 亿、数据类型为布尔类型（true 或者 false）的数组。<br>将这 1 千万个整数作为数组下标，将对应的数组值设置成 true。比如，整数 5 对应下标为 5 的数组值设置为 true，也就是 array[5]=true。</p><p>查询某个整数 K 是否在这 1 千万个整数中的时候，只需要将对应的数组值 array[K]取出来，看是否等于 true。如果等于 true，那说明 1 千万整数中包含这个整数 K；相反，就表示不包含这个整数 K。</p></blockquote><p>很多语言中提供的布尔类型，大小是 1 个字节的，并不能节省太多内存空间。实际上，表示 true 和 false 两个值，只需要用一个二进制位（bit）就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BitMap</span> </span>&#123; <span class="hljs-comment">// Java中char类型占16bit，也即是2个字节</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] bytes;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> nbits;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BitMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nbits)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.nbits = nbits;<br>    <span class="hljs-keyword">this</span>.bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[nbits/<span class="hljs-number">16</span>+<span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k &gt; nbits) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> byteIndex = k / <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">int</span> bitIndex = k % <span class="hljs-number">16</span>;<br>    bytes[byteIndex] |= (<span class="hljs-number">1</span> &lt;&lt; bitIndex);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k &gt; nbits) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> byteIndex = k / <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">int</span> bitIndex = k % <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (bytes[byteIndex] &amp; (<span class="hljs-number">1</span> &lt;&lt; bitIndex)) != <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>散列表是存储已有数据，而位图存储的是范围</p><blockquote><p>比如有1、1000、1000000 ，散列表只需要存储三次，而位图首先需要1000000位才可以存储</p><p><strong>问题：</strong></p><p>如果数字的范围很大，数字范围不是 1 到 1 亿，而是 1 到 10 亿，那位图的大小就是 10 亿个二进制位，消耗内存就很大</p><p><strong>解决方法：布隆过滤器</strong></p></blockquote><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>对位图这种数据结构的一种改进</p><blockquote><p>数据个数是 1 千万，数据的范围是 1 到 10 亿</p><p><strong>布隆过滤器</strong>的做法是，仍然使用一个 1 亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这 1 到 1 亿范围内。</p><p>比如把哈希函数设计成 f(x)=x%n。其中，x 表示数字，n 表示位图的大小（1 亿），也就是，对数字跟位图的大小进行取模求余。</p><p><strong>问题：</strong>哈希函数会存在冲突</p></blockquote><p>一个哈希函数可能会存在冲突，用多个哈希函数一块儿定位一个数据</p><p><strong>布隆过滤器</strong></p><ol><li>使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值分别记作 X<sub>1</sub>，X<sub>2</sub>，X<sub>3</sub>，…，X<sub>k</sub></li><li>把这 K 个数字作为位图中的下标，将对应的 BitMap[X<sub>1</sub>]，BitMap[X<sub>2</sub>]，BitMap[X<sub>3</sub>]，…，BitMap[X<sub>k</sub>]都设置成 true</li><li>用 K 个二进制位，来表示一个数字的存在。当查询某个数字是否存在的时候，用同样的 K 个哈希函数，对这个数字求哈希值，分别得到 Y<sub>1</sub>，Y<sub>2</sub>，Y<sub>3</sub>，…，Y<sub>k</sub>。</li><li>看这 K 个哈希值，对应位图中的数值是否都为 true，如果都是 true，则说明，这个数字存在，如果有其中任意一个不为 true，那就说明这个数字不存在。</li></ol><blockquote><p><strong>问题：容易误判</strong></p><img src="/article/9386/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AF%E5%88%A4%E6%83%85%E5%86%B5.jpg" class title="布隆过滤器误判情况"></blockquote><p>尽管布隆过滤器会存在误判，但是，这并不影响它发挥大作用。</p><blockquote><p><strong>布隆过滤器与散列表</strong></p><p>布隆过滤器用多个哈希函数对同一个网页链接进行处理，CPU 只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是 CPU 密集型的。而在散列表的处理方式中，需要读取散列值相同（散列冲突）的多个网页链接，分别跟待判重的网页链接，进行字符串匹配。这个操作涉及很多内存数据的读取，所以是内存密集型的。</p><p>CPU 计算可能是要比内存访问更快速的，所以，理论上讲，布隆过滤器的判重方式，更加快速。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;位图&quot;&gt;&lt;a href=&quot;#位图&quot; class=&quot;headerlink&quot; title=&quot;位图&quot;&gt;&lt;/a&gt;位图&lt;/h2&gt;&lt;p&gt;位图是通过将数组下标与应用中的一些值关联映射，数组中该下标所指定的位置上的元素可以用来标识应用中值的情况（是否存在或者数目 或者计数等），位
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="位图" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%8D%E5%9B%BE/"/>
    
    
      <category term="数据结构与算法,位图" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BD%8D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://boyolo.github.io/article/55046.html"/>
    <id>https://boyolo.github.io/article/55046.html</id>
    <published>2022-05-31T01:55:14.000Z</published>
    <updated>2022-07-31T12:22:04.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划比较适合用来求解最优问题</p><p>动态规划解决问题的思路:</p><p>把问题分解为多个阶段，每个阶段对应一个决策。记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。</p><h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><blockquote><p>对于一组不同重量、不可分割的物品，需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？</p></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回溯算法实现。注意：我把输入的变量都定义成了成员变量。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">// 结果放到maxW中</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] weight = &#123;<span class="hljs-number">2</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 物品重量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// 物品个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">9</span>; <span class="hljs-comment">// 背包承受的最大重量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw)</span> </span>&#123; <span class="hljs-comment">// 调用f(0, 0)</span><br>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w表示装满了，i==n表示物品都考察完了</span><br>    <span class="hljs-keyword">if</span> (cw &gt; maxW) maxW = cw;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  f(i+<span class="hljs-number">1</span>, cw); <span class="hljs-comment">// 选择不装第i个物品</span><br>  <span class="hljs-keyword">if</span> (cw + weight[i] &lt;= w) &#123;<br>    f(i+<span class="hljs-number">1</span>,cw + weight[i]); <span class="hljs-comment">// 选择装第i个物品</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article/55046/%E5%9B%9E%E6%BA%AF%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.jpg" class title="回溯求解过程"><p>递归树中的每个节点表示一种状态，用（i, cw）来表示。其中，i （从0开始）表示将要决策第几个物品是否装入背包，cw 表示当前背包中物品的总重量。比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。</p><p>有些子问题的求解是重复的，记录已经计算好的 f(i, cw)，当再次计算到重复的 f(i, cw) 的时候，可以直接从备忘录中取出来用，就不用再递归计算了，这样就可以避免冗余计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">// 结果放到maxW中</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] weight = &#123;<span class="hljs-number">2</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 物品重量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// 物品个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">9</span>; <span class="hljs-comment">// 背包承受的最大重量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[][] mem = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">5</span>][<span class="hljs-number">10</span>]; <span class="hljs-comment">// 备忘录，默认值false</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw)</span> </span>&#123; <span class="hljs-comment">// 调用f(0, 0)</span><br>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w表示装满了，i==n表示物品都考察完了</span><br>    <span class="hljs-keyword">if</span> (cw &gt; maxW) maxW = cw;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (mem[i][cw]) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 重复状态</span><br>  mem[i][cw] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 记录(i, cw)这个状态</span><br>  f(i+<span class="hljs-number">1</span>, cw); <span class="hljs-comment">// 选择不装第i个物品</span><br>  <span class="hljs-keyword">if</span> (cw + weight[i] &lt;= w) &#123;<br>    f(i+<span class="hljs-number">1</span>,cw + weight[i]); <span class="hljs-comment">// 选择装第i个物品</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>动态规划</strong></p><p>把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。</p><p>把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量），就成功避免了每层状态个数的指数级增长。</p><p>用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。</p><blockquote><p>第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态。</p><p>第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。用 states[1][0]=true，states[1][2]=true，states[1][4]=true 来表示这三种状态。</p><p>以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。图中 0 表示 false，1 表示 true。只需要在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。</p><img src="/article/55046/0-1%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E5%9B%BE1.jpg" class title="0-1背包动态规划状态图1"><img src="/article/55046/0-1%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E5%9B%BE2.jpg" class title="0-1背包动态规划状态图2"></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//weight:物品重量，n:物品个数，w:背包可承载重量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] weight, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>  <span class="hljs-keyword">boolean</span>[][] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][w+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 默认值false</span><br>  states[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span><br>  <span class="hljs-keyword">if</span> (weight[<span class="hljs-number">0</span>] &lt;= w) &#123;<br>    states[<span class="hljs-number">0</span>][weight[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 动态规划状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w; ++j) &#123;<span class="hljs-comment">// 不把第i个物品放入背包</span><br>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j] == <span class="hljs-keyword">true</span>) states[i][j] = states[i-<span class="hljs-number">1</span>][j];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w-weight[i]; ++j) &#123;<span class="hljs-comment">//把第i个物品放入背包</span><br>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j]==<span class="hljs-keyword">true</span>) states[i][j+weight[i]] = <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = w; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (states[n-<span class="hljs-number">1</span>][i] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span> i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度:耗时最多的部分就是代码中的两层 for 循环，所以时间复杂度是 <strong>O(n*w)</strong>。n 表示物品个数，w 表示背包可以承载的总重量。</p><p><strong>动态规划优化</strong></p><p>需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。需要一个大小为 w+1 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] items, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>  <span class="hljs-keyword">boolean</span>[] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[w+<span class="hljs-number">1</span>]; <span class="hljs-comment">// 默认值false</span><br>  states[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;  <span class="hljs-comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span><br>  <span class="hljs-keyword">if</span> (items[<span class="hljs-number">0</span>] &lt;= w) &#123;<br>    states[items[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 动态规划</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = w-items[i]; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<span class="hljs-comment">//把第i个物品放入背包</span><br>      <span class="hljs-keyword">if</span> (states[j]==<span class="hljs-keyword">true</span>) states[j+items[i]] = <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = w; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">if</span> (states[i] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span> i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="0-1-背包问题升级版"><a href="#0-1-背包问题升级版" class="headerlink" title="0-1 背包问题升级版"></a>0-1 背包问题升级版</h3><p>引入物品价值这一变量</p><blockquote><p>对于一组不同重量、不同价值、不可分割的物品，选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p></blockquote><blockquote><p><strong>回溯算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxV = Integer.MIN_VALUE; <span class="hljs-comment">// 结果放到maxV中</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] items = &#123;<span class="hljs-number">2</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 物品的重量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] value = &#123;<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">8</span>，<span class="hljs-number">9</span>，<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">// 物品的价值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>; <span class="hljs-comment">// 物品个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> w = <span class="hljs-number">9</span>; <span class="hljs-comment">// 背包承受的最大重量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw, <span class="hljs-keyword">int</span> cv)</span> </span>&#123; <span class="hljs-comment">// 调用f(0, 0, 0)</span><br>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w表示装满了，i==n表示物品都考察完了</span><br>    <span class="hljs-keyword">if</span> (cv &gt; maxV) maxV = cv;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  f(i+<span class="hljs-number">1</span>, cw, cv); <span class="hljs-comment">// 选择不装第i个物品</span><br>  <span class="hljs-keyword">if</span> (cw + weight[i] &lt;= w) &#123;<br>    f(i+<span class="hljs-number">1</span>,cw+weight[i], cv+value[i]); <span class="hljs-comment">// 选择装第i个物品</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article/55046/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8D%87%E7%BA%A7%E7%89%88%E5%9B%9E%E6%BA%AF%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="背包问题升级版回溯递归树"><p>在递归树中，每个节点表示一个状态。现在需要 3 个变量（i, cw, cv）来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值。</p><p>在递归树中，有几个节点的 i 和 cw 是完全相同的，比如 f(2,2,4) 和 f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。</p><p><strong>对于 (i, cw) 相同的不同状态，只需要保留 cv 值最大的那个，继续递归处理，其他状态不予考虑。</strong></p></blockquote><p><strong>动态规划</strong></p><p>把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。</p><p>用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] weight, <span class="hljs-keyword">int</span>[] value, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[][] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][w+<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 初始化states</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; w+<span class="hljs-number">1</span>; ++j) &#123;<br>      states[i][j] = -<span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  states[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (weight[<span class="hljs-number">0</span>] &lt;= w) &#123;<br>    states[<span class="hljs-number">0</span>][weight[<span class="hljs-number">0</span>]] = value[<span class="hljs-number">0</span>];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">//动态规划，状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w; ++j) &#123; <span class="hljs-comment">// 不选择第i个物品</span><br>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j] &gt;= <span class="hljs-number">0</span>) states[i][j] = states[i-<span class="hljs-number">1</span>][j];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w-weight[i]; ++j) &#123; <span class="hljs-comment">// 选择第i个物品</span><br>      <span class="hljs-keyword">if</span> (states[i-<span class="hljs-number">1</span>][j] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> v = states[i-<span class="hljs-number">1</span>][j] + value[i];<br>        <span class="hljs-keyword">if</span> (v &gt; states[i][j+weight[i]]) &#123;<br>          states[i][j+weight[i]] = v;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 找出最大值</span><br>  <span class="hljs-keyword">int</span> maxvalue = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= w; ++j) &#123;<br>    <span class="hljs-keyword">if</span> (states[n-<span class="hljs-number">1</span>][j] &gt; maxvalue) maxvalue = states[n-<span class="hljs-number">1</span>][j];<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxvalue;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态规划：一个模型三个特征"><a href="#动态规划：一个模型三个特征" class="headerlink" title="动态规划：一个模型三个特征"></a>动态规划：一个模型三个特征</h3><ol><li><p>多阶段决策最优解模型</p><p>一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p></li><li><p>最优子结构特征</p><p>最优子结构指的是，问题的最优解包含子问题的最优解。</p><p>可以通过子问题的最优解，推导出问题的最优解。后面阶段的状态可以通过前面阶段的状态推导出来。</p></li><li><p>无后效性特征</p><ol><li>在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的</li><li>某阶段状态一旦确定，就不受之后阶段的决策影响</li></ol></li><li><p>重复子问题</p><p>不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态</p></li></ol><h4 id="“一个模型三个特征”实例剖析"><a href="#“一个模型三个特征”实例剖析" class="headerlink" title="“一个模型三个特征”实例剖析"></a>“一个模型三个特征”实例剖析</h4><blockquote><p>假设有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p><img src="/article/55046/%E6%A3%8B%E5%AD%90%E5%AE%9E%E4%BE%8B.jpg" class title="棋子实例"></blockquote><ol><li><p>一个模型</p><p>从 (0, 0) 走到 (n-1, n-1)，总共要走 2*(n-1) 步，也就对应着 2*(n-1) 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。</p><p>把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动态规划的模型。</p><img src="/article/55046/%E6%A3%8B%E5%AD%90%E5%AE%9E%E4%BE%8B%E5%A4%9A%E9%98%B6%E6%AE%B5%E5%86%B3%E7%AD%96%E6%9C%80%E4%BC%98%E8%A7%A3%E6%A8%A1%E5%9E%8B.jpg" class title="棋子实例多阶段决策最优解模型"></li><li><p>三个特征</p><p>如果我们走到 (i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动，也就是说，想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“无后效性”这一特征。</p><p>定义状态的时候，从起始位置 (0, 0) 到 (i, j) 的最小路径，记作 min_dist(i, j)。只有可能从 (i, j-1) 或者 (i-1, j) 两个位置到达 (i, j)。也就是说，到达 (i, j) 的最短路径要么经过 (i, j-1)，要么经过 (i-1, j)，而且到达 (i, j) 的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist(i, j) 可以通过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来。这就说明，这个问题符合“最优子结构”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">min_dist(i, j) = w[i][j] + min(min_dist(i, j-<span class="hljs-number">1</span>), min_dist(i-<span class="hljs-number">1</span>, j))<br></code></pre></td></tr></table></figure></li></ol><h3 id="动态规划解题思路"><a href="#动态规划解题思路" class="headerlink" title="动态规划解题思路"></a>动态规划解题思路</h3><h4 id="状态转移表法"><a href="#状态转移表法" class="headerlink" title="状态转移表法"></a>状态转移表法</h4><p>状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p><blockquote><p>矩阵最短路径问题</p><p>画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。</p><img src="/article/55046/%E7%9F%A9%E9%98%B5%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%981.jpg" class title="矩阵最短路径问题1"><img src="/article/55046/%E7%9F%A9%E9%98%B5%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%982.jpg" class title="矩阵最短路径问题2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistDP</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[][] states = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>  <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123; <span class="hljs-comment">// 初始化states的第一行数据</span><br>    sum += matrix[<span class="hljs-number">0</span>][j];<br>    states[<span class="hljs-number">0</span>][j] = sum;<br>  &#125;<br>  sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 初始化states的第一列数据</span><br>    sum += matrix[i][<span class="hljs-number">0</span>];<br>    states[i][<span class="hljs-number">0</span>] = sum;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>      states[i][j] = <br>            matrix[i][j] + Math.min(states[i][j-<span class="hljs-number">1</span>], states[i-<span class="hljs-number">1</span>][j]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> states[n-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="状态转移方程法"><a href="#状态转移方程法" class="headerlink" title="状态转移方程法"></a>状态转移方程法</h4><p>状态转移方程法有点类似递归的解题思路。需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。</p><blockquote><p>矩阵最短路径问题</p><p>状态转移方程:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">min_dist(i, j) = w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))<br></code></pre></td></tr></table></figure></blockquote><p><strong>状态转移方程是解决动态规划的关键</strong></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] matrix = <br>         &#123;&#123;<span class="hljs-number">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">5</span>，<span class="hljs-number">9</span>&#125;, &#123;<span class="hljs-number">2</span>，<span class="hljs-number">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>&#125;，&#123;<span class="hljs-number">5</span>，<span class="hljs-number">2</span>，<span class="hljs-number">6</span>，<span class="hljs-number">7</span>&#125;，&#123;<span class="hljs-number">6</span>，<span class="hljs-number">8</span>，<span class="hljs-number">4</span>，<span class="hljs-number">3</span>&#125;&#125;;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] mem = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDist</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123; <span class="hljs-comment">// 调用minDist(n-1, n-1);</span><br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">if</span> (mem[i][j] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> mem[i][j];<br>  <span class="hljs-keyword">int</span> minLeft = Integer.MAX_VALUE;<br>  <span class="hljs-keyword">if</span> (j-<span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>    minLeft = minDist(i, j-<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">int</span> minUp = Integer.MAX_VALUE;<br>  <span class="hljs-keyword">if</span> (i-<span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>    minUp = minDist(i-<span class="hljs-number">1</span>, j);<br>  &#125;<br>  <br>  <span class="hljs-keyword">int</span> currMinDist = matrix[i][j] + Math.min(minLeft, minUp);<br>  mem[i][j] = currMinDist;<br>  <span class="hljs-keyword">return</span> currMinDist;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="动态规划实战"><a href="#动态规划实战" class="headerlink" title="动态规划实战"></a>动态规划实战</h3><blockquote><p>如何实现搜索引擎中的拼写纠错功能？</p><p>在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出拼写错误，并且用对应的正确单词来进行搜索</p></blockquote><h4 id="量化两个字符串的相似度"><a href="#量化两个字符串的相似度" class="headerlink" title="量化两个字符串的相似度"></a>量化两个字符串的相似度</h4><p><strong>编辑距离（Edit Distance）</strong></p><p>编辑距离指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。</p><p>编辑距离有多种不同的计算方式，比较著名的有莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）。</p><p>其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，莱文斯坦距离的大小，表示两个字符串差异的大小；最长公共子串长度只允许增加、删除字符这两个编辑操作，最长公共子串的大小，表示两个字符串相似程度的大小。</p><img src="/article/55046/%E8%8E%B1%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E7%A6%BB%E4%B8%8E%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6.jpg" class title="莱文斯坦距离与最长公共子串长度"><h4 id="计算莱文斯坦距离"><a href="#计算莱文斯坦距离" class="headerlink" title="计算莱文斯坦距离"></a><strong>计算莱文斯坦距离</strong></h4><blockquote><p><strong>回溯</strong></p><p>回溯是一个递归处理的过程。如果 a[i]与 b[j]匹配，递归考察 a[i+1]和 b[j+1]。如果 a[i]与 b[j]不匹配：</p><ol><li>可以删除 a[i]，然后递归考察 a[i+1]和 b[j]；</li><li>可以删除 b[j]，然后递归考察 a[i]和 b[j+1]；</li><li>可以在 a[i]前面添加一个跟 b[j]相同的字符，然后递归考察 a[i]和 b[j+1];</li><li>可以在 b[j]前面添加一个跟 a[i]相同的字符，然后递归考察 a[i+1]和 b[j]；</li><li>可以将 a[i]替换成 b[j]，或者将 b[j]替换成 a[i]，然后递归考察 a[i+1]和 b[j+1]。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] a = <span class="hljs-string">&quot;mitcmu&quot;</span>.toCharArray();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] b = <span class="hljs-string">&quot;mtacnu&quot;</span>.toCharArray();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> minDist = Integer.MAX_VALUE; <span class="hljs-comment">// 存储结果</span><br><span class="hljs-comment">// 调用方式 lwstBT(0, 0, 0);</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">lwstBT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> edist)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (i == n || j == m) &#123;<br>    <span class="hljs-keyword">if</span> (i &lt; n) edist += (n-i);<br>    <span class="hljs-keyword">if</span> (j &lt; m) edist += (m - j);<br>    <span class="hljs-keyword">if</span> (edist &lt; minDist) minDist = edist;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123; <span class="hljs-comment">// 两个字符匹配</span><br>    lwstBT(i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>, edist);<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 两个字符不匹配</span><br>    lwstBT(i + <span class="hljs-number">1</span>, j, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除a[i]或者b[j]前添加一个字符</span><br>    lwstBT(i, j + <span class="hljs-number">1</span>, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除b[j]或者a[i]前添加一个字符</span><br>    lwstBT(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 将a[i]和b[j]替换为相同字符</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] a = <span class="hljs-string">&quot;mitcmu&quot;</span>.toCharArray();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] b = <span class="hljs-string">&quot;mtacnu&quot;</span>.toCharArray();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> minDist = Integer.MAX_VALUE; <span class="hljs-comment">// 存储结果</span><br><span class="hljs-comment">// 调用方式 lwstBT(0, 0, 0);</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">lwstBT</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> edist)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (i == n || j == m) &#123;<br>    <span class="hljs-keyword">if</span> (i &lt; n) edist += (n-i);<br>    <span class="hljs-keyword">if</span> (j &lt; m) edist += (m - j);<br>    <span class="hljs-keyword">if</span> (edist &lt; minDist) minDist = edist;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (a[i] == b[j]) &#123; <span class="hljs-comment">// 两个字符匹配</span><br>    lwstBT(i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>, edist);<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 两个字符不匹配</span><br>    lwstBT(i + <span class="hljs-number">1</span>, j, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除a[i]或者b[j]前添加一个字符</span><br>    lwstBT(i, j + <span class="hljs-number">1</span>, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除b[j]或者a[i]前添加一个字符</span><br>    lwstBT(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, edist + <span class="hljs-number">1</span>); <span class="hljs-comment">// 将a[i]和b[j]替换为相同字符</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article/55046/%E8%8E%B1%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E7%A6%BB%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="莱文斯坦距离回溯算法递归树"><p>在递归树中，每个节点代表一个状态，状态包含三个变量 (i, j, edist)，其中，edist 表示处理到 a[i]和 b[j]时，已经执行的编辑操作的次数。</p><p>在递归树中，(i, j) 两个变量重复的节点很多。对于 (i, j) 相同的节点，只需要保留 edist 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i]和 b[j]，已经执行的最少编辑次数。</p><img src="/article/55046/%E8%8E%B1%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E7%A6%BB%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" class title="莱文斯坦距离状态转移的过程"></blockquote><p><strong>动态规划</strong></p><p><strong>状态转移方程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">如果：a[i]!=b[j]，那么：min_edist(i, j)就等于：<br>min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)<br><br>如果：a[i]==b[j]，那么：min_edist(i, j)就等于：<br>min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))<br><br>其中，min表示求三数中的最小值。     <br></code></pre></td></tr></table></figure><img src="/article/55046/%E8%8E%B1%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E7%A6%BB%E7%8A%B6%E6%80%81%E8%A1%A8.jpg" class title="莱文斯坦距离状态表"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lwstDP</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[][] minDist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123; <span class="hljs-comment">// 初始化第0行:a[0..0]与b[0..j]的编辑距离</span><br>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[j]) minDist[<span class="hljs-number">0</span>][j] = j;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) minDist[<span class="hljs-number">0</span>][j] = minDist[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> minDist[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 初始化第0列:a[0..i]与b[0..0]的编辑距离</span><br>    <span class="hljs-keyword">if</span> (a[i] == b[<span class="hljs-number">0</span>]) minDist[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) minDist[i][<span class="hljs-number">0</span>] = minDist[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> minDist[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 按行填表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (a[i] == b[j]) minDist[i][j] = min(<br>          minDist[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>, minDist[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>, minDist[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]);<br>      <span class="hljs-keyword">else</span> minDist[i][j] = min(<br>          minDist[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>, minDist[i][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>, minDist[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> minDist[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> minv = Integer.MAX_VALUE;<br>  <span class="hljs-keyword">if</span> (x &lt; minv) minv = x;<br>  <span class="hljs-keyword">if</span> (y &lt; minv) minv = y;<br>  <span class="hljs-keyword">if</span> (z &lt; minv) minv = z;<br>  <span class="hljs-keyword">return</span> minv;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="计算最长公共子串长度"><a href="#计算最长公共子串长度" class="headerlink" title="计算最长公共子串长度"></a>计算最长公共子串长度</h4><p><strong>动态规划</strong></p><p><strong>状态转移方程</strong></p><p>每个状态包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i]和 b[0…j]的最长公共子串长度。</p><ol><li>如果 a[i]与 b[j]互相匹配，将最大公共子串长度加一，并且继续考察 a[i+1]和 b[j+1]。</li><li>如果 a[i]与 b[j]不匹配，最长公共子串长度不变<ol><li>删除 a[i]，或者在 b[j]前面加上一个字符 a[i]，然后继续考察 a[i+1]和 b[j]；</li><li>删除 b[j]，或者在 a[i]前面加上一个字符 b[j]，然后继续考察 a[i]和 b[j+1]。</li></ol></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">如果：a[i]==b[j]，那么：max_lcs(i, j)就等于：<br>max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；<br><br>如果：a[i]!=b[j]，那么：max_lcs(i, j)就等于：<br>max(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))；<br><br>其中max表示求三数中的最大值。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lcs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[][] maxlcs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][m];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<span class="hljs-comment">//初始化第0行：a[0..0]与b[0..j]的maxlcs</span><br>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[j]) maxlcs[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span>) maxlcs[<span class="hljs-number">0</span>][j] = maxlcs[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">else</span> maxlcs[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<span class="hljs-comment">//初始化第0列：a[0..i]与b[0..0]的maxlcs</span><br>    <span class="hljs-keyword">if</span> (a[i] == b[<span class="hljs-number">0</span>]) maxlcs[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) maxlcs[i][<span class="hljs-number">0</span>] = maxlcs[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">else</span> maxlcs[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 填表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; m; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (a[i] == b[j]) maxlcs[i][j] = max(<br>          maxlcs[i-<span class="hljs-number">1</span>][j], maxlcs[i][j-<span class="hljs-number">1</span>], maxlcs[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">else</span> maxlcs[i][j] = max(<br>          maxlcs[i-<span class="hljs-number">1</span>][j], maxlcs[i][j-<span class="hljs-number">1</span>], maxlcs[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> maxlcs[n-<span class="hljs-number">1</span>][m-<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> maxv = Integer.MIN_VALUE;<br>  <span class="hljs-keyword">if</span> (x &gt; maxv) maxv = x;<br>  <span class="hljs-keyword">if</span> (y &gt; maxv) maxv = y;<br>  <span class="hljs-keyword">if</span> (z &gt; maxv) maxv = z;<br>  <span class="hljs-keyword">return</span> maxv;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="背包问题总结"></a>背包问题总结</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><blockquote><p><strong>dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少?</strong></p></blockquote><p><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</p><p><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</p><p> <strong>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</strong></p><hr><blockquote><p><strong>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]</strong></p></blockquote><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p><strong>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</strong></p><hr><blockquote><ol><li><p>当动态规划数组为二维数组时–先遍历物品 再遍历背包无所谓</p></li><li><p>当动态规划数组为一维数组时–先遍历物品再遍历背包，并且逆序遍历背包</p></li></ol></blockquote><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>对于完全背包，不论动态规划数组为一维还是二维，对物品遍历与背包遍历的顺序都是无所谓的</p><h3 id="背包问题排列组合问题"><a href="#背包问题排列组合问题" class="headerlink" title="背包问题排列组合问题"></a>背包问题排列组合问题</h3><p>之前的遍历顺序不受凑成总和的元素的元素的顺序影响，而排列组合问题不同,求的是凑成总和的方法种类</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;动态规划比较适合用来求解最优问题&lt;/p&gt;
&lt;p&gt;动态规划解决问题的思路:&lt;/p&gt;
&lt;p&gt;把问题分解为多个阶段，每个阶段对应一
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="数据结构与算法,动态规划" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>回溯算法</title>
    <link href="https://boyolo.github.io/article/60033.html"/>
    <id>https://boyolo.github.io/article/60033.html</id>
    <published>2022-05-30T02:48:34.000Z</published>
    <updated>2022-07-11T13:10:18.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h4><blockquote><p>有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。</p><p>第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p><img src="/article/60033/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.jpg" class title="八皇后问题"></blockquote><p>把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>];<span class="hljs-comment">//全局或成员变量,下标表示行,值表示queen存储在哪一列</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cal8queens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row)</span> </span>&#123; <span class="hljs-comment">// 调用方式：cal8queens(0);</span><br>  <span class="hljs-keyword">if</span> (row == <span class="hljs-number">8</span>) &#123; <span class="hljs-comment">// 8个棋子都放置好了，打印结果</span><br>    printQueens(result);<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = <span class="hljs-number">0</span>; column &lt; <span class="hljs-number">8</span>; ++column) &#123; <span class="hljs-comment">// 每一行都有8中放法</span><br>    <span class="hljs-keyword">if</span> (isOk(row, column)) &#123; <span class="hljs-comment">// 有些放法不满足要求</span><br>      result[row] = column; <span class="hljs-comment">// 第row行的棋子放到了column列</span><br>      cal8queens(row+<span class="hljs-number">1</span>); <span class="hljs-comment">// 考察下一行</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column)</span> </span>&#123;<span class="hljs-comment">//判断row行column列放置是否合适</span><br>  <span class="hljs-keyword">int</span> leftup = column - <span class="hljs-number">1</span>, rightup = column + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 逐行往上考察每一行</span><br>    <span class="hljs-keyword">if</span> (result[i] == column) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 第i行的column列有棋子吗？</span><br>    <span class="hljs-keyword">if</span> (leftup &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 考察左上对角线：第i行leftup列有棋子吗？</span><br>      <span class="hljs-keyword">if</span> (result[i] == leftup) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rightup &lt; <span class="hljs-number">8</span>) &#123; <span class="hljs-comment">// 考察右上对角线：第i行rightup列有棋子吗？</span><br>      <span class="hljs-keyword">if</span> (result[i] == rightup) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    --leftup; ++rightup;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] result)</span> </span>&#123; <span class="hljs-comment">// 打印出一个二维矩阵</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">8</span>; ++row) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = <span class="hljs-number">0</span>; column &lt; <span class="hljs-number">8</span>; ++column) &#123;<br>      <span class="hljs-keyword">if</span> (result[row] == column) System.out.print(<span class="hljs-string">&quot;Q &quot;</span>);<br>      <span class="hljs-keyword">else</span> System.out.print(<span class="hljs-string">&quot;* &quot;</span>);<br>    &#125;<br>    System.out.println();<br>  &#125;<br>  System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h4><blockquote><p>有一个背包，背包总的承载重量是 Wkg。现在有 n 个物品，每个物品的重量不等，并且不可分割。现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p></blockquote><p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2^n 种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。</p><p>可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxW = Integer.MIN_VALUE; <span class="hljs-comment">//存储背包中物品总重量的最大值</span><br><span class="hljs-comment">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span><br><span class="hljs-comment">// w背包重量；items表示每个物品的重量；n表示物品个数</span><br><span class="hljs-comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span><br><span class="hljs-comment">// f(0, 0, a, 10, 100)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> cw, <span class="hljs-keyword">int</span>[] items, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (cw == w || i == n) &#123; <span class="hljs-comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span><br>    <span class="hljs-keyword">if</span> (cw &gt; maxW) maxW = cw;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  f(i+<span class="hljs-number">1</span>, cw, items, n, w);<span class="hljs-comment">//当前物品不装进背包</span><br>  <span class="hljs-keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="hljs-comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span><br>    f(i+<span class="hljs-number">1</span>,cw + items[i], items, n, w);<span class="hljs-comment">// 当前物品装进背包</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><blockquote><p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。</p><p>假设正则表达式中只包含“*”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。</p><p>如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p></blockquote><p>依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</p><p>如果遇到特殊字符的时候，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pattern</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> matched = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] pattern; <span class="hljs-comment">// 正则表达式</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> plen; <span class="hljs-comment">// 正则表达式长度</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pattern</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] pattern, <span class="hljs-keyword">int</span> plen)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.pattern = pattern;<br>    <span class="hljs-keyword">this</span>.plen = plen;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text, <span class="hljs-keyword">int</span> tlen)</span> </span>&#123; <span class="hljs-comment">// 文本串及长度</span><br>    matched = <span class="hljs-keyword">false</span>;<br>    rmatch(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, text, tlen);<br>    <span class="hljs-keyword">return</span> matched;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rmatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ti, <span class="hljs-keyword">int</span> pj, <span class="hljs-keyword">char</span>[] text, <span class="hljs-keyword">int</span> tlen)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matched) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果已经匹配了，就不要继续递归了</span><br>    <span class="hljs-keyword">if</span> (pj == plen) &#123; <span class="hljs-comment">// 正则表达式到结尾了</span><br>      <span class="hljs-keyword">if</span> (ti == tlen) matched = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 文本串也到结尾了</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pattern[pj] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123; <span class="hljs-comment">// *匹配任意个字符</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt;= tlen-ti; ++k) &#123;<br>        rmatch(ti+k, pj+<span class="hljs-number">1</span>, text, tlen);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pattern[pj] == <span class="hljs-string">&#x27;?&#x27;</span>) &#123; <span class="hljs-comment">// ?匹配0个或者1个字符</span><br>      rmatch(ti, pj+<span class="hljs-number">1</span>, text, tlen);<br>      rmatch(ti+<span class="hljs-number">1</span>, pj+<span class="hljs-number">1</span>, text, tlen);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="hljs-comment">// 纯字符匹配才行</span><br>      rmatch(ti+<span class="hljs-number">1</span>, pj+<span class="hljs-number">1</span>, text, tlen);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回溯算法&quot;&gt;&lt;a href=&quot;#回溯算法&quot; class=&quot;headerlink&quot; title=&quot;回溯算法&quot;&gt;&lt;/a&gt;回溯算法&lt;/h2&gt;&lt;p&gt;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法,回溯算法" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治算法</title>
    <link href="https://boyolo.github.io/article/46607.html"/>
    <id>https://boyolo.github.io/article/46607.html</id>
    <published>2022-05-30T01:54:15.000Z</published>
    <updated>2022-07-11T13:10:18.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p><strong>分治算法（divide and conquer）的核心思想</strong>其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong></p><p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ol><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li>合并：将子问题的结果合并成原问题。</li></ol><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ol><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ol><h3 id="分治算法应用举例"><a href="#分治算法应用举例" class="headerlink" title="分治算法应用举例"></a>分治算法应用举例</h3><blockquote><p><strong>如何求出一组数据的有序对个数或者逆序对个数</strong></p></blockquote><p>有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。</p><p>假设有 n 个数据，期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。</p><p>用分治的思想来求数组 A 的逆序对个数。可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p><p><strong>归并排序</strong>中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，就可以计算这两个小数组的逆序对个数了。每次合并操作，都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p><img src="/article/46607/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E4%B8%AA%E6%95%B0.jpg" class title="归并排序求逆序对个数"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>; <span class="hljs-comment">// 全局变量或者成员变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  num = <span class="hljs-number">0</span>;<br>  mergeSortCounting(a, <span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> num;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSortCounting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (p &gt;= r) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">int</span> q = (p+r)/<span class="hljs-number">2</span>;<br>  mergeSortCounting(a, p, q);<br>  mergeSortCounting(a, q+<span class="hljs-number">1</span>, r);<br>  merge(a, p, q, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> i = p, j = q+<span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[r-p+<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;<br>    <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) &#123;<br>      tmp[k++] = a[i++];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      num += (q-i+<span class="hljs-number">1</span>); <span class="hljs-comment">// 统计p-q之间，比a[j]大的元素个数</span><br>      tmp[k++] = a[j++];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (i &lt;= q) &#123; <span class="hljs-comment">// 处理剩下的</span><br>    tmp[k++] = a[i++];<br>  &#125;<br>  <span class="hljs-keyword">while</span> (j &lt;= r) &#123; <span class="hljs-comment">// 处理剩下的</span><br>    tmp[k++] = a[j++];<br>  &#125;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= r-p; ++i) &#123; <span class="hljs-comment">// 从tmp拷贝回a</span><br>    a[p+i] = tmp[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h3><blockquote><p>给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而机器的内存可能只有 2、3GB ，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p></blockquote><p>利用分治的思想。可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p><blockquote><p>给 10GB 的订单排序，可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分治算法&quot;&gt;&lt;a href=&quot;#分治算法&quot; class=&quot;headerlink&quot; title=&quot;分治算法&quot;&gt;&lt;/a&gt;分治算法&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;分治算法（divide and conquer）的核心思想&lt;/strong&gt;其实就是四个字，分而治之 ，也就
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="分治算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法,分治算法" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://boyolo.github.io/article/51855.html"/>
    <id>https://boyolo.github.io/article/51855.html</id>
    <published>2022-05-29T05:04:47.000Z</published>
    <updated>2022-07-11T13:10:18.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心算法解决问题的步骤:</p><ol><li>针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。<strong>当看到这类问题的时候，首先要联想到贪心算法。</strong></li><li>尝试看这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。</li><li>第三步，举几个例子看下贪心算法产生的结果是否是最优的。</li></ol><h3 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h3><ol><li><p>分糖果</p><blockquote><p>有 m 个糖果和 n 个孩子。现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n），所以糖果只能分配给一部分孩子。</p><p>每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。</p><p>如何分配糖果，能尽可能满足最多数量的孩子？</p></blockquote><p><strong>抽象问题：从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。这个问题的限制值就是糖果个数 m。</strong></p><p>对于一个孩子来说，如果小的糖果可以满足，就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，可以从需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对期望值的贡献是一样的。</p><p>每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p></li><li><p>钱币找零</p><blockquote><p>假设有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p></blockquote><p>先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。</p></li><li><p>区间覆盖</p><blockquote><p>假设有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？</p><img src="/article/51855/%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96.jpg" class title="区间覆盖"></blockquote><p><strong>解决思路:</strong>假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。</p><p>每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</p><img src="/article/51855/%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF.jpg" class title="区间覆盖解决思路"></li></ol><h3 id="贪心算法实现Huffman压缩编码"><a href="#贪心算法实现Huffman压缩编码" class="headerlink" title="贪心算法实现Huffman压缩编码"></a>贪心算法实现Huffman压缩编码</h3><blockquote><p>假设有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p><p>假设通过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">a(000)、b(001)、c(010)、d(011)、e(100)、f(101)<br></code></pre></td></tr></table></figure></blockquote><p><strong>霍夫曼编码是一种十分有效的编码方法</strong>，广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。</p><p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。</p><p>如何给不同频率的字符选择不同长度的编码呢？<strong>根据贪心的思想，可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</strong></p><blockquote><p>对于等长的编码来说，解压缩起来很简单。比如用 3 个 bit 表示一个字符。在解压缩的时候，每次从文本中读取 3 位二进制码，然后翻译成对应的字符。</p><p><strong>但是，霍夫曼编码是不等长的，每次应该读取 1 位还是 2 位、3 位等等来解压缩呢？</strong>这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，<strong>霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</strong></p></blockquote><p><strong>霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</strong></p><p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，<strong>在解压缩的时候，每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。</strong></p><img src="/article/51855/Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81.jpg" class title="Huffman压缩编码"><p><strong>根据字符出现频率的不同，给不同的字符进行不同长度的编码</strong></p><p>把每个字符看作一个节点，并且附带着把频率放到优先级队列中。从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p><p><strong>给每一条边加上画一个权值，指向左子节点的边标记为 0，指向右子节点的边，标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</strong></p><img src="/article/51855/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.jpg" class title="霍夫曼编码">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h2&gt;&lt;p&gt;贪心算法解决问题的步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="贪心算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法,贪心算法" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配</title>
    <link href="https://boyolo.github.io/article/41181.html"/>
    <id>https://boyolo.github.io/article/41181.html</id>
    <published>2022-05-26T13:11:52.000Z</published>
    <updated>2022-07-11T13:10:18.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>在字符串 A 中查找字符串 B，那字符串 A 就是<strong>主串</strong>，字符串 B 就是<strong>模式串</strong>。</p><h3 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h3><p>BF 算法中的 BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。</p><p><strong>在主串中，检查起始位置分别是 0、1、2….n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。</strong></p><p><img src="/article/BF 算法实例.jpg"><span class="image-caption">BF 算法实例</span></p><p>最坏情况时间复杂度是 O(n*m)</p><h3 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h3><p>RK 算法的全称叫 Rabin-Karp 算法，是 BF 算法的升级版</p><h4 id="RK-算法的思路"><a href="#RK-算法的思路" class="headerlink" title="RK 算法的思路"></a>RK 算法的思路</h4><p>通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p><img src="/article/41181/%E4%B8%BB%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC.jpg" class title="主串哈希值"><h4 id="提高哈希算法计算子串哈希值的效率"><a href="#提高哈希算法计算子串哈希值的效率" class="headerlink" title="提高哈希算法计算子串哈希值的效率"></a><strong>提高哈希算法计算子串哈希值的效率</strong></h4><p>假设要匹配的字符串的字符集中只包含 K 个字符，可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p><p>相邻两个子串 s[i-1]和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，<strong>可以使用 s[i-1]的哈希值很快的计算出 s[i]的哈希值。</strong></p><img src="/article/41181/%E6%8F%90%E9%AB%98%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%AD%90%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC%E7%9A%84%E6%95%88%E7%8E%87.jpg" class title="提高哈希算法计算子串哈希值的效率"><p>26<sup>(m-1)</sup> 这部分的计算，我们可以通过查表的方法来提高效率。事先计算好 26<sup>0</sup>、26<sup>1</sup>、26<sup>2</sup>、26<sup>3</sup>……26<sup>(m-1)</sup> ，并且<strong>存储在一个长度为 m 的数组中</strong>，公式中的“次方”就对应数组的下标，需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。</p><blockquote><p><strong>问题：模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？</strong></p><p>为了能将哈希值落在整型数据范围内，可以允许哈希冲突</p></blockquote><h4 id="RK-算法的时间复杂度"><a href="#RK-算法的时间复杂度" class="headerlink" title="RK 算法的时间复杂度"></a><strong>RK 算法的时间复杂度</strong></h4><p>整个 RK 算法包含两部分</p><ol><li><p>计算子串哈希值和模式串哈希值</p><p>通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 <strong>O(n)</strong></p></li><li><p>子串哈希值之间的比较</p><p>时间复杂度是 <strong>O(1)</strong>，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 <strong>O(n)</strong></p></li></ol><p>RK 算法整体的时间复杂度就是 <strong>O(n)</strong></p><p>最坏情况时间复杂度<strong>O(n*m)</strong></p><h3 id="BF、RK算法实现"><a href="#BF、RK算法实现" class="headerlink" title="BF、RK算法实现"></a>BF、RK算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bF</span><span class="hljs-params">(String a,String b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> m=a.length(),n=b.length(),k;<br><span class="hljs-keyword">char</span>[] a1=a.toCharArray();<br><span class="hljs-keyword">char</span>[] b1=b.toCharArray();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m-n;i++) &#123;<br>k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br><span class="hljs-keyword">if</span>(a1[i+j]==b1[j]) &#123;<br>k++;<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(k==n) &#123;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rK</span><span class="hljs-params">(String a,String b)</span> </span>&#123;<br><span class="hljs-keyword">int</span> m=a.length(),n=b.length(),s,j;<br><span class="hljs-keyword">int</span>[] hash=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m-n+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">int</span>[] table=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br><span class="hljs-keyword">char</span>[] a1=a.toCharArray();<br><span class="hljs-keyword">char</span>[] b1=b.toCharArray();<br>s=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//将26的次方存储在一个表里，取的时候直接用,虽然溢出，但没啥问题</span><br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;j++) &#123;<br>table[j]=s;<br>s*=<span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m-n;i++) &#123;<br>s=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br>s+=(a1[i+j]-<span class="hljs-string">&#x27;a&#x27;</span>)*table[n-<span class="hljs-number">1</span>-j];<br>&#125;<br>hash[i]=s;<br>&#125;<br>s=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++) &#123;<br>s+=(b1[j]-<span class="hljs-string">&#x27;a&#x27;</span>)*table[n-<span class="hljs-number">1</span>-j];<br>&#125;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;m-n+<span class="hljs-number">1</span>;j++) &#123;<br><span class="hljs-keyword">if</span>(hash[j]==s) &#123;<br><span class="hljs-keyword">return</span> j;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BM（Boyer-Moore）算法"><a href="#BM（Boyer-Moore）算法" class="headerlink" title="BM（Boyer-Moore）算法"></a>BM（Boyer-Moore）算法</h3><h4 id="BM-算法的核心思想"><a href="#BM-算法的核心思想" class="headerlink" title="BM 算法的核心思想"></a>BM 算法的核心思想</h4><p>BM 算法包含两部分，分别是<strong>坏字符规则（bad character rule）</strong>和<strong>好后缀规则（good suffix shift）</strong>。</p><ol><li><p>坏字符规则</p><p><img src="/article/BM 算法的匹配顺序实例.jpg"><span class="image-caption">BM 算法的匹配顺序实例</span></p><p>BM 算法的匹配顺序是<strong>按照模式串下标从大到小的顺序</strong></p><p>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候，把这个没有匹配的字符叫作<strong>坏字符（主串中的字符）</strong>。</p><blockquote><ol><li><p>坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p><p><img src="/article/BM 算法的匹配顺序1.jpg"><span class="image-caption">BM 算法的匹配顺序1</span></p></li><li><p>模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，<strong>不能将模式串往后滑动三位</strong>。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。</p><p><img src="/article/BM 算法的匹配顺序2.jpg"><span class="image-caption">BM 算法的匹配顺序2</span></p></li></ol></blockquote><p>当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。</p><p><img src="/article/BM 算法坏字符规律.jpg"><span class="image-caption">BM 算法坏字符规律</span></p><p><strong>如果坏字符在模式串里多处出现，在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</strong></p><p><strong>最好情况时间复杂度：</strong>O(n/m)</p><p><strong>问题：</strong>根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。</p></li><li><p>好后缀规则</p><img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E5%AE%9E%E4%BE%8B.jpg" class title="好后缀规则实例"><p><strong>把已经匹配的 bc 叫作好后缀</strong>，记作{u}</p><blockquote><ol><li><p>拿 {u} 在模式串中查找，如果找到了另一个跟 {u} 相匹配的子串 {u*} ，就将模式串滑动到子串{u*}与主串中{u}对齐的位置。</p><img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F1.jpg" class title="好后缀规则顺序1"></li><li><p>如果好后缀在模式串中不存在可匹配的子串，在一步一步往后滑动模式串的过程中，只要主串中的 {u} 与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中 {u} 的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。</p><img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F2.jpg" class title="好后缀规则顺序2"><img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D.jpg" class title="好后缀规则前缀后缀部分匹配"><p>所以，针对这种情况，不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察<strong>好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的</strong>。</p><p><strong>从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是 {v} ，然后将模式串滑动到如图所示的位置。</strong></p><img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F3.jpg" class title="好后缀规则顺序3"></li></ol></blockquote></li></ol><p><strong>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数</strong></p><h4 id="BM-算法代码实现"><a href="#BM-算法代码实现" class="headerlink" title="BM 算法代码实现"></a>BM 算法代码实现</h4><blockquote><p><strong>如何查找坏字符在模式串中出现的位置?</strong></p><p>可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。</p><p>假设字符串的字符集不是很大，每个字符长度是 1 字节，用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。</p><img src="/article/41181/%E6%9F%A5%E6%89%BE%E5%9D%8F%E5%AD%97%E7%AC%A6%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg" class title="查找坏字符在模式串中出现的位置"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">256</span>; <span class="hljs-comment">// 全局变量或成员变量</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateBC</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] bc)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; ++i) &#123;<br>    bc[i] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化bc</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>    <span class="hljs-keyword">int</span> ascii = (<span class="hljs-keyword">int</span>)b[i]; <span class="hljs-comment">// 计算b[i]的ASCII值</span><br>    bc[ascii] = i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>变量 b 是模式串，m 是模式串的长度，bc 表示散列表</p></blockquote><blockquote><p><strong>不考虑好后缀规则，仅用坏字符规则，并且不考虑 si-xi 计算得到的移动位数可能会出现负数的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bm</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[] bc = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE]; <span class="hljs-comment">// 记录模式串中每个字符最后出现的位置</span><br>  generateBC(b, m, bc); <span class="hljs-comment">// 构建坏字符哈希表</span><br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// i表示主串与模式串对齐的第一个字符</span><br>  <span class="hljs-keyword">while</span> (i &lt;= n - m) &#123;<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">for</span> (j = m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123; <span class="hljs-comment">// 模式串从后往前匹配</span><br>      <span class="hljs-keyword">if</span> (a[i+j] != b[j]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 坏字符对应模式串中的下标是j</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br>    &#125;<br>    <span class="hljs-comment">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span><br>    i = i + (j - bc[(<span class="hljs-keyword">int</span>)a[i+j]]); <br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article/41181/%E6%9F%A5%E6%89%BE%E5%9D%8F%E5%AD%97%E7%AC%A6%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%B9%B6%E7%A7%BB%E5%8A%A8.jpg" class title="查找坏字符在模式串中出现的位置并移动"></blockquote><blockquote><p><strong>好后缀规则</strong></p><ol><li>在模式串中，查找跟好后缀匹配的另一个子串；</li><li>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</li></ol><p><strong>在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置</strong></p><ol><li><p>表示模式串中不同的后缀子串</p><p>后缀子串的最后一个字符的位置是固定的，下标为 m-1，只需要记录长度就可以了。通过长度，可以确定一个唯一的后缀子串。</p><img src="/article/41181/%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84%E5%90%8E%E7%BC%80%E5%AD%90%E4%B8%B2.jpg" class title="表示模式串中不同的后缀子串"></li><li><p><strong>引入关键变量 suffix 数组</strong></p><p>suffix 数组的下标 k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀{u}相匹配的子串{u*}的起始下标值</p><p><img src="/article/suffix 数组.jpg"><span class="image-caption">suffix 数组</span></p></li><li><p><strong>引入 boolean 类型的 prefix 数组</strong></p><p>记录模式串的后缀子串是否能匹配模式串的前缀子串</p><p><img src="/article/prefix 数组.jpg"><span class="image-caption">prefix 数组</span></p></li></ol><p>拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 k，那我们就记录 suffix[k]=j（j 表示公共后缀子串的起始下标）。如果 j 等于 0，也就是说，公共后缀子串也是模式串的前缀子串，我们就记录 prefix[k]=true。</p><p><img src="/article/suffix 数组、prefix 数组计算.jpg"><span class="image-caption">suffix 数组、prefix 数组计算</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateGS</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] suffix, <span class="hljs-keyword">boolean</span>[] prefix)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123; <span class="hljs-comment">// 初始化</span><br>    suffix[i] = -<span class="hljs-number">1</span>;<br>    prefix[i] = <span class="hljs-keyword">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; ++i) &#123; <span class="hljs-comment">// b[0, i]</span><br>    <span class="hljs-keyword">int</span> j = i;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; <span class="hljs-comment">// 公共后缀子串长度</span><br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; b[j] == b[m-<span class="hljs-number">1</span>-k]) &#123; <span class="hljs-comment">// 与b[0, m-1]求公共后缀子串</span><br>      --j;<br>      ++k;<br>      suffix[k] = j+<span class="hljs-number">1</span>; <span class="hljs-comment">//j+1表示公共后缀子串在b[0, i]中的起始下标</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span>) prefix[k] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">//如果公共后缀子串也是模式串的前缀子串</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</strong></p><ol><li><p>假设好后缀的长度是 k。先拿好后缀，在 suffix 数组中查找其匹配的子串。如果 suffix[k]不等于 -1（-1 表示不存在匹配的子串），那我们就将模式串往后移动 j-suffix[k]+1 位（j 表示坏字符对应的模式串中的字符下标）。</p><img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D1.jpg" class title="好后缀匹配1"></li><li><p>如果 suffix[k]等于 -1，表示模式串中不存在另一个跟好后缀匹配的子串片段</p><p>好后缀的后缀子串 b[r, m-1]（其中，r 取值从 j+2 到 m-1）的长度 k=m-r，如果 prefix[k]等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样我们可以把模式串后移 r 位。</p><img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D1.jpg" class title="好后缀匹配1"></li><li><p>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，就将整个模式串后移 m 位。</p><img src="/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D3.jpg" class title="好后缀匹配3"></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// a,b表示主串和模式串；n，m表示主串和模式串的长度。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bm</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span>[] b, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[] bc = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[SIZE]; <span class="hljs-comment">// 记录模式串中每个字符最后出现的位置</span><br>  generateBC(b, m, bc); <span class="hljs-comment">// 构建坏字符哈希表</span><br>  <span class="hljs-keyword">int</span>[] suffix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br>  <span class="hljs-keyword">boolean</span>[] prefix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m];<br>  generateGS(b, m, suffix, prefix);<br>  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// j表示主串与模式串匹配的第一个字符</span><br>  <span class="hljs-keyword">while</span> (i &lt;= n - m) &#123;<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">for</span> (j = m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123; <span class="hljs-comment">// 模式串从后往前匹配</span><br>      <span class="hljs-keyword">if</span> (a[i+j] != b[j]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 坏字符对应模式串中的下标是j</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br>    &#125;<br>    <span class="hljs-keyword">int</span> x = j - bc[(<span class="hljs-keyword">int</span>)a[i+j]];<br>    <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (j &lt; m-<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果有好后缀的话</span><br>      y = moveByGS(j, m, suffix, prefix);<br>    &#125;<br>    i = i + Math.max(x, y);<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">moveByGS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] suffix, <span class="hljs-keyword">boolean</span>[] prefix)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> k = m - <span class="hljs-number">1</span> - j; <span class="hljs-comment">// 好后缀长度</span><br>  <span class="hljs-keyword">if</span> (suffix[k] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> j - suffix[k] +<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = j+<span class="hljs-number">2</span>; r &lt;= m-<span class="hljs-number">1</span>; ++r) &#123;<br>    <span class="hljs-keyword">if</span> (prefix[m-r] == <span class="hljs-keyword">true</span>) &#123;<br>      <span class="hljs-keyword">return</span> r;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="KMP-算法基本原理"><a href="#KMP-算法基本原理" class="headerlink" title="KMP 算法基本原理"></a>KMP 算法基本原理</h3><p>在模式串和主串匹配的过程中，把不能匹配的那个字符叫作坏字符，把已经匹配的那段字符串叫作好前缀。</p><img src="/article/41181/%E5%A5%BD%E5%89%8D%E7%BC%80%E4%B8%8E%E5%9D%8F%E5%AD%97%E7%AC%A6.jpg" class title="好前缀与坏字符"><p>当遇到坏字符的时候，把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。</p><img src="/article/41181/%E5%AD%97%E4%B8%B2%E5%AF%B9%E6%AF%94.jpg" class title="字串对比"><p>只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。</p><img src="/article/41181/%E5%AD%97%E4%B8%B2%E5%8C%B9%E9%85%8D.jpg" class title="字串匹配"><p>好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫作<strong>最长可匹配前缀子串</strong>。</p><img src="/article/41181/%E6%9C%80%E9%95%BF%E5%8F%AF%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2.jpg" class title="最长可匹配子串"><h3 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a>next 数组</h3><p>KMP 算法可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。把这个数组定义为 <strong>next 数组</strong>，也叫失效函数（failure function）。</p><p>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。</p><p>匹配发生冲突时，查看坏字符前一位的next数组下标</p><table><thead><tr><th>模式串</th><th>a</th><th>a</th><th>b</th><th>a</th><th>a</th><th>f</th></tr></thead><tbody><tr><td>前缀表（next数组）</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td><td>0</td></tr></tbody></table><p><strong>next 数组算法实现</strong></p><ol><li>初始化</li><li>前后缀不相同情况</li><li>前后缀相同情况</li><li>next数组</li></ol><p>i 表示 后缀末尾位置</p><p>j 表示 前缀末尾位置、i之前包括i的字串的的最长相等前后缀的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] next, <span class="hljs-keyword">char</span>[] s)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>  next[] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.size ; i++)&#123;<br>    <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j])&#123;<br>      j = next[ j - <span class="hljs-number">1</span> ];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s[i] == s[j])&#123;<br>      j++;<br>      next[i] = j;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="KMP-算法复杂度分析"><a href="#KMP-算法复杂度分析" class="headerlink" title="KMP 算法复杂度分析"></a>KMP 算法复杂度分析</h3><p>KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以<strong>空间复杂度是 O(m)</strong>，m 表示模式串的长度。</p><p>KMP 算法的时间复杂度就是 O(m+n)</p><h3 id="KMP算法算法实现"><a href="#KMP算法算法实现" class="headerlink" title="KMP算法算法实现"></a>KMP算法算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种<strong>专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</strong></p><blockquote><p>有 6 个字符串，它们分别是：how，hi，her，hello，so，see。希望在里面多次查找某个字符串是否存在。</p><p>对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。</p></blockquote><p><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</strong></p><blockquote><img src="/article/41181/Trie%E6%A0%91%E5%AE%9E%E4%BE%8B.jpg" class title="Trie树实例"></blockquote><p>根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p><blockquote><p>Trie 树构造的分解过程</p><p><img src="/article/Trie 树构造的分解过程1.jpg"><span class="image-caption">img</span></p><p><img src="/article/Trie 树构造的分解过程2.jpg"><span class="image-caption">Trie 树构造的分解过程</span></p></blockquote><h3 id="如何实现一棵-Trie-树？"><a href="#如何实现一棵-Trie-树？" class="headerlink" title="如何实现一棵 Trie 树？"></a>如何实现一棵 Trie 树？</h3><p>Trie 树主要有两个操作</p><ol><li>一个是将字符串集合构造成 Trie 树。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。</li><li>另一个是在 Trie 树中查询一个字符串。</li></ol><p>借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> data;<br>  TrieNode children[<span class="hljs-number">26</span>];<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article/41181/%E5%80%9F%E5%8A%A9%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0Trie%E6%A0%91.jpg" class title="借助散列表实现Trie树"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> TrieNode root = <span class="hljs-keyword">new</span> TrieNode(<span class="hljs-string">&#x27;/&#x27;</span>); <span class="hljs-comment">// 存储无意义字符</span><br><br>  <span class="hljs-comment">// 往Trie树中插入一个字符串</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; text.length; ++i) &#123;<br>      <span class="hljs-keyword">int</span> index = text[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-keyword">null</span>) &#123;<br>        TrieNode newNode = <span class="hljs-keyword">new</span> TrieNode(text[i]);<br>        p.children[index] = newNode;<br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    p.isEndingChar = <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 在Trie树中查找一个字符串</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] pattern)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pattern.length; ++i) &#123;<br>      <span class="hljs-keyword">int</span> index = pattern[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在pattern</span><br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p.isEndingChar == <span class="hljs-keyword">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不能完全匹配，只是前缀</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 找到pattern</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> data;<br>    <span class="hljs-keyword">public</span> TrieNode[] children = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEndingChar = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li><p>时间复杂度</p><p>构建 Trie 树的过程，需要扫描所有的字符串，<strong>时间复杂度是 O(n)</strong>（n 表示所有字符串的长度和）</p><p>每次查询时，如果要查询的字符串长度是 k，只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的<strong>时间复杂度是 O(k)</strong>，k 表示要查找的字符串的长度。</p></li><li><p>空间复杂度</p><p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组元素要存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p><p><strong>在某些情况下，Trie 树不一定会节省存储空间。在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存。</strong></p></li></ol><h3 id="Trie-树与散列表、红黑树"><a href="#Trie-树与散列表、红黑树" class="headerlink" title="Trie 树与散列表、红黑树"></a>Trie 树与散列表、红黑树</h3><p>Trie 树对要处理的字符串有极其严苛的要求</p><ol><li>第一，字符串中包含的字符集不能太大。即便可以优化，但也要付出牺牲查询、插入效率的代价。</li><li>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</li><li>第三，如果要用 Trie 树解决问题，那就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</li><li>第四，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</li></ol><p>针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树</p><h2 id="AC-自动机-Trie-树优化"><a href="#AC-自动机-Trie-树优化" class="headerlink" title="AC 自动机(Trie 树优化)"></a>AC 自动机(Trie 树优化)</h2><p><strong>基于单模式串和 Trie 树实现的敏感词过滤</strong></p><p>多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。</p><p>只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。</p><p><strong>Trie 树就是一种多模式串匹配算法</strong></p><p>可以对敏感词字典进行预处理，构建成 Trie 树结构。这个预处理的操作只需要做一次，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，只需要动态更新一下 Trie 树就可以了。</p><p>当用户输入一个文本内容后，把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p><h3 id="经典的多模式串匹配算法：AC-自动机"><a href="#经典的多模式串匹配算法：AC-自动机" class="headerlink" title="经典的多模式串匹配算法：AC 自动机"></a>经典的多模式串匹配算法：AC 自动机</h3><p>AC 自动机算法，全称是 Aho-Corasick 算法。</p><p>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AcNode</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> data; <br>  <span class="hljs-keyword">public</span> AcNode[] children = <span class="hljs-keyword">new</span> AcNode[<span class="hljs-number">26</span>]; <span class="hljs-comment">// 字符集只包含a~z这26个字符</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEndingChar = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 结尾字符为true</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> length = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 当isEndingChar=true时，记录模式串长度</span><br>  <span class="hljs-keyword">public</span> AcNode fail; <span class="hljs-comment">// 失败指针</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AcNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.data = data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AC 自动机的构建，包含两个操作：</p><ol><li>将多个模式串构建成 Trie 树；</li><li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。</li></ol><h3 id="构建失败指针"><a href="#构建失败指针" class="headerlink" title="构建失败指针"></a><strong>构建失败指针</strong></h3><p>Trie 树中的每一个节点都有一个失败指针</p><blockquote><p>有 4 个模式串，分别是 c，bc，bcd，abcd；主串是 abcd。</p></blockquote><img src="/article/41181/%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg" class title="构建失败指针"><p>假设沿 Trie 树走到 p 节点，也就是下图中的紫色节点，那 p 的失败指针就是从 root 走到紫色节点形成的字符串 abc，跟所有模式串前缀匹配的最长可匹配后缀子串，就是箭头指的 bc 模式串。</p><blockquote><p>字符串 abc 的后缀子串有两个 bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，那我们就把这个后缀子串叫作可匹配后缀子串。</p></blockquote><p>从可匹配后缀子串中，找出最长的一个。将 p 节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是图中紫色箭头指向的节点。</p><p><strong>如果把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。</strong></p><p><strong>失败指针的构建过程，是一个按层遍历树的过程</strong></p><p>首先 root 的失败指针为 NULL，也就是指向自己。</p><p>假设节点 p 的失败指针指向节点 q，看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc。</p><img src="/article/41181/%E5%AF%BB%E6%89%BE%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg" class title="寻找子节点的失败指针"><p>如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 q=q-&gt;fail（fail 表示失败指针），继续上面的查找，直到 q 是 root 为止，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构建失败指针</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFailurePointer</span><span class="hljs-params">()</span> </span>&#123;<br>  Queue&lt;AcNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  root.fail = <span class="hljs-keyword">null</span>;<br>  queue.add(root);<br>  <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>    AcNode p = queue.remove();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>      AcNode pc = p.children[i];<br>      <span class="hljs-keyword">if</span> (pc == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (p == root) &#123;<br>        pc.fail = root;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        AcNode q = p.fail;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-keyword">null</span>) &#123;<br>          AcNode qc = q.children[pc.data - <span class="hljs-string">&#x27;a&#x27;</span>];<br>          <span class="hljs-keyword">if</span> (qc != <span class="hljs-keyword">null</span>) &#123;<br>            pc.fail = qc;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          q = q.fail;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-keyword">null</span>) &#123;<br>          pc.fail = root;<br>        &#125;<br>      &#125;<br>      queue.add(pc);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article/41181/%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg" class title="失败指针"><h3 id="在-AC-自动机上匹配主串"><a href="#在-AC-自动机上匹配主串" class="headerlink" title="在 AC 自动机上匹配主串"></a>在 AC 自动机上匹配主串</h3><p>在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是 b，主串是 a。</p><ol><li>如果 p 指向的节点有一个等于 a[i]的子节点 x，我们就更新 p 指向 x，这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。处理完之后，我们将 i 加一，继续这两个过程；</li><li>如果 p 指向的节点没有等于 a[i]的子节点，那失败指针就派上用场了，我们让 <code>p=p-&gt;fail</code>，然后继续这 2 个过程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text)</span> </span>&#123; <span class="hljs-comment">// text是主串</span><br>  <span class="hljs-keyword">int</span> n = text.length;<br>  AcNode p = root;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">int</span> idx = text[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (p.children[idx] == <span class="hljs-keyword">null</span> &amp;&amp; p != root) &#123;<br>      p = p.fail; <span class="hljs-comment">// 失败指针发挥作用的地方</span><br>    &#125;<br>    p = p.children[idx];<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) p = root; <span class="hljs-comment">// 如果没有匹配的，从root开始重新匹配</span><br>    AcNode tmp = p;<br>    <span class="hljs-keyword">while</span> (tmp != root) &#123; <span class="hljs-comment">// 打印出可以匹配的模式串</span><br>      <span class="hljs-keyword">if</span> (tmp.isEndingChar == <span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">int</span> pos = i-tmp.length+<span class="hljs-number">1</span>;<br>        System.out.println(<span class="hljs-string">&quot;匹配起始下标&quot;</span> + pos + <span class="hljs-string">&quot;; 长度&quot;</span> + tmp.length);<br>      &#125;<br>      tmp = tmp.fail;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Trie 树构建的<strong>时间复杂度是 O(m*len)</strong>，其中 len 表示敏感词的平均长度，m 表示敏感词的个数。</p><p>整个失败指针的构建过程<strong>时间复杂度是 O(k*len)</strong>， k 是 Trie 树中总的节点个数，每个节点构建失败指针的时候，最耗时的环节是 while 循环中的 q=q-&gt;fail，每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len，所以每个节点构建失败指针的时间复杂度是 O(len)。</p><p>用 AC 自动机做匹配的时间复杂度，for 循环依次遍历主串中的每个字符，for 循环内部最耗时的部分也是 while 循环，而这一部分的时间复杂度也是 O(len)，所以总的匹配的时间复杂度就是 O(n*len)。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，<strong>可能近似于 O(n)</strong>，所以 AC 自动机做敏感词过滤，性能非常高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;字符串匹配&quot;&gt;&lt;a href=&quot;#字符串匹配&quot; class=&quot;headerlink&quot; title=&quot;字符串匹配&quot;&gt;&lt;/a&gt;字符串匹配&lt;/h2&gt;&lt;p&gt;在字符串 A 中查找字符串 B，那字符串 A 就是&lt;strong&gt;主串&lt;/strong&gt;，字符串 B 就是&lt;stro
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
    
      <category term="数据结构与算法,字符串匹配" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://boyolo.github.io/article/47098.html"/>
    <id>https://boyolo.github.io/article/47098.html</id>
    <published>2022-05-22T04:57:59.000Z</published>
    <updated>2022-06-09T07:23:48.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p><strong>如何理解“图”？</strong></p><p><strong>图（Graph）</strong>和树比起来，这是一种更加复杂的非线性表结构。</p><p>图中的元素就叫做<strong>顶点（vertex）</strong>，图中的一个顶点可以与任意其他顶点建立连接关系。这种建立的关系叫做<strong>边（edge）</strong>。跟顶点相连接的边的条数叫做顶点的<strong>度（degree）</strong>。</p><p>边有方向的图叫做<strong>“有向图”</strong>。边没有方向的图就叫做<strong>“无向图”</strong>。</p><p>在有向图中，我们把度分为<strong>入度（In-degree）和出度（Out-degree）</strong>。</p><p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。</p><p><strong>带权图（weighted graph）</strong>。在带权图中，每条边都有一个<strong>权重（weight）</strong>。</p><h3 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h3><p>图最直观的一种存储方法就是，<strong>邻接矩阵（Adjacency Matrix）</strong>。</p><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重。</p><img src="/article/47098/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.webp" class title="邻接矩阵"><p><strong>优点：</strong></p><ol><li>邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。</li><li>其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。</li></ol><p><strong>缺点：</strong></p><ol><li><p>对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1</p><p>无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。</p></li><li><p>如果存储的是稀疏图（Sparse Matrix），顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。</p></li></ol><h3 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h3><p><strong>邻接表</strong></p><img src="/article/47098/%E9%82%BB%E6%8E%A5%E8%A1%A8.jpg" class title="邻接表"><p>每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。</p><p>有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点</p><p>无向图的邻接表存储方式，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点</p><p><strong>图的算法实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123; <span class="hljs-comment">// 无向图</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> v; <span class="hljs-comment">// 顶点的个数</span><br>  <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="hljs-comment">// 邻接表</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.v = v;<br>    adj = <span class="hljs-keyword">new</span> LinkedList[v];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;v; ++i) &#123;<br>      adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 无向图一条边存两次</span><br>    adj[s].add(t);<br>    adj[t].add(s);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逆邻接表</strong></p><p>逆邻接表中，每个顶点的链表中，存储的是指向这个顶点的顶点</p><img src="/article/47098/%E9%82%BB%E6%8E%A5%E8%A1%A8%E4%B8%8E%E9%80%86%E9%82%BB%E6%8E%A5%E8%A1%A8.jpg" class title="邻接表与逆邻接表"><h3 id="“搜索”算法？"><a href="#“搜索”算法？" class="headerlink" title="“搜索”算法？"></a>“搜索”算法？</h3><p>算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。</p><ol><li><p>广度优先搜索（BFS）</p><p>广度优先搜索（Breadth-First-Search，简称 BFS）。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p><img src="/article/47098/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89%E7%A4%BA%E4%BE%8B%E5%9B%BE.jpg" class title="广度优先搜索（BFS）示例图"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (s == t) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//visited 是用来记录已经被访问的顶点</span><br>  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[v];<br>  visited[s]=<span class="hljs-keyword">true</span>;<br>  <span class="hljs-comment">//queue 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点</span><br>  Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  queue.add(s);<br>  <span class="hljs-comment">//prev 用来记录搜索路径</span><br>  <span class="hljs-keyword">int</span>[] prev = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[v];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;<br>    prev[i] = -<span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span> (queue.size() != <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-keyword">int</span> w = queue.poll();<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[w].size(); ++i) &#123;<br>      <span class="hljs-keyword">int</span> q = adj[w].get(i);<br>      <span class="hljs-keyword">if</span> (!visited[q]) &#123;<br>        prev[q] = w;<br>        <span class="hljs-keyword">if</span> (q == t) &#123;<br>          print(prev, s, t);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        visited[q] = <span class="hljs-keyword">true</span>;<br>        queue.add(q);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prev, <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 递归打印s-&gt;t的路径</span><br>  <span class="hljs-keyword">if</span> (prev[t] != -<span class="hljs-number">1</span> &amp;&amp; t != s) &#123;<br>    print(prev, s, prev[t]);<br>  &#125;<br>  System.out.print(t + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 s 表示起始顶点，t 表示终止顶点。搜索一条从 s 到 t 的路径。实际上，这样求得的路径就是从 s 到 t 的最短路径。</p><p><strong>visited</strong> 是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点 q 被访问，那相应的 visited[q]会被设置为 true。</p><p><strong>queue</strong> 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当我们访问到第 k 层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。所以，我们用这个队列来实现记录的功能。</p><p><strong>prev</strong> 用来记录搜索路径。当我们从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w]存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 2 的邻接表访问到顶点 3，那 prev[3]就等于 2。为了正向打印出路径，我们需要递归地来打印，你可以看下 print() 函数的实现方式。</p><blockquote><img src="/article/47098/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E8%A7%A3%E5%9B%BE1.jpg" class title="广度优先搜索的分解图"><img src="/article/47098/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%9A%84%E5%88%86%E8%A7%A3%E5%9B%BE2.jpg" class title="广度优先搜索的分解图"></blockquote><p><strong>最坏情况时间复杂度</strong>：最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，<strong>广度优先搜索的时间复杂度也可以简写为 O(E)。</strong></p><p><strong>空间复杂度</strong>：广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，<strong>所以空间复杂度是 O(V)。</strong></p></li><li><p>深度优先搜索（DFS）</p><p>深度优先搜索（Depth-First-Search，简称 DFS）</p><p>实线箭头表示遍历，虚线箭头表示回退</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当已经找到终止顶点 t 之后，就不再递归地继续查找了。</span><br><span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 全局变量或者类成员变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>  found = <span class="hljs-keyword">false</span>;<br>  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[v];<br>  <span class="hljs-keyword">int</span>[] prev = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[v];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;<br>    prev[i] = -<span class="hljs-number">1</span>;<br>  &#125;<br>  recurDfs(s, t, visited, prev);<br>  print(prev, s, t);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recurDfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">int</span>[] prev)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (found == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">return</span>;<br>  visited[w] = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">if</span> (w == t) &#123;<br>    found = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[w].size(); ++i) &#123;<br>    <span class="hljs-keyword">int</span> q = adj[w].get(i);<br>    <span class="hljs-keyword">if</span> (!visited[q]) &#123;<br>      prev[q] = w;<br>      recurDfs(q, t, visited, prev);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的<strong>时间复杂度是 O(E)</strong>，E 表示边的个数。</p><p><strong>空间复杂度</strong>：深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以<strong>总的空间复杂度就是 O(V)</strong>。</p></li></ol><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><strong>拓扑排序（Topological Sorting</strong>）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：</p><ol><li>每个顶点出现且只出现一次。</li><li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li></ol><p><strong>有向无环图</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> v; <span class="hljs-comment">// 顶点的个数</span><br>  <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="hljs-comment">// 邻接表</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.v = v;<br>    adj = <span class="hljs-keyword">new</span> LinkedList[v];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;v; ++i) &#123;<br>      adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// s先于t，边s-&gt;t</span><br>    adj[s].add(t);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Kahn-算法"><a href="#Kahn-算法" class="headerlink" title="Kahn 算法"></a>Kahn 算法</h4><p>贪心算法思想</p><p>定义数据结构的时候，如果 s 需要先于 t 执行，那就添加一条 s 指向 t 的边。</p><p>如果某个顶点入度为 0， 也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。</p><p>先从图中，找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中，并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 1）。</p><p>循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topoSortByKahn</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span>[] inDegree = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[v]; <span class="hljs-comment">// 统计每个顶点的入度</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); ++j) &#123;<br>      <span class="hljs-keyword">int</span> w = adj[i].get(j); <span class="hljs-comment">// i-&gt;w</span><br>      inDegree[w]++;<br>    &#125;<br>  &#125;<br>  LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (inDegree[i] == <span class="hljs-number">0</span>) queue.add(i);<br>  &#125;<br>  <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>    <span class="hljs-keyword">int</span> i = queue.remove();<br>    System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span> + i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); ++j) &#123;<br>      <span class="hljs-keyword">int</span> k = adj[i].get(j);<br>      inDegree[k]--;<br>      <span class="hljs-keyword">if</span> (inDegree[k] == <span class="hljs-number">0</span>) queue.add(k);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>每个顶点被访问了一次，每个边也都被访问了一次，所以，Kahn 算法的时间复杂度就是 O(V+E)（V 表示顶点个数，E 表示边的个数）。</p><h4 id="DFS-算法"><a href="#DFS-算法" class="headerlink" title="DFS 算法"></a>DFS 算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">topoSortByDFS</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s</span><br>  LinkedList&lt;Integer&gt; inverseAdj[] = <span class="hljs-keyword">new</span> LinkedList[v];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 申请空间</span><br>    inverseAdj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 通过邻接表生成逆邻接表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; adj[i].size(); ++j) &#123;<br>      <span class="hljs-keyword">int</span> w = adj[i].get(j); <span class="hljs-comment">// i-&gt;w</span><br>      inverseAdj[w].add(i); <span class="hljs-comment">// w-&gt;i</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[v];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123; <span class="hljs-comment">// 深度优先遍历图</span><br>    <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-keyword">false</span>) &#123;<br>      visited[i] = <span class="hljs-keyword">true</span>;<br>      dfs(i, inverseAdj, visited);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> vertex, LinkedList&lt;Integer&gt; inverseAdj[], <span class="hljs-keyword">boolean</span>[] visited)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inverseAdj[vertex].size(); ++i) &#123;<br>    <span class="hljs-keyword">int</span> w = inverseAdj[vertex].get(i);<br>    <span class="hljs-keyword">if</span> (visited[w] == <span class="hljs-keyword">true</span>) <span class="hljs-keyword">continue</span>;<br>    visited[w] = <span class="hljs-keyword">true</span>;<br>    dfs(w, inverseAdj, visited);<br>  &#125; <span class="hljs-comment">// 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</span><br>  System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span> + vertex);<br>&#125;<br></code></pre></td></tr></table></figure><p>第一部分是通过邻接表构造逆邻接表。</p><p>邻接表中，边 s-&gt;t 表示 s 先于 t 执行，也就是 t 要依赖 s。在逆邻接表中，边 s-&gt;t 表示 s 依赖于 t，s 后于 t 执行。</p><p>第二部分是递归处理每个顶点。</p><p>对于顶点 vertex 来说，先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己。</p><p><strong>时间复杂度：</strong></p><p>每个顶点被访问两次，每条边都被访问一次，所以时间复杂度也是 O(V+E)。</p><h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><blockquote><p>将整个地图抽象成一个有向有权图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123; <span class="hljs-comment">// 有向有权图的邻接表表示</span><br>  <span class="hljs-keyword">private</span> LinkedList&lt;Edge&gt; adj[]; <span class="hljs-comment">// 邻接表</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> v; <span class="hljs-comment">// 顶点个数</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.v = v;<br>    <span class="hljs-keyword">this</span>.adj = <span class="hljs-keyword">new</span> LinkedList[v];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v; ++i) &#123;<br>      <span class="hljs-keyword">this</span>.adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> w)</span> </span>&#123; <span class="hljs-comment">// 添加一条边</span><br>    <span class="hljs-keyword">this</span>.adj[s].add(<span class="hljs-keyword">new</span> Edge(s, t, w));<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> sid; <span class="hljs-comment">// 边的起始顶点编号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> tid; <span class="hljs-comment">// 边的终止顶点编号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> w; <span class="hljs-comment">// 权重</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sid, <span class="hljs-keyword">int</span> tid, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.sid = sid;<br>      <span class="hljs-keyword">this</span>.tid = tid;<br>      <span class="hljs-keyword">this</span>.w = w;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 下面这个类是为了dijkstra实现用的</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// 顶点编号ID</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> dist; <span class="hljs-comment">// 从起始顶点到这个顶点的距离</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vertex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> dist)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.id = id;<br>      <span class="hljs-keyword">this</span>.dist = dist;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>Dijkstra 算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 因为Java提供的优先级队列，没有暴露更新数据的接口，所以我们需要重新实现一个</span><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span> </span>&#123; <span class="hljs-comment">// 根据vertex.dist构建小顶堆</span><br>  <span class="hljs-keyword">private</span> Vertex[] nodes;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.nodes = <span class="hljs-keyword">new</span> Vertex[v+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">this</span>.count = v;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Vertex <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现... &#125;</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Vertex vertex)</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现...&#125;</span><br>  <span class="hljs-comment">// 更新结点的值，并且从下往上堆化，重新符合堆的定义。时间复杂度O(logn)。</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Vertex vertex)</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现...&#125; </span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 留给读者实现...&#125;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123; <span class="hljs-comment">// 从顶点s到顶点t的最短路径</span><br>  <span class="hljs-keyword">int</span>[] predecessor = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.v]; <span class="hljs-comment">// 用来还原最短路径</span><br>  Vertex[] vertexes = <span class="hljs-keyword">new</span> Vertex[<span class="hljs-keyword">this</span>.v];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.v; ++i) &#123;<br>    vertexes[i] = <span class="hljs-keyword">new</span> Vertex(i, Integer.MAX_VALUE);<br>  &#125;<br>  PriorityQueue queue = <span class="hljs-keyword">new</span> PriorityQueue(<span class="hljs-keyword">this</span>.v);<span class="hljs-comment">// 小顶堆</span><br>  <span class="hljs-keyword">boolean</span>[] inqueue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-keyword">this</span>.v]; <span class="hljs-comment">// 标记是否进入过队列</span><br>  vertexes[s].dist = <span class="hljs-number">0</span>;<br>  queue.add(vertexes[s]);<br>  inqueue[s] = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>    Vertex minVertex= queue.poll(); <span class="hljs-comment">// 取堆顶元素并删除</span><br>    <span class="hljs-keyword">if</span> (minVertex.id == t) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 最短路径产生了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[minVertex.id].size(); ++i) &#123;<br>      Edge e = adj[minVertex.id].get(i); <span class="hljs-comment">// 取出一条minVetex相连的边</span><br>      Vertex nextVertex = vertexes[e.tid]; <span class="hljs-comment">// minVertex--&gt;nextVertex</span><br>      <span class="hljs-keyword">if</span> (minVertex.dist + e.w &lt; nextVertex.dist) &#123; <span class="hljs-comment">// 更新next的dist</span><br>        nextVertex.dist = minVertex.dist + e.w;<br>        predecessor[nextVertex.id] = minVertex.id;<br>        <span class="hljs-keyword">if</span> (inqueue[nextVertex.id] == <span class="hljs-keyword">true</span>) &#123;<br>          queue.update(nextVertex); <span class="hljs-comment">// 更新队列中的dist值</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          queue.add(nextVertex);<br>          inqueue[nextVertex.id] = <span class="hljs-keyword">true</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 输出最短路径</span><br>  System.out.print(s);<br>  print(s, t, predecessor);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span>[] predecessor)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (s == t) <span class="hljs-keyword">return</span>;<br>  print(s, predecessor[t], predecessor);<br>  System.out.print(<span class="hljs-string">&quot;-&gt;&quot;</span> + t);<br>&#125;<br></code></pre></td></tr></table></figure><p>用 vertexes 数组，记录从起始顶点到每个顶点的距离（dist）</p><ol><li><p>首先将所有顶点的 dist 都初始化为无穷大（Integer.MAX_VALUE），起始顶点的 dist 值初始化为 0，然后将其放到优先级队列中。</p></li><li><p>从优先级队列中取出 dist 最小的顶点 minVertex，然后考察这个顶点可达的所有顶点（nextVertex）</p></li><li>如果 minVertex 的 dist 值加上 minVertex 与 nextVertex 之间边的权重 w 小于 nextVertex 当前的 dist 值，也就是说，存在另一条更短的路径，它经过 minVertex 到达 nextVertex。把 nextVertex 的 dist 更新为 minVertex 的 dist 值加上 w。把 nextVertex 加入到优先级队列中。</li><li>重复这个过程，直到找到终止顶点 t 或者队列为空。</li></ol><p>predecessor 数组的作用是为了还原最短路径，它记录每个顶点的前驱顶点。最后，通过递归的方式，将这个路径打印出来。</p><p>inqueue 数组是为了避免将一个顶点多次添加到优先级队列中。更新了某个顶点的 dist 值之后，如果这个顶点已经在优先级队列中了，就不要再将它重复添加进去了。</p><p><img src="/article/Dijkstra 算法.jpg"><span class="image-caption">Dijkstra 算法</span></p><p><strong>时间复杂度</strong></p><p>while 循环最多会执行 V 次（V 表示顶点的个数），而内部的 for 循环的执行次数不确定，跟每个顶点的相邻边的个数有关，分别记作 E0，E1，E2，……，E(V-1)。如果把这 V 个顶点的边都加起来，最大也不会超过图中所有边的个数 E（E 表示边的个数）。</p><p>for 循环内部的代码涉及从优先级队列取数据、往优先级队列中添加数据、更新优先级队列中的数据，这样三个主要的操作。优先级队列是用堆来实现的，堆中的这几个操作，时间复杂度都是 O(logV)（堆中的元素个数不会超过顶点的个数 V）。</p><p>时间复杂度就是 O(E*logV)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;如何理解“图”？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图（Graph）&lt;/strong&gt;和树比起来，这是一种更加复杂的非
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="图" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/"/>
    
    
      <category term="数据结构与算法,图" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Redis核心技术与实战</title>
    <link href="https://boyolo.github.io/article/30584.html"/>
    <id>https://boyolo.github.io/article/30584.html</id>
    <published>2022-05-20T16:03:36.000Z</published>
    <updated>2022-09-16T01:38:28.116Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://time.geekbang.org/column/article/268247">参考</a></p><p><strong>Redis 知识全景图包括“两大维度，三大主线”</strong></p><p><img src="/article/Redis 知识全景图.jpg"><span class="image-caption">Redis 知识全景图</span></p><p><strong>Redis问题画像</strong></p><img src="/article/30584/Redis%E9%97%AE%E9%A2%98%E7%94%BB%E5%83%8F.jpeg" class title="Redis问题画像"><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><blockquote><p><strong>Redis 的快，到底是快在哪里呢？</strong></p><p><strong>一方面</strong>，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。</p><p><strong>另一方面</strong>，这要归功于它的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。</p></blockquote><p>底层数据结构一共有 6 种，分别是<strong>简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组</strong></p><img src="/article/30584/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" class title="底层数据结构"><p>List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p><p><strong>压缩列表</strong>实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 <strong>zlbytes、zltail 和 zllen</strong>，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 <strong>zlend</strong>，表示列表结束。</p><img src="/article/30584/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.jpg" class title="压缩列表"><p><strong>跳表</strong>在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</p><img src="/article/30584/%E8%B7%B3%E8%A1%A8.jpg" class title="跳表"><h3 id="键和值用什么结构组织？"><a href="#键和值用什么结构组织？" class="headerlink" title="键和值用什么结构组织？"></a>键和值用什么结构组织？</h3><p><strong>Redis 使用了一个哈希表来保存所有键值对：</strong>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶，哈希桶中的元素保存的并不是值本身，而是<strong>指向具体值的指针</strong>。</p><p>哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值</p><img src="/article/30584/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.jpg" class title="全局哈希表"><p>可以用 <strong>O(1) 的时间复杂度</strong>来快速查找到键值对——只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中</p><ol><li><p>链式哈希</p><p>Redis 解决哈希冲突的方式，就是链式哈希。<strong>指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。</strong></p><img src="/article/30584/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg" class title="链表法"></li><li><p>rehash</p><p>如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低</p><p><strong>Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突</strong></p><blockquote><p>Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p><ol><li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li><li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li><li>释放哈希表 1 的空间。</li></ol><p>从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用</p><p><strong>问题：第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求</strong></p></blockquote><p><strong>渐进式 rehash</strong></p><p>在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：</p><p><img src="/article/渐进式 rehash.jpg"><span class="image-caption">渐进式 rehash</span></p></li></ol><h3 id="不同数据结构查找的时间复杂度"><a href="#不同数据结构查找的时间复杂度" class="headerlink" title="不同数据结构查找的时间复杂度"></a>不同数据结构查找的时间复杂度</h3><img src="/article/30584/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" class title="时间复杂度"><ol><li>单元素操作，是指每一种集合类型对单个数据实现的增删改查操作，复杂度都是 O(1)</li><li>范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。</li><li>统计操作，是指集合类型对集合中所有元素个数的记录。这类操作复杂度只有 O(1)。</li><li>例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</li></ol><h3 id="String-类型数据结构"><a href="#String-类型数据结构" class="headerlink" title="String 类型数据结构"></a>String 类型数据结构</h3><p>String 类型提供的“一个键对应一个值的数据”</p><p>String 类型并不是适用于所有场合的，它有一个明显的短板，就是它<strong>保存数据时所消耗的内存空间较多。</strong></p><h4 id="为什么-String-类型内存开销大？"><a href="#为什么-String-类型内存开销大？" class="headerlink" title="为什么 String 类型内存开销大？"></a>为什么 String 类型内存开销大？</h4><hr><p>元数据 + 实际数据</p><p>除了<strong>记录实际数据</strong>，String 类型还需要额外的内存空间记录数据长度、空间使用等信息，这些信息也叫作<strong>元数据</strong>。</p><p>当你保存 64 位<strong>有符号整数</strong>时，String 类型会把它保存为一个 8 字节的 Long 类型整数，这种保存方式通常也叫作 int 编码方式。</p><p>但是，当你保存的数据中<strong>包含字符</strong>时，String 类型就会用简单动态字符串（Simple Dynamic String，SDS）结构体来保存，如下图所示：</p><img src="/article/30584/SDS%E7%BB%93%E6%9E%84%E4%BD%93.jpg" class title="SDS结构体"><ol><li>buf：字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个“\0”，这就会额外占用 1 个字节的开销。</li><li>len：占 4 个字节，表示 buf 的已用长度。</li><li>alloc：也占个 4 字节，表示 buf 的实际分配长度，一般大于 len。</li></ol><p>在 SDS 中，buf 保存实际数据，而 len 和 alloc 本身其实是 SDS 结构体的额外开销。</p><hr><p>对于 String 类型来说，除了 SDS 的额外开销，还有一个来自于 <strong>RedisObject</strong> 结构体的开销。</p><p>因为 Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。</p><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在。</p><img src="/article/30584/RedisObject%E7%BB%93%E6%9E%84%E4%BD%93.jpg" class title="RedisObject结构体"><hr><p>为了节省内存空间，Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计。</p><ol><li>当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。</li><li>当保存的是字符串数据，并且字符串<strong>小于等于 44 字节</strong>时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。</li><li>当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 <strong>raw 编码模式</strong>。</li></ol><p><img src="/article/int、embstr 和 raw 三种编码模式.jpg"><span class="image-caption">int、embstr 和 raw 三种编码模式</span></p><hr><p>Redis 使用的内存分配库 jemalloc</p><p>jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。</p><hr><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>Redis 有一种底层数据结构，叫压缩列表（ziplist），这是一种非常节省内存的结构。</p><p>压缩列表的构成：表头有三个字段 <strong>zlbytes、zltail 和 zllen</strong>，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表尾还有一个 <strong>zlend</strong>，表示列表结束。</p><img src="/article/30584/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90.jpg" class title="压缩列表的构成"><p>压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分。</p><ol><li><strong>prev_len</strong>，表示前一个 entry 的长度。prev_len 有两种取值情况：<strong>1 字节或 5 字节</strong>。取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255 表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。</li><li>len：表示自身长度，4 字节；</li><li>encoding：表示编码方式，1 字节；</li><li>content：保存实际数据。</li></ol><p>这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。</p><p>Redis 基于压缩列表实现了 <strong>List、Hash 和 Sorted Set</strong> 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。</p><h4 id="如何用集合类型保存单值的键值对？"><a href="#如何用集合类型保存单值的键值对？" class="headerlink" title="如何用集合类型保存单值的键值对？"></a>如何用集合类型保存单值的键值对？</h4><p>在保存单值的键值对时，可以采用基于 Hash 类型的二级编码方法。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为 Hash 集合的 value。</p><blockquote><p>以图片 ID 1101000060 和图片存储对象 ID 3302000080 为例</p><p>可以把图片 ID 的前 7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象 ID 分别作为 Hash 类型值中的 key 和 value。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; info memory<br><span class="hljs-meta">#</span><span class="bash"> Memory</span><br>used_memory:1039120<br>127.0.0.1:6379&gt; hset 1101000 060 3302000080<br>(integer) 1<br>127.0.0.1:6379&gt; info memory<br><span class="hljs-meta">#</span><span class="bash"> Memory</span><br>used_memory:1039136<br></code></pre></td></tr></table></figure><p>增加一条记录后，内存占用只增加了 16 字节</p></blockquote><p><strong>二级编码方法中采用的 ID 长度</strong></p><p>hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。</p><p>这两个阈值分别对应以下两个配置项：</p><ol><li><code>hash-max-ziplist-entries</code>：表示用压缩列表保存时哈希集合中的最大元素个数。</li><li><code>hash-max-ziplist-value</code>：表示用压缩列表保存时哈希集合中单个元素的最大长度。</li></ol><p>如果 Hash 集合中写入的元素个数超过了 <code>hash-max-ziplist-entries</code>并且写入的单个元素大小超过了 <code>hash-max-ziplist-value</code>，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表。</p><p>一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。</p><p><strong>为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash 集合中的元素个数。</strong></p><blockquote><p>所以，在二级编码中，只用图片 ID <strong>最后 3 位作为 Hash 集合的 key</strong>，也就<strong>保证了 Hash 集合的元素个数不超过 1000</strong>，同时，我们把 <code>hash-max-ziplist-entries</code>设置为 1000，这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了。</p></blockquote><h3 id="集合统计模式"><a href="#集合统计模式" class="headerlink" title="集合统计模式"></a>集合统计模式</h3><p>常见的四种统计模式，包括<strong>聚合统计、排序统计、二值状态统计和基数统计</strong></p><img src="/article/30584/%E9%9B%86%E5%90%88%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%BC%8F.jpg" class title="集合统计模式"><h4 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h4><blockquote><p>在移动应用中，需要统计每天的新增用户数和第二天的留存用户数；</p></blockquote><p>所谓的<strong>聚合统计</strong>，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。</p><blockquote><p>可以用一个集合记录所有登录过 App 的用户 ID，同时，用另一个集合记录每一天登录过 App 的用户 ID。然后，再对这两个集合做聚合统计。</p><p>记录所有登录过 App 的用户 ID 可以直接使用 Set 类型</p><ol><li>key 是 user:id 以及当天日期；</li><li>value 是 Set 集合，记录当天登录的用户 ID。</li></ol><p>这个 Set 叫作每日用户 Set，如下图所示：</p><img src="/article/30584/%E6%AF%8F%E6%97%A5%E7%94%A8%E6%88%B7set.jpg" class title="每日用户set"><ol><li><p>在统计每天的新增用户时，我们只用计算每日用户 Set 和累计用户 Set 的差集就行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">SDIFFSTORE  user:new  user:id:20200804 user:id  <br></code></pre></td></tr></table></figure><p><code>SDIFFSTORE</code> 命令计算累计用户 Set 和 20200804 Set 的差集，结果保存在 key 为 user:new 的 Set 中</p></li><li><p>计算 8 月 4 日的留存用户</p><p>计算 20200803 和 20200804 两个 Set 的交集，就可以得到同时在这两个集合中的用户 ID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SINTERSTORE user:id:rem user:id:20200803 user:id:20200804<br></code></pre></td></tr></table></figure></li></ol></blockquote><p><strong>Set 的差集、并集和交集的计算复杂度较高</strong>，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。</p><p>所以，可以从主从集群中选择一个从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了。</p><p><strong>注意：</strong></p><ol><li><p><strong>“Set数据类型，使用 <code>SUNIONSTORE</code>、<code>SDIFFSTORE</code>、<code>SINTERSTORE</code> 做并集、差集、交集时，选择一个从库进行聚合计算”。这3个命令都会在Redis中生成一个新key，而从库默认是readonly不可写的，所以这些命令只能在主库使用。想在从库上操作，可以使用 <code>SUNION</code>、<code>SDIFF</code>、<code>SINTER</code> ，这些命令可以计算出结果，但不会生成新key。</strong></p></li><li><p><strong>如果是在集群模式使用多个key聚合计算的命令，一定要注意，因为这些key可能分布在不同的实例上，多个实例之间是无法做聚合运算的，这样操作可能会直接报错或者得到的结果是错误的！</strong></p></li></ol><h4 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h4><blockquote><p>在电商网站的商品评论中，需要统计评论列表中的最新评论；</p></blockquote><p>要求集合类型能对元素保序，也就是说，集合中的元素可以按序排列，这种对元素保序的集合类型叫作有序集合。</p><p>在 Redis 常用的 4 个集合类型中（List、Hash、Set、Sorted Set），<strong>List 和 Sorted Set</strong> 就属于有序集合。</p><p><strong>List 是按照元素进入 List 的顺序进行排序的，而 Sorted Set 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。</strong></p><p><strong>使用List</strong></p><blockquote><p>每个商品对应一个 List，这个 List 包含了对这个商品的所有评论，而且会按照评论时间保存这些评论，每来一个新评论，就用 LPUSH 命令把它插入 List 的队头。</p><p>在只有一页评论的时候，我们可以很清晰地看到最新的评论，但是，在实际应用中，网站一般会分页显示最新的评论列表，一旦涉及到分页操作，List 就可能会出现问题了。</p><blockquote><p>假设当前的评论 List 是{A, B, C, D, E, F}（其中，A 是最新的评论，以此类推，F 是最早的评论），在展示第一页的 3 个评论时，可以用下面的命令，得到最新的三条评论 A、B、C：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">LRANGE product1 0 2<br>1) &quot;A&quot;<br>2) &quot;B&quot;<br>3) &quot;C&quot;<br></code></pre></td></tr></table></figure><p>但是，如果在展示第二页前，又产生了一个新评论 G，评论 G 就会被 LPUSH 命令插入到评论 List 的队头，评论 List 就变成了{G, A, B, C, D, E, F}。此时，再用刚才的命令获取第二页评论时，就会发现，评论 C 又被展示出来了，也就是 C、D、E。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">LRANGE product1 3 5<br>1) <span class="hljs-string">&quot;C&quot;</span><br>2) <span class="hljs-string">&quot;D&quot;</span><br>3) <span class="hljs-string">&quot;E&quot;</span><br></code></pre></td></tr></table></figure></blockquote></blockquote><p>List 是通过元素在 List 中的位置来排序的，当有一个新元素插入时，原先的元素在 List 中的位置都后移了一位，比如说原来在第 1 位的元素现在排在了第 2 位。</p><blockquote><p>所以，对比新元素插入前后，List 相同位置上的元素就会发生变化，用 <code>LRANGE</code> 读取时，就会读到旧元素。</p></blockquote><p><strong>使用 Sorted Set</strong></p><p>Sorted Set是根据元素的实际权重来排序和获取数据的</p><blockquote><p>按评论时间的先后给每条评论设置一个权重值，然后再把评论保存到 Sorted Set 中。Sorted Set 的 <code>ZRANGEBYSCORE</code> 命令就可以按权重排序后返回元素。这样的话，即使集合中的元素频繁更新，Sorted Set 也能通过 <code>ZRANGEBYSCORE</code> 命令准确地获取到按序排列的数据。</p><p>假设越新的评论权重越大，目前最新评论的权重是 N，我们执行下面的命令时，就可以获得最新的 10 条评论：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ZRANGEBYSCORE comments N-9 N<br></code></pre></td></tr></table></figure></blockquote><h4 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h4><blockquote><p>用户在手机 App 上的签到打卡信息：一天对应一系列用户的签到记录</p></blockquote><p>二值状态就是指集合元素的取值就<strong>只有 0 和 1 两种</strong></p><blockquote><p>在签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。这个时候，我们就可以选择 <strong>Bitmap</strong>。这是 Redis 提供的扩展数据类型。</p></blockquote><p>Bitmap 本身是<strong>用 String 类型作为底层数据结构</strong>实现的一种统计二值状态的数据类型。String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态。可以把 Bitmap 看作是一个 bit 数组。</p><p>Bitmap 提供了 <code>GETBIT/SETBIT</code> 操作，使用一个偏移值 <strong>offset</strong> 对 bit 数组的某一个 bit 位进行读和写。</p><p>Bitmap 的偏移量是从 0 开始算的，也就是说 offset 的最小值是 0。当使用 <code>SETBIT</code> 对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。Bitmap 还提供了 <code>BITCOUNT</code> 操作，用来统计这个 bit 数组中所有“1”的个数。</p><blockquote><p>统计 ID 3000 的用户在 2020 年 8 月份的签到情况</p><ol><li><p>执行命令，记录该用户 8 月 3 号已签到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SETBIT uid:sign:3000:202008 2 1 <br></code></pre></td></tr></table></figure><p>offset = 2 (从0开始 0、1、2)</p></li><li><p>检查该用户 8 月 3 日是否签到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">GETBIT uid:sign:3000:202008 2 <br></code></pre></td></tr></table></figure></li><li><p>统计该用户在 8 月份的签到次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">BITCOUNT uid:sign:3000:202008<br></code></pre></td></tr></table></figure></li></ol></blockquote><blockquote><p>如果记录了 1 亿个用户 10 天的签到情况，统计出这 10 天连续签到的用户总数吗？</p></blockquote><p>Bitmap 支持用 <code>BITOP</code> 命令对多个 Bitmap 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 Bitmap 中</p><blockquote><p>对应 bit 位做“与”操作，结果保存到了一个新的 Bitmap 中</p><ol><li>在统计 1 亿个用户连续 10 天的签到情况时，把每天的日期作为 key，每个 key 对应一个 1 亿位的 Bitmap，每一个 bit 对应一个用户当天的签到情况</li><li>对 10 个 Bitmap 做“与”操作，得到的结果也是一个 Bitmap。在这个 Bitmap 中，只有 10 天都签到的用户对应的 bit 位上的值才会是 1。</li><li>最后，我们可以用 <code>BITCOUNT</code> 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。</li></ol></blockquote><h4 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h4><blockquote><p>在网页访问记录中，需要统计独立访客（Unique Visitor，UV）量</p></blockquote><p>基数统计就是指统计一个集合中不重复的元素个数</p><blockquote><p>网页 UV 的统计有个独特的地方，就是需要去重，一个用户一天内的多次访问只能算作一次。</p></blockquote><p><strong>使用 set</strong></p><blockquote><p>有一个用户 user1 访问 page1 时，把这个信息加到 Set 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SADD page1:uv user1<br></code></pre></td></tr></table></figure><p>用户 1 再来访问时，Set 的去重功能就保证了不会重复记录用户 1 的访问次数，这样，用户 1 就算是一个独立访客。当需要统计 UV 时，可以直接用 <code>SCARD</code> 命令，这个命令会返回一个集合中的元素个数。</p><p>但是，如果 page1 非常火爆，UV 达到了千万，这个时候，一个 Set 就要记录千万个用户 ID。对于一个搞大促的电商网站而言，这样的页面可能有成千上万个，如果每个页面都用这样的一个 Set，就会<strong>消耗很大的内存空间</strong>。</p></blockquote><p><strong>使用 Hash</strong></p><blockquote><p>可以把用户 ID 作为 Hash 集合的 key，当用户访问页面时，就用 <code>HSET</code> 命令（用于设置 Hash 集合元素的值），对这个用户 ID 记录一个值“1”，表示一个独立访客，用户 1 访问 page1 后，我们就记录为 1 个独立访客，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">HSET page1:uv user1 1<br></code></pre></td></tr></table></figure><p>即使用户 1 多次访问页面，重复执行这个 HSET 命令，也只会把 user1 的值设置为 1，仍然只记为 1 个独立访客。当要统计 UV 时，我们可以用 <code>HLEN</code> 命令统计 Hash 集合中的所有元素个数。</p><p>当页面很多时，Hash 类型也会<strong>消耗很大的内存空间</strong></p></blockquote><p><strong>使用 HyperLogLog</strong></p><p><strong>HyperLogLog 是一种用于统计基数的数据集合类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。</strong></p><p>在 Redis 中，每个 HyperLogLog 只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数。</p><blockquote><p>可以用 <code>PFADD</code> 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">PFADD page1:uv user1 user2 user3 user4 user5<br></code></pre></td></tr></table></figure><p>接下来，就可以用 <code>PFCOUNT</code> 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">PFCOUNT page1:uv<br></code></pre></td></tr></table></figure></blockquote><p><strong>HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的</strong>，标准误算率是 0.81%</p><h3 id="GEO数据类型"><a href="#GEO数据类型" class="headerlink" title="GEO数据类型"></a>GEO数据类型</h3><p><strong>GEO 的底层结构</strong>:GEO 类型的底层数据结构就是用 Sorted Set 来实现的</p><p><strong>GeoHash 的编码方法</strong></p><p>为了能高效地对经纬度进行比较，Redis 采用了业界广泛使用的 GeoHash 编码方法，这个方法的基本原理就是“二分区间，区间编码”。</p><p>要对一组经纬度进行 GeoHash 编码时，要先对经度和纬度分别编码，然后再把经纬度各自的编码组合成一个最终编码。</p><p>对于一个地理位置信息来说，它的经度范围是[-180,180]。GeoHash 编码会把一个经度值编码成一个 N 位的二进制值，我们来对经度范围[-180,180]做 N 次的二分区操作，其中 N 可以自定义。<br>在进行第一次二分区时，经度范围[-180,180]会被分成两个子区间：[-180,0) 和[0,180]（称之为左、右分区）。此时，可以查看一下要编码的经度值落在了左分区还是右分区。如果是落在左分区，我们就用 0 表示；如果落在右分区，就用 1 表示。这样一来，每做完一次二分区，就可以得到 1 位编码值。<br>然后，再对经度值所属的分区再做一次二分区，同时再次查看经度值落在了二分区后的左分区还是右分区，按照刚才的规则再做 1 位编码。当做完 N 次的二分区后，经度值就可以用一个 N bit 的数来表示了。</p><blockquote><p>对（116.37，39.86）进行编码</p><img src="/article/30584/%E7%BB%8F%E5%BA%A6%E7%BC%96%E7%A0%81.jpg" class title="经度编码"><img src="/article/30584/%E7%BA%AC%E5%BA%A6%E7%BC%96%E7%A0%81.jpg" class title="纬度编码"><p>当一组经纬度值都编完码后，再把它们的各自编码值组合在一起，组合的规则是：最终编码值的<strong>偶数位上依次是经度的编码值，奇数位上依次是纬度的编码值</strong>，其中，偶数位从 0 开始，奇数位从 1 开始。</p><img src="/article/30584/%E6%9C%80%E7%BB%88%E7%BC%96%E7%A0%81%E5%80%BC.jpg" class title="最终编码值"></blockquote><p>使用 GeoHash 编码后，相当于把整个地理空间划分成了一个个方格，每个方格对应了 GeoHash 中的一个分区。</p><p>每个方格覆盖了一定范围内的经纬度值，分区越多，每个方格能覆盖到的地理空间就越小，也就越精准。</p><p><img src="/article/4 个方格.jpg"><span class="image-caption">4 个方格</span></p><p>有的编码值虽然在大小上接近，但实际对应的方格却距离比较远</p><blockquote><p><img src="/article/16 个方格.jpg"><span class="image-caption">16 个方格</span></p></blockquote><p>为了避免查询不准确问题，可以同时查询给定经纬度所在的方格周围的 4 个或 8 个方格。</p><h4 id="操作-GEO-类型"><a href="#操作-GEO-类型" class="headerlink" title="操作 GEO 类型"></a>操作 GEO 类型</h4><ol><li><code>GEOADD</code> 命令：用于把一组经纬度信息和相对应的一个 ID 记录到 GEO 类型集合中；</li><li><code>GEORADIUS</code> 命令：会根据输入的经纬度位置，查找以这个经纬度为中心的一定范围内的其他元素。当然，我们可以自己定义这个范围。</li></ol><blockquote><p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">GEOADD cars:locations 116.034579 39.030452 33<br></code></pre></td></tr></table></figure><p>LBS 位置信息服务（Location-Based Service，LBS）应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。可以修改“5”这个参数，来返回更大或更小范围内的车辆信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10<br></code></pre></td></tr></table></figure></blockquote><h3 id="自定义数据类型"><a href="#自定义数据类型" class="headerlink" title="自定义数据类型"></a>自定义数据类型</h3><p><strong>Redis 键值对中的每一个值都是用 RedisObject 保存的</strong></p><p>RedisObject 包括元数据和指针。其中，元数据的一个功能就是用来区分不同的数据类型，指针用来指向具体的数据类型的值。</p><h4 id="Redis-的基本对象结构"><a href="#Redis-的基本对象结构" class="headerlink" title="Redis 的基本对象结构"></a>Redis 的基本对象结构</h4><p>RedisObject 的内部组成包括了 type、encoding、lru 和 refcount 4 个元数据，以及 1 个 *ptr 指针。</p><ol><li>type：表示值的类型，涵盖五大基本类型；</li><li>encoding：是值的编码方式，用来表示 Redis 中实现各个基本类型的底层数据结构，例如 SDS、压缩列表、哈希表、跳表等；</li><li>lru：记录了这个对象最后一次被访问的时间，用于淘汰过期的键值对；</li><li>refcount：记录了对象的引用计数；</li><li>*ptr：是指向数据的指针。</li></ol><p><img src="/article/Redis 的基本对象结构.jpg"><span class="image-caption">Redis 的基本对象结构</span></p><p>RedisObject 结构借助 *ptr 指针，就可以指向不同的数据类型</p><h4 id="开发一个新的数据类型"><a href="#开发一个新的数据类型" class="headerlink" title="开发一个新的数据类型"></a>开发一个新的数据类型</h4><p>首先，需要为新数据类型定义好它的底层结构、type 和 encoding 属性值，然后再实现新数据类型的创建、释放函数和基本命令。</p><img src="/article/30584/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.jpg" class title="开发一个新的数据类型"><ol><li><p>定义新数据类型的底层结构</p><p>用 newtype.h 文件来保存这个新类型的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewTypeObject</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewTypeNode</span> *<span class="hljs-title">head</span>;</span> <br>    <span class="hljs-keyword">size_t</span> len; <br>&#125;NewTypeObject; <br></code></pre></td></tr></table></figure><p>其中，NewTypeNode 结构就是我们自定义的新类型的底层结构。为底层结构设计两个成员变量：一个是 Long 类型的 value 值，用来保存实际数据；一个是*next指针，指向下一个 NewTypeNode 结构。</p></li><li><p>在 RedisObject 的 type 属性中，增加这个新类型的定义</p><p>在 Redis 的 server.h 文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_STRING 0    <span class="hljs-comment">/* String object. */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_LIST 1      <span class="hljs-comment">/* List object. */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_SET 2       <span class="hljs-comment">/* Set object. */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_ZSET 3      <span class="hljs-comment">/* Sorted set object. */</span></span><br>…<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBJ_NEWTYPE 7</span><br></code></pre></td></tr></table></figure></li><li><p>开发新类型的创建和释放函数</p><p>Redis 把数据类型的创建和释放函数都定义在了 object.c 文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">robj *<span class="hljs-title">createNewTypeObject</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>   NewTypeObject *h = newtypeNew(); <br>   robj *o = createObject(OBJ_NEWTYPE,h);<br>   <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p>newtypeNew 函数,它是用来为新数据类型初始化内存结构的。这个初始化过程主要是用 zmalloc 做底层结构分配空间，以便写入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">NewTypeObject *<span class="hljs-title">newtypeNew</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    NewTypeObject *n = zmalloc(<span class="hljs-keyword">sizeof</span>(*n));<br>    n-&gt;head = <span class="hljs-literal">NULL</span>;<br>    n-&gt;len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>newtypeNew 函数涉及到新数据类型的具体创建，而 Redis 默认会为每个数据类型定义一个单独文件，实现这个类型的创建和命令操作。按照 Redis 的惯例，把 newtypeNew 函数定义在名为 t_newtype.c 的文件中。</p><p>createObject 是 Redis 本身提供的 RedisObject 创建函数，它的参数是数据类型的 type 和指向数据类型实现的指针*ptr。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">robj *<span class="hljs-title">createObject</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">void</span> *ptr)</span> </span>&#123;<br>    robj *o = zmalloc(<span class="hljs-keyword">sizeof</span>(*o));<br>    o-&gt;type = type;<br>    o-&gt;ptr = ptr;<br>    ...<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于释放函数来说，它是创建函数的反过程，是用 zfree 命令把新结构的内存空间释放掉。</p></li><li><p>开发新类型的命令操作</p><ol><li><p>在 t_newtype.c 文件中增加命令操作的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ntinsertCommand</span><span class="hljs-params">(client *c)</span></span>&#123;<br>  <span class="hljs-comment">//基于客户端传递的参数，实现在NewTypeObject链表头插入元素</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 server.h 文件中，声明我们已经实现的命令，以便在 server.c 文件引用这个命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ntinsertCommand</span><span class="hljs-params">(client *c)</span></span><br></code></pre></td></tr></table></figure></li><li><p>在 server.c 文件中的 redisCommandTable 里面，把新增命令和实现函数关联起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisCommand</span> <span class="hljs-title">redisCommandTable</span>[] =</span> &#123; <br>...<br>&#123;<span class="hljs-string">&quot;ntinsert&quot;</span>,ntinsertCommand,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;m&quot;</span>,...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="时间序列数据"><a href="#时间序列数据" class="headerlink" title="时间序列数据"></a>时间序列数据</h3><p><strong>时间序列数据的读写特点</strong></p><ol><li><p>写</p><p>时间序列数据通常是持续高并发写入的。</p><p>这种数据的写入特点很简单，就是插入数据快，这就要求选择的数据类型，在进行数据插入时，复杂度要低，尽量不要阻塞。</p></li><li><p>读</p><p>时间序列数据的“读”，查询模式多，比如范围查询、聚合查询等</p></li></ol><h4 id="基于-Hash-和-Sorted-Set-保存时间序列数据"><a href="#基于-Hash-和-Sorted-Set-保存时间序列数据" class="headerlink" title="基于 Hash 和 Sorted Set 保存时间序列数据"></a>基于 Hash 和 Sorted Set 保存时间序列数据</h4><p><strong>好处：</strong>是 Redis 内在的数据类型，代码成熟和性能稳定。所以，基于这两个数据类型保存时间序列数据，系统稳定性是可以预期的。</p><p>用 Hash 类型来实现单键的查询很简单。但是，Hash 类型有个短板：它并不支持对数据进行范围查询。</p><blockquote><p>虽然时间序列数据是按时间递增顺序插入 Hash 集合中的，但 Hash 类型的底层结构是哈希表，并没有对数据进行有序索引。所以，如果要对 Hash 类型进行范围查询的话，就需要扫描 Hash 集合中的所有数据，再把这些数据取回到客户端进行排序，然后，才能在客户端得到所查询范围内的数据。显然，查询效率很低。</p></blockquote><p>为了能同时支持按时间戳范围的查询，可以用 Sorted Set 来保存时间序列数据，因为它能够根据元素的权重分数来排序。可以把时间戳作为 Sorted Set 集合的元素分数，把时间点上记录的数据作为元素本身。</p><p><strong>保证写入 Hash 和 Sorted Set 是一个原子性的操作</strong></p><p>涉及到了 Redis 用来实现简单的事务的 <code>MULTI</code> 和 <code>EXEC</code> 命令。当多个命令及其参数本身无误时，<code>MULTI</code> 和 <code>EXEC</code> 命令可以保证执行这些命令时的原子性。</p><ol><li><code>MULTI</code> 命令：表示一系列原子性操作的开始。收到这个命令后，Redis 就知道，接下来再收到的命令需要放到一个内部队列中，后续一起执行，保证原子性。</li><li><code>EXEC</code> 命令：表示一系列原子性操作的结束。一旦 Redis 收到了这个命令，就表示所有要保证原子性的命令操作都已经发送完成了。此时，Redis 开始执行刚才放到内部队列中的所有命令操作。</li></ol><blockquote><img src="/article/30584/%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%E6%93%8D%E4%BD%9C.jpg" class title="原子性的操作"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">127.0.0.1:6379&gt; MULTI<br>OK<br><br>127.0.0.1:6379&gt; HSET device:temperature 202008030911 26.8<br>QUEUED<br><br>127.0.0.1:6379&gt; ZADD device:temperature 202008030911 26.8<br>QUEUED<br><br>127.0.0.1:6379&gt; EXEC<br>1) (<span class="hljs-built_in">integer</span>) 1<br>2) (<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure></blockquote><p><strong>对时间序列数据进行聚合计算</strong></p><blockquote><p>Sorted Set 只支持范围查询，无法直接进行聚合计算，所以，只能先把时间范围内的数据取回到客户端，然后在客户端自行完成聚合计算。这个方法虽然能完成聚合计算但是会带来一定的潜在风险，也就是大量数据在 Redis 实例和客户端间频繁传输，这会和其他操作命令竞争网络资源，导致其他操作变慢。</p></blockquote><p>为了避免客户端和 Redis 实例间频繁的大量数据传输，<strong>使用 RedisTimeSeries 来保存时间序列数据。</strong></p><p>RedisTimeSeries 支持直接在 Redis 实例上进行聚合计算。</p><h4 id="基于-RedisTimeSeries-模块保存时间序列数据"><a href="#基于-RedisTimeSeries-模块保存时间序列数据" class="headerlink" title="基于 RedisTimeSeries 模块保存时间序列数据"></a>基于 RedisTimeSeries 模块保存时间序列数据</h4><p><strong>RedisTimeSeries</strong> 是 Redis 的一个扩展模块。它专门面向时间序列数据提供了数据类型和访问接口，并且支持在 Redis 实例上直接对数据进行按时间范围的聚合计算以及按标签属性过滤查询数据集合。</p><blockquote><p>因为 RedisTimeSeries 不属于 Redis 的内建功能模块，在使用时，需要先把它的源码单独编译成动态链接库 redistimeseries.so，再使用 loadmodule 命令进行加载，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">loadmodule redistimeseries.so<br></code></pre></td></tr></table></figure></blockquote><p>RedisTimeSeries 的底层数据结构使用了链表，它的范围查询的复杂度是 O(N) 级别的，同时，它的 <code>TS.GET</code> 查询只能返回最新的数据，没有办法像 Hash 类型一样，可以返回任一时间点的数据。</p><p>当用于时间序列数据存取时，RedisTimeSeries 的操作主要有 5 个：</p><ol><li><p>用 <code>TS.CREATE</code> 命令创建时间序列数据集合；</p><p>需要设置时间序列数据集合的 key 和数据的过期时间（以毫秒为单位）。此外，还可以为数据集合设置标签，来表示数据集合的属性。</p><blockquote><p>创建一个 key 为 device:temperature、数据有效期为 600s 的时间序列数据集合。也就是说，这个集合中的数据创建了 600s 后，就会被自动删除。最后，给这个集合设置了一个标签属性{device_id:1}，表明这个数据集合中记录的是属于设备 ID 号为 1 的数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">TS.CREATE device:temperature RETENTION 600000 LABELS device_id 1<br>OK<br></code></pre></td></tr></table></figure></blockquote></li><li><p>用 <code>TS.ADD</code> 命令插入数据；</p><p><code>TS.ADD</code> 命令往时间序列集合中插入数据，包括时间戳和具体的数值</p><blockquote><p>往 device:temperature 集合中插入了一条数据，记录的是设备在 2020 年 8 月 3 日 9 时 5 分的设备温度</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">TS.ADD device:temperature 1596416700 25.1<br>1596416700<br></code></pre></td></tr></table></figure></blockquote></li><li><p>用 <code>TS.GET</code> 命令读取最新数据；</p><p>使用 <code>TS.GET</code> 命令读取数据集合中的最新一条数据</p><blockquote><p>把刚刚插入的最新数据读取出来\</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">TS.GET device:temperature<br>25.1<br></code></pre></td></tr></table></figure></blockquote></li><li><p>用 <code>TS.MGET</code> 命令按标签过滤查询数据集合；</p><p>使用 <code>TS.MGET</code> 命令，按照标签查询部分集合中的最新数据</p><p>在使用 <code>TS.CREATE</code> 创建数据集合时，可以给集合设置标签属性。进行查询时，就可以在查询条件中对集合标签属性进行匹配，最后的查询结果里只返回匹配上的集合中的最新数据。</p><blockquote><p>一共用 4 个集合为 4 个设备保存时间序列数据，设备的 ID 号是 1、2、3、4，在创建数据集合时，把 device_id 设置为每个集合的标签。此时，就可以使用下列 <code>TS.MGET</code> 命令，以及 FILTER 设置（这个配置项用来设置集合标签的过滤条件），查询 device_id 不等于 2 的所有其他设备的数据集合，并返回各自集合中的最新的一条数据。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sh">TS.MGET FILTER device_id!=2 <br>1) 1) <span class="hljs-string">&quot;device:temperature:1&quot;</span><br>   2) (empty list or <span class="hljs-built_in">set</span>)<br>   3) 1) (<span class="hljs-built_in">integer</span>) 1596417000<br>      2) <span class="hljs-string">&quot;25.3&quot;</span><br>2) 1) <span class="hljs-string">&quot;device:temperature:3&quot;</span><br>   2) (empty list or <span class="hljs-built_in">set</span>)<br>   3) 1) (<span class="hljs-built_in">integer</span>) 1596417000<br>      2) <span class="hljs-string">&quot;29.5&quot;</span><br>3) 1) <span class="hljs-string">&quot;device:temperature:4&quot;</span><br>   2) (empty list or <span class="hljs-built_in">set</span>)<br>   3) 1) (<span class="hljs-built_in">integer</span>) 1596417000<br>      2) <span class="hljs-string">&quot;30.1&quot;</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>用 <code>TS.RANGE</code> 支持聚合计算的范围查询。</p><p>在对时间序列数据进行聚合计算时，可以使用 <code>TS.RANGE</code> 命令指定要查询的数据的时间范围，同时用 <code>AGGREGATION</code> 参数指定要执行的聚合计算类型。</p><blockquote><p>按照每 180s 的时间窗口，对 2020 年 8 月 3 日 9 时 5 分和 2020 年 8 月 3 日 9 时 12 分这段时间内的数据进行均值计算</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">TS.RANGE device:temperature 1596416700 1596417120 AGGREGATION avg 180000<br>1) 1) (<span class="hljs-built_in">integer</span>) 1596416700<br>   2) <span class="hljs-string">&quot;25.6&quot;</span><br>2) 1) (<span class="hljs-built_in">integer</span>) 1596416880<br>   2) <span class="hljs-string">&quot;25.8&quot;</span><br>3) 1) (<span class="hljs-built_in">integer</span>) 1596417060<br>   2) <span class="hljs-string">&quot;26.1&quot;</span><br></code></pre></td></tr></table></figure></blockquote></li></ol><h2 id="Redis：高性能IO模型"><a href="#Redis：高性能IO模型" class="headerlink" title="Redis：高性能IO模型"></a>Redis：高性能IO模型</h2><p><strong>Redis 是单线程，主要是指 Redis 的<u>网络 IO 和键值对读写</u>是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。</strong></p><p><strong>采用单线程的一个核心原因是避免多线程开发的并发控制问题</strong></p><p>一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，这是它实现高性能的一个重要原因。</p><p>另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p><h3 id="Socket-网络模型的非阻塞模式"><a href="#Socket-网络模型的非阻塞模式" class="headerlink" title="Socket 网络模型的非阻塞模式"></a>Socket 网络模型的非阻塞模式</h3><blockquote><p>以 Get 请求为例，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。</p><img src="/article/30584/Redis%E5%9F%BA%E6%9C%ACIO%E6%A8%A1%E5%9E%8B.jpg" class title="Redis基本IO模型"><p>但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。</p></blockquote><p>在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。</p><img src="/article/30584/Redis%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AE%BE%E7%BD%AE.jpg" class title="Redis套接字类型与非阻塞设置"><p>针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 accept() 时，已经存在监听套接字了。</p><blockquote><p>要有机制继续监听监听套接字或已连接套接字，并在有数据达到时通知 Redis。</p></blockquote><h3 id="基于多路复用的高性能-I-O-模型"><a href="#基于多路复用的高性能-I-O-模型" class="headerlink" title="基于多路复用的高性能 I/O 模型"></a>基于多路复用的高性能 I/O 模型</h3><p>Linux 中的 IO 多路复用机制是指<strong>一个线程处理多个 IO 流</strong>，就是select/epoll 机制。</p><p>在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p><img src="/article/30584/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B.webp" class title="基于多路复用的Redis高性能IO模型"><p>图中的多个 FD 就是多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。</p><p><strong>回调机制</strong></p><p>为了在请求到达时能通知到 Redis 线程，<strong>select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数</strong>。</p><p>select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。</p><h2 id="Redis-的持久化（AOF）"><a href="#Redis-的持久化（AOF）" class="headerlink" title="Redis 的持久化（AOF）"></a>Redis 的持久化（AOF）</h2><h3 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h3><p>AOF（Append Only File） 日志是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志，如下图所示：</p><p><img src="/article/Redis AOF操作过程.jpg"><span class="image-caption">Redis AOF操作过程</span></p><p>AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。</p><p><strong>优点：</strong></p><ol><li><strong>写后日志</strong>这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。</li><li>它是在命令执行后才记录日志，所以不会阻塞当前的写操作。</li></ol><p><strong>风险：</strong></p><ol><li>首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</li><li>其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</li></ol><p><strong>AOF 文件过大带来的性能问题：</strong></p><ol><li>一是，文件系统本身对文件大小有限制，无法保存过大的文件；</li><li>二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；</li><li>三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用</li></ol><h3 id="AOF-三种写回策略"><a href="#AOF-三种写回策略" class="headerlink" title="AOF 三种写回策略"></a>AOF 三种写回策略</h3><p>AOF 配置项 <code>appendfsync</code> 三个可选值</p><ol><li><p>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p><p>“同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；</p></li><li><p>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p><p>“每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。</p></li><li><p>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p><p>虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；</p></li></ol><img src="/article/30584/%E4%B8%89%E7%A7%8D%E7%AD%96%E7%95%A5%E7%9A%84%E5%86%99%E5%9B%9E%E6%97%B6%E6%9C%BA%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9.jpg" class title="三种策略的写回时机，以及优缺点"><h3 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h3><p>AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。</p><p>旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。</p><blockquote><img src="/article/30584/AOF%E9%87%8D%E5%86%99%E5%87%8F%E5%B0%91%E6%97%A5%E5%BF%97%E5%A4%A7%E5%B0%8F.jpg" class title="AOF重写减少日志大小"></blockquote><p>有两个配置项在控制AOF重写的<strong>触发时机</strong>：</p><ol><li><code>auto-aof-rewrite-min-size</code>: 表示运行AOF重写时文件的最小大小，默认为64MB</li><li><code>auto-aof-rewrite-percentage</code>: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。 </li></ol><p>AOF文件大小同时超出上面这两个配置项时，会触发AOF重写。</p><p>和 AOF 日志由主线程写回不同，<strong>重写过程是由后台子进程 <em>bgrewriteaof</em> 来完成的</strong>，这也是为了避免阻塞主线程，导致数据库性能下降。</p><p><strong>一个拷贝，两处日志</strong></p><ol><li><p>“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 <strong>bgrewriteaof</strong> 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>fork采用操作系统提供的<strong>写时复制(Copy On Write)机制</strong>，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题</p><p>fork子进程时，子进程是会拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据了，此时，类似于有了父进程的所有内存数据。</p></li><li><p>“两处日志”</p><ol><li>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。</li><li>新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，就可以用新的 AOF 文件替代旧文件了。</li></ol></li></ol><img src="/article/30584/AOF%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B.jpg" class title="AOF非阻塞的重写过程"><h2 id="Redis宕机快速恢复（RDB）"><a href="#Redis宕机快速恢复（RDB）" class="headerlink" title="Redis宕机快速恢复（RDB）"></a>Redis宕机快速恢复（RDB）</h2><p><strong>内存快照</strong>。所谓内存快照，就是指内存中的数据在某一个时刻的状态记录</p><p>对 Redis 来说，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 <strong>RDB 文件</strong>，其中，RDB 就是 Redis DataBase 的缩写。</p><p>和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，可以直接把 RDB 文件读入内存，很快地完成恢复。</p><p>Redis 提供了两个命令来生成 RDB 文件：</p><ol><li>save：在主线程中执行，会导致阻塞；</li><li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的认配置。</li></ol><p><strong>关键问题：</strong></p><ol><li><p>对哪些数据做快照？这关系到快照的执行效率问题</p><p>Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是<strong>全量快照</strong>，也就是说，把内存中的所有数据都记录到磁盘中。</p></li><li><p>做快照时，数据还能被增删改吗？这关系到 Redis 是否被阻塞，能否同时正常处理请求。</p><p><strong>避免阻塞和正常处理写操作并不是一回事</strong>。主线程没有阻塞，可以正常接收请求，但是，为了保证快照完整性，它只能处理读操作，因为不能修改正在执行快照的数据。</p><p>Redis 就会借助操作系统提供的<strong>写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</strong></p><blockquote><p>bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</p><p>如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据写入 RDB 文件。</p><img src="/article/30584/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E6%9C%BA%E5%88%B6%E4%BF%9D%E8%AF%81%E5%BF%AB%E7%85%A7%E6%9C%9F%E9%97%B4%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BF%AE%E6%94%B9.jpg" class title="写时复制机制保证快照期间数据可修改"></blockquote><p>既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。</p></li><li><p>多久做一次快照？</p><p>虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销。</p><ol><li>频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li><li>bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，<strong>fork 这个创建过程本身会阻塞主线程</strong>，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了（所以，在 Redis 中如果有一个 bgsave 在运行，就不会再启动第二个 bgsave 子进程）</li></ol></li></ol><p><strong>增量快照</strong>：做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。<strong>需要记住哪些数据被修改了</strong>，需要使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。</p><p>Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。</p><p>简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><p><strong>AOF 和 RDB 的选择问题：</strong></p><ol><li>数据不能丢失时，选择内存快照和 AOF 的混合使用；</li><li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li><li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li></ol><h2 id="Redis数据同步"><a href="#Redis数据同步" class="headerlink" title="Redis数据同步"></a><a href="https://juejin.cn/post/6981744631000072205">Redis数据同步</a></h2><p>Redis 具有高可靠性：</p><ol><li><p>一是数据尽量少丢失</p><p>AOF 和 RDB 保证</p></li><li><p>二是服务尽量少中断</p><p>增加副本冗余量，将一份数据同时保存在多个实例上。即使有一个实例出现了故障，需要过一段时间才能恢复，其他实例也可以对外提供服务，不会影响业务使用。</p></li></ol><p>Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式</p><ol><li>读操作：主库、从库都可以接收；</li><li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li></ol><img src="/article/30584/Redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.jpg" class title="Redis主从库和读写分离"><h3 id="主从库间进行第一次同步"><a href="#主从库间进行第一次同步" class="headerlink" title="主从库间进行第一次同步"></a>主从库间进行第一次同步</h3><p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 <code>replicaof</code>（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p><blockquote><p>实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5），在实例 2 上执行以下这个命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">replicaof  172.16.19.3  6379<br></code></pre></td></tr></table></figure></blockquote><img src="/article/30584/%E4%B8%BB%E4%BB%8E%E5%BA%93%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5%E7%9A%84%E6%B5%81%E7%A8%8B.jpg" class title="主从库第一次同步的流程"><ol><li><p>第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p><p>从库给主库发送 <code>psync</code> 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。<code>psync</code> 命令包含了主库的 <code>runID</code> 和复制进度 <code>offset</code> 两个参数。</p><ol><li>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。</li><li>offset，此时设为 -1，表示第一次复制。</li></ol><p>主库收到 <code>psync</code> 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 <code>runID</code>和主库目前的复制进度 <code>offset</code>，返回给从库。从库收到响应后，会记录下这两个参数。</p><p><strong>FULLRESYNC 响应表示第一次复制采用的全量复制</strong>，也就是说，主库会把当前所有的数据都复制给从库。</p></li><li><p>在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p><p>主库执行 <code>bgsave</code> 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 <code>replicaof</code> 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。</p><p>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 <strong>replication buffer</strong>，记录 RDB 文件生成后收到的所有写操作。</p></li><li><p>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 <strong>replication buffer</strong> 中的修改操作发给从库，从库再重新执行这些操作。</p></li></ol><h3 id="主从级联模式分担全量复制时的主库压力"><a href="#主从级联模式分担全量复制时的主库压力" class="headerlink" title="主从级联模式分担全量复制时的主库压力"></a>主从级联模式分担全量复制时的主库压力</h3><blockquote><p><strong>问题：</strong>一次全量复制中，对于主库来说，需要完成两个耗时的操作：<strong>生成 RDB 文件和传输 RDB 文件</strong>。如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。<u>fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢</u>。<u>此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力</u>。</p></blockquote><p>通过<strong>“主 - 从 - 从”</strong>模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。</p><p>在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">replicaof  所选从库的IP 6379<br></code></pre></td></tr></table></figure><p>在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力</p><img src="/article/30584/%E7%BA%A7%E8%81%94%E7%9A%84%E2%80%9C%E4%B8%BB-%E4%BB%8E-%E4%BB%8E%E2%80%9D%E6%A8%A1%E5%BC%8F.jpg" class title="级联的“主-从-从”模式"><h3 id="主从库间网络中断"><a href="#主从库间网络中断" class="headerlink" title="主从库间网络中断"></a>主从库间网络中断</h3><blockquote><p>在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。</p></blockquote><p>从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步，只会把主从库网络断连期间主库收到的命令，同步给从库。</p><p>当主从库断连后，主库会把断连期间收到的写操作命令，写入 <strong>replication buffer</strong>，同时也会把这些操作命令也写入 <strong>repl_backlog_buffer</strong>这个缓冲区。</p><p>只要有从库存在，这个 <strong>repl_backlog_buffer</strong> 就会存在。主库的所有写命令除了传播给从库之外，都会在这个 <strong>repl_backlog_buffer</strong> 中记录一份，缓存起来，只有预先缓存了这些命令，当从库断连后，从库重新发送 <code>psync <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.049ex" height="2.509ex" style="vertical-align: -0.671ex;" viewbox="0 -791.3 5618.3 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title"><title id="MathJax-SVG-1-Title">master_runid </title><defs aria-hidden="true"><path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/><path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/><path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/><path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/><path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true"> <use xlink:href="#E1-MJMATHI-6D" x="0" y="0"/> <use xlink:href="#E1-MJMATHI-61" x="878" y="0"/> <use xlink:href="#E1-MJMATHI-73" x="1408" y="0"/> <use xlink:href="#E1-MJMATHI-74" x="1877" y="0"/> <use xlink:href="#E1-MJMATHI-65" x="2239" y="0"/><g transform="translate(2705,0)"> <use xlink:href="#E1-MJMATHI-72" x="0" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-72" x="638" y="-213"/></g> <use xlink:href="#E1-MJMATHI-75" x="3576" y="0"/> <use xlink:href="#E1-MJMATHI-6E" x="4148" y="0"/> <use xlink:href="#E1-MJMATHI-69" x="4749" y="0"/> <use xlink:href="#E1-MJMATHI-64" x="5094" y="0"/></g></svg>offset</code>，主库才能通过 <code><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="65.473ex" height="3.343ex" style="vertical-align: -1.171ex;" viewbox="0 -934.9 28189.8 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title"><title id="MathJax-SVG-1-Title">offset` 在 **repl_backlog_buffer** 中找到从库断开的位置，只发送`</title><defs aria-hidden="true"><path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/><path stroke-width="1" id="E1-MJMATHI-66" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/><path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/><path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/><path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/><path stroke-width="1" id="E1-MJMAIN-2018" d="M64 494Q64 548 86 597T131 670T160 694Q163 694 172 685T182 672Q182 669 170 656T144 625T116 573T101 501Q101 489 102 489T107 491T120 497T138 500Q163 500 180 483T198 440T181 397T139 379Q110 379 87 405T64 494Z"/><path stroke-width="1" id="E1-MJMAIN-2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/><path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path stroke-width="1" id="E1-MJMATHI-6C" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path stroke-width="1" id="E1-MJMATHI-62" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/><path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/><path stroke-width="1" id="E1-MJMATHI-63" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/><path stroke-width="1" id="E1-MJMATHI-6B" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path stroke-width="1" id="E1-MJMATHI-67" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/><path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true"> <use xlink:href="#E1-MJMATHI-6F" x="0" y="0"/> <use xlink:href="#E1-MJMATHI-66" x="485" y="0"/> <use xlink:href="#E1-MJMATHI-66" x="1036" y="0"/> <use xlink:href="#E1-MJMATHI-73" x="1586" y="0"/> <use xlink:href="#E1-MJMATHI-65" x="2056" y="0"/> <use xlink:href="#E1-MJMATHI-74" x="2522" y="0"/> <use xlink:href="#E1-MJMAIN-2018" x="2884" y="0"/><g transform="translate(3162,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">在</text></g> <use xlink:href="#E1-MJMAIN-2217" x="4317" y="0"/> <use xlink:href="#E1-MJMAIN-2217" x="5040" y="0"/> <use xlink:href="#E1-MJMATHI-72" x="5540" y="0"/> <use xlink:href="#E1-MJMATHI-65" x="5992" y="0"/> <use xlink:href="#E1-MJMATHI-70" x="6458" y="0"/><g transform="translate(6962,0)"> <use xlink:href="#E1-MJMATHI-6C" x="0" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-62" x="422" y="-213"/></g> <use xlink:href="#E1-MJMATHI-61" x="7664" y="0"/> <use xlink:href="#E1-MJMATHI-63" x="8194" y="0"/> <use xlink:href="#E1-MJMATHI-6B" x="8627" y="0"/> <use xlink:href="#E1-MJMATHI-6C" x="9149" y="0"/> <use xlink:href="#E1-MJMATHI-6F" x="9447" y="0"/><g transform="translate(9933,0)"> <use xlink:href="#E1-MJMATHI-67" x="0" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-62" x="675" y="-213"/></g> <use xlink:href="#E1-MJMATHI-75" x="10814" y="0"/> <use xlink:href="#E1-MJMATHI-66" x="11386" y="0"/> <use xlink:href="#E1-MJMATHI-66" x="11937" y="0"/> <use xlink:href="#E1-MJMATHI-65" x="12487" y="0"/> <use xlink:href="#E1-MJMATHI-72" x="12954" y="0"/> <use xlink:href="#E1-MJMAIN-2217" x="13627" y="0"/> <use xlink:href="#E1-MJMAIN-2217" x="14350" y="0"/><g transform="translate(14851,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">中</text></g><g transform="translate(15784,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">找</text></g><g transform="translate(16716,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">到</text></g><g transform="translate(17649,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">从</text></g><g transform="translate(18582,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">库</text></g><g transform="translate(19515,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">断</text></g><g transform="translate(20448,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">开</text></g><g transform="translate(21381,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">的</text></g><g transform="translate(22314,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">位</text></g><g transform="translate(23246,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">置</text></g><g transform="translate(24179,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">，</text></g><g transform="translate(25112,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">只</text></g><g transform="translate(26045,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">发</text></g><g transform="translate(26978,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">送</text></g> <use xlink:href="#E1-MJMAIN-2018" x="27911" y="0"/></g></svg>offset</code> 之后的增量数据给从库即可。</p><p><strong>注意连接没有断开的时候，这两个缓冲区是同时存在，如果连接断开，那么对应Slave的replication buffer缓冲区就会被删除</strong>。</p><p><strong>repl_backlog_buffer</strong> 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。</p><ol><li>开始时，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，通常用<strong>偏移量</strong>来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是 <code>master_repl_offset</code>。主库接收的新写操作越多，这个值就会越大。</li><li>同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 <code>slave_repl_offset</code> 也在不断增加。正常情况下，这两个偏移量基本相等。</li><li>主从库的连接恢复之后，从库首先会给主库发送 <code>psync</code> 命令，并把自己当前的 <code>slave_repl_offset</code> 发给主库，主库会判断自己的 <code>master_repl_offset</code> 和 <code>slave_repl_offset</code> 之间的差距。 </li></ol><blockquote><ol><li><p><strong>repl_backlog_buffer</strong>：是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量同步带来的性能开销。如果从库断开时间太久， <strong>repl_backlog_buffer</strong> 环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量同步，所以 <strong>repl_backlog_buffer</strong> 配置尽量大一些，可以降低主从断开后全量同步的概率。</p></li><li><p><strong>replication buffer</strong>：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个内存 buffer 进行数据交互，客户端是一个 client，从库也是一个 client，我们每个 client 连上 Redis 后，Redis 都会分配一个 <strong>client buffer</strong>，所有数据交互都是通过这个 buffer 进行的：Redis先把数据写到这个buffer中，然后再把 buffer 中的数据发到 client socket 中再通过网络发送出去，这样就完成了数据交互。</p><p>所以主从在增量同步时，从库作为一个 client，也会分配一个 buffer，只不过这个 buffer 专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做 replication buffer</p></li><li><p>既然有这个内存 buffer 存在，那么这个 buffer 有没有限制呢？</p><p>如果主从在传播命令时，因为某些原因从库处理得非常慢，那么主库上的这个 buffer 就会持续增长，消耗大量的内存资源，甚至 OOM。所以Redis提供了<code>client-output-buffer-limit</code>参数限制这个 buffer 的大小，如果超过限制，主库会强制断开这个client的连接，也就是说从库处理慢导致主库内存buffer 的积压达到限制后，主库会强制断开从库的连接，此时主从复制会中断，中断后如果从库再次发起复制请求，那么此时可能会导致恶性循环，引发复制风暴，这种情况需要格外注意。</p></li></ol></blockquote><p>因为 <strong>repl_backlog_buffer</strong> 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。</p><p>可以调整 <code>repl_backlog_size</code> 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：<strong>缓冲空间大小 = 主库写入命令速度 <em> 操作大小 - 主从库间网络传输命令速度 </em> 操作大小</strong>。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 <strong>repl_backlog_size = 缓冲空间大小 * 2</strong>，这也就是 <code>repl_backlog_size</code> 的最终值。</p><blockquote><p>如果主库每秒写入 2000 个操作，每个操作的大小为 2KB，网络每秒能传输 1000 个操作，那么，有 1000 个操作需要缓冲起来，这就至少需要 2MB 的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，我们最终把 repl_backlog_size 设为 4MB。</p></blockquote><h2 id="Redis哨兵机制"><a href="#Redis哨兵机制" class="headerlink" title="Redis哨兵机制"></a>Redis哨兵机制</h2><img src="/article/30584/%E4%B8%BB%E5%BA%93%E6%95%85%E9%9A%9C%E5%90%8E%E4%BB%8E%E5%BA%93%E6%97%A0%E6%B3%95%E6%9C%8D%E5%8A%A1%E5%86%99%E6%93%8D%E4%BD%9C.jpg" class title="主库故障后从库无法服务写操作"><h3 id="哨兵机制的基本流程"><a href="#哨兵机制的基本流程" class="headerlink" title="哨兵机制的基本流程"></a>哨兵机制的基本流程</h3><p>哨兵主要负责的就是三个任务：<strong>监控、选择主库和通知</strong></p><ol><li>监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</li><li>选择主库是主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。</li><li>通知是指哨兵会把新主库的连接信息发给其他从库，让它们执行 <code>replicaof</code> 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</li></ol><img src="/article/30584/%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%89%E9%A1%B9%E4%BB%BB%E5%8A%A1%E4%B8%8E%E7%9B%AE%E6%A0%87.jpg" class title="哨兵机制的三项任务与目标"><p><strong>主观下线和客观下线</strong></p><ol><li><p>主观下线</p><p>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“<strong>主观下线</strong>”。</p><ol><li>如果检测的是从库，那么，哨兵简单地把它标记为“主观下线”</li><li>如果检测的是主库，那么，哨兵还不能简单地把它标记为“主观下线”，开启主从切换。因为很有可能存在这么一个情况：那就是哨兵误判了，其实主库并没有故障。可是，一旦启动了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销。</li></ol></li></ol><p>哨兵机制通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p><ol start="2"><li><p>客观下线</p><p>在判断主库是否下线时，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”，这个叫法也是表明主库下线成为一个客观事实了。这个判断原则就是：少数服从多数。</p><p>“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。</p></li></ol><p><strong>选定新主库</strong></p><p>筛选 + 打分</p><img src="/article/30584/%E6%96%B0%E4%B8%BB%E5%BA%93%E7%9A%84%E9%80%89%E6%8B%A9%E8%BF%87%E7%A8%8B.jpg" class title="新主库的选择过程"><ol><li><p>筛选的条件</p><ol><li><p>检查从库的当前在线状态</p></li><li><p>判断它之前的网络连接状态</p><blockquote><p>使用配置项 <code>down-after-milliseconds * 10</code>。其中，down-after-milliseconds 是认定主从库断连的最大连接超时时间。</p><p>如果在 <code>down-after-milliseconds</code> 毫秒内，主从节点都没有通过网络联系上，就可以认为主从节点断连了。</p><p>如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库。</p></blockquote></li></ol></li><li><p>从库打分</p><p>分别按照三个规则依次进行三轮打分，这三个规则分别是从库优先级、从库复制进度以及从库 ID 号。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。</p><ol><li><p>第一轮：优先级最高的从库得分高</p><blockquote><p>用户可以通过 <code>slave-priority</code> 配置项，给不同的从库设置不同优先级。</p></blockquote></li><li><p>第二轮：和旧主库同步程度最接近的从库得分高</p><blockquote><p>有从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库</p></blockquote></li><li><p>第三轮：ID 号小的从库得分高</p><blockquote><p>每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号。目前，Redis 在选主库时，有一个默认的规定：在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。</p></blockquote></li></ol></li></ol><h3 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h3><p>一旦多个实例组成了<strong>哨兵集群</strong>，即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作，包括判定主库是不是处于下线状态，选择新主库，以及通知从库和客户端。</p><h4 id="基于-pub-sub-机制的哨兵集群组成"><a href="#基于-pub-sub-机制的哨兵集群组成" class="headerlink" title="基于 pub/sub 机制的哨兵集群组成"></a>基于 pub/sub 机制的哨兵集群组成</h4><p>哨兵实例之间可以相互发现，要归功于 Redis 提供的 <strong>pub/sub 机制</strong>，也就是发布 / 订阅机制。</p><p>哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。</p><p>只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换。</p><img src="/article/30584/%E5%93%A8%E5%85%B5%E4%B9%8B%E9%97%B4%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.jpg" class title="哨兵之间建立连接"><h4 id="哨兵获取从库的-IP-地址和端口"><a href="#哨兵获取从库的-IP-地址和端口" class="headerlink" title="哨兵获取从库的 IP 地址和端口"></a>哨兵获取从库的 IP 地址和端口</h4><p><strong>哨兵向主库发送 <code>INFO</code> 命令来获取从库的 IP 地址和端口</strong></p><p><img src="/article/哨兵获取从库的 IP 地址和端口.jpg"><span class="image-caption">哨兵获取从库的 IP 地址和端口</span></p><p>哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。</p><h4 id="基于-pub-sub-机制的客户端事件通知"><a href="#基于-pub-sub-机制的客户端事件通知" class="headerlink" title="基于 pub/sub 机制的客户端事件通知"></a>基于 pub/sub 机制的客户端事件通知</h4><p>从本质上说，哨兵就是一个运行在特定模式下的 Redis 实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。</p><img src="/article/30584/%E5%85%B3%E9%94%AE%E4%BA%8B%E4%BB%B6.jpg" class title="关键事件"><p>客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。</p><blockquote><p>订阅“所有实例进入客观下线状态的事件”：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SUBSCRIBE +odown<br></code></pre></td></tr></table></figure><p>订阅所有的事件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">PSUBSCRIBE  *<br></code></pre></td></tr></table></figure></blockquote><p>当哨兵把新主库选择出来后，客户端就会看到下面的 switch-master 事件。这个事件表示主库已经切换了，新主库的 IP 地址和端口信息已经有了。这个时候，客户端就可以用这里面的新主库地址和端口进行通信了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">switch-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;<br></code></pre></td></tr></table></figure><h4 id="由哪个哨兵执行主从切换？"><a href="#由哪个哨兵执行主从切换？" class="headerlink" title="由哪个哨兵执行主从切换？"></a>由哪个哨兵执行主从切换？</h4><p>哨兵集群要判定主库“客观下线”，需要有一定数量的实例都认为该主库已经“主观下线”了。</p><p>任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 <code>is-master-down-by-addr</code> 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。</p><img src="/article/30584/%E5%8F%91%E9%80%81%E4%B8%8B%E7%BA%BF%E6%8A%95%E7%A5%A8.jpg" class title="发送下线投票"><p>一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。这个所需的赞成票数是通过哨兵配置文件中的 <strong>quorum 配置</strong>项设定的。</p><p>此时，这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为<strong>“Leader 选举”</strong>。因为最终执行主从切换的哨兵称为 Leader，投票过程就是确定 Leader。</p><p>在投票过程中，任何一个想成为 Leader 的哨兵，要满足两个条件：</p><ol><li>第一，<strong>拿到半数以上的赞成票；</strong></li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 <strong>quorum 值</strong>。</li></ol><blockquote><p>需要注意的是，如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得 2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，<strong>通常至少会配置 3 个哨兵实例</strong>。</p></blockquote><h2 id="Redis切片集群"><a href="#Redis切片集群" class="headerlink" title="Redis切片集群"></a>Redis切片集群</h2><p><strong>切片集群，也叫分片集群</strong>，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。</p><p>采用多个实例保存数据切片后，我们既能保存大量数据，又避免了 fork 子进程阻塞主线程而导致的响应突然变慢。</p><p>Redis 应对数据量增多的两种方案：纵向扩展（scale up）和横向扩展（scale out）。</p><ol><li><p>纵向扩展：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。</p><blockquote><p>优点：实施起来简单、直接</p><p>缺点：</p><ol><li>当使用 RDB 对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程 fork 子进程时就可能会阻塞</li><li>纵向扩展会受到硬件和成本的限制</li></ol></blockquote></li><li><p>横向扩展：横向增加当前 Redis 实例的个数。</p></li></ol><img src="/article/30584/%E7%BA%B5%E5%90%91%E6%89%A9%E5%B1%95%E5%92%8C%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95.jpg" class title="纵向扩展和横向扩展"><h3 id="数据切片和实例的对应分布关系（Redis-Cluster）"><a href="#数据切片和实例的对应分布关系（Redis-Cluster）" class="headerlink" title="数据切片和实例的对应分布关系（Redis Cluster）"></a>数据切片和实例的对应分布关系（Redis Cluster）</h3><p>切片集群是一种保存大量数据的通用机制，从 Redis 3.0 开始，官方提供了一个名为 <strong>Redis Cluster</strong> 的方案，用于实现切片集群。</p><p>Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和实例之间的映射关系。</p><p>在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</p><p>具体的映射过程：</p><ol><li>首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；</li><li>然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li></ol><p>哈希槽如何被映射到具体的 Redis 实例：</p><ol><li><p>在部署 Redis Cluster 方案时，可以使用 <code>cluster create</code> 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。</p></li><li><p>也可以使用 <code>cluster meet</code> 命令手动建立实例间的连接，形成集群，再使用 <code>cluster addslots</code> 命令，指定每个实例上的哈希槽个数。</p><blockquote><img src="/article/30584/%E6%89%8B%E5%8A%A8%E5%88%86%E9%85%8D%E5%93%88%E5%B8%8C%E6%A7%BD.jpg" class title="手动分配哈希槽"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1<br>redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3<br>redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4<br></code></pre></td></tr></table></figure></blockquote><p><strong>在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</strong></p></li></ol><h3 id="客户端定位数据"><a href="#客户端定位数据" class="headerlink" title="客户端定位数据"></a>客户端定位数据</h3><p>在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，要进一步定位到实例，还需要知道哈希槽分布在哪个实例上。</p><p>一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。<strong>Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。</strong></p><p>客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p><p><strong>实例和哈希槽的对应关系会发生变化：</strong></p><ol><li>在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；</li><li>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</li></ol><blockquote><p><strong>问题：实例和哈希槽的对应关系会发生变化后，实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是，客户端是无法主动感知这些变化的。这就会导致，它缓存的分配信息和最新的分配信息就不一致了</strong></p><p><strong>Redis Cluster</strong> 方案提供了一种<strong>重定向机制</strong>，所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。</p><p>当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 <strong>MOVED 命令响应结果</strong>，这个结果中就包含了新实例的访问地址。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">GET hello:key<br>(error) MOVED 13320 172.16.19.5:6379<br></code></pre></td></tr></table></figure><p>其中，MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 这个实例上。通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。</p><img src="/article/30584/%E5%AE%A2%E6%88%B7%E7%AB%AFMOVED%E9%87%8D%E5%AE%9A%E5%90%91%E5%91%BD%E4%BB%A4.jpg" class title="客户端MOVED重定向命令"><blockquote><p><strong>问题：如果 Slot 2 中的数据比较多，就可能会出现一种情况：客户端向实例 2 发送请求，但此时，Slot 2 中的数据只有一部分迁移到了实例 3，还有部分数据没有迁移</strong></p><p>在这种迁移部分完成的情况下，客户端就会收到一条 <strong>ASK 报错信息</strong>，如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">GET hello:key<br>(error) ASK 13320 172.16.19.5:6379<br></code></pre></td></tr></table></figure><p>这个结果中的 ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 这个实例上，但是这个哈希槽正在迁移。此时，客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送 GET 命令，以读取数据。</p><img src="/article/30584/%E5%AE%A2%E6%88%B7%E7%AB%AFASK%E9%87%8D%E5%AE%9A%E5%90%91%E5%91%BD%E4%BB%A4.jpg" class title="客户端ASK重定向命令"><p><strong>ASK 命令表示两层含义</strong>：第一，表明 Slot 数据还在迁移中；第二，ASK 命令把客户端所请求数据的最新实例地址返回给客户端</p><p><strong>和 MOVED 命令不同，ASK 命令并不会更新客户端缓存的哈希槽分配信息。</strong></p><p>如果客户端再次请求 Slot 2 中的数据，它还是会给实例 2 发送请求。这也就是说，<strong>ASK 命令的作用只是让客户端能给新实例发送一次请求</strong>，而不像 <strong>MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。</strong></p></blockquote></blockquote><h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><p>在分布式系统中，当两个组件要基于消息队列进行通信时，一个组件会把要处理的数据以消息的形式传递给消息队列，然后，这个组件就可以继续执行其他操作了；远端的另一个组件从消息队列中把消息读取出来，再在本地进行处理。</p><p><strong>消息队列在存取消息时，必须要满足三个需求：</strong></p><ol><li>消息保序</li><li>处理重复的消息</li><li>保证消息可靠性</li></ol><p><img src="/article/List 和 Streams 实现消息队列的特点和区别.jpg"><span class="image-caption">List 和 Streams 实现消息队列的特点和区别</span></p><h3 id="基于-List-的消息队列解决方案"><a href="#基于-List-的消息队列解决方案" class="headerlink" title="基于 List 的消息队列解决方案"></a>基于 List 的消息队列解决方案</h3><p><strong>顺序读取</strong></p><p>List 本身就是按先进先出的顺序对数据进行存取的</p><p>生产者可以使用 <code>LPUSH</code> 命令把要发送的消息依次写入 List，而消费者则可以使用 <code>RPOP</code> 命令，从 List 的另一端按照消息的写入顺序，依次读取消息并进行处理。</p><blockquote><p><strong>性能风险:</strong></p><p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code> 命令（比如使用一个 while(1) 循环）。如果有新消息写入，<code>RPOP</code> 命令就会返回结果，否则，<code>RPOP</code> 命令返回空值，再继续循环。</p><p>所以，即使没有新消息写入 List，消费者也要不停地调用 <code>RPOP</code> 命令，这就会导致消费者程序的 CPU 一直消耗在执行 <code>RPOP</code> 命令上，带来不必要的性能损失。</p></blockquote><p>Redis 提供了 <code>BRPOP</code> 命令。<code>BRPOP</code> 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。</p><p><strong>重复消息判断</strong></p><ol><li><p>消息队列要能给每一个消息提供全局唯一的 ID 号</p></li><li><p>消费者程序要把已经处理过的消息的 ID 号记录下来</p><p>幂等性就是指，对于同一条消息，消费者收到一次的处理结果和收到多次的处理结果是一致的。</p></li></ol><blockquote><p>List 本身是不会为每个消息生成 ID 号的，所以，消息的全局唯一 ID 号就需要生产者程序在发送消息前自行生成。生成之后，用 <code>LPUSH</code> 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p></blockquote><p><strong>消息可靠性</strong></p><p>List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p><p><img src="/article/List 类型BRPOPLPUSH命令.jpg"><span class="image-caption">List 类型BRPOPLPUSH命令</span></p><blockquote><p><strong>问题：</strong>生产者消息发送很快，而消费者处理消息的速度比较慢，这就导致 List 中的消息越积越多，给 Redis 的内存带来很大压力。</p></blockquote><h3 id="基于-Streams-的消息队列解决方案"><a href="#基于-Streams-的消息队列解决方案" class="headerlink" title="基于 Streams 的消息队列解决方案"></a>基于 Streams 的消息队列解决方案</h3><p>Streams 是 Redis 专门为消息队列设计的数据类型</p><ol><li><p><code>XADD</code>：插入消息，保证有序，可以自动生成全局唯一 ID；</p><p>消息的格式是<strong>键 - 值</strong>对形式。对于插入的每一条消息，Streams 可以自动为其生成一个全局唯一的 ID。</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">XADD mqstream * repo 5<br><span class="hljs-string">&quot;1599203861727-0&quot;</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>消息队列名称后面的*，表示让 Redis 为插入的数据自动生成一个全局唯一的 ID</strong></p><blockquote><p>消息的全局唯一 ID 由两部分组成</p><p>第一部分“1599203861727”是数据插入时，以毫秒为单位计算的当前服务器时间</p><p>第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1599203861727-0”就表示在“1599203861727”毫秒内的第 1 条消息。</p></blockquote></li><li><p><code>XREAD</code>：用于读取消息，可以按 ID 读取数据；</p><p>读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取。</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">XREAD BLOCK 100 STREAMS  mqstream 1599203861727-0<br>1) 1) <span class="hljs-string">&quot;mqstream&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1599274912765-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;3&quot;</span><br>      2) 1) <span class="hljs-string">&quot;1599274925823-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;2&quot;</span><br>      3) 1) <span class="hljs-string">&quot;1599274927910-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure><p>从 ID 号为 1599203861727-0 的消息开始，读取后续的所有消息</p></blockquote><p>在调用 <code>XRAED</code> 时设定 block 配置项，实现类似于 <code>BRPOP</code> 的阻塞读取操作。当消息队列中没有消息时，一旦设置了 block 配置项，<code>XREAD</code> 就会阻塞，阻塞的时长可以在 block 配置项进行设置。</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">XREAD block 10000 streams mqstream $<br>(nil)<br>(10.00s)<br></code></pre></td></tr></table></figure><p>设置了 block 10000 的配置项，10000 的单位是毫秒，表明 <code>XREAD</code> 在读取最新消息时，如果没有消息到来，<code>XREAD</code> 将阻塞 10000 毫秒（即 10 秒），然后再返回</p></blockquote><p>命令最后的“$”符号表示读取最新的消息</p></li><li><p><code>XREADGROUP</code>：按消费组形式读取消息；</p><p>创建消费组之后，Streams 可以使用 <code>XREADGROUP</code> 命令让消费组内的消费者读取消息</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">XGROUP create mqstream group1 0<br>OK<br></code></pre></td></tr></table></figure><p>创建一个名为 group1 的消费组，这个消费组消费的消息队列是 mqstream</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">XREADGROUP group group1 consumer1 streams mqstream &gt;<br>1) 1) <span class="hljs-string">&quot;mqstream&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1599203861727-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;5&quot;</span><br>      2) 1) <span class="hljs-string">&quot;1599274912765-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;3&quot;</span><br>      3) 1) <span class="hljs-string">&quot;1599274925823-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;2&quot;</span><br>      4) 1) <span class="hljs-string">&quot;1599274927910-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure><p>group1 消费组里的消费者 consumer1 从 mqstream 中读取所有消息，其中，命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取</p></blockquote><p><strong>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了</strong></p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;<br>1) 1) <span class="hljs-string">&quot;mqstream&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1599203861727-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;5&quot;</span><br><br>XREADGROUP group group2 consumer2 count 1 streams mqstream &gt;<br>1) 1) <span class="hljs-string">&quot;mqstream&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1599274912765-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;3&quot;</span><br><br>XREADGROUP group group2 consumer3 count 1 streams mqstream &gt;<br>1) 1) <span class="hljs-string">&quot;mqstream&quot;</span><br>   2) 1) 1) <span class="hljs-string">&quot;1599274925823-0&quot;</span><br>         2) 1) <span class="hljs-string">&quot;repo&quot;</span><br>            2) <span class="hljs-string">&quot;2&quot;</span><br></code></pre></td></tr></table></figure><p>group2 中的 consumer1、2、3 各自读取一条消息</p></blockquote></li><li><p><code>XPENDING</code> 和 <code>XACK</code>：<code>XPENDING</code> 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 <code>XACK</code> 命令用于向消息队列确认消息处理已完成。</p><p>为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 <code>XACK</code> 命令通知 Streams“消息已经处理完成”。</p><p>如果消费者没有成功处理消息，它就不会给 Streams 发送 <code>XACK</code> 命令，消息仍然会留存。此时，消费者可以在重启后，用 <code>XPENDING</code> 命令查看已读取、但尚未确认处理完成的消息。</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">XPENDING mqstream group2<br>1) (<span class="hljs-built_in">integer</span>) 3<br>2) <span class="hljs-string">&quot;1599203861727-0&quot;</span><br>3) <span class="hljs-string">&quot;1599274925823-0&quot;</span><br>4) 1) 1) <span class="hljs-string">&quot;consumer1&quot;</span><br>      2) <span class="hljs-string">&quot;1&quot;</span><br>   2) 1) <span class="hljs-string">&quot;consumer2&quot;</span><br>      2) <span class="hljs-string">&quot;1&quot;</span><br>   3) 1) <span class="hljs-string">&quot;consumer3&quot;</span><br>      2) <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure><p>查看 group2 中各个消费者已读取、但尚未确认的消息个数</p><p><code>XPENDING</code> 返回结果的第二、三行分别表示 group2 中所有消费者读取的消息最小 ID 和最大 ID。</p></blockquote><blockquote><p>进一步查看某个消费者具体读取了哪些数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">XPENDING mqstream group2 - + 10 consumer2<br>1) 1) <span class="hljs-string">&quot;1599274912765-0&quot;</span><br>   2) <span class="hljs-string">&quot;consumer2&quot;</span><br>   3) (<span class="hljs-built_in">integer</span>) 513336<br>   4) (<span class="hljs-built_in">integer</span>) 1<br></code></pre></td></tr></table></figure><p>consumer2 已读取的消息的 ID 是 1599274912765-0</p></blockquote></li></ol><h2 id="Redis性能影响因素"><a href="#Redis性能影响因素" class="headerlink" title="Redis性能影响因素"></a>Redis性能影响因素</h2><h3 id="Redis-内部的阻塞式操作-以及-异步机制"><a href="#Redis-内部的阻塞式操作-以及-异步机制" class="headerlink" title="Redis 内部的阻塞式操作 以及 异步机制"></a>Redis 内部的阻塞式操作 以及 异步机制</h3><h4 id="Redis-内部的阻塞式操作"><a href="#Redis-内部的阻塞式操作" class="headerlink" title="Redis 内部的阻塞式操作"></a>Redis 内部的阻塞式操作</h4><p><strong>Redis 实例交互的对象，以及交互时会发生的操作：</strong></p><ol><li>客户端：网络 IO，键值对增删改查操作，数据库操作；</li><li>磁盘：生成 RDB 快照，记录 AOF 日志，AOF 日志重写；</li><li>主从节点：主库生成、传输 RDB 文件，从库接收 RDB 文件、清空数据库、加载 RDB 文件；</li><li>切片集群实例：向其他实例传输哈希槽信息，数据迁移。</li></ol><p><img src="/article/Redis 实例交互的对象，以及交互时会发生的操作.jpg"><span class="image-caption">Redis 实例交互的对象，以及交互时会发生的操作</span></p><p><strong>Redis 实例阻塞点：</strong></p><ol><li><p>和客户端交互时的阻塞点</p><p>键值对的增删改查操作是 Redis 和客户端交互的主要部分，<strong>复杂度高的增删改查操作</strong>肯定会阻塞 Redis。</p><p>最基本的标准，就是看操作的复杂度是否为 O(N)。</p><ol><li><p>集合全量查询和聚合操作</p></li><li><p>bigkey 删除操作</p><p>删除操作的<strong>本质是要释放键值对占用的内存空间</strong>。首先释放内存，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序，所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞。</p></li><li><p>清空数据库</p><p>涉及到删除和释放所有的键值对</p></li></ol></li><li><p>和磁盘交互时的阻塞点</p><p>AOF 日志同步写</p></li><li><p>主从节点交互时的阻塞点</p><ol><li>主从库同步，从库在接收了 RDB 文件后，需要使用 <code>FLUSHDB</code> 命令<strong>清空当前数据库</strong></li><li>从库在清空当前数据库后，还需要把 <strong>RDB 文件加载到内存</strong>，这个过程的快慢和 RDB 文件的大小密切相关，RDB 文件越大，加载过程越慢</li></ol></li></ol><h4 id="异步机制"><a href="#异步机制" class="headerlink" title="异步机制"></a>异步机制</h4><p>为了避免阻塞式操作，Redis 提供了异步线程机制，启动一些子线程，然后把一些任务交给这些子线程，让它们在后台完成，而不再由主线程来执行这些任务。</p><blockquote><ol><li><p>集合全量查询和聚合操作都涉及到了<strong>读操作</strong>，<strong>不能进行异步操作</strong></p><p>读操作是典型的关键路径操作，因为客户端发送了读操作之后，就会等待读取的数据返回，以便进行后续的数据处理。</p><blockquote><p>可以使用 SCAN 命令，分批读取数据，再在客户端进行聚合计算；</p></blockquote></li><li><p>从库加载 RDB 文件，<strong>不能进行异步操作</strong></p><p>从库要想对客户端提供数据存取服务，就必须把 RDB 文件加载完成。所以，这个操作也属于关键路径上的操作。</p><blockquote><p>从库加载 RDB 文件，把主库的数据量大小控制在 2~4GB 左右，以保证 RDB 文件能以较快的速度加载。</p></blockquote></li></ol></blockquote><ol><li><p>bigkey 删除操作</p></li><li><p>清空数据库</p><p>删除操作与清空数据库并不需要给客户端返回具体的数据结果，所以不算是关键路径操作</p></li><li><p>AOF 日志同步写</p><p>不会返回具体的数据结果给实例，可以启动一个子线程来执行 AOF 日志的同步写</p></li></ol><p><strong>异步的子线程机制</strong></p><p>Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。</p><img src="/article/30584/%E5%BC%82%E6%AD%A5%E7%9A%84%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6.jpg" class title="异步的子线程机制"><p>主线程通过一个链表形式的任务队列和子线程进行交互。当收到<strong>键值对删除和清空数据库的操作</strong>时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始<strong>实际删除键值对</strong>，并释放相应的内存空间。因此，我们把这种异步删除也称为惰性删除（lazy free）。</p><p><strong>AOF 日志同步写</strong>，AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志，这样主线程就不用一直等待 AOF 日志写完了。</p><p>异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能：</p><ol><li>键值对删除：当集合类型中有大量元素需要删除时，建议使用 <code>UNLINK</code> 命令。</li><li>清空数据库：可以在 <code>FLUSHDB</code> 和 <code>FLUSHALL</code> 命令后加上 <code>ASYNC</code> 选项，这样就可以让后台子线程异步地清空数据库</li></ol><h3 id="CPU结构影响性能"><a href="#CPU结构影响性能" class="headerlink" title="CPU结构影响性能"></a>CPU结构影响性能</h3><p><strong>主流的 CPU 架构</strong></p><p>一个 CPU 处理器中一般有多个运行核心，一个运行核心称为一个物理核，每个物理核都可以运行应用程序。每个物理核都拥有私有的一级缓存（Level 1 cache，简称 L1 cache），包括一级指令缓存和一级数据缓存，以及私有的二级缓存（Level 2 cache，简称 L2 cache）。</p><p><strong>物理核的私有缓存。它其实是指缓存空间只能被当前的这个物理核使用，其他的物理核无法对这个核的缓存空间进行数据存取。</strong></p><p><img src="/article/CPU 物理核的架构.jpg"><span class="image-caption">CPU 物理核的架构</span></p><p>L1 和 L2 缓存的大小受限于处理器的制造技术，一般只有 KB 级别</p><p>不同的物理核还会共享一个共同的三级缓存（Level 3 cache，简称为 L3 cache）。L3 缓存能够使用的存储资源比较多，能达到几 MB 到几十 MB，这就能让应用程序缓存更多的数据。当 L1、L2 缓存中没有数据缓存时，可以访问 L3，尽可能避免访问内存。</p><p>每个物理核通常都会运行两个超线程，也叫作逻辑核。同一个物理核的逻辑核会共享使用 L1、L2 缓存。</p><img src="/article/30584/%E7%89%A9%E7%90%86%E6%A0%B8%E5%92%8C%E9%80%BB%E8%BE%91%E6%A0%B8.jpg" class title="物理核和逻辑核"><p><strong>多 CPU Socket 架构</strong></p><p><img src="/article/多 CPU Socket 架构.jpg"><span class="image-caption">多 CPU Socket 架构</span></p><p>在多 CPU 架构上，应用程序可以在不同的处理器上运行</p><p>在多 CPU 架构下，一个应用程序访问所在 Socket 的本地内存和访问远端内存的延迟并不一致，所以，我们也把这个架构称为<strong>非统一内存访问架构（</strong>Non-Uniform Memory Access，NUMA 架构）。</p><h4 id="CPU-多核对-Redis-性能的影响"><a href="#CPU-多核对-Redis-性能的影响" class="headerlink" title="CPU 多核对 Redis 性能的影响"></a>CPU 多核对 Redis 性能的影响</h4><p>在一个 CPU 核上运行时，应用程序需要记录自身使用的软硬件资源信息（例如栈指针、CPU 核的寄存器值等），这些信息称为<strong>运行时信息</strong>。同时，应用程序访问最频繁的指令和数据还会被缓存到 L1、L2 缓存上，以便提升执行速度。</p><p>在多核 CPU 的场景下，一旦应用程序<strong>调度</strong>在一个新的 CPU 核上运行，那么，运行时信息就需要重新加载到新的 CPU 核上。而且，新的 CPU 核的 L1、L2 缓存也需要重新加载数据和指令，这会导致程序的运行时间增加。</p><p><strong>每调度一次，一些请求就会受到运行时信息、指令和数据重新加载过程的影响，这就会导致某些请求的延迟明显高于其他请求。</strong></p><p>可以使用 <code>taskset</code> 命令把一个程序绑定在一个核上运行</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">taskset -c 0 ./redis-server<br></code></pre></td></tr></table></figure><p>把 Redis 实例绑在了 0 号核上，其中，“-c”选项用于设置要绑定的核编号。</p></blockquote><h4 id="NUMA-架构对-Redis-性能的影响"><a href="#NUMA-架构对-Redis-性能的影响" class="headerlink" title="NUMA 架构对 Redis 性能的影响"></a>NUMA 架构对 Redis 性能的影响</h4><p>Redis 实例和网络中断程序的数据交互：网络中断处理程序从网卡硬件中读取数据，并把数据写入到操作系统内核维护的一块内存缓冲区。内核会通过 epoll 机制触发事件，通知 Redis 实例，Redis 实例再把数据从内核的内存缓冲区拷贝到自己的内存空间，如下图所示：</p><p><img src="/article/Redis 实例和网络中断程序的数据交互.jpg"><span class="image-caption">Redis 实例和网络中断程序的数据交互</span></p><p>在 CPU 的 NUMA 架构下，当网络中断处理程序、Redis 实例分别和 CPU 核绑定后，就会有一个<strong>潜在的风险</strong>：如果网络中断处理程序和 Redis 实例各自所绑的 CPU 核不在同一个 CPU Socket 上，那么，Redis 实例读取网络数据时，就需要跨 CPU Socket 访问内存，这个过程会花费较多时间。</p><p><strong>为了避免 Redis 跨 CPU Socket 访问网络数据，最好把网络中断程序和 Redis 实例绑在同一个 CPU Socket 上</strong></p><p><strong>NUMA 架构下，CPU 核的编号规则：</strong>先给每个 CPU Socket 中每个物理核的第一个逻辑核依次编号，再给每个 CPU Socket 中的物理核的第二个逻辑核依次编号。</p><blockquote><p>假设有 2 个 CPU Socket，每个 Socket 上有 6 个物理核，每个物理核又有 2 个逻辑核，总共 24 个逻辑核。可以执行 <code>lscpu</code> 命令，查看到这些核的编号：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">lscpu<br>Architecture: x86_64<br>...<br>NUMA node0 CPU(s): 0-5,12-17<br>NUMA node1 CPU(s): 6-11,18-23<br>...<br></code></pre></td></tr></table></figure><p>NUMA node0 的 CPU 核编号是 0 到 5、12 到 17。其中，0 到 5 是 node0 上的 6 个物理核中的第一个逻辑核的编号，12 到 17 是相应物理核中的第二个逻辑核编号。NUMA node1 的 CPU 核编号规则和 node0 一样。</p></blockquote><p><strong>在 CPU 多核的场景下，用 taskset 命令把 Redis 实例和一个核绑定，可以减少 Redis 实例在不同核上被来回调度执行的开销，避免较高的尾延迟；</strong></p><p><strong>在多 CPU 的 NUMA 架构下，建议同时把 Redis 实例和网络中断程序绑在同一个 CPU Socket 的不同核上，这样可以避免 Redis 跨 Socket 访问内存中的网络数据的时间开销。</strong></p><h4 id="绑核的风险和解决方案"><a href="#绑核的风险和解决方案" class="headerlink" title="绑核的风险和解决方案"></a>绑核的风险和解决方案</h4><p><strong>风险：</strong>把 Redis 实例绑到一个 CPU 逻辑核上时，就会导致子进程、后台线程和 Redis 主线程竞争 CPU 资源，一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致 Redis 请求延迟增加。</p><p><strong>解决方案：</strong></p><ol><li><p>一个 Redis 实例对应绑一个物理核</p><p>在给 Redis 实例绑核时，不要把一个实例和一个逻辑核绑定，而要和一个物理核绑定，把一个物理核的 2 个逻辑核都用上。</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">taskset -c 0,12 ./redis-server<br></code></pre></td></tr></table></figure><p>把 Redis 实例绑定到了逻辑核 0 和 12 上，而这两个核正好都属于物理核 1</p></blockquote></li><li><p>优化 Redis 源码</p><p>通过修改 Redis 源码，把子进程和后台线程绑到不同的 CPU 核上</p><blockquote><p>1 个数据结构 cpu_set_t 和 3 个函数 CPU_ZERO、CPU_SET 和 sched_setaffinity</p><ol><li>cpu_set_t 数据结构：是一个位图，每一位用来表示服务器上的一个 CPU 逻辑核</li><li>CPU_ZERO 函数：以 cpu_set_t 结构的位图为输入参数，把位图中所有的位设置为 0</li><li>CPU_SET 函数：以 CPU 逻辑核编号和 cpu_set_t 位图为参数，把位图中和输入的逻辑核编号对应的位设置为 1</li><li>sched_setaffinity 函数：以进程 / 线程 ID 号和 cpu_set_t 为参数，检查 cpu_set_t 中哪一位为 1，就把输入的 ID 号所代表的进程 / 线程绑在对应的逻辑核上</li></ol></blockquote><ol><li>创建一个 cpu_set_t 结构的位图变量；</li><li>使用 CPU_ZERO 函数，把 cpu_set_t 结构的位图所有的位都设置为 0；</li><li>根据要绑定的逻辑核编号，使用 CPU_SET 函数，把 cpu_set_t 结构的位图相应位设置为 1；</li><li>使用 sched_setaffinity 函数，把程序绑定在 cpu_set_t 结构位图中为 1 的逻辑核上。</li></ol><p>对于 Redis 来说，生成 RDB 和 AOF 日志重写的子进程分别是下面两个文件的函数中实现的。</p><ol><li>rdb.c 文件：rdbSaveBackground 函数；</li><li>aof.c 文件：rewriteAppendOnlyFileBackground 函数。</li></ol><p>这两个函数中都调用了 fork 创建子进程，可以在子进程代码部分加上绑核的四步操作。</p></li></ol><h3 id="波动的响应延迟"><a href="#波动的响应延迟" class="headerlink" title="波动的响应延迟"></a>波动的响应延迟</h3><h4 id="判断-Redis-是否变慢"><a href="#判断-Redis-是否变慢" class="headerlink" title="判断 Redis 是否变慢"></a>判断 Redis 是否变慢</h4><ol><li><p>查看 Redis 的响应延迟，是看 Redis 延迟的绝对值，不同的硬件环境条件不同</p></li><li><p>基于当前环境下的 Redis 基线性能（一个系统在低压力、无干扰下的基本性能）判断</p><p>从 2.8.7 版本开始，<code>redis-cli</code> 命令提供了 <code>–intrinsic-latency</code> 选项，可以用来监测和统计测试期间内的最大延迟，这个延迟可以作为 Redis 的基线性能。</p></li></ol><p>如果 Redis 运行时延迟是其基线性能的 2 倍及以上，就可以认定 Redis 变慢了。</p><blockquote><p>用 iPerf 工具，测量从 Redis 客户端到服务器端的网络延迟。如果这个延迟有几十毫秒甚至是几百毫秒，就说明，Redis 运行的网络环境中很可能有大流量的其他应用程序在运行，导致网络拥塞了。这个时候，就需要协调网络运维，调整网络的流量分配了。</p></blockquote><h4 id="如何应对-Redis-变慢？"><a href="#如何应对-Redis-变慢？" class="headerlink" title="如何应对 Redis 变慢？"></a>如何应对 Redis 变慢？</h4><p><img src="/article/影响 Redis 性能的三大要素.jpg"><span class="image-caption">影响 Redis 性能的三大要素</span></p><h5 id="Redis-自身操作特性的影响"><a href="#Redis-自身操作特性的影响" class="headerlink" title="Redis 自身操作特性的影响"></a><strong>Redis 自身操作特性的影响</strong></h5><ol><li><p>慢查询命令</p><p>慢查询命令，就是指在 Redis 中执行速度慢的命令，这会导致 Redis 延迟增加。</p><blockquote><p>可以通过 Redis 日志，或者是 latency monitor 工具，查询变慢的请求，根据请求对应的具体命令以及官方文档，确认下是否采用了复杂度高的慢查询命令。</p></blockquote><p><strong>处理方式：</strong></p><ol><li>用其他高效命令代替。</li><li>需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。</li></ol></li><li><p>过期 key 操作</p><p>是 Redis 用来回收内存空间的常用机制，本身就会引起 Redis 操作阻塞，导致性能变慢</p><p>默认情况下，Redis 每 100 毫秒会删除一些过期 key，具体的算法如下：</p><ol><li>采样 <code>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code>(默认是 20，一秒内基本有 200 个过期 key 会被删除) 个数的 key，并将其中过期的 key 全部删除；</li><li>如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。</li></ol><p><strong>处理方式：</strong></p><p>检查业务代码在使用 <code>EXPIREAT</code> 命令设置 key 过期时间时，是否使用了相同的 UNIX 时间戳，有没有使用 <code>EXPIRE</code> 命令给批量的 key 设置相同的过期秒数。因为，这都会造成大量 key 在同一时间过期，导致性能变慢。</p></li></ol><h5 id="文件系统：AOF-模式"><a href="#文件系统：AOF-模式" class="headerlink" title="文件系统：AOF 模式"></a><strong>文件系统：AOF 模式</strong></h5><p>AOF 日志提供了三种日志写回策略：no、everysec、always。这三种写回策略依赖文件系统的两个系统调用完成，也就是 write 和 fsync。</p><ol><li>write 只要把日志记录写到内核缓冲区，就可以返回了，并不需要等待日志实际写回到磁盘；</li><li>fsync 需要把日志记录写回到磁盘后才能返回，时间较长。</li></ol><blockquote><p>使用 everysec 时，Redis 允许丢失一秒的操作记录，所以，Redis 主线程并不需要确保每个操作记录日志都写回磁盘。而且，fsync 的执行时间很长，如果是在 Redis 主线程中执行 fsync，就容易阻塞主线程。所以，当写回策略配置为 everysec 时，Redis 会使用<strong>后台的子线程异步完成 fsync 的操作。</strong></p></blockquote><p>对于 always 策略来说，Redis 需要确保每个操作记录日志都写回磁盘，如果用后台子线程异步完成，主线程就无法及时地知道每个操作是否已经完成了，就不符合 always 策略的要求了。所以，<strong>always 策略并不使用后台子线程来执行。</strong></p><blockquote><p>使用 AOF 日志时，为了避免日志文件不断增大，Redis 会执行 AOF 重写，生成体量缩小的新的 AOF 日志文件。AOF 重写本身需要的时间很长，也容易阻塞 Redis 主线程，所以，<strong>Redis 使用子进程来进行 AOF 重写。</strong></p><p><strong>潜在的风险点：</strong>AOF 重写会对磁盘进行大量 IO 操作，同时，fsync 又需要等到数据写到磁盘后才能返回，所以，当 AOF 重写的压力比较大时，就会导致 fsync 被阻塞。虽然 fsync 是由后台子线程负责执行的，但是，主线程会监控 fsync 的执行进度。</p><p>当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞。所以，如果后台子线程执行的 fsync 频繁阻塞的话（比如 AOF 重写占用了大量的磁盘 IO 带宽），主线程也会阻塞，导致 Redis 性能变慢。</p></blockquote><p><strong>排查和解决建议</strong></p><p>检查下 Redis 配置文件中的 appendfsync 配置项，该配置项的取值表明了 Redis 实例使用的是哪种 AOF 日志写回策略。</p><ol><li><p>如果 AOF 写回策略使用了 everysec 或 always 配置，请先确认下业务方对数据可靠性的要求，明确是否需要每一秒或每一个操作都记日志。</p></li><li><p>如果业务应用对延迟非常敏感，但同时允许一定量的数据丢失，那么，可以把配置项 no-appendfsync-on-rewrite 设置为 yes</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">no-appendfsync-on-rewrite yes<br></code></pre></td></tr></table></figure><p>这个配置项设置为 yes 时，表示在 AOF 重写时，不进行 fsync 操作。Redis 实例把写命令写到内存后，不调用后台线程进行 fsync 操作，就可以直接返回了。<strong>如果此时实例发生宕机，就会导致数据丢失。</strong></p><p>如果这个配置项设置为 no（也是默认配置），在 AOF 重写时，Redis 实例仍然会调用后台线程进行 fsync 操作，这就会给实例带来阻塞。</p></li></ol><p>如果的确需要高性能，同时也需要高可靠数据保证，考虑采用<strong>高速的固态硬盘</strong>作为 AOF 日志的写入设备。</p><h5 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h5><ol><li><p>Swap</p><p>内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写，所以，一旦触发 swap（swap 触发后影响的是 Redis 主 IO 线程），无论是被换入数据的进程，还是被换出数据的进程，其性能都会受到慢速磁盘读写的影响。</p><p><strong>触发 swap 的原因主要是物理机器内存不足</strong></p><ol><li>Redis 实例自身使用了大量的内存，导致物理机器的可用内存不足；</li><li>Redis 实例在同一台机器上运行的其他进程，在进行大量的文件读写操作。文件读写本身会占用系统内存，这会导致分配给 Redis 实例的内存量变少，进而触发 Redis 发生 swap。</li></ol><p><strong>增加机器的内存或者使用 Redis 集群</strong></p></li><li><p>内存大页</p><p>内存大页机制（Transparent Huge Page, THP）</p><p>Linux 内核从 2.6.38 开始支持内存大页机制，该机制支持 2MB 大小的内存页分配，而常规的内存页分配是按 4KB 的粒度来执行的。</p><blockquote><p>Redis 为了提供数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，所以，Redis 主线程仍然可以接收客户端写请求。客户端的写请求可能会修改正在进行持久化的数据。在这一过程中，Redis 就会采用写时复制机制，也就是说，一旦有数据要被修改，Redis 并不会直接修改内存中的数据，而是将这些数据拷贝一份，然后再进行修改。</p><p>如果采用了内存大页，即使客户端请求只修改很小的数据，Redis 也需要拷贝 2MB 的大页。当客户端请求修改或新写入数据较多时，内存大页机制将导致大量的拷贝，这就会影响 Redis 正常的访存操作，最终导致性能变慢。</p></blockquote><p><strong>关闭内存大页</strong></p><blockquote><p>排查下内存大页</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cat /sys/kernel/mm/transparent_hugepage/enabled<br></code></pre></td></tr></table></figure><p>如果执行结果是 always，就表明内存大页机制被启动了；如果是 never，就表示，内存大页机制被禁止。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh\">echo never /sys/kernel/mm/transparent_hugepage/enabled<br></code></pre></td></tr></table></figure></li></ol><h3 id="Redis-性能变慢-8-个检查点"><a href="#Redis-性能变慢-8-个检查点" class="headerlink" title="Redis 性能变慢 8 个检查点:"></a><strong>Redis 性能变慢 8 个检查点:</strong></h3><blockquote><ol><li>获取 Redis 实例在当前环境下的基线性能。</li><li>是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做。</li><li>是否对过期 key 设置了相同的过期时间？对于批量删除的 key，可以在每个 key 的过期时间上加一个随机数，避免同时删除。</li><li>是否存在 bigkey？ 对于 bigkey 的删除操作，如果你的 Redis 是 4.0 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 Redis 4.0 以前的版本，可以使用 SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 SCAN 命令在客户端完成。</li><li>Redis AOF 配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入盘。</li><li>Redis 实例的内存使用是否过大？发生 swap 了吗？如果是的话，就增加机器内存，或者是使用 Redis 集群，分摊单机 Redis 的键值对数量和内存压力。同时，要避免出现 Redis 和其他内存需求大的应用共享机器的情况。在 Redis 实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了。</li><li>是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。</li><li>是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上。</li></ol></blockquote><h2 id="Redis-的内存空间存储效率"><a href="#Redis-的内存空间存储效率" class="headerlink" title="Redis 的内存空间存储效率"></a>Redis 的内存空间存储效率</h2><p>当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存</p><p><strong>潜在的风险点：</strong>Redis 释放的内存空间可能并不是连续的，那么，这些不连续的内存空间很有可能处于一种闲置的状态。虽然有空闲空间，Redis 却无法用来保存数据，不仅会减少 Redis 能够实际保存的数据量，还会降低 Redis 运行机器的成本回报率。</p><h3 id="内存碎片的形成"><a href="#内存碎片的形成" class="headerlink" title="内存碎片的形成"></a>内存碎片的形成</h3><ol><li><p>内因：内存分配器的分配策略</p><p>内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。</p></li><li><p>外因：键值对大小不一样和删改操作</p></li></ol><h3 id="判断是否有内存碎片"><a href="#判断是否有内存碎片" class="headerlink" title="判断是否有内存碎片"></a>判断是否有内存碎片</h3><p>Redis 自身提供了 INFO 命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">INFO memory<br><span class="hljs-comment"># Memory</span><br>used_memory:1073741736<br>used_memory_human:1024.00M<br>used_memory_rss:1997159792<br>used_memory_rss_human:1.86G<br>…<br>mem_fragmentation_ratio:1.86<br></code></pre></td></tr></table></figure><p>mem_fragmentation_ratio 指标，表示的就是 Redis 当前的内存碎片率</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mem_fragmentation_ratio = used_memory_rss/ used_memory<br></code></pre></td></tr></table></figure><p>used_memory_rss 是操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片；</p><p>used_memory 是 Redis 为了保存数据实际申请使用的空间。</p><ol><li><p>mem_fragmentation_ratio 大于 1 但小于 1.5</p><p><strong>合理</strong></p></li><li><p>mem_fragmentation_ratio 大于 1.5</p><p>表明内存碎片率已经超过了 50%，需要采取措施来降低内存碎片率</p></li></ol><h3 id="清理内存碎片"><a href="#清理内存碎片" class="headerlink" title="清理内存碎片"></a>清理内存碎片</h3><ol><li><p>重启 Redis 实例</p><ol><li>如果 Redis 中的数据没有持久化，就会丢失数据；</li><li>即使 Redis 数据持久化了，还需要通过 AOF 或 RDB 进行恢复，恢复时长取决于 AOF 或 RDB 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。</li></ol></li><li><p>4.0-RC3 版本以后，Redis 自身提供了一种内存碎片自动清理的方法</p><img src="/article/30584/%E7%A2%8E%E7%89%87%E6%B8%85%E7%90%86.jpg" class title="碎片清理"><p>Redis 是单线程，在数据拷贝时，Redis 只能等着，这就导致 Redis 无法及时处理请求，性能就会降低。</p><p>可以通过设置参数，来控制碎片清理的开始和结束时机，以及占用的 CPU 比例，从而减少碎片清理对 Redis 本身请求处理的性能影响。</p><ol><li><p>Redis 需要启用自动内存碎片清理， activedefrag 配置项设置为 yes</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">config <span class="hljs-built_in">set</span> activedefrag yes<br></code></pre></td></tr></table></figure></li><li><p>内存碎片的字节数达到 XXMB 时，开始清理；</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">active-defrag-ignore-bytes XXmb<br></code></pre></td></tr></table></figure><p>内存碎片空间占操作系统分配给 Redis 的总空间比例达到 XX% 时，开始清理</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">active-defrag-threshold-lower XX<br></code></pre></td></tr></table></figure><p><strong>同时满足这两个条件，就开始清理。在清理的过程中，只要有一个条件不满足了，就停止自动清理</strong></p></li><li><p>自动清理过程所用 CPU 时间的比例不低于 25%，清理能正常开展</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">active-defrag-cycle-min 25<br></code></pre></td></tr></table></figure><p>自动清理过程所用 CPU 时间的比例不高于 75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞 Redis，导致响应延迟升高</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">active-defrag-cycle-max 75<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="Redis-缓冲区"><a href="#Redis-缓冲区" class="headerlink" title="Redis 缓冲区"></a>Redis 缓冲区</h2><h3 id="客户端输入和输出缓冲区"><a href="#客户端输入和输出缓冲区" class="headerlink" title="客户端输入和输出缓冲区"></a>客户端输入和输出缓冲区</h3><p>为了避免客户端和服务器端的请求发送和处理速度不匹配，服务器端给每个连接的客户端都设置了一个输入缓冲区和输出缓冲区，称之为客户端输入缓冲区和输出缓冲区。</p><p>输入缓冲区会先把客户端发送过来的命令暂存起来，Redis 主线程再从输入缓冲区中读取命令，进行处理。当 Redis 主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端</p><img src="/article/30584/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%8C%BA.jpg" class title="客户端输入和输出缓冲区"><h4 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a><strong>输入缓冲区</strong></h4><p><strong>输入缓冲区溢出</strong></p><ol><li>写入了 bigkey</li><li>服务器端处理请求的速度过慢</li></ol><p><strong>查看输入缓冲区的内存使用情况</strong></p><p><code>CLIENT LIST</code> 命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">CLIENT LIST<br>id=5 addr=127.0.0.1:50487 fd=9 name= age=4 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client<br></code></pre></td></tr></table></figure><ol><li>一类是与服务器端连接的客户端的信息</li><li>一类是与输入缓冲区相关的三个参数<ol><li>cmd，表示客户端最新执行的命令</li><li>qbuf，表示输入缓冲区已经使用的大小</li><li>qbuf-free，表示输入缓冲区尚未使用的大小</li></ol></li></ol><p><strong>避免输入缓冲区溢出</strong></p><blockquote><p>把缓冲区调大</p><p>Redis 服务器端允许为每个客户端最多暂存 1GB 的命令和数据，Redis 并没有提供参数让我们调节客户端输入p缓冲区的大小</p></blockquote><p>数据命令的发送和处理速度：避免客户端写入 bigkey，以及避免 Redis 主线程阻塞</p><h4 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h4><p>Redis 的输出缓冲区暂存的是 Redis 主线程要返回给客户端的数据</p><p>Redis 为每个客户端设置的输出缓冲区包括两部分：</p><ol><li>一个大小为 16KB 的固定缓冲空间，用来暂存 OK 响应和出错信息；</li><li>一个可以动态增加的缓冲空间，用来暂存大小可变的响应结果。</li></ol><p><strong>输出缓冲区溢出</strong></p><ol><li><p>服务器端返回 bigkey 的大量结果；</p></li><li><p>执行了 <code>MONITOR</code> 命令；</p><p><code>MONITOR</code> 命令是用来监测 Redis 执行的，持续输出监测到的各个命令操作</p><p><code>MONITOR</code> 的输出结果会持续占用输出缓冲区，并越占越多，最后的结果就是发生溢出</p><blockquote><p>MONITOR 命令主要用在调试环境中，不要在线上生产环境中持续使用 MONITOR</p></blockquote></li><li><p>缓冲区大小设置得不合理</p><p>通过 <code>client-output-buffer-limit</code> 配置项，来设置缓冲区的大小</p><ol><li>设置缓冲区大小的上限阈值；</li><li>设置输出缓冲区持续写入数据的数量上限阈值，和持续写入数据的时间的上限阈值。</li></ol><blockquote><p>和 Redis 实例进行交互的应用程序来说，主要使用两类客户端和 Redis 服务器端交互</p><ol><li>常规和 Redis 服务器端进行读写命令交互的普通客户端</li><li>订阅了 Redis 频道的订阅客户端</li><li>主节点上用来和从节点进行数据同步的客户端</li></ol></blockquote><ol><li><p>常规和 Redis 服务器端进行读写命令交互的普通客户端</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">client-output-buffer-limit normal 0 0 0<br></code></pre></td></tr></table></figure><p>normal 表示当前设置的是普通客户端，第 1 个 0 设置的是缓冲区大小限制，第 2 个 0 和第 3 个 0 分别表示缓冲区持续写入量限制和持续写入时间限制</p><blockquote><p>对于普通客户端来说，它每发送完一个请求，会等到请求结果返回后，再发送下一个请求，这种发送方式称为<strong>阻塞式发送</strong>。在这种情况下，如果不是读取体量特别大的 bigkey，服务器端的输出缓冲区一般不会被阻塞的。</p></blockquote><p>0 表示 不做限制 </p></li><li><p>订阅了 Redis 频道的订阅客户端</p><blockquote><p>对于订阅客户端来说，一旦订阅的 Redis 频道有消息了，服务器端都会通过输出缓冲区把消息发给客户端。所以，订阅客户端和服务器间的消息发送方式，不属于阻塞式发送。</p></blockquote><p>给订阅客户端设置缓冲区大小限制、缓冲区持续写入量限制，以及持续写入时间限制</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">client-output-buffer-limit pubsub 8mb 2mb 60<br></code></pre></td></tr></table></figure><p>pubsub 参数表示当前是对订阅客户端进行设置</p><p>8mb 表示输出缓冲区的大小上限为 8MB，一旦实际占用的缓冲区大小要超过 8MB，服务器端就会直接关闭客户端的连接；2mb 和 60 表示，如果连续 60 秒内对输出缓冲区的写入量超过 2MB 的话，服务器端也会关闭客户端连接。</p></blockquote></li></ol></li></ol><p><strong>避免输出缓冲区溢出</strong></p><ol><li>避免 bigkey 操作返回大量数据结果；</li><li>避免在线上环境中持续使用 MONITOR 命令。</li><li>使用 <code>client-output-buffer-limit</code> 设置合理的缓冲区大小上限，或是缓冲区连续写入时间和写入量上限。</li></ol><h3 id="主从集群中的缓冲区"><a href="#主从集群中的缓冲区" class="headerlink" title="主从集群中的缓冲区"></a>主从集群中的缓冲区</h3><p>主从集群间的数据复制包括全量复制和增量复制两种，无论在哪种形式的复制中，为了保证主从节点的数据一致，都会用到缓冲区</p><h4 id="复制缓冲区的溢出问题（全量复制）"><a href="#复制缓冲区的溢出问题（全量复制）" class="headerlink" title="复制缓冲区的溢出问题（全量复制）"></a>复制缓冲区的溢出问题（全量复制）</h4><p>在全量复制过程中，主节点在向从节点传输 RDB 文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在复制缓冲区中，等 RDB 文件传输完成后，再发送给从节点去执行。主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步。</p><img src="/article/30584/%E5%A4%8D%E5%88%B6%E7%BC%93%E5%86%B2%E5%8C%BA.jpg" class title="复制缓冲区"><p>在全量复制时，从节点接收和加载 RDB 较慢，同时主节点接收到了大量的写命令，写命令在复制缓冲区中就会越积越多，最终导致溢出。</p><p><strong>避免复制缓冲区溢出</strong></p><ol><li><p>控制主节点保存的数据量大小</p><p>一般把主节点的数据量控制在 2~4GB，这样可以让全量同步执行得更快些，避免复制缓冲区累积过多命令。</p></li><li><p>使用 <code>client-output-buffer-limit</code> 配置项，设置合理的复制缓冲区大小</p><blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">config <span class="hljs-built_in">set</span> client-output-buffer-limit slave 512mb 128mb 60<br></code></pre></td></tr></table></figure><p>slave 参数表明该配置项是针对复制缓冲区的</p><p>512mb 代表将缓冲区大小的上限设置为 512MB；128mb 和 60 代表的设置是，如果连续 60 秒内的写入量超过 128MB 的话，也会触发缓冲区溢出。</p></blockquote><p>实际应用中设置复制缓冲区的大小时，可以根据写命令数据的大小和应用的实际负载情况（也就是写命令速率），来粗略估计缓冲区中会累积的写命令数据量；然后，再和所设置的复制缓冲区大小进行比较，判断设置的缓冲区大小是否足够支撑累积的写命令数据量。</p></li><li><p>控制和主节点连接的从节点个数</p><p>主节点上复制缓冲区的内存开销，会是每个从节点客户端输出缓冲区占用内存的总和</p><p>如果集群中的从节点数非常多的话，主节点的内存开销就会非常大</p></li></ol><h4 id="复制积压缓冲区的溢出问题-增量复制"><a href="#复制积压缓冲区的溢出问题-增量复制" class="headerlink" title="复制积压缓冲区的溢出问题(增量复制)"></a>复制积压缓冲区的溢出问题(增量复制)</h4><p>主节点在把接收到的写命令同步给从节点时，同时会把这些写命令写入复制积压缓冲区。一旦从节点发生网络闪断，再次和主节点恢复连接后，从节点就会从复制积压缓冲区中，读取断连期间主节点接收到的写命令，进而进行增量同步</p><img src="/article/30584/aedc9b41b31860e283c5d140bdb3318f.jpg" class title="img"><ol><li>复制积压缓冲区(repl_backlog_buffer)是一个大小有限的环形缓冲区。当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据。如果从节点还没有同步这些旧命令数据，就会造成主从节点间重新开始执行全量复制。</li><li>为了应对复制积压缓冲区的溢出问题，我们可以调整复制积压缓冲区的大小，也就是设置 repl_backlog_size 这个参数的值</li></ol><h2 id="Java操作Redis"><a href="#Java操作Redis" class="headerlink" title="Java操作Redis"></a>Java操作Redis</h2><blockquote><p><strong>Redis依赖</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- spring data redis 依赖 --&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>1.0 版本 默认使用连接池技术是 Jedis</p><p>2.0 以上版本 默认使用连接池技术是 Lettuce</p><p>如果使用 Jedis ，需要排除 Lettuce</p></blockquote><blockquote><p><strong>Redis配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">redis:</span><br>    <span class="hljs-comment">#超时时间</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-string">10000ms</span><br>    <span class="hljs-comment">#服务器地址</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>    <span class="hljs-comment">#服务器端口</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-comment">#数据库</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">*******</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-comment">#最大连接数</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">1024</span><br>        <span class="hljs-comment">#最大连接阻塞等待时间</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">10000ms</span><br>        <span class="hljs-comment">#最大空闲连接</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">200</span><br>        <span class="hljs-comment">#最小空闲连接</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>Redis配置类</strong> – 进行序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.config;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;<br>    RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>    <span class="hljs-comment">//String类型key序列器</span><br>    redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>    <span class="hljs-comment">//String类型Value序列器</span><br>    redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer());<br>    <span class="hljs-comment">//Hash类型key序列器</span><br>    redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>    <span class="hljs-comment">//Hash类型Value序列器</span><br>    redisTemplate.setHashValueSerializer(<span class="hljs-keyword">new</span> GenericJackson2JsonRedisSerializer());<br>    redisTemplate.setConnectionFactory(redisConnectionFactory);<br>    <span class="hljs-keyword">return</span> redisTemplate;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>通过用户ID查询菜单，并存入Redis</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> MenuMapper menuMapper;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getMenusByAdminID</span><span class="hljs-params">()</span> </span>&#123;<br>  Integer adminId = AdminUtils.getCurrentAdmin().getId();<br>  ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();<br>  <span class="hljs-comment">//从redis获取菜单数据</span><br>  List&lt;Menu&gt; menus = (List&lt;Menu&gt;) valueOperations.get(<span class="hljs-string">&quot;menu_&quot;</span> + adminId);<br>  <span class="hljs-comment">//如果为空，去数据库获取</span><br>  <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(menus)) &#123;<br>    menus = menuMapper.getMenusByAdminID(adminId);<br>    <span class="hljs-comment">//将数据设置到redis中</span><br>    valueOperations.set(<span class="hljs-string">&quot;menu_&quot;</span> + adminId, menus);<br>  &#125;<br>  <span class="hljs-keyword">return</span> menus;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="FastDFS-头像上传"><a href="#FastDFS-头像上传" class="headerlink" title="FastDFS 头像上传"></a>FastDFS 头像上传</h2><h3 id="FastDFS简介"><a href="#FastDFS简介" class="headerlink" title="FastDFS简介"></a>FastDFS简介</h3><ol><li><p>FastDFS 是一个开源的轻量级<strong>分布式文件系统</strong>，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。</p><p>FastDFS 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用 FastDFS 很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。</p></li><li><p>FastDFS 服务端有两个角色：跟踪器（tracker）和存储节点（storage）。</p><ol><li>跟踪器主要做调度工作，在访问上起负载均衡的作用。</li><li>存储节点存储文件，完成文件管理的所有功能，存储、同步和提供存取接口。</li></ol></li></ol><p>FastDFS 同时对文件的 metadata 进行管理。所谓文件的 metadata 就是文件的相关属性，以键值对（key value）方式表示。</p><ol start="3"><li><p>集群</p><p>跟踪器和存储节点都可以由一台或多台服务器构成【所以说都可以做集群】。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。【<strong>跟踪器除了做调度作用以外，还可以在访问上能起到简单的负载均衡的作用</strong>。】 </p><p>为了支持大容量，<strong>存储节点（服务器）采用了分卷（或分组）的组织方式</strong>。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了<strong>冗余备份和负载均衡</strong>的作用。</p><p>在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。</p></li></ol><p><strong>FastDFS 中的文件标识分为两个部分：卷名和文件名，二者缺一不可</strong></p><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><img src="/article/30584/FastDFS%E6%9E%B6%E6%9E%84%E5%9B%BE.png" class title="FastDFS架构图"><h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>同一组内的 storage server 之间是对等的，文件上传、删除等操作可以在任意一台 storage server 上进行；</p><p>文件同步只在同组内的 storage server 之间进行，采用 push 方式，即源服务器同步给目标服务器；</p><p>源头数据才需要同步，备份数据不需要再次同步，否则就构成环路了；</p><p>上述第二条规则有个例外，就是新增加一台storage server时，由已有的一台storage server将已有的所有数据（包括源头数据和备份数据）同步给该新增服务器</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强。</p><p>为了使Web应用直接使用HTTP协议，直接访问存储器中的文件</p><h3 id="Java使用FastDFS"><a href="#Java使用FastDFS" class="headerlink" title="Java使用FastDFS"></a>Java使用FastDFS</h3><blockquote><p><strong>依赖</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>  &lt;groupId&gt;org.csource&lt;/groupId&gt;<br>  &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;<br>  &lt;version&gt;<span class="hljs-number">1.29</span>-SNAPSHOT&lt;/version&gt;<br> &lt;/dependency&gt;<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>常用类</strong></p><ol><li><p><strong>CLientGlobal</strong></p><p>用于加载配置文件的公共客户端工具</p><p>init(String conf_filename) 根据配置文件路径以及命名，加载配置文件，并设置客户端公共参数，配置文件类型为 <strong>.conf</strong> 文件，可以使用绝对路径或相对路径加载；</p><p>initByPropereties(Propereties props) 根据Propereties对象设置客户端公共参数</p></li><li><p><strong>TrackerClient</strong></p><p>跟踪器客户端类型，创建此类对象时，需要传递跟踪器组，就是跟踪器的访问地址信息，无参构造方法默认使用ClientGlobal.g_tracker_group 常量作为跟踪器来构造对象</p></li><li><p><strong>TrackerServer</strong></p><p>跟踪器服务类型，此类型的对象是通过跟踪器客户端构建的，实际上就是一个与FastDFS Tracker Server的链接对象。</p></li><li><p><strong>StorageServer</strong></p><p>存储服务类型，通过跟踪器客户端对象构建，实质上就是一个与FastDFS Storage Server 的链接对象，是代码只能够与 StorageServer 链接的工具，获取的具体存储服务链接，是由 TrackerServer 分配的，所以构建存储服务器对象时，需要依赖跟踪器服务对象。</p></li><li><p><strong>StorageClient</strong></p><p>存储客户端类型，此类型的对象时通过构造方法创建的，创建时，需传递跟踪器服务对象和存储服务对象，此对象实质上是一个访问 FastDFS Storage Server 的客户端对象，用于实现文件的读写操作。</p></li></ol></blockquote><blockquote><p><strong>FastDFS配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs conf">#ubuntu 开启8888 23000 22122 端口<br>#开启tracker /etc/init.d/fdfs_trackerd stop<br>#开启stroage /etc/init.d/fdfs_storaged start<br>#开启nginx  /usr/local/nginx/sbin/nginx<br><br>#连接超时<br>connect_timeout = 2<br>#网络超时<br>network_time = 30<br>#编码格式<br>charset = UTF-8<br>#tracker端口<br>http.tracker_http_port = 8080<br>#防盗链功能<br>http.anit_steal_token = no<br>#密钥<br>http.secret_key = FastDFS1234567890<br>#tracker ip:端口号<br>tracker_server = 10.211.55.11:22122<br>#连接池配置<br>connection_pool.enabled = true<br>connection_pool.max_count_per_entry = 500<br>connection_pool.max_idle_time = 3600<br>connection_pool.max_wait_time_in_ms = 1000<br></code></pre></td></tr></table></figure></blockquote><blockquote><p><strong>FastDFS工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.boyolo.server.utiles;<br><br><span class="hljs-keyword">import</span> org.csource.fastdfs.*;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;<br><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> renbo</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//centos服务器安装fastDFS</span><br><span class="hljs-comment">//https://www.cnblogs.com/homjun/p/14841843.html</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastDFSUtils</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(FastDFSUtils.class);<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化客户端</span><br><span class="hljs-comment">     * ClientGlobal 读取配置文件，并初始化对应属性</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      String filePath = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">&quot;fdfs_client.conf&quot;</span>).getFile().getAbsolutePath();<br>      ClientGlobal.init(filePath);<br>      logger.info(<span class="hljs-string">&quot;初始化FastDFS成功&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;初始化FastDFS失败&quot;</span>, e.getMessage());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成TrackerServer</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TrackerServer <span class="hljs-title">getTrackerServer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();<br>    TrackerServer trackerServer = trackerClient.getTrackerServer();<br>    <span class="hljs-keyword">return</span> trackerServer;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成StorageClient</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StorageClient <span class="hljs-title">getStorageClient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    TrackerServer trackerServer = getTrackerServer();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StorageClient(trackerServer, <span class="hljs-keyword">null</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上传文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] upload(MultipartFile file) &#123;<br>    String name = file.getOriginalFilename();<br>    logger.info(<span class="hljs-string">&quot;文件名：&quot;</span>, name);<br>    StorageClient storageClient = <span class="hljs-keyword">null</span>;<br>    String[] uploadResults = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//获取 storageClient</span><br>      storageClient = getStorageClient();<br>      <span class="hljs-comment">//上传</span><br>      uploadResults = storageClient.upload_file(file.getBytes(), name.substring(name.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>) + <span class="hljs-number">1</span>), <span class="hljs-keyword">null</span>);<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;上传文件失败！&quot;</span>, e.getMessage());<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == uploadResults &amp;&amp; <span class="hljs-keyword">null</span> != storageClient) &#123;<br>      logger.error(<span class="hljs-string">&quot;上传失败！&quot;</span>, storageClient.getErrorCode());<br>    &#125;<br>    <span class="hljs-keyword">return</span> uploadResults;<br>  &#125;<br><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取文件信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> remoteFileName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FileInfo <span class="hljs-title">getFileInfo</span><span class="hljs-params">(String groupName, String remoteFileName)</span> </span>&#123;<br>    StorageClient storageClient = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      storageClient = getStorageClient();<br>      <span class="hljs-keyword">return</span> storageClient.get_file_info(groupName, remoteFileName);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;文件信息获取失败！&quot;</span>, e.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下载文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> remoteFileName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InputStream <span class="hljs-title">downFile</span><span class="hljs-params">(String groupName, String remoteFileName)</span> </span>&#123;<br>    StorageClient storageClient = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      storageClient = getStorageClient();<br>      <span class="hljs-keyword">byte</span>[] fileByte = storageClient.download_file(groupName, remoteFileName);<br>      InputStream inputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(fileByte);<br>      <span class="hljs-keyword">return</span> inputStream;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;文件下载失败！&quot;</span>, e.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> groupName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> remoteFileName</span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteFile</span><span class="hljs-params">(String groupName, String remoteFileName)</span> </span>&#123;<br>    StorageClient storageClient = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      storageClient = getStorageClient();<br>      storageClient.delete_file(groupName, remoteFileName);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;文件删除失败！&quot;</span>, e.getMessage());<br>    &#125;<br>  &#125;<br><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取文件路径</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getTrackerUrl</span><span class="hljs-params">()</span> </span>&#123;<br>    TrackerClient trackerClient = <span class="hljs-keyword">new</span> TrackerClient();<br>    TrackerServer trackerServer = <span class="hljs-keyword">null</span>;<br>    StorageServer storeStorage = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      trackerServer = trackerClient.getTrackerServer();<br>      storeStorage = trackerClient.getStoreStorage(trackerServer);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;文件路径获取失败！&quot;</span>, e.getMessage());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;http://&quot;</span> + storeStorage.getInetSocketAddress().getHostString() + <span class="hljs-string">&quot;:8888/&quot;</span>;<br>    <span class="hljs-comment">//        return &quot;http://localhost:8888/&quot;;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/268247&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis 知识全景图包括“两大维度，三大主线”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/artic
      
    
    </summary>
    
      <category term="Redis" scheme="https://boyolo.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://boyolo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="https://boyolo.github.io/article/23384.html"/>
    <id>https://boyolo.github.io/article/23384.html</id>
    <published>2022-05-17T02:32:28.000Z</published>
    <updated>2022-05-28T16:58:10.034Z</updated>
    
    <content type="html"><![CDATA[<p><strong>二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</strong></p><h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><img src="/article/23384/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%91.jpg" class title="什么是树"><img src="/article/23384/%E6%A0%91.jpg" class title="树"><p>A 节点就是 B 节点的<strong>父节点</strong>，B 节点是 A 节点的<strong>子节点</strong>。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为<strong>兄弟节点</strong>。没有父节点的节点叫做<strong>根节点</strong>，也就是图中的节点 E。我们把没有子节点的节点叫做<strong>叶子节点或者叶节点</strong>，比如图中的 G、H、I、J、K、L 都是叶子节点。</p><p><strong>高度（Height）：</strong>节点到叶子结点的最长路径（边数） （树的高度 = 根节点的高度）</p><p><strong>深度（Depth）：</strong>根节点到这个节点所经历的边得个数</p><p><strong>层（Level）：</strong>节点的深度 + 1</p><img src="/article/23384/%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E6%B7%B1%E5%BA%A6%E5%B1%82.jpg" class title="树的高度深度层"><h2 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h2><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是<strong>左子节点和右子节点</strong>。</p><img src="/article/23384/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" class title="二叉树"><p><strong>满二叉树：</strong>编号 2 的二叉树中，<strong>叶子节点全都在最底层</strong>，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做满二叉树。</p><p><strong>完全二叉树：</strong>编号 3 的二叉树中，<strong>叶子节点都在最底下两层</strong>，<strong>最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大</strong>，这种二叉树叫做完全二叉树。</p><blockquote><p><strong>如何求一棵包含 n 个节点的完全二叉树的高度？</strong></p><p>包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(K-1)。</p><p><strong>最后一层的节点个数包含的节点个数在 1 个到 2^(L-1) 个之间（假设最大层数是 L）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">n &gt;= 1+2+4+8+...+2^(L-2)+1<br>n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)<br></code></pre></td></tr></table></figure><p><strong>L 的范围是[log<sub>2</sub>(n+1), log<sub>2</sub>n +1]</strong></p><p>完全二叉树的层数小于等于 log<sub>2</sub>n +1，也就是说，完全二叉树的高度小于等于 log<sub>2</sub>n。</p></blockquote><h3 id="如何表示（或者存储）一棵二叉树？"><a href="#如何表示（或者存储）一棵二叉树？" class="headerlink" title="如何表示（或者存储）一棵二叉树？"></a>如何表示（或者存储）一棵二叉树？</h3><p>想要存储一棵二叉树，有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p><ol><li><p>链式存储法</p><img src="/article/23384/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.jpg" class title="二叉树的链式存储"><p>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针</p></li><li><p>顺序存储法</p><img src="/article/23384/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg" class title="二叉树的顺序存储"><p><strong>根节点存储在下标 i = 1 的位置</strong></p><p><strong>左子节点</strong>存储在下标 <strong>2 * i = 2</strong> 的位置</p><p><strong>右子节点</strong>存储在 <strong>2 * i + 1 = 3</strong> 的位置</p><p>如果节点 X 存储在数组中下标为 i 的位置，下标为 2 <em> i 的位置存储的就是左子节点，下标为 2 </em> i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。</p><p><strong>完全二叉树，用数组存储是最节省内存的一种方式</strong></p></li></ol><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><img src="/article/23384/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.jpg" class title="二叉树的遍历"><p>二叉树的前、中、后序遍历就是一个递归的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">前序遍历的递推公式：<br>preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)<br><br>中序遍历的递推公式：<br>inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)<br><br>后序遍历的递推公式：<br>postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>  print root <span class="hljs-comment">// 此处为伪代码，表示打印root节点</span><br>  preOrder(root-&gt;left);<br>  preOrder(root-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>  inOrder(root-&gt;left);<br>  print root <span class="hljs-comment">// 此处为伪代码，表示打印root节点</span><br>  inOrder(root-&gt;right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>  postOrder(root-&gt;left);<br>  postOrder(root-&gt;right);<br>  print root <span class="hljs-comment">// 此处为伪代码，表示打印root节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说<strong>二叉树遍历的时间复杂度是 O(n)</strong></p><p><strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)</strong></p><h3 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h3><p><strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong></p><ol><li><p>二叉查找树的查找操作</p><p>先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p><img src="/article/23384/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C.jpg" class title="二叉查找树的查找操作"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> Node tree;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    Node p = tree;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (data &lt; p.data) p = p.left;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">private</span> Node left;<br>    <span class="hljs-keyword">private</span> Node right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉查找树的插入操作</p><p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (tree == <span class="hljs-keyword">null</span>) &#123;<br>    tree = <span class="hljs-keyword">new</span> Node(data);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  Node p = tree;<br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (data &gt; p.data) &#123;<br>      <span class="hljs-keyword">if</span> (p.right == <span class="hljs-keyword">null</span>) &#123;<br>        p.right = <span class="hljs-keyword">new</span> Node(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      p = p.right;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// data &lt; p.data</span><br>      <span class="hljs-keyword">if</span> (p.left == <span class="hljs-keyword">null</span>) &#123;<br>        p.left = <span class="hljs-keyword">new</span> Node(data);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      p = p.left;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉查找树的删除操作</p><ol><li>如果要删除的节点没有子节点，只需要直接将父节点中，指向要删除节点的指针置为 null</li><li>如果要删除的节点只有一个子节点（只有左子节点或者右子节点），只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了</li><li>如果要删除的节点有两个子节点，需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了）</li></ol><img src="/article/23384/%E8%A6%81%E5%88%A0%E9%99%A4%E7%9A%84%E8%8A%82%E7%82%B9%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AD%90%E8%8A%82%E7%82%B9.jpg" class title="要删除的节点有两个子节点"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>  Node p = tree; <span class="hljs-comment">// p指向要删除的节点，初始化指向根节点</span><br>  Node pp = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// pp记录的是p的父节点</span><br>  <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.data != data) &#123;<br>    pp = p;<br>    <span class="hljs-keyword">if</span> (data &gt; p.data) p = p.right;<br>    <span class="hljs-keyword">else</span> p = p.left;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 没有找到</span><br><br>  <span class="hljs-comment">// 要删除的节点有两个子节点</span><br>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span> &amp;&amp; p.right != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 查找右子树中最小节点</span><br>    Node minP = p.right;<br>    Node minPP = p; <span class="hljs-comment">// minPP表示minP的父节点</span><br>    <span class="hljs-keyword">while</span> (minP.left != <span class="hljs-keyword">null</span>) &#123;<br>      minPP = minP;<br>      minP = minP.left;<br>    &#125;<br>    p.data = minP.data; <span class="hljs-comment">// 将minP的数据替换到p中</span><br>    p = minP; <span class="hljs-comment">// 下面就变成了删除minP了</span><br>    pp = minPP;<br>  &#125;<br><br>  <span class="hljs-comment">// 删除节点是叶子节点或者仅有一个子节点</span><br>  Node child; <span class="hljs-comment">// p的子节点</span><br>  <span class="hljs-keyword">if</span> (p.left != <span class="hljs-keyword">null</span>) child = p.left;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.right != <span class="hljs-keyword">null</span>) child = p.right;<br>  <span class="hljs-keyword">else</span> child = <span class="hljs-keyword">null</span>;<br><br>  <span class="hljs-keyword">if</span> (pp == <span class="hljs-keyword">null</span>) tree = child; <span class="hljs-comment">// 删除的是根节点</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p) pp.left = child;<br>  <span class="hljs-keyword">else</span> pp.right = child;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二叉查找树的其他操作</p><p>二叉查找树中还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点</p></li></ol><p><strong>支持重复数据的二叉查找树</strong></p><p>二叉查找树也可以存储包含很多字段的对象</p><p>利用对象的<strong>某个字段作为键值（key）</strong>来构建二叉查找树。对象中的其他字段叫作卫星数据。</p><blockquote><p><strong>问题：如果存储的两个对象键值相同，这种情况该怎么处理呢？</strong></p><ol><li><p>二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p></li><li><p>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p><p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p></li></ol></blockquote><p><strong>二叉查找树的时间复杂度分析</strong></p><ol><li><p>最坏情况时间复杂度：O(n)</p></li><li><p>最好情况时间复杂度：二叉查找树是一棵完全二叉树（或满二叉树），跟树的高度成正比，也就是 O(height)</p></li></ol><hr><blockquote><p><strong>问题：相对散列表，为什么还要用二叉查找树呢？</strong></p><ol><li>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</li><li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</li><li>尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li><li>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li><li>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li></ol></blockquote><hr><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h3><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。</p><img src="/article/23384/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" class title="平衡二叉树"><p>很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1）。比如<strong>红黑树</strong>，<strong>它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</strong></p><h3 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h3><p>红黑树(Red-Black Tree，简称 R-B Tree)，是一种不严格的平衡二叉查找树。</p><p>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p><ol><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li></ol><img src="/article/23384/%E7%9C%81%E7%95%A5%E5%8C%85%E5%90%AB%E7%A9%BA%E8%8A%82%E7%82%B9%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" class title="省略包含空节点的红黑树"><h3 id="为什么说红黑树是“近似平衡”的？"><a href="#为什么说红黑树是“近似平衡”的？" class="headerlink" title="为什么说红黑树是“近似平衡”的？"></a>为什么说红黑树是“近似平衡”的？</h3><p>平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，<strong>“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化得太严重。</strong></p><blockquote><p><strong>红黑树的高度分析</strong></p><ol><li><p>首先，如果将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？</p><p>红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。</p><img src="/article/23384/%E5%8E%BB%E6%8E%89%E7%BA%A2%E8%89%B2%E8%8A%82%E7%82%B9%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" class title="去掉红色节点的红黑树"><blockquote><p>红黑树的定义中：从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。</p></blockquote><p>从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。</p></li><li><p>把红色节点加回去，高度会变成多少呢？</p><blockquote><p>红黑树的定义中：任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。</p></blockquote><p>红黑树中包含最多黑色节点的路径不会超过 log<sub>2</sub>n，所以加入红色节点之后，最长路径不会超过 2log<sub>2</sub>nn，也就是说，<strong>红黑树的高度近似 2log<sub>2</sub>n。</strong></p></li></ol></blockquote><h3 id="实现红黑树的基本思想"><a href="#实现红黑树的基本思想" class="headerlink" title="实现红黑树的基本思想"></a>实现红黑树的基本思想</h3><p>一棵合格的红黑树需要满足这样几个要求：</p><ol><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。</li></ol><p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏，而红黑树的“平衡调整”，实际上就是要把被破坏的第三、第四点恢复过来。</p><p><strong>左旋（rotate left）围绕某个节点的左旋、右旋（rotate right）围绕某个节点的右旋</strong></p><img src="/article/23384/%E5%B7%A6%E6%97%8B%E5%8F%B3%E6%97%8B%E7%AE%80%E5%9B%BE.jpg" class title="左旋右旋简图"><h3 id="插入删除平衡调整"><a href="#插入删除平衡调整" class="headerlink" title="插入删除平衡调整"></a>插入删除平衡调整</h3><h4 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h4><p><strong>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上</strong></p><ol><li>如果插入节点的父节点是黑色的，什么都不用做，它仍然满足红黑树的定义。</li><li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</li><li>其他违背红黑树定义的情况。（<strong>左右旋转和改变颜色</strong>）</li></ol><p>正在处理的节点叫做<strong>关注节点</strong></p><ol><li><p>如果关注节点是 a，它的叔叔节点 d 是红色</p><p><img src="/article/插入CASE 1.jpg"><span class="image-caption">CASE 1</span></p><ol><li>将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；</li><li>将关注节点 a 的祖父节点 c 的颜色设置成红色；</li><li>关注节点变成 a 的祖父节点 c；</li><li>跳到 CASE 2 或者 CASE 3。</li></ol></li><li><p>如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点</p><p><img src="/article/插入CASE 2.jpg"><span class="image-caption">CASE 2</span></p><ol><li>关注节点变成节点 a 的父节点 b；</li><li>围绕新的关注节点b 左旋；</li><li>跳到 CASE 3。</li></ol></li><li><p>如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点</p><p><img src="/article/插入CASE 3.jpg"><span class="image-caption">CASE 3</span></p><ol><li>围绕关注节点 a 的祖父节点 c 右旋；</li><li>将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。</li><li>调整结束。</li></ol></li></ol><h4 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h4><p><strong>第一步是针对删除节点初步调整</strong>。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；<strong>第二步是针对关注节点进行二次调整</strong>，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p><ol><li><p>针对删除节点初步调整</p><p>红黑树的定义中“只包含红色节点和黑色节点”，</p><p>经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。</p><ol><li><p>如果要删除的节点是 a，它只有一个子节点 b</p><p><img src="/article/初步删除CASE 1.jpg"><span class="image-caption">初步删除CASE 1</span></p><ol><li>删除节点 a，并且把节点 b 替换到节点 a 的位置；</li><li>节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；</li><li>调整结束，不需要进行二次调整。</li></ol></li><li><p>如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c</p><p><img src="/article/初步删除CASE 2.jpg"><span class="image-caption">初步删除CASE 2</span></p><ol><li>如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。把节点 a 删除，并且将节点 c 替换到节点 a 的位置；</li><li>然后把节点 c 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；</li><li>这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。</li></ol></li><li><p>如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点</p><p><img src="/article/初步删除CASE 3.jpg"><span class="image-caption">初步删除CASE 3</span></p><ol><li>找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；</li><li>将节点 a 替换成后继节点 d；</li><li>把节点 d 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；</li><li>这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。</li></ol></li></ol></li><li><p>针对关注节点进行二次调整</p><p>经过初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点</p><ol><li><p>如果关注节点是 a，它的兄弟节点 c 是红色的</p><p><img src="/article/删除二次调整CASE 1.jpg"><span class="image-caption">删除二次调整CASE 1</span></p><ol><li>围绕关注节点 a 的父节点 b 左旋；</li><li>关注节点 a 的父节点 b 和祖父节点 c 交换颜色；</li><li>关注节点不变；</li><li>继续从四种情况中选择适合的规则来调整。</li></ol></li><li><p>如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的</p><p><img src="/article/删除二次调整CASE 2.jpg"><span class="image-caption">删除二次调整CASE 2</span></p><ol><li>将关注节点 a 的兄弟节点 c 的颜色变成红色；</li><li>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；</li><li>给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；</li><li>关注节点从 a 变成其父节点 b；</li><li>继续从四种情况中选择符合的规则来调整。</li></ol></li><li><p>如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色</p><p><img src="/article/删除二次调整CASE 3.jpg"><span class="image-caption">删除二次调整CASE 3</span></p><ol><li>围绕关注节点 a 的兄弟节点 c 右旋；</li><li>节点 c 和节点 d 交换颜色；</li><li>关注节点不变；</li><li>跳转到 CASE 4，继续调整。</li></ol></li><li><p>如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的</p><p><img src="/article/删除二次调整CASE 4.jpg"><span class="image-caption">删除二次调整CASE 4</span></p><ol><li>围绕关注节点 a 的父节点 b 左旋；</li><li>将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；</li><li>将关注节点 a 的父节点 b 的颜色设置为黑色；</li><li>从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；</li><li>将关注节点 a 的叔叔节点 e 设置为黑色；调整结束。</li></ol></li></ol></li></ol><h2 id="递归树"><a href="#递归树" class="headerlink" title="递归树"></a>递归树</h2><p><strong>如何用递归树，来分析递归代码的时间复杂度</strong></p><blockquote><img src="/article/23384/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="归并排序递归树"><p>归并排序递归树时间复杂度</p><p>因为每次分解都是一分为二，所以代价很低，把时间上的消耗记作常量 1。</p><p>归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。把每一层归并操作消耗的时间记作 n。</p><p>只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O(n * h)</p><p>归并排序递归树是一棵满二叉树。满二叉树的高度大约是 log<sub>2</sub>n，所以，<strong>归并排序递归实现的时间复杂度就是 O(nlogn)</strong></p></blockquote><h3 id="实战一：分析快速排序的时间复杂度"><a href="#实战一：分析快速排序的时间复杂度" class="headerlink" title="实战一：分析快速排序的时间复杂度"></a>实战一：分析快速排序的时间复杂度</h3><blockquote><p>快速排序在最好情况下，每次分区都能一分为二，用递推公式 T(n)=2T(n/2)+n，很容易就能推导出时间复杂度是 O(nlogn)。但是，不可能每次分区都正好一分为二。</p><p>假设平均情况下，每次分区之后，两个分区的大小比例为 1:k。当 k=9 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 T(n)=T(n/10)+T(9n/10)+n。</p></blockquote><p><strong>用递归树来分析快速排序的平均情况时间复杂度</strong></p><img src="/article/23384/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="快速排序递归树"><p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。我们现在只要求出递归树的高度 h，这个快排过程遍历的数据个数就是 h <em> n ，也就是说，时间复杂度就是 O(h </em> n)。</p><p>因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。</p><blockquote><p>快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 1/10，最长的一个路径每次都乘以 9/10。通过计算可以得到，从根节点到叶子节点的最短路径是 log<sub>10</sub>n，最长的路径是 log<sub>10/9</sub>n</p><img src="/article/23384/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E6%A0%91%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6.jpg" class title="快速排序递归树路径长度"></blockquote><p>所以，遍历数据的个数总和就介于 nlog<sub>10</sub>n 和 nlog<sub>10/9</sub>n 之间</p><p>当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 O(nlogn)</p><p>对于 k 等于 9，99，甚至是 999，9999……，只要 k 的值不随 n 变化，是一个事先确定的常量，那快排的时间复杂度就是 O(nlogn)。所以，从概率论的角度来说，快排的平均时间复杂度就是 O(nlogn)。</p><h3 id="实战二：分析斐波那契数列的时间复杂度"><a href="#实战二：分析斐波那契数列的时间复杂度" class="headerlink" title="实战二：分析斐波那契数列的时间复杂度"></a>实战二：分析斐波那契数列的时间复杂度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) + f(n-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article/23384/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="斐波那契数列递归树"><blockquote><p>斐波那契数列递归树的高度</p><p>f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 n/2。</p><p>每次分解之后的合并操作只需要一次加法运算，把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 2<sup>2</sup>。依次类推，第 k 层的时间消耗就是 2<sup>k−1</sup>，那整个算法的总的时间消耗就是每一层时间消耗之和。</p><p>如果路径长度都为 n，那这个总和就是 2<sup>n</sup>−1。</p><p>如果路径长度都是 n/2 ，那整个算法的总的时间消耗就是 2<sup>n/2</sup>−1。</p></blockquote><p>算法的时间复杂度就介于 O(2<sup>n</sup>) 和 O(2<sup>n/2</sup>) 之间</p><h3 id="实战三：分析全排列的时间复杂度"><a href="#实战三：分析全排列的时间复杂度" class="headerlink" title="实战三：分析全排列的时间复杂度"></a>实战三：分析全排列的时间复杂度</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">1, 2, 3<br>1, 3, 2<br>2, 1, 3<br>2, 3, 1<br>3, 1, 2<br>3, 2, 1<br></code></pre></td></tr></table></figure><p>如果确定了最后一位数据，那就变成了求解剩下 n−1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，“n 个数据的排列”问题，就可以分解成 n 个“n−1 个数据的排列”的子问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">假设数组中存储的是1，2， 3...n。<br>        <br>f(1,2,...n) = &#123;最后一位是1, f(n-1)&#125; + &#123;最后一位是2, f(n-1)&#125; +...+&#123;最后一位是n, f(n-1)&#125;。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用方式：</span><br><span class="hljs-comment">// int[]a = a=&#123;1, 2, 3, 4&#125;; printPermutations(a, 4, 4);</span><br><span class="hljs-comment">// k表示要处理的子数组的数据个数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printPermutations</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] data, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      System.out.print(data[i] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>    <span class="hljs-keyword">int</span> tmp = data[i];<br>    data[i] = data[k-<span class="hljs-number">1</span>];<br>    data[k-<span class="hljs-number">1</span>] = tmp;<br><br>    printPermutations(data, n, k - <span class="hljs-number">1</span>);<br><br>    tmp = data[i];<br>    data[i] = data[k-<span class="hljs-number">1</span>];<br>    data[k-<span class="hljs-number">1</span>] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article/23384/%E5%85%A8%E6%8E%92%E5%88%97%E9%80%92%E5%BD%92%E6%A0%91.jpg" class title="全排列递归树"><p>第一层分解有 n 次交换操作，第二层有 n 个节点，每个节点分解需要 n−1 次交换，所以第二层总的交换次数是 n <em> (n−1)。第三层有 n </em> (n−1) 个节点，每个节点分解需要 n−2 次交换，所以第三层总的交换次数是 n <em> (n−1) </em> (n−2)。</p><p>以此类推，第 k 层总的交换次数就是 n <em> (n−1) </em> (n−2) <em> … </em> (n−k+1)。最后一层的交换次数就是 n <em> (n−1) </em> (n−2) <em> … </em> 2 * 1。每一层的交换次数之和就是总的交换次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1<br></code></pre></td></tr></table></figure><p>最后一个数，n <em> (n−1) </em> (n−2) <em> … </em> 2 <em> 1 等于 n!，而前面的 n−1 个数都小于最后一个数，所以，总和肯定小于 n </em> n!，也就是说，<strong>全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n * n!)</strong></p><h2 id="“堆”（Heap）"><a href="#“堆”（Heap）" class="headerlink" title="“堆”（Heap）"></a>“堆”（Heap）</h2><p><strong>堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法</strong></p><p><strong>堆排序不是稳定的排序算法</strong></p><p>堆满足的两点要求：</p><ol><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ol><h3 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h3><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。</p><img src="/article/23384/%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%A0%86.jpg" class title="数组存储堆"><p>数组中下标为 i 的节点的左子节点，就是下标为 i <em> 2 的节点，右子节点就是下标为 i </em> 2 + 1 的节点，父节点就是下标为 i/2 的节点。</p><p><strong>堆化（heapify）</strong></p><p>堆化有两种，从下往上和从上往下</p><ol><li><p>从下往上的堆化方法</p><img src="/article/23384/%E5%BE%80%E5%A0%86%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0.jpg" class title="往堆中插入一个元素"><p>让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足堆的大小关系</p><img src="/article/23384/%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8A%E7%9A%84%E5%A0%86%E5%8C%96%E6%96%B9%E6%B3%95.jpg" class title="从下往上的堆化方法"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] a; <span class="hljs-comment">// 数组，从下标1开始存储数据</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;  <span class="hljs-comment">// 堆可以存储的最大数据个数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count; <span class="hljs-comment">// 堆中已经存储的数据个数</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Heap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[capacity + <span class="hljs-number">1</span>];<br>    n = capacity;<br>    count = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (count &gt;= n) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 堆满了</span><br>    ++count;<br>    a[count] = data;<br>    <span class="hljs-keyword">int</span> i = count;<br>    <span class="hljs-keyword">while</span> (i/<span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="hljs-number">2</span>]) &#123; <span class="hljs-comment">// 自下往上堆化</span><br>      swap(a, i, i/<span class="hljs-number">2</span>); <span class="hljs-comment">// swap()函数作用：交换下标为i和i/2的两个元素</span><br>      i = i/<span class="hljs-number">2</span>;<br>    &#125;<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>从上往下的堆化方法</p><p>删除堆顶元素之后，需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p><p>把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是<strong>从上往下的堆化方法</strong>。</p><img src="/article/23384/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E7%9A%84%E5%A0%86%E5%8C%96%E6%96%B9%E6%B3%95.jpg" class title="从上往下的堆化方法"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeMax</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 堆中没有数据</span><br>  a[<span class="hljs-number">1</span>] = a[count];<br>  --count;<br>  heapify(a, count, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i)</span> </span>&#123; <span class="hljs-comment">// 自上往下堆化</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">int</span> maxPos = i;<br>    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="hljs-number">2</span>]) maxPos = i*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) maxPos = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (maxPos == i) <span class="hljs-keyword">break</span>;<br>    swap(a, i, maxPos);<br>    i = maxPos;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>一个包含 n 个节点的完全二叉树，树的高度不会超过 log<sub>2</sub>n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。</p><h3 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h3><ol><li><p>建堆</p><p>将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。</p><ol><li><p>第一种是在堆中插入一个元素的思路。尽管数组中包含 n 个数据，假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，调用插入操作，将下标从 2 到 n 的数据依次插入到堆中。</p></li><li><p>第二种实现思路是从后往前处理数组，并且每个数据都是从上往下堆化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n/<span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>    heapify(a, n, i);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>    <span class="hljs-keyword">int</span> maxPos = i;<br>    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="hljs-number">2</span>]) maxPos = i*<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) maxPos = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (maxPos == i) <span class="hljs-keyword">break</span>;<br>    swap(a, i, maxPos);<br>    i = maxPos;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对下标从 n/2 开始到 1 的数据进行堆化，下标是 n/2+1 到 n 的节点是叶子节点，我们不需要堆化</p><p><strong>对于完全二叉树来说，下标从 n/2+1 到 n 的节点都是叶子节点</strong></p></li></ol><blockquote><p>建堆操作的时间复杂度:</p><p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。</p><img src="/article/23384/%E5%BB%BA%E5%A0%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg" class title="建堆的时间复杂度"><img src="/article/23384/%E6%AF%8F%E4%B8%AA%E9%9D%9E%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E9%AB%98%E5%BA%A6%E6%B1%82%E5%92%8C.jpg" class title="每个非叶子节点的高度求和"></blockquote><p>因为 h=log<sub>2</sub>n，代入公式 S，就能得到 S=O(n)，所以，建堆的时间复杂度就是 O(n)。</p></li><li><p>排序</p><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。</p><p>然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  buildHeap(a, n);<br>  <span class="hljs-keyword">int</span> k = n;<br>  <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span>) &#123;<br>    swap(a, <span class="hljs-number">1</span>, k);<br>    --k;<br>    heapify(a, k, <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>堆排序的时间复杂度:</p><p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。</p></blockquote></li></ol><hr><blockquote><p><strong>问题：实际开发中，为什么快速排序要比堆排序性能好？</strong></p><ol><li><p>堆排序数据访问的方式没有快速排序友好</p></li><li><p>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序</p><p>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。</p><p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。</p></li></ol></blockquote><hr><h3 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h3><ol><li><p>优先级队列</p><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p><p>往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p><blockquote><ol><li><p>合并有序小文件</p><p>假设有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。希望将这些 100 个小文件合并成一个有序的大文件。</p><blockquote><p>将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。</p></blockquote></li><li><p>高性能定时器</p><p>假设有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</p><img src="/article/23384/%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E4%BE%8B.jpg" class title="高性能定时器实例"><p>但是，这样每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</p><blockquote><p>按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。</p><p>定时器拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。</p><p>这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。</p><p>定时器就可以设定在 T 秒之后，再来执行任务。从当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情。</p><p>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。这样，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。</p></blockquote></li></ol></blockquote></li><li><p>利用堆求 Top K</p><blockquote><ol><li><p>针对静态数据集合：数据集合事先确定，不会再变</p><blockquote><p>维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。</p></blockquote><p>遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)。</p></li><li><p>针对动态数据集合：数据集合事先并不确定，有数据动态地加入到集合中</p><p>一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小。</p><blockquote><p>一直维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回。</p></blockquote></li></ol></blockquote></li><li><p>利用堆求中位数</p><blockquote><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</p><p>如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2 个数据存储在大顶堆中，后 n/2 个数据存储在小顶堆中。这样，大顶堆中的堆顶元素就是我们要找的中位数。如果 n 是奇数，情况是类似的，大顶堆就存储 n/2+1 个数据，小顶堆中就存储 n/2 个数据。</p><p>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。</p><p>可能出现，两个堆中的数据个数不符合前面约定的情况:从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。</p><img src="/article/23384/%E4%B8%A4%E4%B8%AA%E5%A0%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%AA%E6%95%B0%E4%B8%8D%E7%AC%A6%E5%90%88.jpg" class title="两个堆中的数据个数不符合"></blockquote></li></ol><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种<strong>专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</strong></p><blockquote><p>有 6 个字符串，它们分别是：how，hi，her，hello，so，see。希望在里面多次查找某个字符串是否存在。</p><p>对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。</p></blockquote><p><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</strong></p><blockquote><img src="/article/23384/Trie%E6%A0%91%E5%AE%9E%E4%BE%8B.jpg" class title="Trie树实例"></blockquote><p>根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p><blockquote><p>Trie 树构造的分解过程</p><p><img src="/article/Trie 树构造的分解过程1.jpg"><span class="image-caption">img</span></p><p><img src="/article/Trie 树构造的分解过程2.jpg"><span class="image-caption">Trie 树构造的分解过程</span></p></blockquote><h3 id="如何实现一棵-Trie-树？"><a href="#如何实现一棵-Trie-树？" class="headerlink" title="如何实现一棵 Trie 树？"></a>如何实现一棵 Trie 树？</h3><p>Trie 树主要有两个操作</p><ol><li>一个是将字符串集合构造成 Trie 树。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。</li><li>另一个是在 Trie 树中查询一个字符串。</li></ol><p>借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> data;<br>  TrieNode children[<span class="hljs-number">26</span>];<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article/23384/%E5%80%9F%E5%8A%A9%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0Trie%E6%A0%91.jpg" class title="借助散列表实现Trie树"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> TrieNode root = <span class="hljs-keyword">new</span> TrieNode(<span class="hljs-string">&#x27;/&#x27;</span>); <span class="hljs-comment">// 存储无意义字符</span><br><br>  <span class="hljs-comment">// 往Trie树中插入一个字符串</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] text)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; text.length; ++i) &#123;<br>      <span class="hljs-keyword">int</span> index = text[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-keyword">null</span>) &#123;<br>        TrieNode newNode = <span class="hljs-keyword">new</span> TrieNode(text[i]);<br>        p.children[index] = newNode;<br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    p.isEndingChar = <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 在Trie树中查找一个字符串</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] pattern)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pattern.length; ++i) &#123;<br>      <span class="hljs-keyword">int</span> index = pattern[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>      <span class="hljs-keyword">if</span> (p.children[index] == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不存在pattern</span><br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p.isEndingChar == <span class="hljs-keyword">false</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 不能完全匹配，只是前缀</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 找到pattern</span><br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> data;<br>    <span class="hljs-keyword">public</span> TrieNode[] children = <span class="hljs-keyword">new</span> TrieNode[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isEndingChar = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ol><li><p>时间复杂度</p><p>构建 Trie 树的过程，需要扫描所有的字符串，<strong>时间复杂度是 O(n)</strong>（n 表示所有字符串的长度和）</p><p>每次查询时，如果要查询的字符串长度是 k，只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的<strong>时间复杂度是 O(k)</strong>，k 表示要查找的字符串的长度。</p></li><li><p>空间复杂度</p><p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组元素要存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p><p><strong>在某些情况下，Trie 树不一定会节省存储空间。在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存。</strong></p></li></ol><h3 id="Trie-树与散列表、红黑树"><a href="#Trie-树与散列表、红黑树" class="headerlink" title="Trie 树与散列表、红黑树"></a>Trie 树与散列表、红黑树</h3><p>Trie 树对要处理的字符串有极其严苛的要求</p><ol><li>第一，字符串中包含的字符集不能太大。即便可以优化，但也要付出牺牲查询、插入效率的代价。</li><li>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</li><li>第三，如果要用 Trie 树解决问题，那就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</li><li>第四，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</li></ol><p>针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;树（Tree）&quot;&gt;&lt;a href=&quot;#树（Tree）&quot; class=&quot;headerlink&quot; title=&quot;树（Tree）&quot;&gt;&lt;/a&gt;树（Tree）&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
    
      <category term="数据结构与算法,树" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈希算法</title>
    <link href="https://boyolo.github.io/article/60365.html"/>
    <id>https://boyolo.github.io/article/60365.html</id>
    <published>2022-05-16T02:36:16.000Z</published>
    <updated>2022-05-24T11:41:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p><strong>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值</strong></p><p>优秀的哈希算法需要满足的几点要求：</p><ol><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li></ol><h3 id="哈希算法的应用"><a href="#哈希算法的应用" class="headerlink" title="哈希算法的应用"></a>哈希算法的应用</h3><ol><li><p>应用一：安全加密</p><p>最常用于加密的哈希算法是 MD5（MD5 Message-Digest Algorithm，MD5 消息摘要算法）、 SHA（Secure Hash Algorithm，安全散列算法）、DES（Data Encryption Standard，数据加密标准）、AES（Advanced Encryption Standard，高级加密标准）。</p><p><strong>没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长</strong></p></li><li><p>应用二：唯一标识</p></li><li><p>应用三：数据校验</p></li><li><p>应用四：散列函数</p><p>散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。</p><p>散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p></li><li><p>应用五：负载均衡</p><p>负载均衡算法有很多，比如轮询、随机、加权轮询等。</p><blockquote><p>如何实现一个会话粘滞（session sticky）的负载均衡算法？</p><p>需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p><p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。</p><p>弊端：</p><ol><li>如果客户端很多，映射表可能会很大，比较浪费内存空间；</li><li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；</li></ol><p><strong>可以通过哈希算法</strong>，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。</p></blockquote></li><li><p>应用六：数据分片</p><ol><li><blockquote><p>如何统计“搜索关键词”出现的次数？</p><p>假如我们有 <strong>1T</strong> 的日志文件，这里面记录了用户的搜索关键词，想要<strong>快速统计</strong>出每个关键词被搜索的次数，该怎么做呢？</p><p>可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。</p><p>具体思路：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p><p>哈希值相同的搜索关键词就被分配到了同一个机器上,每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p></blockquote></li><li><blockquote><p>如何快速判断图片是否在有1 亿张图片的图库中？</p><p>可以对数据进行分片，然后采用多机处理。</p><p>具体思路：准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</p><p>当要判断一个图片是否在图库中的时候，通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p></blockquote></li></ol></li><li><p>应用七：分布式存储</p><p>现在互联网面对的都是海量的数据、海量的用户。为了提高数据的读取、写入能力，一般都采用<strong>分布式的方式来存储数据</strong>，比如分布式缓存。</p><p>该如何决定将哪个数据放到哪个机器上呢？可以借用数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。</p><blockquote><p>如果数据增多，原来的 10 个机器已经无法承受了，就需要扩容，比如扩到 11 个机器，<strong>但这里并不是简单地加个机器就可以了</strong>。</p><p>所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生雪崩效应，压垮数据库。</p></blockquote><p><strong><a href="https://www.zsythink.net/archives/1182">一致性哈希算法</a></strong>：假设有 k 个机器，数据的哈希值的范围是[0, MAX]。将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法,哈希算法" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="https://boyolo.github.io/article/31130.html"/>
    <id>https://boyolo.github.io/article/31130.html</id>
    <published>2022-05-15T01:47:00.000Z</published>
    <updated>2022-05-24T11:41:34.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p><strong>散列表(Hash Table)，也叫“哈希表”或者“Hash 表”</strong></p><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成 <strong>hash(key)</strong>，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p><p><strong>散列函数设计的基本要求：</strong></p><ol><li>散列函数计算得到的散列值是一个非负整数；</li><li>如果 key1 = key2，那 hash(key1) == hash(key2)；</li><li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。</li></ol><h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p><strong>再好的散列函数也无法避免散列冲突</strong></p><ol><li><p>开放寻址法</p><p>开放寻址法的<strong>核心思想</strong>是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。</p><ol><li><p>线性探测（Linear Probing）</p><p><strong>插入数据</strong><br>往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><blockquote><img src="/article/31130/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.jpg" class title="线性探测插入数据"><p>散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。</p><p>于是顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p></blockquote><p><strong>查找数据</strong></p><p>在散列表中查找元素的过程有点儿类似插入过程。</p><p>通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p><blockquote><img src="/article/31130/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE.jpg" class title="线性探测查找数据"></blockquote><p><strong>删除数据</strong></p><p>删除数据时，不能单纯地把要删除的元素设置为空</p><blockquote><p>因为在查找的时候，一旦通过线性探测方法，找到一个空闲位置，就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。</p></blockquote><p>将删除的元素，<strong>特殊标记为 deleted</strong>。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p></li></ol></li></ol><pre><code>**线性探测问题：**当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</code></pre><ol start="2"><li><p>二次探测（Quadratic probing）</p><p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+1<sup>2</sup>，hash(key)+2<sup>2</sup>……</p></li><li><p>双重散列（Double hashing）</p><p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p></li></ol><p>   不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会<strong>尽可能保证散列表中有一定比例的空闲槽位</strong>。我们用<strong>装载因子（load factor）</strong>来表示空位的多少。</p><p>   <strong>散列表的装载因子=填入表中的元素个数/散列表的长度</strong></p><p>   装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><ol start="2"><li><p>链表法</p><p>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><blockquote><img src="/article/31130/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg" class title="链表法"></blockquote><p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。</p><p>当查找、删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。</p><p>时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p></li></ol><h3 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h3><ol><li><p>开放寻址法</p><p><strong>优点：</strong>开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。</p><p><strong>缺点：</strong></p><ol><li>用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。</li><li>而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</li></ol><p><strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。</strong></p></li><li><p>链表法</p><p><strong>优点：</strong></p><ol><li>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</li><li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</li></ol><p><strong>缺点：</strong></p><ol><li>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。</li><li>因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</li></ol><p><strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></p></li></ol><h3 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h3><ol><li><p>散列函数的设计不能太复杂</p><p>过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能</p></li><li><p>散列函数生成的值要尽可能随机并且均匀分布</p><p>这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况</p></li></ol><h3 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h3><p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p><p>针对散列表，当装载因子过大时，可以进行<strong>动态扩容</strong>，重新申请一个更大的散列表，将数据搬移到这个新散列表中。</p><p>针对散列表的扩容，因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置。</p><p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol><li><p><strong>插入数据时间复杂度</strong></p><p><strong>最好时间复杂度：</strong>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。</p><p><strong>最坏时间复杂度：</strong>最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。</p><p><strong>摊还时间复杂度：</strong>用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p></li><li><p><strong>删除数据时间复杂度</strong></p><p>删除数据时间复杂度为O(1)。</p><p>对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。</p></li></ol><h3 id="如何避免低效的扩容？"><a href="#如何避免低效的扩容？" class="headerlink" title="如何避免低效的扩容？"></a>如何避免低效的扩容？</h3><p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p><p>当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。</p><p>经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p><p>对于查询操作，为了兼容了新、老散列表中的数据，先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p><p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。<strong>这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。</strong></p><h3 id="工业级散列表举例分析（Java-HashMap）"><a href="#工业级散列表举例分析（Java-HashMap）" class="headerlink" title="工业级散列表举例分析（Java HashMap）"></a>工业级散列表举例分析（Java HashMap）</h3><ol><li><p>初始大小</p><p>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p></li><li><p>装载因子和动态扩容</p><p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p></li><li><p>散列冲突解决方法</p><p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p><p>在 JDK1.8 版本中，为了对 HashMap 做进一步优化，<strong>引入了红黑树</strong>。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。但不是所有的链表长度为8后都会转成树，还需要判断存放key值的数组桶长度是否小于64。如果小于则需要扩容，扩容后链表上的数据会被拆分散列的相应的桶节点上，也就把链表长度缩短了。</p><p>可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p></li><li><p>散列函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> h = key.hashCode()；<br>  <span class="hljs-keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)) &amp; (capicity -<span class="hljs-number">1</span>); <span class="hljs-comment">//capicity表示散列表的大小</span><br>&#125;<br></code></pre></td></tr></table></figure><p>hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> var1 = <span class="hljs-keyword">this</span>.hash;<br>  <span class="hljs-keyword">if</span>(var1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.value.length &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">char</span>[] var2 = <span class="hljs-keyword">this</span>.value;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var3 = <span class="hljs-number">0</span>; var3 &lt; <span class="hljs-keyword">this</span>.value.length; ++var3) &#123;<br>      var1 = <span class="hljs-number">31</span> * var1 + var2[var3];<br>    &#125;<br>    <span class="hljs-keyword">this</span>.hash = var1;<br>  &#125;<br>  <span class="hljs-keyword">return</span> var1;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><hr><blockquote><p><strong>问题：如何设计一个工业级的散列函数？</strong></p><blockquote><p>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？</p><ol><li>支持快速地查询、插入、删除操作；</li><li>内存占用合理，不能浪费过多的内存空间；</li><li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</li></ol></blockquote><p>设计思路：</p><ol><li>设计一个合适的散列函数；</li><li>定义装载因子阈值，并且设计动态扩容策略；</li><li>选择合适的散列冲突解决方法。</li></ol></blockquote><h3 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h3><p><strong>借助散列表，可以把 LRU 缓存淘汰算法的时间复杂度降低为 O(1)</strong></p><blockquote><p>如何通过链表实现 LRU 缓存淘汰算法?</p><p>需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，直接将链表头部的结点删除。</p><p>当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。</p></blockquote><p>一个缓存（cache）系统主要包含下面这几个操作：</p><ol><li>往缓存中添加一个数据；</li><li>从缓存中删除一个数据；</li><li>在缓存中查找一个数据。</li></ol><blockquote><p>单纯地采用链表的话，时间复杂度只能是 O(n)</p><p>将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 <strong>O(1)</strong></p></blockquote><img src="/article/31130/%E6%95%A3%E5%88%97%E8%A1%A8%E9%93%BE%E8%A1%A8URL.jpg" class title="散列表链表URL"><p>使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext</p><p>散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是双向链表，另一个链是散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。</p><p><strong>如何查找一个数据：</strong>散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，可以很快地在缓存中找到一个数据。当找到数据之后，还需要将它移动到双向链表的尾部。</p><p><strong>如何删除一个数据：</strong>需要找到数据所在的结点，然后将结点删除。借助散列表，可以在 O(1) 时间复杂度里找到要删除的结点。因为链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。</p><p><strong>如何添加一个数据：</strong>需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;散列表&quot;&gt;&lt;a href=&quot;#散列表&quot; class=&quot;headerlink&quot; title=&quot;散列表&quot;&gt;&lt;/a&gt;散列表&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;散列表(Hash Table)，也叫“哈希表”或者“Hash 表”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="散列表" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法,散列表" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>跳表</title>
    <link href="https://boyolo.github.io/article/44093.html"/>
    <id>https://boyolo.github.io/article/44093.html</id>
    <published>2022-05-14T02:57:57.000Z</published>
    <updated>2022-05-24T11:41:34.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><blockquote><p>假设每两个节点建立一个索引</p></blockquote><p>对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫做<strong>跳表（Skip list）</strong></p><p><strong>Redis 中的有序集合（Sorted Set）就是用跳表来实现的。</strong></p><h3 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h3><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p><p><strong>初级优化</strong></p><p>像图中那样，对链表建立一级“索引”，每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做<strong>索引或索引层</strong>。down 表示 down 指针，指向下一级结点。</p><img src="/article/44093/%E9%93%BE%E8%A1%A8+%E7%B4%A2%E5%BC%95.jpg" class title="链表+索引"><p>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了</p><p><strong>再次优化</strong></p><p>跟前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。</p><img src="/article/44093/%E9%93%BE%E8%A1%A8+%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.jpg" class title="链表+二级索引"><p><strong>这种链表加多级索引的结构，就是跳表</strong></p><h3 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h3><p>如果链表里有 n 个结点，会有多少级索引呢？</p><p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，<strong>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2<sup>k</sup>)。</strong></p><p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，可以得到 n/(2<sup>h</sup>)=2，从而求得 h=log<sub>2</sub>n-1。如果包含原始链表这一层，整个跳表的高度就是 log<sub>2</sub>n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p><p>m 的值是多少呢？</p><p>按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m=3。</p><blockquote><p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p><img src="/article/44093/%E6%AF%8F%E5%B1%82%E6%9C%80%E5%A4%9A3%E8%8A%82%E7%82%B9%E9%81%8D%E5%8E%86.jpg" class title="每层最多3节点遍历"></blockquote><p><strong>在跳表中查询任意数据的时间复杂度就是 O(logn)</strong></p><h3 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h3><p>假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。</p><img src="/article/44093/%E8%B7%B3%E8%A1%A8%E6%AF%8F%E5%B1%82%E8%8A%82%E7%82%B9%E6%95%B0.jpg" class title="跳表每层节点数"><p>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2</p><p>所以，<strong>跳表的空间复杂度是 O(n)</strong></p><h3 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h3><p><strong>插入、删除操作的时间复杂度是 O(logn)</strong></p><img src="/article/44093/%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.jpg" class title="插入操作"><h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当我们不停地往跳表中插入数据时，如果不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p><p><strong>跳表是通过随机函数来维护前面提到的“平衡性”</strong></p><blockquote><p>当往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？</p></blockquote><p>通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p><img src="/article/44093/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95.jpg" class title="随机函数更新索引"><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> skiplist;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跳表的一种实现方法。</span><br><span class="hljs-comment"> * 跳表中存储的是正整数，并且存储的是不重复的。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SkipList</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> SKIPLIST_P = <span class="hljs-number">0.5f</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_LEVEL = <span class="hljs-number">16</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> levelCount = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">private</span> Node head = <span class="hljs-keyword">new</span> Node();  <span class="hljs-comment">// 带头链表</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    Node p = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = levelCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">while</span> (p.forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;<br>        p = p.forwards[i];<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p.forwards[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[<span class="hljs-number">0</span>].data == value) &#123;<br>      <span class="hljs-keyword">return</span> p.forwards[<span class="hljs-number">0</span>];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> level = randomLevel();<br>    Node newNode = <span class="hljs-keyword">new</span> Node();<br>    newNode.data = value;<br>    newNode.maxLevel = level;<br>    Node update[] = <span class="hljs-keyword">new</span> Node[level];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; ++i) &#123;<br>      update[i] = head;<br>    &#125;<br><br>    <span class="hljs-comment">// record every level largest value which smaller than insert value in update[]</span><br>    Node p = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">while</span> (p.forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;<br>        p = p.forwards[i];<br>      &#125;<br>      update[i] = p;<span class="hljs-comment">// use update save node in search path</span><br>    &#125;<br><br>    <span class="hljs-comment">// in search path node next node become new node forwords(next)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; ++i) &#123;<br>      newNode.forwards[i] = update[i].forwards[i];<br>      update[i].forwards[i] = newNode;<br>    &#125;<br><br>    <span class="hljs-comment">// update node hight</span><br>    <span class="hljs-keyword">if</span> (levelCount &lt; level) levelCount = level;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    Node[] update = <span class="hljs-keyword">new</span> Node[levelCount];<br>    Node p = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = levelCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>      <span class="hljs-keyword">while</span> (p.forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[i].data &lt; value) &#123;<br>        p = p.forwards[i];<br>      &#125;<br>      update[i] = p;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p.forwards[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span> &amp;&amp; p.forwards[<span class="hljs-number">0</span>].data == value) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = levelCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">if</span> (update[i].forwards[i] != <span class="hljs-keyword">null</span> &amp;&amp; update[i].forwards[i].data == value) &#123;<br>          update[i].forwards[i] = update[i].forwards[i].forwards[i];<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (levelCount&gt;<span class="hljs-number">1</span>&amp;&amp;head.forwards[levelCount]==<span class="hljs-keyword">null</span>)&#123;<br>      levelCount--;<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-comment">// 理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最顶层。</span><br>  <span class="hljs-comment">// 因为这里每一层的晋升概率是 50%。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的层数。</span><br>  <span class="hljs-comment">// 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：</span><br>  <span class="hljs-comment">//        50%的概率返回 1</span><br>  <span class="hljs-comment">//        25%的概率返回 2</span><br>  <span class="hljs-comment">//      12.5%的概率返回 3 ...</span><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> level = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL)<br>      level += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> level;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">()</span> </span>&#123;<br>    Node p = head;<br>    <span class="hljs-keyword">while</span> (p.forwards[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span>) &#123;<br>      System.out.print(p.forwards[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; &quot;</span>);<br>      p = p.forwards[<span class="hljs-number">0</span>];<br>    &#125;<br>    System.out.println();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> data = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> Node forwards[] = <span class="hljs-keyword">new</span> Node[MAX_LEVEL];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxLevel = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>      StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();<br>      builder.append(<span class="hljs-string">&quot;&#123; data: &quot;</span>);<br>      builder.append(data);<br>      builder.append(<span class="hljs-string">&quot;; levels: &quot;</span>);<br>      builder.append(maxLevel);<br>      builder.append(<span class="hljs-string">&quot; &#125;&quot;</span>);<br><br>      <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;跳表&quot;&gt;&lt;a href=&quot;#跳表&quot; class=&quot;headerlink&quot; title=&quot;跳表&quot;&gt;&lt;/a&gt;跳表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;假设每两个节点建立一个索引&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对链表稍加改造，就可以支持类似“二分”的查找
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="跳表" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B7%B3%E8%A1%A8/"/>
    
    
      <category term="数据结构与算法,跳表" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://boyolo.github.io/article/42877.html"/>
    <id>https://boyolo.github.io/article/42877.html</id>
    <published>2022-05-13T02:46:38.000Z</published>
    <updated>2022-09-06T05:22:17.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找（Binary Search）算法，也叫折半查找算法</p><p>二分查找针对的是一个<strong>有序的数据集合</strong>，查找思想有点<strong>类似分治思想</strong>。<strong>每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</strong></p><h3 id="时间复杂度：O-logn"><a href="#时间复杂度：O-logn" class="headerlink" title="时间复杂度：O(logn)"></a>时间复杂度：O(logn)</h3><blockquote><p>假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。</p><img src="/article/42877/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E5%8F%98%E5%8C%96.jpg" class title="二分查找区间变化"><p>其中 n/2k=1 时，k 的值就是总共缩小的次数。</p><p>而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。</p><p>通过 n/2<sup>k</sup>=1，我们可以求得 k=log<sub>2</sub>n，所以<strong>时间复杂度就是 O(logn)</strong>。</p></blockquote><p>指数时间复杂度的算法在大规模数据面前是无效的</p><h3 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h3><p><strong>非递归实现</strong></p><blockquote><p>有序数组中不存在重复元素，用二分查找值等于给定值的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>      <span class="hljs-comment">//int mid = (low + high) / 2;</span><br>      <span class="hljs-keyword">int</span> mid = low+(high-low)/<span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span> (a[mid] == value) &#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;<br>        low = mid + <span class="hljs-number">1</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        high = mid - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>注意：</strong></p><ol><li><p>注意是 low&lt;=high，而不是 &lt;</p></li><li><p><strong>mid=(low+high)/2 这种写法是有问题的</strong>。</p><p>因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。</p><p><strong>改进的方法是将 mid 的计算方式写成 low+(high-low)/2。</strong>更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 <strong>low+((high-low)&gt;&gt;1)</strong>。因为相比除法运算来说，计算机处理位运算要快得多。</p></li><li><p>low 和 high 的更新</p><p>low=mid+1，high=mid-1</p></li></ol><p><strong>递归实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 二分查找的递归实现</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> bsearchInternally(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearchInternally</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (low &gt; high) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (a[mid] == value) &#123;<br>    <span class="hljs-keyword">return</span> mid;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;<br>    <span class="hljs-keyword">return</span> bsearchInternally(a, mid+<span class="hljs-number">1</span>, high, value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> bsearchInternally(a, low, mid-<span class="hljs-number">1</span>, value);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h3><ol><li><p>首先，二分查找依赖的是顺序表结构，简单点说就是数组。</p><p>二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。</p></li><li><p>其次，二分查找针对的是有序数据。</p><p>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中</p></li><li><p>再次，数据量太小不适合二分查找。</p><p><strong>例外：</strong>如果数据之间的比较操作非常耗时，不管数据量大小，推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p></li><li><p>最后，数据量太大也不适合二分查找。</p></li></ol><h3 id="二分查找变形问题"><a href="#二分查找变形问题" class="headerlink" title="二分查找变形问题"></a>二分查找变形问题</h3><h4 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h4><p><strong>问题：有序数据集合中存在重复的数据，希望找到第一个值等于给定值的数据</strong></p><blockquote><p>下面这样一个有序数组，其中，a[5]，a[6]，a[7]的值都等于 8，是重复的数据。希望查找第一个等于 8 的数据，也就是下标是 5 的元素。</p><img src="/article/42877/%E5%8F%98%E4%BD%93%E4%B8%80.jpg" class title="变体一"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//写法一：</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt;= value) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (low &lt; n &amp;&amp; a[low]==value) <span class="hljs-keyword">return</span> low;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//写法二：</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || (a[mid - <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;<br>      <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h4><p><strong>问题：有序数据集合中存在重复的数据，希望查找最后一个值等于给定值的元素</strong></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &lt; value) &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> ((mid == n - <span class="hljs-number">1</span>) || (a[mid + <span class="hljs-number">1</span>] != value)) <span class="hljs-keyword">return</span> mid;<br>      <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h4><p><strong>问题：在有序数组中，查找第一个大于等于给定值的元素</strong></p><blockquote><p>数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于 5 的元素，那就是 6。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt;= value) &#123;<br>      <span class="hljs-keyword">if</span> ((mid == <span class="hljs-number">0</span>) || (a[mid - <span class="hljs-number">1</span>] &lt; value)) <span class="hljs-keyword">return</span> mid;<br>      <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h4><p><strong>问题：查找最后一个小于等于给定值的元素</strong></p><blockquote><p>数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于 7 的元素就是 6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bsearch7</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> high = n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>    <span class="hljs-keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (a[mid] &gt; value) &#123;<br>      high = mid - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> ((mid == n - <span class="hljs-number">1</span>) || (a[mid + <span class="hljs-number">1</span>] &gt; value)) <span class="hljs-keyword">return</span> mid;<br>      <span class="hljs-keyword">else</span> low = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="LeetCode实战经验"><a href="#LeetCode实战经验" class="headerlink" title="LeetCode实战经验"></a>LeetCode实战经验</h3><ol><li><p>target 是在一个在左闭右闭的区间，<strong>[left, right]</strong> </p><p>left = 0;<br>right = nums.length - 1;</p><p>二分细节</p><blockquote><p>循环体：<strong>当left==right，区间[left, right]依然有效，所以用 &lt;=</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (left &lt;= right)&#123;&#125;;<br></code></pre></td></tr></table></figure><p>target 在左区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">right = middle - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>target 在右区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">left = middle + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>target 是在一个在左闭右开的区间里，<strong>[left, right)</strong> </p><p>left = 0;<br>right = nums.length;</p><p>二分细节</p><blockquote><p>循环体：<strong>因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (left &lt; right)&#123;&#125;;<br></code></pre></td></tr></table></figure><p>target 在左区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">right = middle;<br></code></pre></td></tr></table></figure><p>target 在右区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">left = middle + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></blockquote></li></ol><h3 id="Leetcode实战"><a href="#Leetcode实战" class="headerlink" title="Leetcode实战"></a>Leetcode实战</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><ol><li><p>先找到位置，遍历左右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span> || nums[<span class="hljs-number">0</span>] &gt; target || nums[len-<span class="hljs-number">1</span>] &lt; target)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>    <span class="hljs-keyword">int</span> result = -<span class="hljs-number">1</span>;<br>    result =  binarySearch(nums,target);<br>    <span class="hljs-keyword">if</span>(result != -<span class="hljs-number">1</span>)&#123;<br>      <span class="hljs-keyword">int</span> left = result;<br>      <span class="hljs-keyword">int</span> right = result;<br>      <span class="hljs-keyword">while</span>(left - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[left-<span class="hljs-number">1</span>] == target )&#123;<br>        left--;<br>      &#125;<br>      <span class="hljs-keyword">while</span>(right + <span class="hljs-number">1</span> &lt; len &amp;&amp; nums[right+<span class="hljs-number">1</span>] == target )&#123;<br>        right++;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left,right&#125;;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>      <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>        right = mid;<br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>        left = mid + <span class="hljs-number">1</span>;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>直接找到左右边界</p><ol><li><p>寻找右边界（不包括target）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRightBorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> rightBorder = -<span class="hljs-number">2</span>; <span class="hljs-comment">// 记录一下rightBorder没有被赋值的情况</span><br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>      right = middle - <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 寻找右边界，nums[middle] == target的时候更新left</span><br>      left = middle + <span class="hljs-number">1</span>;<br>      rightBorder = left;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> rightBorder;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>寻找左边界（不包括target）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLeftBorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> leftBorder = -<span class="hljs-number">2</span>; <span class="hljs-comment">// 记录一下leftBorder没有被赋值的情况</span><br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (nums[middle] &gt;= target) &#123; <span class="hljs-comment">// 寻找左边界，nums[middle] == target的时候更新right</span><br>      right = middle - <span class="hljs-number">1</span>;<br>      leftBorder = right;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      left = middle + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> leftBorder;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>主函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>  <span class="hljs-keyword">int</span> leftBorder = getLeftBorder(nums, target);<br>  <span class="hljs-keyword">int</span> rightBorder = getRightBorder(nums, target);<br>  <span class="hljs-keyword">if</span> (leftBorder == -<span class="hljs-number">2</span> || rightBorder == -<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-keyword">if</span> (rightBorder - leftBorder &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;leftBorder + <span class="hljs-number">1</span>, rightBorder - <span class="hljs-number">1</span>&#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><p><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span> || nums == <span class="hljs-keyword">null</span>)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length;<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>      <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>        right = mid;<br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>        left = mid + <span class="hljs-number">1</span>;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> mid;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 分别处理如下四种情况</span><br>    <span class="hljs-comment">// 目标值在数组所有元素之前 [0,0)</span><br>    <span class="hljs-comment">// 目标值等于数组中某一个元素 return middle</span><br>    <span class="hljs-comment">// 目标值插入数组中的位置 [left, right) ，return right 即可</span><br>    <span class="hljs-comment">// 目标值在数组所有元素之后的情况 [left, right)，因为是右开区间，所以 return right</span><br>    <span class="hljs-keyword">return</span> right;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h2&gt;&lt;p&gt;二分查找（Binary Search）算法，也叫折半查找算法&lt;/p&gt;
&lt;p&gt;二分查找针对的是一个&lt;strong&gt;有序的数据集
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="数据结构与算法,二分查找" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Mysql45讲-实践（四）</title>
    <link href="https://boyolo.github.io/article/17540.html"/>
    <id>https://boyolo.github.io/article/17540.html</id>
    <published>2022-05-09T02:34:05.000Z</published>
    <updated>2022-08-25T09:19:19.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自增主键为什么不是连续的？"><a href="#自增主键为什么不是连续的？" class="headerlink" title="自增主键为什么不是连续的？"></a>自增主键为什么不是连续的？</h2><p>自增主键，由于自增主键可以让主键索引尽量地保持递增顺序插入，避免了页分裂，因此索引更紧凑。</p><p><strong>自增主键不能保证连续递增</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `c` int(11) DEFAULT NULL,<br>  `d` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  UNIQUE KEY `c` (`c`)<br>) ENGINE=InnoDB;<br></code></pre></td></tr></table></figure></blockquote><h3 id="自增值保存在哪儿？"><a href="#自增值保存在哪儿？" class="headerlink" title="自增值保存在哪儿？"></a>自增值保存在哪儿？</h3><blockquote><p>在这个空表 t 里面执行 insert into t values(null, 1, 1); 插入一行数据，再执行 show create table 命令，就可以看到如下图所示的结果：</p><p><img src="/article/自动生成的 AUTO_INCREMENT 值.png"><span class="image-caption">自动生成的 AUTO_INCREMENT 值</span></p><p>表定义里面出现了一个 AUTO_INCREMENT=2，表示下一次插入数据时，如果需要自动生成自增值，会生成 id=2。</p><p>其实，这个输出结果容易引起这样的误解：自增值是保存在表结构定义里的。</p></blockquote><p><strong>表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。</strong></p><p>不同的引擎对于自增值的保存策略不同：</p><ol><li><p>MyISAM 引擎的自增值保存在数据文件中。</p></li><li><p>InnoDB 引擎的自增值，其实是保存在了内存里，并且到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为 MySQL 重启前的值”，具体情况是：</p><ol><li><p>在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。</p><p>﻿举例来说，如果一个表当前数据行里最大的 id 是 10，AUTO_INCREMENT=11。这时候，我们删除 id=10 的行，AUTO_INCREMENT 还是 11。但如果马上重启实例，重启后这个表的 AUTO_INCREMENT 就会变成 10。</p><p>   ﻿也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。</p></li><li><p>在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值。</p></li></ol></li></ol><h3 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h3><p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p><ol><li><p>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</p></li><li><p>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</p><p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。</p><p>假设，某次要插入的值是 X，当前的自增值是 Y。</p><ol><li>如果 X&lt;Y，那么这个表的自增值不变；</li><li>如果 X≥Y，就需要把当前自增值修改为新的自增值。</li></ol></li></ol><p><strong>新的自增值生成算法</strong>是：从 <code>auto_increment_offset</code> 开始，以 <code>auto_increment_increment</code> 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。</p><p>其中，<code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 是两个系统参数，分别用来表示自增的初始值和步长，默认值都是 1。</p><h3 id="自增值的修改时机"><a href="#自增值的修改时机" class="headerlink" title="自增值的修改时机"></a>自增值的修改时机</h3><p><strong>导致自增主键 id 不连续的原因</strong></p><ol><li>唯一键冲突</li><li>事务回滚</li><li>批量插入数据</li></ol><p><strong>自增值为什么不能回退：为了提升性能</strong></p><blockquote><p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请。</p><ol><li>假设事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。</li><li>事务 B 正确提交了，但事务 A 出现了唯一键冲突。</li><li>如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2。</li><li>接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。</li></ol><p>解决这个主键冲突，有两种方法：</p><ol><li>每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。</li><li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li></ol><p>这两个方法都会导致性能问题</p></blockquote><h3 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h3><p>自增 id 锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。</p><ol><li><p>MySQL 5.0 版本</p><p>自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。</p></li><li><p>MySQL 5.1.22 版本</p><p>新增参数 <code>innodb_autoinc_lock_mode</code>，默认值是 1</p><ol><li>这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁；</li><li>这个参数的值被设置为 1 时：<ol><li>普通 <code>insert</code> 语句，自增锁在申请之后就马上释放；</li><li>类似 <code>insert … select</code> 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li></ol></li><li>这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁。</li></ol></li></ol><p>在生产上，尤其是有 <code>insert … select</code> 这种批量插入数据(<code>insert … select</code>、<code>replace … select</code> 和 <code>load data</code> 语句)的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：<code>innodb_autoinc_lock_mode=2</code> ，并且 <code>binlog_format=row</code>. 这样做，既能提升并发性，又不会出现数据一致性问题。</p><p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p><ol><li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li><li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li><li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li><li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li></ol><hr><blockquote><p><strong>问题：在 binlog_format=statement 时，语句 A 先获取 id=1，然后语句 B 获取 id=2；接着语句 B 提交，写 binlog，然后语句 A 再写 binlog。这时候，如果 binlog 重放，是不是会发生语句 B 的 id 为 1，而语句 A 的 id 为 2 的不一致情况呢？</strong></p><p>自增 id 的生成顺序，和 binlog 的写入顺序可能是不同的</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table t(id int auto_increment primary key);<br>insert into t values(null);<br></code></pre></td></tr></table></figure><p><img src="/article/insert 语句的 binlog.jpg"><span class="image-caption">insert 语句的 binlog</span></p><p>可以看到，在 insert 语句之前，还有一句 SET INSERT_ID=1。这条命令的意思是，这个线程里下一次需要用到自增值的时候，不论当前表的自增值是多少，固定用 1 这个值。</p><p>这个 SET INSERT_ID 语句是固定跟在 insert 语句之前的,主库上语句 A 的 id 是 1，语句 B 的 id 是 2，但是写入 binlog 的顺序先 B 后 A，那么 binlog 就变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET INSERT_ID=2;<br>语句B；<br>SET INSERT_ID=1;<br>语句A；<br></code></pre></td></tr></table></figure><p>在备库上语句 B 用到的 INSERT_ID 依然是 2，跟主库相同</p></blockquote><p><strong>因此，即使两个 INSERT 语句在主备库的执行顺序不同，自增主键字段的值也不会不一致。</strong></p></blockquote><hr><h2 id="insert语句的锁为什么这么多？"><a href="#insert语句的锁为什么这么多？" class="headerlink" title="insert语句的锁为什么这么多？"></a>insert语句的锁为什么这么多？</h2><h3 id="insert-…-select-语句"><a href="#insert-…-select-语句" class="headerlink" title="insert … select 语句"></a>insert … select 语句</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `c` int(11) DEFAULT NULL,<br>  `d` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  UNIQUE KEY `c` (`c`)<br>) ENGINE=InnoDB;<br><br>insert into t values(null, 1,1);<br>insert into t values(null, 2,2);<br>insert into t values(null, 3,3);<br>insert into t values(null, 4,4);<br><br>create table t2 like t<br></code></pre></td></tr></table></figure><p>在可重复读隔离级别下，binlog_format=statement 时执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t2(c,d) select c,d from t;<br></code></pre></td></tr></table></figure><p>需要对表 t 的所有行和间隙加锁。</p><p>执行序列：</p><p><img src="/article/并发 insert 场景.png"><span class="image-caption">并发 insert 场景</span></p><p>实际的执行效果是，如果 session B 先执行，由于这个语句对表 t 主键索引加了 (-∞,1]这个 next-key lock，会在语句执行完成后，才允许 session A 的 insert 语句执行。</p><p>但如果没有锁的话，就可能出现 session B 的 insert 语句先执行，但是后写入 binlog 的情况。于是，在 binlog_format=statement 的情况下，binlog 里面就记录了这样的语句序列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t values(-1,-1,-1);<br>insert into t2(c,d) select c,d from t;<br></code></pre></td></tr></table></figure><p>这个语句到了备库执行，就会把 id=-1 这一行也写到表 t2 中，出现主备不一致。</p></blockquote><p>执行 <code>insert … select</code> 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源。</p><h3 id="insert-循环写入"><a href="#insert-循环写入" class="headerlink" title="insert 循环写入"></a>insert 循环写入</h3><blockquote><p>要往表 t2 中插入一行数据，这一行的 c 值是表 t 中 c 值的最大值加 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t2(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);<br></code></pre></td></tr></table></figure><p>这个语句的加锁范围，就是表 t 索引 c 上的 (3,4]和 (4,supremum]这两个 next-key lock，以及主键索引上 id=4 这一行。</p><p>执行流程:从表 t 中按照索引 c 倒序，扫描第一行，拿到结果写入到表 t2 中。</p><p>整条语句的扫描行数是 1。</p></blockquote><blockquote><p>把这样的一行数据插入到表 t 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t(c,d)  (select c+1, d from t force index(c) order by c desc limit 1);<br></code></pre></td></tr></table></figure><p>慢查询日志:</p><p><img src="/article/慢查询日志 -- 将数据插入表 t.png"><span class="image-caption">慢查询日志 -- 将数据插入表 t</span></p><p>Rows_examined 的值是 5</p><p>explain 结果:</p><p><img src="/article/explain 结果.png"><span class="image-caption">explain 结果.png</span></p><p>从 Extra 字段可以看到“Using temporary”字样，表示这个语句用到了临时表。执行过程中，需要把表 t 的内容读出来，写入临时表。</p><p>在执行这个语句前后查看 Innodb_rows_read 的结果:</p><p><img src="/article/查看 Innodb_rows_read 变化.png"><span class="image-caption">查看 Innodb_rows_read 变化</span></p><p>这个语句执行前后，Innodb_rows_read 的值增加了 4。因为默认临时表是使用 Memory 引擎的，所以这 4 行查的都是表 t，也就是说对表 t 做了全表扫描。</p><p>执行过程:</p><ol><li>创建临时表，表里有两个字段 c 和 d。</li><li>按照索引 c 扫描表 t，依次取 c=4、3、2、1，然后回表，读到 c 和 d 的值写入临时表。这时，Rows_examined=4。</li><li>由于语义里面有 limit 1，所以只取了临时表的第一行，再插入到表 t 中。这时，Rows_examined 的值加 1，变成了 5。</li></ol><p>这个语句会导致在表 t 上做全表扫描，并且会给索引 c 上的所有间隙都加上共享的 next-key lock。所以，这个语句执行期间，其他事务不能在这个表上插入数据。</p><p><strong>这个语句的执行为什么需要临时表?</strong></p><p>原因是这类一边遍历数据，一边更新数据的情况，如果读出来的数据直接写回原表，就可能在遍历过程中，读到刚刚插入的记录，新插入的记录如果参与计算逻辑，就跟语义不符。</p></blockquote><h3 id="insert-唯一键冲突"><a href="#insert-唯一键冲突" class="headerlink" title="insert 唯一键冲突"></a>insert 唯一键冲突</h3><blockquote><img src="/article/17540/%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81%E5%8A%A0%E9%94%81.png" class title="唯一键冲突加锁"><p>在可重复读（repeatable read）隔离级别下执行</p><p>session B 要执行的 insert 语句进入了锁等待状态。</p><p>session A 执行的 insert 语句，发生唯一键冲突的时候，并不只是简单地报错返回，还在冲突的索引上加了锁。</p><p>这时候，session A 持有索引 c 上的 (5,10]共享 next-key lock（读锁）。</p></blockquote><h3 id="insert-into-…-on-duplicate-key-update"><a href="#insert-into-…-on-duplicate-key-update" class="headerlink" title="insert into … on duplicate key update"></a>insert into … on duplicate key update</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into t values(11,10,10) on duplicate key update d=100; <br></code></pre></td></tr></table></figure><p>会给索引 c 上 (5,10] 加一个排他的 next-key lock（写锁）</p></blockquote><p><code>insert into … on duplicate key update</code> 这个语义的逻辑是，插入一行数据，如果碰到唯一键约束，就执行后面的更新语句。</p><p>注意，如果有多个列违反了唯一性约束，就会按照索引的顺序，修改跟第一个索引冲突的行。</p><blockquote><p>现在表 t 里面已经有了 (1,1,1) 和 (2,2,2) 这两行</p><img src="/article/17540/%E4%B8%A4%E4%B8%AA%E5%94%AF%E4%B8%80%E9%94%AE%E5%90%8C%E6%97%B6%E5%86%B2%E7%AA%81.png" class title="两个唯一键同时冲突"><p>主键 id 是先判断的，MySQL 认为这个语句跟 id=2 这一行冲突，所以修改的是 id=2 的行。</p><p>需要注意的是，执行这条语句的 affected rows 返回的是 2，很容易造成误解。实际上，真正更新的只有一行，只是在代码实现上，insert 和 update 都认为自己成功了，update 计数加了 1， insert 计数也加了 1。</p></blockquote><h2 id="怎么最快地复制一张表？"><a href="#怎么最快地复制一张表？" class="headerlink" title="怎么最快地复制一张表？"></a>怎么最快地复制一张表？</h2><ol><li>如果可以控制对源表的扫描行数和加锁范围很小的话，简单地使用 <code>insert … select</code>语句即可实现。</li><li>为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表。</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database db1;<br>use db1;<br><br>create table t(id int primary key, a int, b int, index(a))engine=innodb;<br>delimiter ;;<br>  create procedure idata()<br>  begin<br>    declare i int;<br>    set i=1;<br>    while(i&lt;=1000)do<br>      insert into t values(i,i,i);<br>      set i=i+1;<br>    end while;<br>  end;;<br>delimiter ;<br>call idata();<br><br>create database db2;<br>create table db2.t like db1.t<br></code></pre></td></tr></table></figure><p>先创建一个表 db1.t，并插入 1000 行数据，同时创建一个相同结构的表 db2.t</p></blockquote><h3 id="mysqldump-方法"><a href="#mysqldump-方法" class="headerlink" title="mysqldump 方法"></a>mysqldump 方法</h3><p>使用 mysqldump 命令将数据导出成一组 INSERT 语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqldump -h<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.982ex" height="2.343ex" style="vertical-align: -0.505ex;" viewbox="0 -791.3 3867.4 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title"><title id="MathJax-SVG-1-Title">host -P</title><defs aria-hidden="true"><path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/><path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/><path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/><path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/><path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path stroke-width="1" id="E1-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true"> <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/> <use xlink:href="#E1-MJMATHI-6F" x="576" y="0"/> <use xlink:href="#E1-MJMATHI-73" x="1062" y="0"/> <use xlink:href="#E1-MJMATHI-74" x="1531" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="2115" y="0"/> <use xlink:href="#E1-MJMATHI-50" x="3115" y="0"/></g></svg>port -u$user --add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&quot;a&gt;900&quot; --result-file=/client_tmp/t.sql<br></code></pre></td></tr></table></figure><ol><li><code>–single-transaction</code> 的作用是，在导出数据的时候不需要对表 db1.t 加表锁，而是使用 <code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code>(立即开启一个事务，否则事务是再执行到第一个sql语句的时候创建的) 的方法；</li><li><code>–add-locks</code> 设置为 0，表示在输出的文件结果里，不增加” <code>LOCK TABLES t WRITE;</code>“ ；</li><li><code>–no-create-info</code> 的意思是，不需要导出表结构；</li><li><code>–set-gtid-purged=off</code> 表示的是，不输出跟 GTID 相关的信息；</li><li><code>–result-file</code> 指定了输出文件的路径，其中 client 表示生成的文件是在客户端机器上的。</li></ol><blockquote><p>通过这条 mysqldump 命令生成的 t.sql 文件中就包含了如图所示的 INSERT 语句</p><p><img src="/article/mysqldump 输出文件的部分结果.png"><span class="image-caption">mysqldump 输出文件的部分结果</span></p><p>一条 INSERT 语句里面会包含多个 value 对，这是为了后续用这个文件来写入数据的时候，执行速度可以更快。</p><p>如果希望生成的文件中一条 INSERT 语句只插入一行数据的话，可以在执行 mysqldump 命令时，加上参数<code>–skip-extended-insert</code>。</p></blockquote><p>然后，可以通过下面这条命令，将这些 INSERT 语句放到 db2 库里去执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -h127.0.0.1 -P13000  -uroot db2 -e &quot;source /client_tmp/t.sql&quot;<br></code></pre></td></tr></table></figure><p>source 并不是一条 SQL 语句，而是一个</p><p>客户端命令</p><p>mysql 客户端执行这个命令的流程是这样的：</p><ol><li>打开文件，默认以分号为结尾读取一条条的 SQL 语句；</li><li>将 SQL 语句发送到服务端执行。</li></ol><p>也就是说，服务端执行的并不是这个“<code>source t.sql</code>“语句，而是 <code>INSERT</code> 语句。所以，不论是在慢查询日志（slow log），还是在 binlog，记录的都是这些要被真正执行的 INSERT 语句。</p><h3 id="导出-CSV-文件"><a href="#导出-CSV-文件" class="headerlink" title="导出 CSV 文件"></a>导出 CSV 文件</h3><p>直接将结果导出成.csv 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from db1.t where a&gt;900 into outfile &#x27;/server_tmp/t.csv&#x27;;<br></code></pre></td></tr></table></figure><p>需要注意如下几点:</p><ol><li>这条语句会将结果保存在服务端。如果你执行命令的客户端和 MySQL 服务端不在同一个机器上，客户端机器的临时目录下是不会生成 t.csv 文件的。</li><li><code>into outfile</code> 指定了文件的生成位置（/server_tmp/），这个位置必须受参数 <code>secure_file_priv</code> 的限制。参数 <code>secure_file_priv</code> 的可选值和作用分别是：<ol><li>如果设置为 empty，表示不限制文件生成的位置，这是不安全的设置；</li><li>如果设置为一个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</li><li>如果设置为 NULL，就表示禁止在这个 MySQL 实例上执行 <code>select … into outfile</code> 操作。</li></ol></li><li>这条命令不会帮你覆盖文件，因此你需要确保 /server_tmp/t.csv 这个文件不存在，否则执行语句时就会因为有同名文件的存在而报错。</li><li>这条命令生成的文本文件中，原则上一个数据行对应文本文件的一行。但是，如果字段中包含换行符，在生成的文本中也会有换行符。不过类似换行符、制表符这类符号，前面都会跟上“\”这个转义符，这样就可以跟字段之间、数据行之间的分隔符区分开。</li></ol><p>得到.csv 导出文件后，就可以用下面的 load data 命令将数据导入到目标表 db2.t 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">load data infile &#x27;/server_tmp/t.csv&#x27; into table db2.t;<br></code></pre></td></tr></table></figure><p>这条语句的执行流程如下所示:</p><ol><li>打开文件 /server_tmp/t.csv，以制表符 (\t) 作为字段间的分隔符，以换行符（\n）作为记录之间的分隔符，进行数据读取；</li><li>启动事务</li><li>判断每一行的字段数与表 db2.t 是否相同：<ol><li>若不相同，则直接报错，事务回滚；</li><li>若相同，则构造成一行，调用 InnoDB 引擎接口，写入到表中。</li></ol></li><li>重复步骤 3，直到 /server_tmp/t.csv 整个文件读入完成，提交事务。</li></ol><blockquote><p><strong>问题：如果 binlog_format=statement，这个 load 语句记录到 binlog 里以后，怎么在备库重放呢？</strong></p><p>由于 /server_tmp/t.csv 文件只保存在主库所在的主机上，如果只是把这条语句原文写到 binlog 中，在备库执行的时候，备库的本地机器上没有这个文件，就会导致主备同步停止。</p><p>所以，这条语句执行的完整流程，其实是下面这样的：</p><ol><li>主库执行完成后，将 /server_tmp/t.csv 文件的内容直接写到 binlog 文件中。</li><li>往 binlog 文件中写入语句 load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE `db2`.`t`。</li><li>把这个 binlog 日志传到备库。</li><li>备库的 apply 线程在执行这个事务日志时：<ol><li>先将 binlog 中 t.csv 文件的内容读出来，写入到本地临时目录 /tmp/SQL_LOAD_MB-1-0 中；</li><li>再执行 load data 语句，往备库的 db2.t 表中插入跟主库相同的数据。</li></ol></li></ol><p><img src="/article/load data 的同步流程.jpg"><span class="image-caption">load data 的同步流程</span></p><p>注意，这里备库执行的 load data 语句里面，多了一个“local”。它的意思是“将执行这条命令的客户端所在机器的本地文件 /tmp/SQL_LOAD_MB-1-0 的内容，加载到目标表 db2.t 中”。</p></blockquote><p>load data 命令有两种用法：</p><ol><li>不加“local”，是读取服务端的文件，这个文件必须在 secure_file_priv 指定的目录或子目录下；</li><li>加上“local”，读取的是客户端的文件，只要 mysql 客户端有访问这个文件的权限即可。这时候，MySQL 客户端会先把本地文件传给服务端，然后执行上述的 load data 流程</li></ol><p><code>select …into outfile</code> 方法<strong>不会生成表结构文件</strong>, 所以我们导数据时还需要单独的命令得到表结构定义。</p><p>mysqldump 提供了一个<code>–tab</code> 参数，可以同时导出表结构定义文件和 csv 数据文件。这条命令的使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysqldump -h<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.982ex" height="2.343ex" style="vertical-align: -0.505ex;" viewbox="0 -791.3 3867.4 1008.6" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title"><title id="MathJax-SVG-1-Title">host -P</title><defs aria-hidden="true"><path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/><path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/><path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/><path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/><path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path stroke-width="1" id="E1-MJMATHI-50" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true"> <use xlink:href="#E1-MJMATHI-68" x="0" y="0"/> <use xlink:href="#E1-MJMATHI-6F" x="576" y="0"/> <use xlink:href="#E1-MJMATHI-73" x="1062" y="0"/> <use xlink:href="#E1-MJMATHI-74" x="1531" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="2115" y="0"/> <use xlink:href="#E1-MJMATHI-50" x="3115" y="0"/></g></svg>port -u<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="105.481ex" height="2.509ex" style="vertical-align: -0.671ex;" viewbox="0 -791.3 45415.1 1080.4" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title"><title id="MathJax-SVG-1-Title">user ---single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --tab=</title><defs aria-hidden="true"><path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-73" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/><path stroke-width="1" id="E1-MJMATHI-65" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/><path stroke-width="1" id="E1-MJMATHI-72" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMAIN-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path stroke-width="1" id="E1-MJMATHI-69" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-67" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/><path stroke-width="1" id="E1-MJMATHI-6C" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path stroke-width="1" id="E1-MJMATHI-74" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/><path stroke-width="1" id="E1-MJMATHI-61" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/><path stroke-width="1" id="E1-MJMATHI-63" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/><path stroke-width="1" id="E1-MJMATHI-6F" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/><path stroke-width="1" id="E1-MJMATHI-64" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"/><path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path stroke-width="1" id="E1-MJMATHI-4F" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path stroke-width="1" id="E1-MJMATHI-46" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"/><path stroke-width="1" id="E1-MJMATHI-62" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/><path stroke-width="1" id="E1-MJMAIN-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path stroke-width="1" id="E1-MJMATHI-77" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"/><path stroke-width="1" id="E1-MJMATHI-68" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/><path stroke-width="1" id="E1-MJMAIN-22" d="M34 634Q34 659 50 676T93 694Q121 694 144 668T168 579Q168 525 146 476T101 403T73 379Q69 379 60 388T50 401Q50 404 62 417T88 448T116 500T131 572Q131 584 130 584T125 581T112 576T94 573Q69 573 52 590T34 634ZM238 634Q238 659 254 676T297 694Q325 694 348 668T372 579Q372 525 350 476T305 403T277 379Q273 379 264 388T254 401Q254 404 266 417T292 448T320 500T335 572Q335 584 334 584T329 581T316 576T298 573Q273 573 256 590T238 634Z"/><path stroke-width="1" id="E1-MJMAIN-3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/><path stroke-width="1" id="E1-MJMAIN-39" d="M352 287Q304 211 232 211Q154 211 104 270T44 396Q42 412 42 436V444Q42 537 111 606Q171 666 243 666Q245 666 249 666T257 665H261Q273 665 286 663T323 651T370 619T413 560Q456 472 456 334Q456 194 396 97Q361 41 312 10T208 -22Q147 -22 108 7T68 93T121 149Q143 149 158 135T173 96Q173 78 164 65T148 49T135 44L131 43Q131 41 138 37T164 27T206 22H212Q272 22 313 86Q352 142 352 280V287ZM244 248Q292 248 321 297T351 430Q351 508 343 542Q341 552 337 562T323 588T293 615T246 625Q208 625 181 598Q160 576 154 546T147 441Q147 358 152 329T172 282Q197 248 244 248Z"/><path stroke-width="1" id="E1-MJMAIN-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true"> <use xlink:href="#E1-MJMATHI-75" x="0" y="0"/> <use xlink:href="#E1-MJMATHI-73" x="572" y="0"/> <use xlink:href="#E1-MJMATHI-65" x="1042" y="0"/> <use xlink:href="#E1-MJMATHI-72" x="1508" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="2182" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="3182" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="4183" y="0"/> <use xlink:href="#E1-MJMATHI-73" x="5184" y="0"/> <use xlink:href="#E1-MJMATHI-69" x="5653" y="0"/> <use xlink:href="#E1-MJMATHI-6E" x="5999" y="0"/> <use xlink:href="#E1-MJMATHI-67" x="6599" y="0"/> <use xlink:href="#E1-MJMATHI-6C" x="7080" y="0"/> <use xlink:href="#E1-MJMATHI-65" x="7378" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="8067" y="0"/> <use xlink:href="#E1-MJMATHI-74" x="9068" y="0"/> <use xlink:href="#E1-MJMATHI-72" x="9429" y="0"/> <use xlink:href="#E1-MJMATHI-61" x="9881" y="0"/> <use xlink:href="#E1-MJMATHI-6E" x="10410" y="0"/> <use xlink:href="#E1-MJMATHI-73" x="11011" y="0"/> <use xlink:href="#E1-MJMATHI-61" x="11480" y="0"/> <use xlink:href="#E1-MJMATHI-63" x="12010" y="0"/> <use xlink:href="#E1-MJMATHI-74" x="12443" y="0"/> <use xlink:href="#E1-MJMATHI-69" x="12805" y="0"/> <use xlink:href="#E1-MJMATHI-6F" x="13150" y="0"/> <use xlink:href="#E1-MJMATHI-6E" x="13636" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="14459" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="15459" y="0"/> <use xlink:href="#E1-MJMATHI-73" x="16238" y="0"/> <use xlink:href="#E1-MJMATHI-65" x="16707" y="0"/> <use xlink:href="#E1-MJMATHI-74" x="17174" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="17758" y="0"/> <use xlink:href="#E1-MJMATHI-67" x="18758" y="0"/> <use xlink:href="#E1-MJMATHI-74" x="19239" y="0"/> <use xlink:href="#E1-MJMATHI-69" x="19600" y="0"/> <use xlink:href="#E1-MJMATHI-64" x="19946" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="20691" y="0"/> <use xlink:href="#E1-MJMATHI-70" x="21692" y="0"/> <use xlink:href="#E1-MJMATHI-75" x="22196" y="0"/> <use xlink:href="#E1-MJMATHI-72" x="22768" y="0"/> <use xlink:href="#E1-MJMATHI-67" x="23220" y="0"/> <use xlink:href="#E1-MJMATHI-65" x="23700" y="0"/> <use xlink:href="#E1-MJMATHI-64" x="24167" y="0"/> <use xlink:href="#E1-MJMAIN-3D" x="24968" y="0"/> <use xlink:href="#E1-MJMATHI-4F" x="26024" y="0"/> <use xlink:href="#E1-MJMATHI-46" x="26788" y="0"/> <use xlink:href="#E1-MJMATHI-46" x="27537" y="0"/> <use xlink:href="#E1-MJMATHI-64" x="28287" y="0"/> <use xlink:href="#E1-MJMATHI-62" x="28810" y="0"/> <use xlink:href="#E1-MJMAIN-31" x="29240" y="0"/> <use xlink:href="#E1-MJMATHI-74" x="29740" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="30324" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="31325" y="0"/> <use xlink:href="#E1-MJMATHI-77" x="32103" y="0"/> <use xlink:href="#E1-MJMATHI-68" x="32820" y="0"/> <use xlink:href="#E1-MJMATHI-65" x="33396" y="0"/> <use xlink:href="#E1-MJMATHI-72" x="33863" y="0"/> <use xlink:href="#E1-MJMATHI-65" x="34314" y="0"/><g transform="translate(35058,0)"> <use xlink:href="#E1-MJMAIN-3D"/> <use xlink:href="#E1-MJMAIN-22" x="778" y="0"/></g> <use xlink:href="#E1-MJMATHI-61" x="36615" y="0"/> <use xlink:href="#E1-MJMAIN-3E" x="37423" y="0"/><g transform="translate(38479,0)"> <use xlink:href="#E1-MJMAIN-39"/> <use xlink:href="#E1-MJMAIN-30" x="500" y="0"/> <use xlink:href="#E1-MJMAIN-30" x="1001" y="0"/></g> <use xlink:href="#E1-MJMAIN-22" x="40258" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="41036" y="0"/> <use xlink:href="#E1-MJMAIN-2212" x="42037" y="0"/> <use xlink:href="#E1-MJMATHI-74" x="43038" y="0"/> <use xlink:href="#E1-MJMATHI-61" x="43399" y="0"/> <use xlink:href="#E1-MJMATHI-62" x="43929" y="0"/> <use xlink:href="#E1-MJMAIN-3D" x="44636" y="0"/></g></svg>secure_file_priv<br></code></pre></td></tr></table></figure><p>这条命令会在 <code>$secure_file_priv</code> 定义的目录下，创建一个 t.sql 文件保存建表语句，同时创建一个 t.txt 文件保存 CSV 数据。</p><h3 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h3><blockquote><p><strong>问题：直接把 db1.t 表的.frm 文件和.ibd 文件拷贝到 db2 目录下，是否可行呢？</strong></p><p>一个 InnoDB 表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有 db2.t 这个表，系统是不会识别和接受它们的。</p></blockquote><p>在 MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出 + 导入表空间的方式，实现物理拷贝表的功能。</p><blockquote><p>假设我们现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r，具体的执行步骤如下：</p><ol><li>执行 <code>create table r like t</code>，创建一个相同表结构的空表；</li><li>执行 <code>alter table r discard tablespace</code>，这时候 r.ibd 文件会被删除；</li><li>执行 <code>flush table t for export</code>，这时候 db1 目录下会生成一个 t.cfg 文件；</li><li>在 db1 目录下执行 <code>cp t.cfg r.cfg; cp t.ibd r.ibd；</code>这两个命令（这里需要注意的是，拷贝得到的两个文件，MySQL 进程要有读写权限）；</li><li>执行 <code>unlock tables</code>，这时候 t.cfg 文件会被删除；</li><li>执行 <code>alter table r import tablespace</code>，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</li></ol><img src="/article/17540/%E7%89%A9%E7%90%86%E6%8B%B7%E8%B4%9D%E8%A1%A8.jpg" class title="物理拷贝表"><p><strong>注意点：</strong></p><ol><li>在第 3 步执行完 <code>flsuh table</code> 命令之后，db1.t 整个表处于只读状态，直到执行 <code>unlock tables</code> 命令后才释放读锁；</li><li>在执行 <code>import tablespace</code> 的时候，为了让文件里的表空间 id 和数据字典中的一致，会修改 r.ibd 的表空间 id。而这个表空间 id 存在于每一个数据页中。因此，如果是一个很大的文件（比如 TB 级别），每个数据页都需要修改，所以你会看到这个 import 语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import 语句的耗时是非常短的。</li></ol></blockquote><h3 id="三种方法的优缺点"><a href="#三种方法的优缺点" class="headerlink" title="三种方法的优缺点"></a>三种方法的优缺点</h3><ol><li>物理拷贝的方式速度最快，尤其对于大表拷贝来说是最快的方法。如果出现误删表的情况，用备份恢复出误删之前的临时库，然后再把临时库中的表拷贝到生产库上，是恢复数据最快的方法。但是，这种方法的使用也有一定的局限性：<ol><li>必须是全表拷贝，不能只拷贝部分数据；</li><li>需要到服务器上拷贝数据，在用户无法登录数据库主机的场景下无法使用；</li><li>由于是通过拷贝物理文件实现的，源表和目标表都是使用 InnoDB 引擎时才能使用。</li></ol></li><li>用 mysqldump 生成包含 INSERT 语句文件的方法，可以在 where 参数增加过滤条件，来实现只导出部分数据。这个方式的不足之一是，不能使用 join 这种比较复杂的 where 条件写法。</li><li>用 <code>select … into outfile</code> 的方法是最灵活的，支持所有的 SQL 写法。但，这个方法的缺点之一就是，每次只能导出一张表的数据，而且表结构也需要另外的语句单独备份。</li></ol><h2 id="grant之后要跟着flush-privileges吗？"><a href="#grant之后要跟着flush-privileges吗？" class="headerlink" title="grant之后要跟着flush privileges吗？"></a>grant之后要跟着flush privileges吗？</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user &#x27;ua&#x27;@&#x27;%&#x27; identified by &#x27;pa&#x27;;<br></code></pre></td></tr></table></figure><p>这条语句的逻辑是创建一个用户’ua’@’%’，密码是 pa。注意，在 MySQL 里面，用户名 (user)+ 地址 (host) 才表示一个用户。</p><p>这条命令做了两个动作：</p><ol><li>磁盘上，往 mysql.user 表里插入一行，由于没有指定权限，所以这行数据上所有表示权限的字段的值都是 N；</li><li>内存里，往数组 acl_users 里插入一个 acl_user 对象，这个对象的 access 字段值为 0。</li></ol><p>用户 ua 在 user 表中的状态</p><p><img src="/article/mysql.user 数据行.png"><span class="image-caption">mysql.user 数据行</span></p></blockquote><h3 id="全局权限"><a href="#全局权限" class="headerlink" title="全局权限"></a>全局权限</h3><p>全局权限，作用于整个 MySQL 实例，这些权限信息保存在 mysql 库的 user 表里。</p><blockquote><p>如果要给用户 ua 赋一个最高权限的话，语句是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on *.* to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;<br></code></pre></td></tr></table></figure><p>这个 grant 命令做了两个动作：</p><ol><li>磁盘上，将 mysql.user 表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为‘Y’；</li><li>内存里，从数组 acl_users 中找到这个用户对应的对象，将 access 值（权限位）修改为二进制的“全 1”。</li></ol><p>在这个 grant 命令执行完成后，如果有新的客户端使用用户名 ua 登录成功，MySQL 会为新连接维护一个线程对象，然后从 acl_users 数组里查到这个用户的权限，并将权限值拷贝到这个线程对象中。之后在这个连接中执行的语句，所有关于全局权限的判断，都直接使用线程对象内部保存的权限位</p></blockquote><p>基于上面的分析我们可以知道：</p><ol><li>grant 命令对于全局权限，同时更新了磁盘和内存。命令完成后即时生效，接下来新创建的连接会使用新的权限。</li><li>对于一个已经存在的连接，它的全局权限不受 grant 命令的影响。</li></ol><blockquote><p>如果要回收上面的 grant 语句赋予的权限，可以使用下面这条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">revoke all privileges on *.* from &#x27;ua&#x27;@&#x27;%&#x27;;<br></code></pre></td></tr></table></figure><p>这条 revoke 命令的用法与 grant 类似，做了如下两个动作：</p><ol><li>磁盘上，将 mysql.user 表里，用户’ua’@’%’这一行的所有表示权限的字段的值都修改为“N”；</li><li>内存里，从数组 acl_users 中找到这个用户对应的对象，将 access 的值修改为 0。</li></ol></blockquote><h3 id="db-权限"><a href="#db-权限" class="headerlink" title="db 权限"></a>db 权限</h3><p>除了全局权限，MySQL 也支持库级别的权限定义。</p><blockquote><p>如果要让用户 ua 拥有库 db1 的所有权限，可以执行下面这条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant all privileges on db1.* to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;<br></code></pre></td></tr></table></figure><p>基于库的权限记录保存在 mysql.db 表中，在内存里则保存在数组 acl_dbs 中。这条 grant 命令做了如下两个动作：</p><ol><li>磁盘上，往 mysql.db 表中插入了一行记录，所有权限位字段设置为“Y”；</li><li>内存里，增加一个对象到数组 acl_dbs 中，这个对象的权限位为“全 1”。</li></ol><p>这个时刻用户 ua 在 db 表中的状态:</p><p><img src="/article/mysql.db 数据行.png"><span class="image-caption">mysql.db 数据行</span></p><p>每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次 acl_dbs 数组，根据 user、host 和 db 找到匹配的对象，然后根据对象的权限位来判断。</p></blockquote><p>grant 修改 db 权限的时候，是同时对磁盘和内存生效的</p><p>对于全局权限，因为全局权限存储在线程对象中，所以修改用户的全局权限后，不会影响到已经存在的连接； </p><p>对于数据库权限，因为acl_dbs是一个全局数组，修改用户的数据库权限，acl_dbs也会立马随之修改，线程对象可以立刻读到，所以会直接影响到已经存在的连接。</p><h3 id="表权限和列权限"><a href="#表权限和列权限" class="headerlink" title="表权限和列权限"></a>表权限和列权限</h3><p>除了 db 级别的权限外，MySQL 支持更细粒度的表权限和列权限。</p><p>其中，表权限定义存放在表 mysql.tables_priv 中，列权限定义存放在表 mysql.columns_priv 中。</p><p>这两类权限，组合起来存放在内存的 hash 结构 column_priv_hash 中。</p><blockquote><p>这两类权限的赋权命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table db1.t1(id int, a int);<br><br>grant all privileges on db1.t1 to &#x27;ua&#x27;@&#x27;%&#x27; with grant option;<br>GRANT SELECT(id), INSERT (id,a) ON mydb.mytbl TO &#x27;ua&#x27;@&#x27;%&#x27; with grant option;<br></code></pre></td></tr></table></figure><p>跟 db 权限类似，这两个权限每次 grant 的时候都会修改数据表，也会同步修改内存中的 hash 结构。因此，<strong>对这两类权限的操作，也会马上影响到已经存在的连接。</strong></p></blockquote><h3 id="flush-privileges-命令"><a href="#flush-privileges-命令" class="headerlink" title="flush privileges 命令"></a>flush privileges 命令</h3><p><code>flush privileges</code> 命令会清空 acl_users 数组，然后从 mysql.user 表中读取数据重新加载，重新构造一个 acl_users 数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一遍。</p><p>对于 db 权限、表权限和列权限，MySQL 也做了这样的处理</p><p>也就是说，如果内存的权限数据和磁盘数据表相同的话，不需要执行 flush privileges。而如果我们都是用 grant/revoke 语句来执行的话，内存和数据表本来就是保持同步更新的。<strong>因此，正常情况下，grant 命令之后，没有必要跟着执行 flush privileges 命令。</strong></p><h3 id="flush-privileges-使用场景"><a href="#flush-privileges-使用场景" class="headerlink" title="flush privileges 使用场景"></a>flush privileges 使用场景</h3><p>当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges 语句可以用来重建内存数据，达到一致状态。</p><blockquote><p>直接用 DML 语句操作系统权限表</p><p><img src="/article/使用 flush privileges.png"><span class="image-caption">使用 flush privileges</span></p><p>T3 时刻虽然已经用 delete 语句删除了用户 ua，但是在 T4 时刻，仍然可以用 ua 连接成功。原因就是，这时候内存中 acl_users 数组中还有这个用户，因此系统判断时认为用户还正常存在。</p><p>在 T5 时刻执行过 flush 命令后，内存更新，T6 时刻再要用 ua 来登录的话，就会报错“无法访问”了</p></blockquote><h2 id="要不要使用分区表？"><a href="#要不要使用分区表？" class="headerlink" title="要不要使用分区表？"></a>要不要使用分区表？</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `t` (<br>  `ftime` datetime NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  KEY (`ftime`)<br>) ENGINE=InnoDB DEFAULT CHARSET=latin1<br>PARTITION BY RANGE (YEAR(ftime))<br>(PARTITION p_2017 VALUES LESS THAN (2017) ENGINE = InnoDB,<br> PARTITION p_2018 VALUES LESS THAN (2018) ENGINE = InnoDB,<br> PARTITION p_2019 VALUES LESS THAN (2019) ENGINE = InnoDB,<br>PARTITION p_others VALUES LESS THAN MAXVALUE ENGINE = InnoDB);<br>insert into t values(&#x27;2017-4-1&#x27;,1),(&#x27;2018-4-1&#x27;,1);<br></code></pre></td></tr></table></figure><p><img src="/article/表 t 的磁盘文件.png"><span class="image-caption">表 t 的磁盘文件</span></p><p>在表 t 中初始化插入了两行记录，按照定义的分区规则，这两行记录分别落在 p_2018 和 p_2019 这两个分区上。</p><p>这个表包含了一个.frm 文件和 4 个.ibd 文件，每个分区对应一个.ibd 文件。也就是说：</p><ol><li>对于引擎层来说，这是 4 个表；</li><li>对于 Server 层来说，这是 1 个表。</li></ol></blockquote><ol><li>MySQL 在第一次打开分区表的时候，需要访问所有的分区；</li><li>在 server 层，认为这是同一张表，因此所有分区共用同一个 MDL 锁；</li><li>在引擎层，认为这是不同的表，因此 MDL 锁之后的执行过程，会根据分区表规则，只访问必要的分区。</li></ol><ol><li>分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。</li><li>分区也不要提前预留太多，在使用之前预先创建即可。</li><li>对于没有数据的历史分区，要及时的 drop 掉。</li></ol><h2 id="自增id用完怎么办？"><a href="#自增id用完怎么办？" class="headerlink" title="自增id用完怎么办？"></a>自增id用完怎么办？</h2><p>MySQL 里有很多自增的 id，每个自增 id 都是定义了初始值，然后不停地往上加步长。虽然自然数是没有上限的，但是在计算机里，只要定义了表示这个数的字节长度，那它就有上限。比如，无符号整型 (unsigned int) 是 4 个字节，上限就是 2<sup>32</sup>-1。</p><h3 id="表定义自增值-id"><a href="#表定义自增值-id" class="headerlink" title="表定义自增值 id"></a>表定义自增值 id</h3><p>表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table t(id int unsigned auto_increment primary key) auto_increment=4294967295;<br>insert into t values(null);<br>//成功插入一行 4294967295<br>show create table t;<br>/* CREATE TABLE `t` (<br>  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=4294967295;<br>*/<br><br>insert into t values(null);<br>//Duplicate entry &#x27;4294967295&#x27; for key &#x27;PRIMARY&#x27;<br></code></pre></td></tr></table></figure><p>第一个 insert 语句插入数据成功后，这个表的 AUTO_INCREMENT 没有改变（还是 4294967295），就导致了第二个 insert 语句又拿到相同的自增 id 值，再试图执行插入语句，报主键冲突错误。</p></blockquote><h3 id="InnoDB-系统自增-row-id"><a href="#InnoDB-系统自增-row-id" class="headerlink" title="InnoDB 系统自增 row_id"></a>InnoDB 系统自增 row_id</h3><p>如果创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节的 <strong>row_id</strong>。</p><p>InnoDB 维护了一个全局的 ‘dict_sys.row_id’ 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 ‘dict_sys.row_id’ 值作为要插入数据的 row_id，然后把 ‘dict_sys.row_id’ 的值加 1。                                                                                                                              </p><p>实际上，在代码实现时 row_id 是一个长度为 8 字节的无符号长整型 (bigint unsigned)。但是，InnoDB 在设计时，给 row_id 留的只是 6 个字节的长度，这样写到数据表中时只放了最后 6 个字节，所以 row_id 能写到数据表中的值，就有两个特征：</p><ol><li><p>row_id 写入表中的值范围，是从 0 到 2<sup>48</sup>-1；</p></li><li><p>当 ‘dict_sys.row_id=2<sup>48</sup>‘时，如果再有插入数据的行为要来申请 row_id，拿到以后再取最后 6 个字节的话就是 0。(写入表的 row_id 是从 0 开始到 2<sup>48</sup>-1。达到上限后，下一个值就是 0，然后继续循环。)</p><p>在 InnoDB 逻辑里，申请到 row_id=N 后，就将这行数据写入表中；如果表中已经存在 row_id=N 的行，新写入的行就会覆盖原有的行。</p></li></ol><h3 id="Xid"><a href="#Xid" class="headerlink" title="Xid"></a>Xid</h3><p>MySQL 内部维护了一个全局变量 ‘global_query_id’，每次执行语句的时候将它赋值给 ‘Query_id’，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 ‘Query_id’ 赋值给这个事务的 <strong>Xid</strong>。</p><p>而 <strong>‘global_query_id’ 是一个纯内存变量</strong>，重启之后就清零了。所以在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，<strong>同一个 binlog 文件里，Xid 一定是惟一的</strong>。</p><p>虽然 MySQL 重启不会导致同一个 binlog 里面出现两个相同的 Xid，但是如果 ‘global_query_id’ 达到上限后，就会继续从 0 开始计数。从理论上讲，还是就会出现同一个 binlog 里面出现相同 Xid 的场景。</p><h3 id="Innodb-trx-id"><a href="#Innodb-trx-id" class="headerlink" title="Innodb trx_id"></a>Innodb trx_id</h3><p><strong>Xid 是由 server 层维护的</strong>。InnoDB 内部使用 Xid，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，<strong>InnoDB 自己的 trx_id，是另外维护的</strong>。</p><p>InnoDB 内部维护了一个 ‘max_trx_id’ 全局变量，每次需要申请一个新的 trx_id 时，就获得 ‘max_trx_id’ 的当前值，然后并将 ‘max_trx_id’ 加 1。</p><p>InnoDB 数据可见性的<strong>核心思想</strong>是：每一行数据都记录了更新它的 trx_id，当一个事务读到一行数据的时候，判断这个数据是否可见的方法，就是通过事务的一致性视图与这行数据的 trx_id 做对比。</p><p>对于正在执行的事务，可以从 <code>information_schema.innodb_trx</code> 表中看到事务的 trx_id。</p><blockquote><p><img src="/article/事务的 trx_id.png"><span class="image-caption">事务的 trx_id</span></p><p>session B 里，从 innodb_trx 表里查出的这两个字段，第二个字段 <code>trx_mysql_thread_id</code> 就是线程 id。显示线程 id，是为了说明这两次查询看到的事务对应的线程 id 都是 5，也就是 session A 所在的线程。</p><p>实际上，在 T1 时刻，session A 还没有涉及到更新，是一个只读事务。而对于只读事务，InnoDB 并不会分配 trx_id。也就是说：</p><ol><li>在 T1 时刻，trx_id 的值其实就是 0。而这个很大的数，只是显示用的。</li><li>直到 session A 在 T3 时刻执行 insert 语句的时候，InnoDB 才真正分配了 trx_id。所以，T4 时刻，session B 查到的这个 trx_id 的值就是 1289。</li></ol></blockquote><p>除了修改类语句外，如果在 select 语句后面加上 for update，这个事务也不是只读事务。</p><ol><li>update 和 delete 语句除了事务本身，还涉及到标记删除旧数据，也就是要把数据放到 purge 队列里等待后续物理删除，这个操作也会把 max_trx_id+1， 因此在一个事务中至少加 2；</li><li>InnoDB 的后台操作，比如表的索引信息统计这类操作，也是会启动内部事务的，因此你可能看到，trx_id 值并不是按照加 1 递增的。</li></ol><blockquote><p>T2 时刻查到的这个很大的数字是怎么来的呢？</p></blockquote><p>这个数字是每次查询的时候由系统临时计算出来的。它的算法是：把当前事务的 trx 变量的指针地址转成整数，再加上 2<sup>48</sup>。使用这个算法，就可以保证以下两点：</p><ol><li>因为同一个只读事务在执行期间，它的指针地址是不会变的，所以不论是在 innodb_trx 还是在 innodb_locks 表里，同一个只读事务查出来的 trx_id 就会是一样的。</li><li>如果有并行的多个只读事务，每个事务的 trx 变量的指针地址肯定不同。这样，不同的并发只读事务，查出来的 trx_id 就是不同的。</li><li>在显示值里面加上 2<sup>48</sup>，目的是要保证只读事务显示的 trx_id 值比较大，正常情况下就会区别于读写事务的 id。但是，trx_id 跟 row_id 的逻辑类似，定义长度也是 8 个字节。因此，在理论上还是可能出现一个读写事务与一个只读事务显示的 trx_id 相同的情况。不过这个概率很低，并且也没有什么实质危害，可以不管它。</li></ol><p>只读事务不分配 trx_id，有什么好处呢？</p><ol><li>一个好处是，这样做可以减小事务视图里面活跃事务数组的大小。因为当前正在运行的只读事务，是不影响数据的可见性判断的。所以，在创建事务的一致性视图时，InnoDB 就只需要拷贝读写事务的 trx_id。</li><li>另一个好处是，可以减少 trx_id 的申请次数。在 InnoDB 里，即使你只是执行一个普通的 select 语句，在执行过程中，也是要对应一个只读事务的。所以只读事务优化后，普通的查询语句不需要申请 trx_id，就大大减少了并发事务申请 trx_id 的锁冲突。</li></ol><p>max_trx_id 会持久化存储，重启也不会重置为 0，那么从理论上讲，只要一个 MySQL 服务跑得足够久，就可能出现 max_trx_id 达到 2<sup>48</sup>-1 的上限，然后从 0 开始的情况。</p><p>当达到这个状态后，MySQL 就会持续出现一个脏读的 bug</p><blockquote><p>脏读的 bug 复现</p><p>首先需要把当前的 max_trx_id 先修改成 248-1。注意：这个 case 里使用的是可重复读隔离级别。</p><img src="/article/17540/%E5%A4%8D%E7%8E%B0%E8%84%8F%E8%AF%BB.png" class title="复现脏读"><p>由于已经把系统的 max_trx_id 设置成了 2<sup>48</sup>-1，所以在 session A 启动的事务 TA 的低水位就是 2<sup>48</sup>-1。</p><p>在 T2 时刻，session B 执行第一条 update 语句的事务 id 就是 2<sup>48</sup>-1，而第二条 update 语句的事务 id 就是 0 了，这条 update 语句执行后生成的数据版本上的 trx_id 就是 0。</p><p>在 T3 时刻，session A 执行 select 语句的时候，判断可见性发现，c=3 这个数据版本的 trx_id，小于事务 TA 的低水位，因此认为这个数据可见。</p><p>但，这个是脏读。</p><p>由于低水位值会持续增加，而事务 id 从 0 开始计数，就导致了系统在这个时刻之后，所有的查询都会出现脏读的。</p><p>并且，MySQL 重启时 max_trx_id 也不会清 0，也就是说重启 MySQL，这个 bug 仍然存在。</p></blockquote><h3 id="thread-id"><a href="#thread-id" class="headerlink" title="thread_id"></a>thread_id</h3><p><strong>线程 id（thread_id）</strong>才是 MySQL 中最常见的一种自增 id。</p><p>thread_id 的逻辑：系统保存了一个全局变量 ‘thread_id_counter’，每新建一个连接，就将 thread_id_counter 赋值给这个新连接的线程变量。</p><p>thread_id_counter 定义的大小是 4 个字节，因此达到 2<sup>32</sup>-1 后，它就会重置为 0，然后继续增加。</p><p><strong>但是，不会在 show processlist 里看到两个相同的 thread_id。</strong>因为 MySQL 设计了一个唯一数组的逻辑，给新线程分配 thread_id 的时候，逻辑代码是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">do &#123;<br>  new_id= thread_id_counter++;<br>&#125; while (!thread_ids.insert_unique(new_id).second);<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li>表的自增 id 达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误。</li><li>row_id 达到上限后，则会归 0 再重新递增，如果出现相同的 row_id，后写的数据会覆盖之前的数据。</li><li>Xid 只需要不在同一个 binlog 文件中出现重复值即可。虽然理论上会出现重复值，但是概率极小，可以忽略不计。</li><li>InnoDB 的 max_trx_id 递增值每次 MySQL 重启都会被保存起来，脏读的例子就是一个必现的 bug。</li><li>thread_id 是最常见的，而且也是处理得最好的一个自增 id 逻辑。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;自增主键为什么不是连续的？&quot;&gt;&lt;a href=&quot;#自增主键为什么不是连续的？&quot; class=&quot;headerlink&quot; title=&quot;自增主键为什么不是连续的？&quot;&gt;&lt;/a&gt;自增主键为什么不是连续的？&lt;/h2&gt;&lt;p&gt;自增主键，由于自增主键可以让主键索引尽量地保持递增顺
      
    
    </summary>
    
      <category term="Mysql" scheme="https://boyolo.github.io/categories/Mysql/"/>
    
      <category term="面试" scheme="https://boyolo.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="实习,Mysql" scheme="https://boyolo.github.io/tags/%E5%AE%9E%E4%B9%A0-Mysql/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="https://boyolo.github.io/article/38362.html"/>
    <id>https://boyolo.github.io/article/38362.html</id>
    <published>2022-05-08T03:04:06.000Z</published>
    <updated>2022-05-24T11:41:34.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何理解“递归”？"><a href="#如何理解“递归”？" class="headerlink" title="如何理解“递归”？"></a>如何理解“递归”？</h2><h3 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h3><ol><li><p>一个问题的解可以分解为几个子问题的解</p><p>子问题就是数据规模更小的问题</p></li><li><p>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</p></li><li><p>存在递归终止条件</p><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p></li></ol><h3 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h3><p>写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong></p><p><strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</strong></p><h3 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h3><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p><blockquote><p><strong>问题：如何避免出现堆栈溢出呢？</strong></p><p>可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。</p><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。</p></blockquote><h3 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h3><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p><ol><li>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。</li><li>在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何理解“递归”？&quot;&gt;&lt;a href=&quot;#如何理解“递归”？&quot; class=&quot;headerlink&quot; title=&quot;如何理解“递归”？&quot;&gt;&lt;/a&gt;如何理解“递归”？&lt;/h2&gt;&lt;h3 id=&quot;递归需要满足的三个条件&quot;&gt;&lt;a href=&quot;#递归需要满足的三个条件&quot; c
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/"/>
    
    
      <category term="数据结构与算法,递归" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="https://boyolo.github.io/article/26671.html"/>
    <id>https://boyolo.github.io/article/26671.html</id>
    <published>2022-05-07T05:00:55.000Z</published>
    <updated>2022-05-24T11:41:34.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="队列：队列在线程池等有限资源池中的应用"><a href="#队列：队列在线程池等有限资源池中的应用" class="headerlink" title="队列：队列在线程池等有限资源池中的应用"></a>队列：队列在线程池等有限资源池中的应用</h2><p>CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。</p><blockquote><p>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</p></blockquote><p><strong>先进者先出，这就是典型的“队列”。</strong></p><p>最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。</p><p>队列跟栈一样，也是<strong>一种操作受限的线性表数据结构</strong>。</p><p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><h3 id="基于数组的队列实现方法"><a href="#基于数组的队列实现方法" class="headerlink" title="基于数组的队列实现方法"></a>基于数组的队列实现方法</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用数组实现的队列</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span> </span>&#123;<br>  <span class="hljs-comment">// 数组：items，数组大小：n</span><br>  <span class="hljs-keyword">private</span> String[] items;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 申请一个大小为capacity的数组</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    items = <span class="hljs-keyword">new</span> String[capacity];<br>    n = capacity;<br>  &#125;<br><br>  <span class="hljs-comment">// 入队</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果tail == n 表示队列已经满了</span><br>    <span class="hljs-keyword">if</span> (tail == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    items[tail] = item;<br>    ++tail;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 出队</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果head == tail 表示队列为空</span><br>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span><br>    String ret = items[head];<br>    ++head;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>队列需要两个指针：</p><ol><li>一个是 head 指针，指向队头；</li><li>一个是 tail 指针，指向队尾。</li></ol><blockquote><p>每次进行出队操作都相当于删除数组下标为 0 的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的 O(1) 变为 O(n)。能不能优化一下呢？</p></blockquote><p>在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 入队操作，将item放入队尾</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;<br>  <span class="hljs-comment">// tail == n表示队列末尾没有空间了</span><br>  <span class="hljs-keyword">if</span> (tail == n) &#123;<br>    <span class="hljs-comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 数据搬移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = head; i &lt; tail; ++i) &#123;<br>      items[i-head] = items[i];<br>    &#125;<br>    <span class="hljs-comment">// 搬移完之后重新更新head和tail</span><br>    tail -= head;<br>    head = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  items[tail] = item;<br>  ++tail;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/article/26671/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.jpg" class title="顺序队列数据迁移"></blockquote><h3 id="基于链表的队列实现方法"><a href="#基于链表的队列实现方法" class="headerlink" title="基于链表的队列实现方法"></a>基于链表的队列实现方法</h3><p>基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。</p><img src="/article/26671/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.jpg" class title="基于链表的队列实现"><p><strong>循环队列</strong></p><img src="/article/26671/%E5%9F%BA%E4%BA%8E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.jpg" class title="基于循环链表的队列实现"><p><strong>确定好队空和队满的判定条件：</strong></p><ol><li><p>队列为空的判断条件是 head == tail</p></li><li><p>当队满时的判断条件是 (tail+1)%n=head</p><img src="/article/26671/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E9%98%9F%E6%BB%A1.jpg" class title="循环队列队满"><p><strong>循环队列会浪费一个数组的存储空间</strong></p></li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularQueue</span> </span>&#123;<br>  <span class="hljs-comment">// 数组：items，数组大小：n</span><br>  <span class="hljs-keyword">private</span> String[] items;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// head表示队头下标，tail表示队尾下标</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tail = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 申请一个大小为capacity的数组</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    items = <span class="hljs-keyword">new</span> String[capacity];<br>    n = capacity;<br>  &#125;<br><br>  <span class="hljs-comment">// 入队</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(String item)</span> </span>&#123;<br>    <span class="hljs-comment">// 队列满了</span><br>    <span class="hljs-keyword">if</span> ((tail + <span class="hljs-number">1</span>) % n == head) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    items[tail] = item;<br>    tail = (tail + <span class="hljs-number">1</span>) % n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 出队</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果head == tail 表示队列为空</span><br>    <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    String ret = items[head];<br>    head = (head + <span class="hljs-number">1</span>) % n;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h3><p><strong>阻塞队列</strong>就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p><img src="/article/26671/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.jpg" class title="阻塞队列"><p><strong>并发队列</strong>是线程安全的队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。</p><blockquote><p><strong>问题：线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</strong></p><ol><li>第一种是非阻塞的处理方式，直接拒绝任务请求；</li><li>另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<ol><li>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</li><li>而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</li></ol></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;队列：队列在线程池等有限资源池中的应用&quot;&gt;&lt;a href=&quot;#队列：队列在线程池等有限资源池中的应用&quot; class=&quot;headerlink&quot; title=&quot;队列：队列在线程池等有限资源池中的应用&quot;&gt;&lt;/a&gt;队列：队列在线程池等有限资源池中的应用&lt;/h2&gt;&lt;p&gt;CP
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/"/>
    
    
      <category term="数据结构与算法,队列" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://boyolo.github.io/article/37273.html"/>
    <id>https://boyolo.github.io/article/37273.html</id>
    <published>2022-05-06T07:27:26.000Z</published>
    <updated>2022-05-24T11:41:34.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈：如何实现浏览器的前进和后退功能？"><a href="#栈：如何实现浏览器的前进和后退功能？" class="headerlink" title="栈：如何实现浏览器的前进和后退功能？"></a>栈：如何实现浏览器的前进和后退功能？</h2><blockquote><p>当你依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果你后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。</p></blockquote><p><strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong></p><p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</strong></p><h3 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h3><p>栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。</p><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 基于数组实现的顺序栈</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> String[] items;  <span class="hljs-comment">// 数组</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;       <span class="hljs-comment">// 栈中元素个数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;           <span class="hljs-comment">//栈的大小</span><br><br>  <span class="hljs-comment">// 初始化数组，申请一个大小为n的数组空间</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> String[n];<br>    <span class="hljs-keyword">this</span>.n = n;<br>    <span class="hljs-keyword">this</span>.count = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 入栈操作</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">push</span><span class="hljs-params">(String item)</span> </span>&#123;<br>    <span class="hljs-comment">// 数组空间不够了，直接返回false，入栈失败。</span><br>    <span class="hljs-keyword">if</span> (count == n) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 将item放到下标为count的位置，并且count加一</span><br>    items[count] = item;<br>    ++count;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 出栈操作</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 栈为空，则直接返回null</span><br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span><br>    String tmp = items[count-<span class="hljs-number">1</span>];<br>    --count;<br>    <span class="hljs-keyword">return</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>空间复杂度是 O(1)</p><p>时间复杂度是 O(1)</p><h3 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h3><blockquote><p>如何来实现一个支持动态扩容的数组的？</p><p>当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p></blockquote><p>要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</p><img src="/article/37273/%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88.jpg" class title="支持动态扩容的顺序栈"><p>对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。</p><p>但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。<strong>对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。</strong></p><p>入栈操作的均摊时间复杂度为 O(1)</p><blockquote><p>假设和定义：</p><ul><li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li><li>为了简化分析，假设只有入栈操作没有出栈操作；</li><li>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)。</li></ul><p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。</p><img src="/article/37273/%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E6%A0%88.jpg" class title="动态扩容栈"><p>这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，<strong>入栈操作的均摊时间复杂度就为 O(1)</strong>。</p></blockquote><h3 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h3><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; <br>   <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>   ret = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>   res = a + ret;<br>   printf(<span class="hljs-string">&quot;%d&quot;</span>, res);<br>   reuturn <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>   sum = x + y;<br>   <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相加，最后打印 res 的值</p><p> 函数调用栈.jpg)</p></blockquote><h3 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h3><blockquote><p>3+5*8-6</p></blockquote><p>编译器就是通过两个栈来实现的。</p><ol><li>其中一个保存操作数的栈，</li><li>另一个是保存运算符的栈。</li></ol><p>我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><blockquote><img src="/article/37273/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.jpg" class title="表达式的计算过程"></blockquote><h3 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h3><blockquote><p>假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。</p></blockquote><p>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p><p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p><h3 id="如何实现浏览器的前进、后退功能？"><a href="#如何实现浏览器的前进、后退功能？" class="headerlink" title="如何实现浏览器的前进、后退功能？"></a>如何实现浏览器的前进、后退功能？</h3><p>使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;栈：如何实现浏览器的前进和后退功能？&quot;&gt;&lt;a href=&quot;#栈：如何实现浏览器的前进和后退功能？&quot; class=&quot;headerlink&quot; title=&quot;栈：如何实现浏览器的前进和后退功能？&quot;&gt;&lt;/a&gt;栈：如何实现浏览器的前进和后退功能？&lt;/h2&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://boyolo.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/"/>
    
    
      <category term="数据结构与算法,栈" scheme="https://boyolo.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/"/>
    
  </entry>
  
</feed>
