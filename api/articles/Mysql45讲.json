{"title":"Mysql45讲","slug":"Mysql45讲","date":"2022-03-26T06:52:53.000Z","updated":"2022-09-16T09:07:57.085Z","comments":true,"path":"api/articles/Mysql45讲.json","realPath":null,"excerpt":null,"covers":["/article/53105/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png","/article/53105/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png","/article/53105/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png","/article/53105/%E6%97%A0%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg","/article/53105/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg","/article/53105/%E6%95%B0%E6%8D%AE%E7%89%88%E6%9C%AC%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99.png"],"cover":"/images/theme/coverphoto/Mysql.jpg","content":"<p>关于MySQL的发音：</p>\n<blockquote>\n<p>The official way to pronounce “MySQL” is “My Ess Que Ell” (not “my sequel”), but we do not mind if you pronounce it as “my sequel” or in some other localized way.</p>\n</blockquote>\n<h2 id=\"一条SQL查询语句是如何执行的？\"><a href=\"#一条SQL查询语句是如何执行的？\" class=\"headerlink\" title=\"一条SQL查询语句是如何执行的？\"></a>一条SQL查询语句是如何执行的？</h2><p><img src=\"/article/MySQL 的基本架构示意图.png\"><span class=\"image-caption\">img</span></p>\n<p><strong>MySQL 可以分为 Server 层和存储引擎层两部分。</strong>不同的存储引擎共用一个 Server 层。</p>\n<p>Server 层包括<strong>连接器、查询缓存、分析器、优化器、执行器</strong>等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>\n<p>现在最常用的存储引擎是 <strong>InnoDB</strong>，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>\n<h3 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql -h<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"6.558ex\" height=\"2.509ex\" style=\"vertical-align: -0.671ex;\" viewbox=\"0 -791.3 2823.4 1080.4\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">ip -P</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-69\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-70\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-50\" d=\"M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z\"/>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-69\" x=\"0\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-70\" x=\"345\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMAIN-2212\" x=\"1071\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-50\" x=\"2071\" y=\"0\"/>\n</g>\n</svg>port -u$user -p<br></code></pre></td></tr></table></figure>\n<p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份。</p>\n<blockquote>\n<ol>\n<li><p>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p>\n</li>\n<li><p>如果用户名密码认证通过，连接器会到<strong>权限表</strong>里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</p>\n<p>(一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。)</p>\n</li>\n</ol>\n</blockquote>\n<p>显示用户正在运行的线程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">show processlist<br></code></pre></td></tr></table></figure>\n<p>Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>\n<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是 8 小时。</p>\n<p><strong>建议尽量使用长连接</strong></p>\n<blockquote>\n<p>数据库里面，<strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。<strong>短连接</strong>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>\n</blockquote>\n<p>全部使用长连接后，有些时候 MySQL 占用内存涨得特别快</p>\n<p><strong>这是因为</strong> MySQL 在执行过程中临时使用的内存是管理在<strong>连接对象里面的</strong>。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，<strong>被系统强行杀掉（OOM）</strong>，从现象看就是 MySQL 异常重启了。</p>\n<blockquote>\n<p><strong>解决方法</strong></p>\n<ol>\n<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>\n<li>MySQL 5.7 或更新版本：可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。<strong>这个过程不需要重连和重新做权限验证</strong>，但是会将连接恢复到刚刚创建完时的状态。</li>\n</ol>\n</blockquote>\n<h3 id=\"查询缓存\"><a href=\"#查询缓存\" class=\"headerlink\" title=\"查询缓存\"></a>查询缓存</h3><p>MySQL 拿到一个查询请求后:</p>\n<ol>\n<li>先到查询缓存：之前是否执行过这条语句，之前执行过的语句及其结果可能会以 <code>key(查询语句)-value（查询结果）</code> 对的形式，被直接缓存在内存中。(<a href=\"https://dev.mysql.com/blog-archive/mysql-8-0-retiring-support-for-the-query-cache/\">MySQL 8.0版本直接将查询缓存的整块功能删掉了</a> （弊大于利）查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空)。</li>\n<li>没有找缓存结果：<a href=\"#分析器\">开始真正执行语句</a></li>\n</ol>\n<h3 id=\"分析器\"><a href=\"#分析器\" class=\"headerlink\" title=\"分析器\"></a>分析器</h3><ol>\n<li><strong>词法分析</strong>\u0010：MySQL 需要识别出输入的的字符串（SQL语句）分别是什么，代表什么；</li>\n<li><strong>语法分析</strong>：根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。（语法错误提示：“You have an error in your SQL syntax”）。</li>\n</ol>\n<p>分析器处理语法和解析查询, 生成一课对应的解析树。 预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。</p>\n<h3 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h3><p>在开始执行之前，还要先经过优化器的处理。</p>\n<p><strong>优化器</strong>是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>\n<p>优化器阶段完成后，这个语句的执行方案就确定下来了。</p>\n<h3 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h3><ol>\n<li>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限(在工程实现上，如果命中查询缓存，会在<strong>查询缓存返回结果</strong>的时候，做权限验证。查询也会在<strong>优化器之前</strong>调用 precheck 验证权限)；</li>\n<li>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的<strong>引擎定义</strong>，去使用这个引擎提供的接口。</li>\n</ol>\n<p>你会在数据库的慢查询日志中看到一个 <code>rows_examined</code> 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>\n<blockquote>\n<p>执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 <code>rows_examined</code> 并不是完全相同的</p>\n</blockquote>\n<h2 id=\"一条SQL更新语句是如何执行的？\"><a href=\"#一条SQL更新语句是如何执行的？\" class=\"headerlink\" title=\"一条SQL更新语句是如何执行的？\"></a>一条SQL更新语句是如何执行的？</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">update T set c=c+1 where ID=2;<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article/MySQL 的基本架构示意图.png\"><span class=\"image-caption\">img</span></p>\n<p><strong>执行流程</strong></p>\n<p>执行语句前要先<strong>连接</strong>数据库，这是连接器的工作</p>\n<p>在一个表上有<strong>更新</strong>的时候，跟这个表有关的<strong>查询缓存会失效</strong>，所以这条语句就会把表 T 上所有缓存结果都清空。</p>\n<p><strong>分析器</strong>会通过词法和语法解析知道这是一条更新语句。<strong>优化器</strong>决定要使用 ID 这个索引。然后，<strong>执行器</strong>负责具体执行，找到这一行，然后更新。</p>\n<p>两个重要的日志模块：<strong>redo log（重做日志）和 binlog（归档日志）</strong>（只要我们写的是DML语句（insert,update,delete,create）等等，那么我们在数据库服务端执行的时候就会涉及到 redo log(重做日志) 和 binlog(归档日志) 两个日志文件的变动）</p>\n<h3 id=\"redo-log（重做日志）–InnoDB特有的日志\"><a href=\"#redo-log（重做日志）–InnoDB特有的日志\" class=\"headerlink\" title=\"redo log（重做日志）–InnoDB特有的日志\"></a>redo log（重做日志）–InnoDB特有的日志</h3><blockquote>\n<p>问题：如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。</p>\n</blockquote>\n<p>解决：<strong>WAL 技术</strong>，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。</p>\n<p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 <strong>redo log</strong>里面，并更新内存，这个时候更新就算完成了。同时，<strong>InnoDB 引擎</strong>会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>\n<blockquote>\n<p>问题：InnoDB 的 redo log 是固定大小的，redo log 写满之后，先将日志中的部分记录写到磁盘，腾出redo log的空间继续写入。</p>\n</blockquote>\n<p><img src=\"/article/redo log 循环写入.png\"><span class=\"image-caption\">img</span></p>\n<p><code>write pos</code> 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<code>check point</code> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>\n<p><code>write pos</code> 和 <code>checkpoint</code> 之间的是“redo log”上还空着的部分，可以用来记录新的操作。</p>\n<p>如果 <code>write pos</code> 追上 <code>checkpoint</code>，表示“redo log”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>\n<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。</p>\n<p>redo log 用于保证 crash-safe 能力。<code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p>\n<h3 id=\"binlog（归档日志）–Server层-日志\"><a href=\"#binlog（归档日志）–Server层-日志\" class=\"headerlink\" title=\"binlog（归档日志）–Server层 日志\"></a>binlog（归档日志）–Server层 日志</h3><blockquote>\n<p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，<strong>binlog</strong> 日志只能用于<strong>归档</strong>。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p>\n</blockquote>\n<p><code>sync_binlog</code> 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">redo log</th>\n<th style=\"text-align:left\">binlog</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">InnoDB 引擎特有的</td>\n<td style=\"text-align:left\">MySQL 的 Server 层实现的，所有引擎都可以使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">物理日志：记录的是“在某个数据页上做了什么修改”</td>\n<td style=\"text-align:left\">逻辑日志：记录的是这个语句的原始逻辑</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">循环写入，空间固定会用完</td>\n<td style=\"text-align:left\">追加写入，binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</td>\n</tr>\n</tbody>\n</table>\n<p>浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p>\n<p><img src=\"/article/update 语句执行流程.png\"><span class=\"image-caption\">img</span></p>\n<p><strong>两阶段提交</strong>:为了让两份日志之间的逻辑一致</p>\n<h2 id=\"事务隔离：为什么你改了我还看不见？\"><a href=\"#事务隔离：为什么你改了我还看不见？\" class=\"headerlink\" title=\"事务隔离：为什么你改了我还看不见？\"></a>事务隔离：为什么你改了我还看不见？</h2><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的（MySQL 原生的 MyISAM 引擎就不支持事务）。</p>\n<p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p>\n<h3 id=\"隔离性与隔离级\"><a href=\"#隔离性与隔离级\" class=\"headerlink\" title=\"隔离性与隔离级\"></a>隔离性与隔离级</h3><p><strong>隔离得越严实，效率就会越低</strong></p>\n<p>当数据库上有多个事务同时执行的时候，就可能出现<strong>脏读</strong>（dirty read）、<strong>不可重复读</strong>（non-repeatable read）、<strong>幻读</strong>（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>\n<ol>\n<li><strong>脏读</strong>：读到其他事务未提交的数据；</li>\n<li><strong>不可重复读</strong>：前后读取的记录内容不一致；</li>\n<li><strong>幻读</strong>：前后读取的记录数量不一致。</li>\n</ol>\n<blockquote>\n<p>脏读：事务A查询数据后进行了一次修改且未提交，而事务B这个时候去查询，然后使用了这个数据，因为这个数据还没有被事务A 提交到数据库中，所以事务B的得到数据就是脏数据，对脏数据进行操作可能是不正确的。 不可重复读: 事务A访问了两次数据，但是这访问第二次之间事务B进行一次并进行了修改，导致事务A访问第二次的时候得到的数据与第一次不同，导致一个事务访问两次数据得到的数据不相同。因此叫做不可重复读。 幻读： 与不可重复读都点相似，只是这次是事务B在事务A访问第二次的之前做了一个新增，导致事务A第二次读取的时候发现了多的记录，这就是幻读。 丢失修改：事务A访问该数据，事务B也访问该数据，事务A修改了该数据，事务B也修改了该数据，这样导致事务A的修改被丢失，因此称为丢失修改； 不可重复度和幻读区别： 不可重复读主要是修改操作，幻读的主要在于新增或者删除。 幻读主要在于数据的条数变了，而不可重复读主要在于数据内容变了。</p>\n</blockquote>\n<p>SQL 标准的事务隔离级别包括<strong>：读未提交</strong>（read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（serializable ）。</p>\n<ol>\n<li><strong>读未提交</strong>，一个事务还没提交时，它做的变更就能被别的事务看到；</li>\n<li><strong>读提交</strong>，一个事务提交之后，它做的变更才会被其他事务看到；</li>\n<li><strong>可重复读</strong>，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的；(<strong>别人改数据的事务已经提交，我在我的事务中也不去读</strong>。)</li>\n<li><strong>串行化</strong>，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>\n</ol>\n<p><strong>这4种隔离级别，并行性能依次降低，安全性依次提高</strong></p>\n<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p>\n<p>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。（事务启动时的视图可以认为是静态的，不受其他事务更新的影响。）</p>\n<blockquote>\n<p>事务启动方式：</p>\n<ol>\n<li>一致性视图是在执行第一个快照读语句时创建的；</li>\n<li>一致性视图是在执行 <code>start transaction with consistent snapshot</code> 时创建的。</li>\n</ol>\n</blockquote>\n<p>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。</p>\n<p>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</p>\n<p>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>\n<p>Oracle 数据库的默认隔离级别其实就是“读提交”；</p>\n<p>MySQL默认的隔离级别是”可重复读”。</p>\n<h3 id=\"事务隔离的实现\"><a href=\"#事务隔离的实现\" class=\"headerlink\" title=\"事务隔离的实现\"></a>事务隔离的实现</h3><p>实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>\n<p><strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong></p>\n<p>系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。（就是当系统里没有比这个回滚日志更早的视图的时候）</p>\n<p><strong>问题：为什么建议你尽量不要使用长事务</strong></p>\n<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>\n<p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 <strong>ibdata</strong> 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。</p>\n<p>长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>\n<h3 id=\"事务的启动方式\"><a href=\"#事务的启动方式\" class=\"headerlink\" title=\"事务的启动方式\"></a>事务的启动方式</h3><ol>\n<li><p>显式启动事务语句， <code>begin</code> 或 <code>start transaction</code>。配套的提交语句是 <code>commit</code>，回滚语句是 <code>rollback</code>。</p>\n</li>\n<li><p><code>set autocommit=0</code>，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 <code>commit</code> 或<code>rollback</code>语句，或者断开连接。</p>\n<p><strong>建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务。</strong></p>\n</li>\n<li><p>用 <code>commit work and chain</code> 语法</p>\n<p>在 <strong>autocommit 为 1</strong> 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>\n</li>\n</ol>\n<p><code>information_schema 库的 innodb_trx 这个表</code>中查询长事务</p>\n<hr>\n<p><strong>问题：有什么方案来避免出现或者处理长事物？</strong></p>\n<blockquote>\n<p>首先，从应用开发端来看：</p>\n<ol>\n<li>确认是否使用了 <code>set autocommit=0</code>。这个确认工作可以在测试环境中开展，把 MySQL 的 <code>general_log</code> 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</li>\n<li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 <code>begin/commit</code> 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</li>\n<li>业务连接数据库的时候，根据业务本身的预估，通过 <code>SET MAX_EXECUTION_TIME</code> 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li>\n</ol>\n<p>其次，从数据库端来看：</p>\n<ol>\n<li><p>监控 <code>information_schema.Innodb_trx 表</code>，设置长事务阈值，超过就报警 / 或者 kill；</p>\n</li>\n<li><p>Percona 的 pt-kill 这个工具不错，推荐使用；</p>\n</li>\n<li><p>在业务功能测试阶段要求输出所有的 <code>general_log</code>，分析日志行为提前发现问题；</p>\n</li>\n<li><p>如果使用的是 MySQL 5.6 或者更新版本，把 <code>innodb_undo_tablespaces</code> 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</p>\n<p>(innodb_undo_tablespaces是控制undo是否开启独立的表空间的参数 </p>\n<ol>\n<li>为0表示：undo使用系统表空间，即ibdata1 </li>\n<li>不为0表示：使用独立的表空间，一般名称为 undo001 undo002，存放地址的配置项为：innodb_undo_directory </li>\n<li>一般innodb_undo_tablespaces 默认配置为0，innodb_undo_directory默认配置为当前数据目录)</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"深入浅出索引\"><a href=\"#深入浅出索引\" class=\"headerlink\" title=\"深入浅出索引\"></a>深入浅出索引</h2><p><strong>索引的出现是为了提高查询效率</strong></p>\n<h3 id=\"哈希表索引模型\"><a href=\"#哈希表索引模型\" class=\"headerlink\" title=\"哈希表索引模型\"></a>哈希表索引模型</h3><p>哈希表是一种以 <strong>键 - 值</strong>（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。</p>\n<blockquote>\n<p>思路：</p>\n<p>用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>\n</blockquote>\n<blockquote>\n<p><strong>问题</strong>：多个 key 值经过哈希函数的换算，会出现同一个值的情况</p>\n<p><strong>解决方法：</strong>拉出一个链表</p>\n<img src=\"/article/53105/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" class title=\"根据身份证号查找对应的名字\">\n<p><strong>缺点：</strong>因为不是有序的（比如四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加），所以<strong>哈希索引做区间查询的速度是很慢的</strong>。</p>\n<p>哈希表这种结构适用于只有<strong>等值查询</strong>的场景，比如 Memcached 及其他一些 NoSQL 引擎。</p>\n</blockquote>\n<h3 id=\"有序数组索引模型\"><a href=\"#有序数组索引模型\" class=\"headerlink\" title=\"有序数组索引模型\"></a>有序数组索引模型</h3><p>适用于<strong>等值查询</strong>和<strong>范围查询</strong>场景</p>\n<blockquote>\n<p>根据身份证号查找对应的名字<strong>有序数组</strong>示意图</p>\n<img src=\"/article/53105/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" class title=\"根据身份证号查找对应的名字\">\n<p>用二分法就可以快速得到，这个<strong>时间复杂度是 O(log(N))</strong></p>\n<p><strong>优点：</strong>仅仅看查询效率，有序数组就是最好的数据结构</p>\n<p><strong>缺点：</strong>中间插入一个记录就必须得挪动后面所有的记录，成本太高</p>\n<p>有序数组索引<strong>只适用于静态存储引擎</strong></p>\n</blockquote>\n<h3 id=\"二叉搜索树索引模型\"><a href=\"#二叉搜索树索引模型\" class=\"headerlink\" title=\"二叉搜索树索引模型\"></a>二叉搜索树索引模型</h3><blockquote>\n<p>根据身份证号查找对应的名字<strong>二叉搜索树</strong>示意图</p>\n<img src=\"/article/53105/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" class title=\"根据身份证号查找对应的名字\">\n<p>二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。</p>\n<p><strong>时间复杂度是 O(log(N))</strong></p>\n<p><strong>优点：</strong>二叉树是搜索效率最高的</p>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是<strong>平衡二叉树</strong>。为了做这个保证，<strong>更新的时间复杂度也是 O(log(N))</strong>。</li>\n<li>索引不止存在内存中，还要写到磁盘上（所以大多数的数据库存储并不使用二叉树）</li>\n</ol>\n<p><strong>解决方法：</strong>为了让一个查询<strong>尽量少地读磁盘</strong>，就必须让查询过程<strong>访问尽量少的数据块</strong>。那么，我们就不应该使用二叉树，而是要使用“<strong>N 叉</strong>”树。这里，<strong>“N 叉”树中的“N”取决于数据块的大小</strong>。</p>\n<p><strong>N叉树优点：</strong>读写上的性能优点，以及适配磁盘的访问模式</p>\n</blockquote>\n<p>在 MySQL 中，<strong>索引是在存储引擎层实现</strong>的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>\n<h3 id=\"InnoDB-的索引模型\"><a href=\"#InnoDB-的索引模型\" class=\"headerlink\" title=\"InnoDB 的索引模型\"></a>InnoDB 的索引模型</h3><p>在 InnoDB 中，表都是根据<strong>主键顺序以索引</strong>的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。</p>\n<p>InnoDB 使用了 <strong><a href=\"https://blog.csdn.net/weixin_35871519/article/details/113303881\">B+ 树索引模型</a></strong>，所以数据都是存储在 B+ 树中的。</p>\n<p><strong>每一个索引在 InnoDB 里面对应一棵 B+ 树</strong></p>\n<p><strong>B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</strong></p>\n<blockquote>\n<p>假设有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; create table T(<br>id int primary key, <br>k int not null, <br>name varchar(16),<br>index (k))engine=InnoDB;<br></code></pre></td></tr></table></figure>\n<p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下:</p>\n<p><img src=\"/article/InnoDB 的索引组织结构.png\"><span class=\"image-caption\">InnoDB 的索引组织结构</span></p>\n<p>图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>\n<p>查询时：</p>\n<ol>\n<li><p>主键查询方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from T where ID=500<br></code></pre></td></tr></table></figure>\n<p>只需要搜索 ID 这棵 B+ 树</p>\n</li>\n<li><p>普通索引查询方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from T where k=5<br></code></pre></td></tr></table></figure>\n<p>需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</p>\n</li>\n</ol>\n<p>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该<strong>尽量使用主键查询</strong>。</p>\n</blockquote>\n<p><strong>主键索引</strong>的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为<strong>聚簇索引</strong>（clustered index）。</p>\n<p><strong>非主键索引</strong>的叶子节点内容是<strong>主键的值</strong>。在 InnoDB 里，非主键索引也被称为<strong>二级索引</strong>（secondary index）。</p>\n<h3 id=\"索引维护\"><a href=\"#索引维护\" class=\"headerlink\" title=\"索引维护\"></a><strong>索引维护</strong></h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p>\n<blockquote>\n<p><strong>页分裂</strong>:新插入的数据符合条件的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。（除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。）</p>\n<p><strong>页合并</strong>：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>\n</blockquote>\n<p><strong>性能和存储空间方面考量，自增主键往往是更合理的选择</strong></p>\n<p>自增主键的插入数据模式，正符合了递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>\n<blockquote>\n<p>适合用业务字段直接做主键的场景\u0010:</p>\n<ol>\n<li>只有一个索引；</li>\n<li>该索引必须是唯一索引。</li>\n</ol>\n<p>直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树</p>\n</blockquote>\n<h3 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h3><p><strong>经过索引优化，避免回表过程</strong></p>\n<blockquote>\n<p>搜索由</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from T where k between 3 and 5<br></code></pre></td></tr></table></figure>\n<p>变为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select ID from T where k between 3 and 5<br></code></pre></td></tr></table></figure>\n<p>只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为<strong>覆盖索引</strong>。</p>\n</blockquote>\n<p>由于覆盖索引可以<strong>减少树的搜索次数</strong>，<strong>显著提升查询性能</strong>，所以使用<strong>覆盖索引</strong>是一个常用的性能优化手段。</p>\n<h3 id=\"最左前缀原则\"><a href=\"#最左前缀原则\" class=\"headerlink\" title=\"最左前缀原则\"></a>最左前缀原则</h3><p><strong>为一个不频繁的请求创建一个索引感觉很浪费</strong></p>\n<p><strong>最左前缀</strong>可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>\n<blockquote>\n<p><strong>问题：</strong>在建立联合索引的时候，如何安排索引内的字段顺序</p>\n<p><strong>评估标准:</strong>索引的复用能力</p>\n<ol>\n<li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>\n<li>(如果既有联合查询，又有基于 a、b 各自的查询)第二原则是,空间</li>\n</ol>\n</blockquote>\n<h3 id=\"索引下推\"><a href=\"#索引下推\" class=\"headerlink\" title=\"索引下推\"></a>索引下推</h3><p>MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;<br></code></pre></td></tr></table></figure>\n<p>无索引下推执行流程</p>\n<img src=\"/article/53105/%E6%97%A0%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg\" class title=\"无索引下推执行流程\">\n<p>索引下推执行流程</p>\n<img src=\"/article/53105/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg\" class title=\"索引下推执行流程\">\n</blockquote>\n<hr>\n<p><strong>问题：重建索引时，是重建非主键索引还是主键索引？</strong></p>\n<p>重建非主键索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">alter table T drop index k;<br>alter table T add index(k);<br></code></pre></td></tr></table></figure>\n<p>重建主键索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">alter table T drop primary key;<br>alter table T add primary key(id);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>重建索引 k 的做法是合理的，可以达到省空间的目的。</p>\n<p>但是，重建主键的过程不合理。<strong>不论是删除主键还是创建主键，都会将整个表重建。</strong>所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。</p>\n</blockquote>\n<hr>\n<h2 id=\"全局锁和表锁-：给表加个字段怎么有这么多阻碍？\"><a href=\"#全局锁和表锁-：给表加个字段怎么有这么多阻碍？\" class=\"headerlink\" title=\"全局锁和表锁 ：给表加个字段怎么有这么多阻碍？\"></a>全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h2><p>数据库锁设计的<strong>初衷是处理并发问题</strong>。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p>\n<p>MySQL 里面的锁大致可以分成<strong>全局锁、表级锁和行锁</strong>三类。</p>\n<h3 id=\"全局锁\"><a href=\"#全局锁\" class=\"headerlink\" title=\"全局锁\"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock (FTWRL)</code>。</p>\n<p>当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>\n<p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong></p>\n<blockquote>\n<p>全局锁的问题:</p>\n<ol>\n<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>\n<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li>\n</ol>\n</blockquote>\n<p>官方自带的逻辑备份工具是 <strong>mysqldump</strong>。当 mysqldump 使用参数<code>–single-transaction</code> 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p>\n<blockquote>\n<p><strong>问题：有了mysqldump功能，为什么还需要 FTWRL 呢？</strong></p>\n<p>一致性读是好，但前提是引擎要支持<strong>可重复读</strong>隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p>\n</blockquote>\n<p><strong><code>-single-transaction</code> 方法只适用于所有的表使用事务引擎的库。</strong></p>\n<blockquote>\n<p><strong>问题：既然要全库只读，为什么不使用 set global readonly=true 的方式呢？</strong></p>\n<ol>\n<li>一在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议你使用。</li>\n<li>在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>\n</ol>\n</blockquote>\n<h3 id=\"表级锁\"><a href=\"#表级锁\" class=\"headerlink\" title=\"表级锁\"></a>表级锁</h3><p>MySQL 里面表级别的锁有两种：一种是<strong>表锁</strong>，一种是<strong>元数据锁</strong>（meta data lock，MDL)。</p>\n<p><strong>表锁</strong></p>\n<p>表锁的语法是 <code>lock tables … read/write</code>。与 FTWRL 类似，可以用 <code>unlock tables</code> 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法<strong>除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</strong></p>\n<p><strong>元数据锁</strong>(MySQL 5.5 版本中引入)</p>\n<p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。</p>\n<p>MDL 的作用是，<strong>保证读写的正确性</strong>。</p>\n<ol>\n<li>当对一个表做增删改查操作的时候，加 <strong>MDL 读锁</strong>；</li>\n<li>当要对表做结构变更操作的时候，加 <strong>MDL 写锁</strong>。</li>\n</ol>\n<p>每执行一条DML、DDL语句时都会申请MDL锁，<strong>DML操作需要MDL读锁，DDL操作需要MDL写锁</strong>（MDL加锁过程是系统自动控制，无法直接干预，读读共享，读写互斥，写写互斥）</p>\n<ol>\n<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li>\n<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>\n</ol>\n<p><strong>MDL 会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</strong></p>\n<p><strong>表锁一般是在数据库引擎 <em>不支持行锁</em> 的时候才会被用到的。</strong></p>\n<hr>\n<p><strong>问题：如何安全地给小表加字段？</strong></p>\n<blockquote>\n<p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 <code>information_schema 库的 innodb_trx 表</code>中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p>\n</blockquote>\n<hr>\n<p><strong>问题：如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</strong></p>\n<blockquote>\n<p>在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p>\n<p><code>DDL NOWAIT/WAIT n</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">ALTER TABLE tbl_name NOWAIT add column ...<br>ALTER TABLE tbl_name WAIT N add column ... <br></code></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<p><strong>问题：如果你发现你的应用程序里有 lock tables 这样的语句，需要怎么做？</strong></p>\n<blockquote>\n<ol>\n<li>要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；</li>\n<li>要么是你的引擎升级了，但是代码还没升级。最后业务开发就是把 lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。</li>\n</ol>\n</blockquote>\n<hr>\n<p><strong>问题：备份一般都会在备库上执行，你在用–single-transaction 方法做逻辑备份的过程中，如果主库上的一个小表做了一个 DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</strong></p>\n<blockquote>\n<p>假设这个 DDL 是针对表 t1 的， 这里我把备份过程中几个关键的语句列出来：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；<br>/* other tables */<br>Q3:SAVEPOINT sp;<br>/* 时刻 1 */<br>Q4:show create table `t1`;<br>/* 时刻 2 */<br>Q5:SELECT * FROM `t1`;<br>/* 时刻 3 */<br>Q6:ROLLBACK TO SAVEPOINT sp;<br>/* 时刻 4 */<br>/* other tables */<br></code></pre></td></tr></table></figure>\n<ol>\n<li>如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。</li>\n<li>如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；</li>\n<li>如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。</li>\n<li>从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。</li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"行锁功过：怎么减少行锁对性能的影响？\"><a href=\"#行锁功过：怎么减少行锁对性能的影响？\" class=\"headerlink\" title=\"行锁功过：怎么减少行锁对性能的影响？\"></a>行锁功过：怎么减少行锁对性能的影响？</h2><p><strong>MySQL 的行锁是在引擎层由各个引擎自己实现的。</strong></p>\n<p>(MyISAM 引擎就不支持行锁)</p>\n<h3 id=\"两阶段锁\"><a href=\"#两阶段锁\" class=\"headerlink\" title=\"两阶段锁\"></a>两阶段锁</h3><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>\n<p><strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></p>\n<h3 id=\"死锁和死锁检测\"><a href=\"#死锁和死锁检测\" class=\"headerlink\" title=\"死锁和死锁检测\"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为<strong>死锁</strong>。</p>\n<p>当出现死锁以后，有两种策略：</p>\n<ol>\n<li><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</p>\n<blockquote>\n<p>问题：在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>\n<p>我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>\n</blockquote>\n</li>\n<li><p>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。</p>\n<p><code>innodb_deadlock_detect</code> 的默认值本身就是 on。</p>\n<blockquote>\n<p>问题：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>\n<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<p><strong>问题：怎么解决由热点行更新导致的性能问题呢？</strong></p>\n<blockquote>\n<p>问题的症结在于，死锁检测要耗费大量的 CPU 资源。</p>\n<ol>\n<li><p>如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</p>\n</li>\n<li><p>控制并发度</p>\n<p>并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。</p>\n<p>基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p>\n</li>\n<li><p>设计上优化</p>\n<p>将一行改成逻辑上的多行来减少锁冲突</p>\n</li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"事务到底是隔离的还是不隔离的？\"><a href=\"#事务到底是隔离的还是不隔离的？\" class=\"headerlink\" title=\"事务到底是隔离的还是不隔离的？\"></a>事务到底是隔离的还是不隔离的？</h2><p>在 MySQL 里，有两个“视图”的概念：</p>\n<p>一个是 <strong>view</strong>。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</p>\n<p>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 <code>consistent read view</code>，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。<strong>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</strong></p>\n<p><a href=\"#事务隔离：为什么你改了我还看不见？\">参考章节</a></p>\n<h3 id=\"“快照”在-MVCC-里是怎么工作的？\"><a href=\"#“快照”在-MVCC-里是怎么工作的？\" class=\"headerlink\" title=\"“快照”在 MVCC 里是怎么工作的？\"></a>“快照”在 MVCC 里是怎么工作的？</h3><p>在<strong>可重复读</strong>隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是<strong>基于整库</strong>的。</p>\n<p>InnoDB 里面每个事务有一个<strong>唯一</strong>的事务 ID，叫作 <code>transaction id</code>。它是在事务开始的时候向 InnoDB 的事务系统申请的，是<strong>按申请顺序严格递增</strong>的。</p>\n<p>而每行数据也都是有多个版本的。<strong>每次</strong>事务更新数据的时候，都会生成一个<strong>新的数据版本</strong>，并且把 <code>transaction id</code> 赋值给这个数据版本的事务 ID，记为 <code>row trx_id</code>。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>\n<p><strong>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</strong></p>\n<p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p>\n<p>数组里面事务 ID 的最小值记为<strong>低水位</strong>，当前系统里面已经创建过的事务 ID 的最大值加 1 记为<strong>高水位</strong>。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>\n<p>数据版本的可见性规则，就是<strong>基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</strong></p>\n<img src=\"/article/53105/%E6%95%B0%E6%8D%AE%E7%89%88%E6%9C%AC%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99.png\" class title=\"数据版本可见性规则\">\n<p>对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>\n<ol>\n<li><p>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</p>\n</li>\n<li><p>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</p>\n</li>\n<li><p>如果落在黄色部分，那就包括两种情况</p>\n<ol>\n<li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li>\n<li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>\n</ol>\n<p>(高水位的定义是事务创建时所有未提交的事务ID的最大值+1是高水位，但并不是小于高水位大于低水位的事务就都没有提交。所以row trx_id 在这个范围内却不在数组中就是已经提交了的可见)</p>\n</li>\n</ol>\n<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>\n<ol>\n<li>版本未提交，不可见；</li>\n<li>版本已提交，但是是在视图创建后提交的，不可见；</li>\n<li>版本已提交，而且是在视图创建前提交的，可见。</li>\n</ol>\n<h3 id=\"更新逻辑\"><a href=\"#更新逻辑\" class=\"headerlink\" title=\"更新逻辑\"></a>更新逻辑</h3><p>更新数据都是先读后写的，而这个读，只能读当前的值，称为“<strong>当前读</strong>”（current read）。</p>\n<p>除了 update 语句外，select 语句如果加锁，也是当前读。（<code>lock in share mode</code> 或 <code>for update</code>）</p>\n<hr>\n<p><strong>问题：事务的可重复读的能力是怎么实现的？</strong></p>\n<blockquote>\n<p>可重复读的<strong>核心就是一致性读</strong>（consistent read）；</p>\n<p>而事务更新数据的时候，只能用<strong>当前读</strong>。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>\n<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>\n<ol>\n<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>\n<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>这里需要说明一下，“<code>start transaction with consistent snapshot</code>; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在<strong>读提交</strong>隔离级别下，这个用法就没意义了，等效于普通的 <code>start transaction</code>。</p>\n</blockquote>\n<hr>\n","more":"<p>关于MySQL的发音：</p>\n<blockquote>\n<p>The official way to pronounce “MySQL” is “My Ess Que Ell” (not “my sequel”), but we do not mind if you pronounce it as “my sequel” or in some other localized way.</p>\n</blockquote>\n<h2 id=\"一条SQL查询语句是如何执行的？\"><a href=\"#一条SQL查询语句是如何执行的？\" class=\"headerlink\" title=\"一条SQL查询语句是如何执行的？\"></a>一条SQL查询语句是如何执行的？</h2><p><img src=\"/article/MySQL 的基本架构示意图.png\"><span class=\"image-caption\">img</span></p>\n<p><strong>MySQL 可以分为 Server 层和存储引擎层两部分。</strong>不同的存储引擎共用一个 Server 层。</p>\n<p>Server 层包括<strong>连接器、查询缓存、分析器、优化器、执行器</strong>等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>\n<p>现在最常用的存储引擎是 <strong>InnoDB</strong>，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>\n<h3 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql -h<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"6.558ex\" height=\"2.509ex\" style=\"vertical-align: -0.671ex;\" viewbox=\"0 -791.3 2823.4 1080.4\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">ip -P</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-69\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-70\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-50\" d=\"M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z\"/>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-69\" x=\"0\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-70\" x=\"345\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMAIN-2212\" x=\"1071\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-50\" x=\"2071\" y=\"0\"/>\n</g>\n</svg>port -u$user -p<br></code></pre></td></tr></table></figure>\n<p>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份。</p>\n<blockquote>\n<ol>\n<li><p>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</p>\n</li>\n<li><p>如果用户名密码认证通过，连接器会到<strong>权限表</strong>里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</p>\n<p>(一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。)</p>\n</li>\n</ol>\n</blockquote>\n<p>显示用户正在运行的线程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">show processlist<br></code></pre></td></tr></table></figure>\n<p>Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>\n<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是 8 小时。</p>\n<p><strong>建议尽量使用长连接</strong></p>\n<blockquote>\n<p>数据库里面，<strong>长连接</strong>是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。<strong>短连接</strong>则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>\n</blockquote>\n<p>全部使用长连接后，有些时候 MySQL 占用内存涨得特别快</p>\n<p><strong>这是因为</strong> MySQL 在执行过程中临时使用的内存是管理在<strong>连接对象里面的</strong>。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，<strong>被系统强行杀掉（OOM）</strong>，从现象看就是 MySQL 异常重启了。</p>\n<blockquote>\n<p><strong>解决方法</strong></p>\n<ol>\n<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>\n<li>MySQL 5.7 或更新版本：可以在每次执行一个比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新初始化连接资源。<strong>这个过程不需要重连和重新做权限验证</strong>，但是会将连接恢复到刚刚创建完时的状态。</li>\n</ol>\n</blockquote>\n<h3 id=\"查询缓存\"><a href=\"#查询缓存\" class=\"headerlink\" title=\"查询缓存\"></a>查询缓存</h3><p>MySQL 拿到一个查询请求后:</p>\n<ol>\n<li>先到查询缓存：之前是否执行过这条语句，之前执行过的语句及其结果可能会以 <code>key(查询语句)-value（查询结果）</code> 对的形式，被直接缓存在内存中。(<a href=\"https://dev.mysql.com/blog-archive/mysql-8-0-retiring-support-for-the-query-cache/\">MySQL 8.0版本直接将查询缓存的整块功能删掉了</a> （弊大于利）查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空)。</li>\n<li>没有找缓存结果：<a href=\"#分析器\">开始真正执行语句</a></li>\n</ol>\n<h3 id=\"分析器\"><a href=\"#分析器\" class=\"headerlink\" title=\"分析器\"></a>分析器</h3><ol>\n<li><strong>词法分析</strong>\u0010：MySQL 需要识别出输入的的字符串（SQL语句）分别是什么，代表什么；</li>\n<li><strong>语法分析</strong>：根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。（语法错误提示：“You have an error in your SQL syntax”）。</li>\n</ol>\n<p>分析器处理语法和解析查询, 生成一课对应的解析树。 预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器。</p>\n<h3 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h3><p>在开始执行之前，还要先经过优化器的处理。</p>\n<p><strong>优化器</strong>是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>\n<p>优化器阶段完成后，这个语句的执行方案就确定下来了。</p>\n<h3 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h3><ol>\n<li>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限(在工程实现上，如果命中查询缓存，会在<strong>查询缓存返回结果</strong>的时候，做权限验证。查询也会在<strong>优化器之前</strong>调用 precheck 验证权限)；</li>\n<li>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的<strong>引擎定义</strong>，去使用这个引擎提供的接口。</li>\n</ol>\n<p>你会在数据库的慢查询日志中看到一个 <code>rows_examined</code> 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>\n<blockquote>\n<p>执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 <code>rows_examined</code> 并不是完全相同的</p>\n</blockquote>\n<h2 id=\"一条SQL更新语句是如何执行的？\"><a href=\"#一条SQL更新语句是如何执行的？\" class=\"headerlink\" title=\"一条SQL更新语句是如何执行的？\"></a>一条SQL更新语句是如何执行的？</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">update T set c=c+1 where ID=2;<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article/MySQL 的基本架构示意图.png\"><span class=\"image-caption\">img</span></p>\n<p><strong>执行流程</strong></p>\n<p>执行语句前要先<strong>连接</strong>数据库，这是连接器的工作</p>\n<p>在一个表上有<strong>更新</strong>的时候，跟这个表有关的<strong>查询缓存会失效</strong>，所以这条语句就会把表 T 上所有缓存结果都清空。</p>\n<p><strong>分析器</strong>会通过词法和语法解析知道这是一条更新语句。<strong>优化器</strong>决定要使用 ID 这个索引。然后，<strong>执行器</strong>负责具体执行，找到这一行，然后更新。</p>\n<p>两个重要的日志模块：<strong>redo log（重做日志）和 binlog（归档日志）</strong>（只要我们写的是DML语句（insert,update,delete,create）等等，那么我们在数据库服务端执行的时候就会涉及到 redo log(重做日志) 和 binlog(归档日志) 两个日志文件的变动）</p>\n<h3 id=\"redo-log（重做日志）–InnoDB特有的日志\"><a href=\"#redo-log（重做日志）–InnoDB特有的日志\" class=\"headerlink\" title=\"redo log（重做日志）–InnoDB特有的日志\"></a>redo log（重做日志）–InnoDB特有的日志</h3><blockquote>\n<p>问题：如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。</p>\n</blockquote>\n<p>解决：<strong>WAL 技术</strong>，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。</p>\n<p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 <strong>redo log</strong>里面，并更新内存，这个时候更新就算完成了。同时，<strong>InnoDB 引擎</strong>会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>\n<blockquote>\n<p>问题：InnoDB 的 redo log 是固定大小的，redo log 写满之后，先将日志中的部分记录写到磁盘，腾出redo log的空间继续写入。</p>\n</blockquote>\n<p><img src=\"/article/redo log 循环写入.png\"><span class=\"image-caption\">img</span></p>\n<p><code>write pos</code> 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<code>check point</code> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>\n<p><code>write pos</code> 和 <code>checkpoint</code> 之间的是“redo log”上还空着的部分，可以用来记录新的操作。</p>\n<p>如果 <code>write pos</code> 追上 <code>checkpoint</code>，表示“redo log”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>\n<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。</p>\n<p>redo log 用于保证 crash-safe 能力。<code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p>\n<h3 id=\"binlog（归档日志）–Server层-日志\"><a href=\"#binlog（归档日志）–Server层-日志\" class=\"headerlink\" title=\"binlog（归档日志）–Server层 日志\"></a>binlog（归档日志）–Server层 日志</h3><blockquote>\n<p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，<strong>binlog</strong> 日志只能用于<strong>归档</strong>。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p>\n</blockquote>\n<p><code>sync_binlog</code> 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">redo log</th>\n<th style=\"text-align:left\">binlog</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">InnoDB 引擎特有的</td>\n<td style=\"text-align:left\">MySQL 的 Server 层实现的，所有引擎都可以使用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">物理日志：记录的是“在某个数据页上做了什么修改”</td>\n<td style=\"text-align:left\">逻辑日志：记录的是这个语句的原始逻辑</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">循环写入，空间固定会用完</td>\n<td style=\"text-align:left\">追加写入，binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志</td>\n</tr>\n</tbody>\n</table>\n<p>浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。</p>\n<p><img src=\"/article/update 语句执行流程.png\"><span class=\"image-caption\">img</span></p>\n<p><strong>两阶段提交</strong>:为了让两份日志之间的逻辑一致</p>\n<h2 id=\"事务隔离：为什么你改了我还看不见？\"><a href=\"#事务隔离：为什么你改了我还看不见？\" class=\"headerlink\" title=\"事务隔离：为什么你改了我还看不见？\"></a>事务隔离：为什么你改了我还看不见？</h2><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的（MySQL 原生的 MyISAM 引擎就不支持事务）。</p>\n<p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p>\n<h3 id=\"隔离性与隔离级\"><a href=\"#隔离性与隔离级\" class=\"headerlink\" title=\"隔离性与隔离级\"></a>隔离性与隔离级</h3><p><strong>隔离得越严实，效率就会越低</strong></p>\n<p>当数据库上有多个事务同时执行的时候，就可能出现<strong>脏读</strong>（dirty read）、<strong>不可重复读</strong>（non-repeatable read）、<strong>幻读</strong>（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。</p>\n<ol>\n<li><strong>脏读</strong>：读到其他事务未提交的数据；</li>\n<li><strong>不可重复读</strong>：前后读取的记录内容不一致；</li>\n<li><strong>幻读</strong>：前后读取的记录数量不一致。</li>\n</ol>\n<blockquote>\n<p>脏读：事务A查询数据后进行了一次修改且未提交，而事务B这个时候去查询，然后使用了这个数据，因为这个数据还没有被事务A 提交到数据库中，所以事务B的得到数据就是脏数据，对脏数据进行操作可能是不正确的。 不可重复读: 事务A访问了两次数据，但是这访问第二次之间事务B进行一次并进行了修改，导致事务A访问第二次的时候得到的数据与第一次不同，导致一个事务访问两次数据得到的数据不相同。因此叫做不可重复读。 幻读： 与不可重复读都点相似，只是这次是事务B在事务A访问第二次的之前做了一个新增，导致事务A第二次读取的时候发现了多的记录，这就是幻读。 丢失修改：事务A访问该数据，事务B也访问该数据，事务A修改了该数据，事务B也修改了该数据，这样导致事务A的修改被丢失，因此称为丢失修改； 不可重复度和幻读区别： 不可重复读主要是修改操作，幻读的主要在于新增或者删除。 幻读主要在于数据的条数变了，而不可重复读主要在于数据内容变了。</p>\n</blockquote>\n<p>SQL 标准的事务隔离级别包括<strong>：读未提交</strong>（read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（serializable ）。</p>\n<ol>\n<li><strong>读未提交</strong>，一个事务还没提交时，它做的变更就能被别的事务看到；</li>\n<li><strong>读提交</strong>，一个事务提交之后，它做的变更才会被其他事务看到；</li>\n<li><strong>可重复读</strong>，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的；(<strong>别人改数据的事务已经提交，我在我的事务中也不去读</strong>。)</li>\n<li><strong>串行化</strong>，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>\n</ol>\n<p><strong>这4种隔离级别，并行性能依次降低，安全性依次提高</strong></p>\n<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p>\n<p>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。（事务启动时的视图可以认为是静态的，不受其他事务更新的影响。）</p>\n<blockquote>\n<p>事务启动方式：</p>\n<ol>\n<li>一致性视图是在执行第一个快照读语句时创建的；</li>\n<li>一致性视图是在执行 <code>start transaction with consistent snapshot</code> 时创建的。</li>\n</ol>\n</blockquote>\n<p>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。</p>\n<p>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</p>\n<p>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>\n<p>Oracle 数据库的默认隔离级别其实就是“读提交”；</p>\n<p>MySQL默认的隔离级别是”可重复读”。</p>\n<h3 id=\"事务隔离的实现\"><a href=\"#事务隔离的实现\" class=\"headerlink\" title=\"事务隔离的实现\"></a>事务隔离的实现</h3><p>实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p>\n<p><strong>同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）</strong></p>\n<p>系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。（就是当系统里没有比这个回滚日志更早的视图的时候）</p>\n<p><strong>问题：为什么建议你尽量不要使用长事务</strong></p>\n<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>\n<p>在 MySQL 5.5 及以前的版本，回滚日志是跟数据字典一起放在 <strong>ibdata</strong> 文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。</p>\n<p>长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。</p>\n<h3 id=\"事务的启动方式\"><a href=\"#事务的启动方式\" class=\"headerlink\" title=\"事务的启动方式\"></a>事务的启动方式</h3><ol>\n<li><p>显式启动事务语句， <code>begin</code> 或 <code>start transaction</code>。配套的提交语句是 <code>commit</code>，回滚语句是 <code>rollback</code>。</p>\n</li>\n<li><p><code>set autocommit=0</code>，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 <code>commit</code> 或<code>rollback</code>语句，或者断开连接。</p>\n<p><strong>建议总是使用 set autocommit=1, 通过显式语句的方式来启动事务。</strong></p>\n</li>\n<li><p>用 <code>commit work and chain</code> 语法</p>\n<p>在 <strong>autocommit 为 1</strong> 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p>\n</li>\n</ol>\n<p><code>information_schema 库的 innodb_trx 这个表</code>中查询长事务</p>\n<hr>\n<p><strong>问题：有什么方案来避免出现或者处理长事物？</strong></p>\n<blockquote>\n<p>首先，从应用开发端来看：</p>\n<ol>\n<li>确认是否使用了 <code>set autocommit=0</code>。这个确认工作可以在测试环境中开展，把 MySQL 的 <code>general_log</code> 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</li>\n<li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 <code>begin/commit</code> 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</li>\n<li>业务连接数据库的时候，根据业务本身的预估，通过 <code>SET MAX_EXECUTION_TIME</code> 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。</li>\n</ol>\n<p>其次，从数据库端来看：</p>\n<ol>\n<li><p>监控 <code>information_schema.Innodb_trx 表</code>，设置长事务阈值，超过就报警 / 或者 kill；</p>\n</li>\n<li><p>Percona 的 pt-kill 这个工具不错，推荐使用；</p>\n</li>\n<li><p>在业务功能测试阶段要求输出所有的 <code>general_log</code>，分析日志行为提前发现问题；</p>\n</li>\n<li><p>如果使用的是 MySQL 5.6 或者更新版本，把 <code>innodb_undo_tablespaces</code> 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</p>\n<p>(innodb_undo_tablespaces是控制undo是否开启独立的表空间的参数 </p>\n<ol>\n<li>为0表示：undo使用系统表空间，即ibdata1 </li>\n<li>不为0表示：使用独立的表空间，一般名称为 undo001 undo002，存放地址的配置项为：innodb_undo_directory </li>\n<li>一般innodb_undo_tablespaces 默认配置为0，innodb_undo_directory默认配置为当前数据目录)</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"深入浅出索引\"><a href=\"#深入浅出索引\" class=\"headerlink\" title=\"深入浅出索引\"></a>深入浅出索引</h2><p><strong>索引的出现是为了提高查询效率</strong></p>\n<h3 id=\"哈希表索引模型\"><a href=\"#哈希表索引模型\" class=\"headerlink\" title=\"哈希表索引模型\"></a>哈希表索引模型</h3><p>哈希表是一种以 <strong>键 - 值</strong>（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。</p>\n<blockquote>\n<p>思路：</p>\n<p>用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>\n</blockquote>\n<blockquote>\n<p><strong>问题</strong>：多个 key 值经过哈希函数的换算，会出现同一个值的情况</p>\n<p><strong>解决方法：</strong>拉出一个链表</p>\n<img src=\"/article/53105/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" class title=\"根据身份证号查找对应的名字\">\n<p><strong>缺点：</strong>因为不是有序的（比如四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加），所以<strong>哈希索引做区间查询的速度是很慢的</strong>。</p>\n<p>哈希表这种结构适用于只有<strong>等值查询</strong>的场景，比如 Memcached 及其他一些 NoSQL 引擎。</p>\n</blockquote>\n<h3 id=\"有序数组索引模型\"><a href=\"#有序数组索引模型\" class=\"headerlink\" title=\"有序数组索引模型\"></a>有序数组索引模型</h3><p>适用于<strong>等值查询</strong>和<strong>范围查询</strong>场景</p>\n<blockquote>\n<p>根据身份证号查找对应的名字<strong>有序数组</strong>示意图</p>\n<img src=\"/article/53105/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" class title=\"根据身份证号查找对应的名字\">\n<p>用二分法就可以快速得到，这个<strong>时间复杂度是 O(log(N))</strong></p>\n<p><strong>优点：</strong>仅仅看查询效率，有序数组就是最好的数据结构</p>\n<p><strong>缺点：</strong>中间插入一个记录就必须得挪动后面所有的记录，成本太高</p>\n<p>有序数组索引<strong>只适用于静态存储引擎</strong></p>\n</blockquote>\n<h3 id=\"二叉搜索树索引模型\"><a href=\"#二叉搜索树索引模型\" class=\"headerlink\" title=\"二叉搜索树索引模型\"></a>二叉搜索树索引模型</h3><blockquote>\n<p>根据身份证号查找对应的名字<strong>二叉搜索树</strong>示意图</p>\n<img src=\"/article/53105/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" class title=\"根据身份证号查找对应的名字\">\n<p>二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。</p>\n<p><strong>时间复杂度是 O(log(N))</strong></p>\n<p><strong>优点：</strong>二叉树是搜索效率最高的</p>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是<strong>平衡二叉树</strong>。为了做这个保证，<strong>更新的时间复杂度也是 O(log(N))</strong>。</li>\n<li>索引不止存在内存中，还要写到磁盘上（所以大多数的数据库存储并不使用二叉树）</li>\n</ol>\n<p><strong>解决方法：</strong>为了让一个查询<strong>尽量少地读磁盘</strong>，就必须让查询过程<strong>访问尽量少的数据块</strong>。那么，我们就不应该使用二叉树，而是要使用“<strong>N 叉</strong>”树。这里，<strong>“N 叉”树中的“N”取决于数据块的大小</strong>。</p>\n<p><strong>N叉树优点：</strong>读写上的性能优点，以及适配磁盘的访问模式</p>\n</blockquote>\n<p>在 MySQL 中，<strong>索引是在存储引擎层实现</strong>的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>\n<h3 id=\"InnoDB-的索引模型\"><a href=\"#InnoDB-的索引模型\" class=\"headerlink\" title=\"InnoDB 的索引模型\"></a>InnoDB 的索引模型</h3><p>在 InnoDB 中，表都是根据<strong>主键顺序以索引</strong>的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。</p>\n<p>InnoDB 使用了 <strong><a href=\"https://blog.csdn.net/weixin_35871519/article/details/113303881\">B+ 树索引模型</a></strong>，所以数据都是存储在 B+ 树中的。</p>\n<p><strong>每一个索引在 InnoDB 里面对应一棵 B+ 树</strong></p>\n<p><strong>B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</strong></p>\n<blockquote>\n<p>假设有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; create table T(<br>id int primary key, <br>k int not null, <br>name varchar(16),<br>index (k))engine=InnoDB;<br></code></pre></td></tr></table></figure>\n<p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下:</p>\n<p><img src=\"/article/InnoDB 的索引组织结构.png\"><span class=\"image-caption\">InnoDB 的索引组织结构</span></p>\n<p>图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>\n<p>查询时：</p>\n<ol>\n<li><p>主键查询方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from T where ID=500<br></code></pre></td></tr></table></figure>\n<p>只需要搜索 ID 这棵 B+ 树</p>\n</li>\n<li><p>普通索引查询方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from T where k=5<br></code></pre></td></tr></table></figure>\n<p>需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</p>\n</li>\n</ol>\n<p>基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该<strong>尽量使用主键查询</strong>。</p>\n</blockquote>\n<p><strong>主键索引</strong>的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为<strong>聚簇索引</strong>（clustered index）。</p>\n<p><strong>非主键索引</strong>的叶子节点内容是<strong>主键的值</strong>。在 InnoDB 里，非主键索引也被称为<strong>二级索引</strong>（secondary index）。</p>\n<h3 id=\"索引维护\"><a href=\"#索引维护\" class=\"headerlink\" title=\"索引维护\"></a><strong>索引维护</strong></h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p>\n<blockquote>\n<p><strong>页分裂</strong>:新插入的数据符合条件的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。（除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。）</p>\n<p><strong>页合并</strong>：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>\n</blockquote>\n<p><strong>性能和存储空间方面考量，自增主键往往是更合理的选择</strong></p>\n<p>自增主键的插入数据模式，正符合了递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>\n<blockquote>\n<p>适合用业务字段直接做主键的场景\u0010:</p>\n<ol>\n<li>只有一个索引；</li>\n<li>该索引必须是唯一索引。</li>\n</ol>\n<p>直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树</p>\n</blockquote>\n<h3 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h3><p><strong>经过索引优化，避免回表过程</strong></p>\n<blockquote>\n<p>搜索由</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from T where k between 3 and 5<br></code></pre></td></tr></table></figure>\n<p>变为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select ID from T where k between 3 and 5<br></code></pre></td></tr></table></figure>\n<p>只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为<strong>覆盖索引</strong>。</p>\n</blockquote>\n<p>由于覆盖索引可以<strong>减少树的搜索次数</strong>，<strong>显著提升查询性能</strong>，所以使用<strong>覆盖索引</strong>是一个常用的性能优化手段。</p>\n<h3 id=\"最左前缀原则\"><a href=\"#最左前缀原则\" class=\"headerlink\" title=\"最左前缀原则\"></a>最左前缀原则</h3><p><strong>为一个不频繁的请求创建一个索引感觉很浪费</strong></p>\n<p><strong>最左前缀</strong>可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>\n<blockquote>\n<p><strong>问题：</strong>在建立联合索引的时候，如何安排索引内的字段顺序</p>\n<p><strong>评估标准:</strong>索引的复用能力</p>\n<ol>\n<li>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>\n<li>(如果既有联合查询，又有基于 a、b 各自的查询)第二原则是,空间</li>\n</ol>\n</blockquote>\n<h3 id=\"索引下推\"><a href=\"#索引下推\" class=\"headerlink\" title=\"索引下推\"></a>索引下推</h3><p>MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;<br></code></pre></td></tr></table></figure>\n<p>无索引下推执行流程</p>\n<img src=\"/article/53105/%E6%97%A0%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg\" class title=\"无索引下推执行流程\">\n<p>索引下推执行流程</p>\n<img src=\"/article/53105/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg\" class title=\"索引下推执行流程\">\n</blockquote>\n<hr>\n<p><strong>问题：重建索引时，是重建非主键索引还是主键索引？</strong></p>\n<p>重建非主键索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">alter table T drop index k;<br>alter table T add index(k);<br></code></pre></td></tr></table></figure>\n<p>重建主键索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">alter table T drop primary key;<br>alter table T add primary key(id);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>重建索引 k 的做法是合理的，可以达到省空间的目的。</p>\n<p>但是，重建主键的过程不合理。<strong>不论是删除主键还是创建主键，都会将整个表重建。</strong>所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。</p>\n</blockquote>\n<hr>\n<h2 id=\"全局锁和表锁-：给表加个字段怎么有这么多阻碍？\"><a href=\"#全局锁和表锁-：给表加个字段怎么有这么多阻碍？\" class=\"headerlink\" title=\"全局锁和表锁 ：给表加个字段怎么有这么多阻碍？\"></a>全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h2><p>数据库锁设计的<strong>初衷是处理并发问题</strong>。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。</p>\n<p>MySQL 里面的锁大致可以分成<strong>全局锁、表级锁和行锁</strong>三类。</p>\n<h3 id=\"全局锁\"><a href=\"#全局锁\" class=\"headerlink\" title=\"全局锁\"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock (FTWRL)</code>。</p>\n<p>当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>\n<p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong></p>\n<blockquote>\n<p>全局锁的问题:</p>\n<ol>\n<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>\n<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li>\n</ol>\n</blockquote>\n<p>官方自带的逻辑备份工具是 <strong>mysqldump</strong>。当 mysqldump 使用参数<code>–single-transaction</code> 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p>\n<blockquote>\n<p><strong>问题：有了mysqldump功能，为什么还需要 FTWRL 呢？</strong></p>\n<p>一致性读是好，但前提是引擎要支持<strong>可重复读</strong>隔离级别。比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p>\n</blockquote>\n<p><strong><code>-single-transaction</code> 方法只适用于所有的表使用事务引擎的库。</strong></p>\n<blockquote>\n<p><strong>问题：既然要全库只读，为什么不使用 set global readonly=true 的方式呢？</strong></p>\n<ol>\n<li>一在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议你使用。</li>\n<li>在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>\n</ol>\n</blockquote>\n<h3 id=\"表级锁\"><a href=\"#表级锁\" class=\"headerlink\" title=\"表级锁\"></a>表级锁</h3><p>MySQL 里面表级别的锁有两种：一种是<strong>表锁</strong>，一种是<strong>元数据锁</strong>（meta data lock，MDL)。</p>\n<p><strong>表锁</strong></p>\n<p>表锁的语法是 <code>lock tables … read/write</code>。与 FTWRL 类似，可以用 <code>unlock tables</code> 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法<strong>除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</strong></p>\n<p><strong>元数据锁</strong>(MySQL 5.5 版本中引入)</p>\n<p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。</p>\n<p>MDL 的作用是，<strong>保证读写的正确性</strong>。</p>\n<ol>\n<li>当对一个表做增删改查操作的时候，加 <strong>MDL 读锁</strong>；</li>\n<li>当要对表做结构变更操作的时候，加 <strong>MDL 写锁</strong>。</li>\n</ol>\n<p>每执行一条DML、DDL语句时都会申请MDL锁，<strong>DML操作需要MDL读锁，DDL操作需要MDL写锁</strong>（MDL加锁过程是系统自动控制，无法直接干预，读读共享，读写互斥，写写互斥）</p>\n<ol>\n<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li>\n<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>\n</ol>\n<p><strong>MDL 会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</strong></p>\n<p><strong>表锁一般是在数据库引擎 <em>不支持行锁</em> 的时候才会被用到的。</strong></p>\n<hr>\n<p><strong>问题：如何安全地给小表加字段？</strong></p>\n<blockquote>\n<p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 <code>information_schema 库的 innodb_trx 表</code>中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p>\n</blockquote>\n<hr>\n<p><strong>问题：如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</strong></p>\n<blockquote>\n<p>在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p>\n<p><code>DDL NOWAIT/WAIT n</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">ALTER TABLE tbl_name NOWAIT add column ...<br>ALTER TABLE tbl_name WAIT N add column ... <br></code></pre></td></tr></table></figure>\n</blockquote>\n<hr>\n<p><strong>问题：如果你发现你的应用程序里有 lock tables 这样的语句，需要怎么做？</strong></p>\n<blockquote>\n<ol>\n<li>要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；</li>\n<li>要么是你的引擎升级了，但是代码还没升级。最后业务开发就是把 lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。</li>\n</ol>\n</blockquote>\n<hr>\n<p><strong>问题：备份一般都会在备库上执行，你在用–single-transaction 方法做逻辑备份的过程中，如果主库上的一个小表做了一个 DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</strong></p>\n<blockquote>\n<p>假设这个 DDL 是针对表 t1 的， 这里我把备份过程中几个关键的语句列出来：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；<br>/* other tables */<br>Q3:SAVEPOINT sp;<br>/* 时刻 1 */<br>Q4:show create table `t1`;<br>/* 时刻 2 */<br>Q5:SELECT * FROM `t1`;<br>/* 时刻 3 */<br>Q6:ROLLBACK TO SAVEPOINT sp;<br>/* 时刻 4 */<br>/* other tables */<br></code></pre></td></tr></table></figure>\n<ol>\n<li>如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。</li>\n<li>如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；</li>\n<li>如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。</li>\n<li>从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。</li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"行锁功过：怎么减少行锁对性能的影响？\"><a href=\"#行锁功过：怎么减少行锁对性能的影响？\" class=\"headerlink\" title=\"行锁功过：怎么减少行锁对性能的影响？\"></a>行锁功过：怎么减少行锁对性能的影响？</h2><p><strong>MySQL 的行锁是在引擎层由各个引擎自己实现的。</strong></p>\n<p>(MyISAM 引擎就不支持行锁)</p>\n<h3 id=\"两阶段锁\"><a href=\"#两阶段锁\" class=\"headerlink\" title=\"两阶段锁\"></a>两阶段锁</h3><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>\n<p><strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></p>\n<h3 id=\"死锁和死锁检测\"><a href=\"#死锁和死锁检测\" class=\"headerlink\" title=\"死锁和死锁检测\"></a>死锁和死锁检测</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为<strong>死锁</strong>。</p>\n<p>当出现死锁以后，有两种策略：</p>\n<ol>\n<li><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</p>\n<blockquote>\n<p>问题：在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>\n<p>我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>\n</blockquote>\n</li>\n<li><p>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。</p>\n<p><code>innodb_deadlock_detect</code> 的默认值本身就是 on。</p>\n<blockquote>\n<p>问题：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>\n<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p>\n</blockquote>\n</li>\n</ol>\n<hr>\n<p><strong>问题：怎么解决由热点行更新导致的性能问题呢？</strong></p>\n<blockquote>\n<p>问题的症结在于，死锁检测要耗费大量的 CPU 资源。</p>\n<ol>\n<li><p>如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</p>\n</li>\n<li><p>控制并发度</p>\n<p>并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。</p>\n<p>基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p>\n</li>\n<li><p>设计上优化</p>\n<p>将一行改成逻辑上的多行来减少锁冲突</p>\n</li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"事务到底是隔离的还是不隔离的？\"><a href=\"#事务到底是隔离的还是不隔离的？\" class=\"headerlink\" title=\"事务到底是隔离的还是不隔离的？\"></a>事务到底是隔离的还是不隔离的？</h2><p>在 MySQL 里，有两个“视图”的概念：</p>\n<p>一个是 <strong>view</strong>。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</p>\n<p>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 <code>consistent read view</code>，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。<strong>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</strong></p>\n<p><a href=\"#事务隔离：为什么你改了我还看不见？\">参考章节</a></p>\n<h3 id=\"“快照”在-MVCC-里是怎么工作的？\"><a href=\"#“快照”在-MVCC-里是怎么工作的？\" class=\"headerlink\" title=\"“快照”在 MVCC 里是怎么工作的？\"></a>“快照”在 MVCC 里是怎么工作的？</h3><p>在<strong>可重复读</strong>隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是<strong>基于整库</strong>的。</p>\n<p>InnoDB 里面每个事务有一个<strong>唯一</strong>的事务 ID，叫作 <code>transaction id</code>。它是在事务开始的时候向 InnoDB 的事务系统申请的，是<strong>按申请顺序严格递增</strong>的。</p>\n<p>而每行数据也都是有多个版本的。<strong>每次</strong>事务更新数据的时候，都会生成一个<strong>新的数据版本</strong>，并且把 <code>transaction id</code> 赋值给这个数据版本的事务 ID，记为 <code>row trx_id</code>。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>\n<p><strong>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</strong></p>\n<p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p>\n<p>数组里面事务 ID 的最小值记为<strong>低水位</strong>，当前系统里面已经创建过的事务 ID 的最大值加 1 记为<strong>高水位</strong>。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>\n<p>数据版本的可见性规则，就是<strong>基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</strong></p>\n<img src=\"/article/53105/%E6%95%B0%E6%8D%AE%E7%89%88%E6%9C%AC%E5%8F%AF%E8%A7%81%E6%80%A7%E8%A7%84%E5%88%99.png\" class title=\"数据版本可见性规则\">\n<p>对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>\n<ol>\n<li><p>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</p>\n</li>\n<li><p>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</p>\n</li>\n<li><p>如果落在黄色部分，那就包括两种情况</p>\n<ol>\n<li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li>\n<li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>\n</ol>\n<p>(高水位的定义是事务创建时所有未提交的事务ID的最大值+1是高水位，但并不是小于高水位大于低水位的事务就都没有提交。所以row trx_id 在这个范围内却不在数组中就是已经提交了的可见)</p>\n</li>\n</ol>\n<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>\n<ol>\n<li>版本未提交，不可见；</li>\n<li>版本已提交，但是是在视图创建后提交的，不可见；</li>\n<li>版本已提交，而且是在视图创建前提交的，可见。</li>\n</ol>\n<h3 id=\"更新逻辑\"><a href=\"#更新逻辑\" class=\"headerlink\" title=\"更新逻辑\"></a>更新逻辑</h3><p>更新数据都是先读后写的，而这个读，只能读当前的值，称为“<strong>当前读</strong>”（current read）。</p>\n<p>除了 update 语句外，select 语句如果加锁，也是当前读。（<code>lock in share mode</code> 或 <code>for update</code>）</p>\n<hr>\n<p><strong>问题：事务的可重复读的能力是怎么实现的？</strong></p>\n<blockquote>\n<p>可重复读的<strong>核心就是一致性读</strong>（consistent read）；</p>\n<p>而事务更新数据的时候，只能用<strong>当前读</strong>。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p>\n<p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p>\n<ol>\n<li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li>\n<li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>这里需要说明一下，“<code>start transaction with consistent snapshot</code>; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在<strong>读提交</strong>隔离级别下，这个用法就没意义了，等效于普通的 <code>start transaction</code>。</p>\n</blockquote>\n<hr>\n","categories":[{"name":"Mysql","path":"api/categories/Mysql.json"},{"name":"面试","path":"api/categories/面试.json"}],"tags":[{"name":"实习,Mysql","path":"api/tags/实习,Mysql.json"}]}