{"title":"Linux-梦开始的地方","slug":"Linux-梦开始的地方","date":"2022-03-21T08:56:47.000Z","updated":"2022-04-09T16:28:54.129Z","comments":true,"path":"api/articles/Linux-梦开始的地方.json","realPath":null,"excerpt":null,"covers":["/article/23540/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png","/article/23540/%E5%B8%B8%E7%94%A8%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png","/article/23540/%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2.png","/article/23540/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%9B%BE.png","/article/23540/image-20220327230200902.png"],"cover":"/images/theme/coverphoto/Linux.jpeg","content":"<h2 id=\"Linux-梦开始的地方\"><a href=\"#Linux-梦开始的地方\" class=\"headerlink\" title=\"Linux-梦开始的地方\"></a>Linux-梦开始的地方</h2><p>Linux，全称GNU/Linux，是一种免费使用和自由传播的<a href=\"https://baike.baidu.com/item/类UNIX/9032872\">类UNIX</a>操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到<a href=\"https://baike.baidu.com/item/Minix/7106045\">Minix</a>和Unix思想的启发，是一个基于<a href=\"https://baike.baidu.com/item/POSIX\">POSIX</a>的多用户、<a href=\"https://baike.baidu.com/item/多任务/1011764\">多任务</a>、支持<a href=\"https://baike.baidu.com/item/多线程/1190404\">多线程</a>和多<a href=\"https://baike.baidu.com/item/CPU\">CPU</a>的操作系统。它能运行主要的<a href=\"https://baike.baidu.com/item/Unix/219943\">Unix</a>工具软件、应用程序和网络协议。</p>\n<p><a href=\"https://www.kernel.org\">Linux源码</a></p>\n<h3 id=\"网络连接三种模式\"><a href=\"#网络连接三种模式\" class=\"headerlink\" title=\"网络连接三种模式\"></a>网络连接三种模式</h3><img src=\"/article/23540/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png\" class title=\"网络连接三种模式\">\n<h4 id=\"Bridged\"><a href=\"#Bridged\" class=\"headerlink\" title=\"Bridged\"></a><strong>Bridged</strong></h4><p><strong>桥接模式</strong></p>\n<p>桥接模式是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。</p>\n<blockquote>\n<p>类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中。桥接模式通过虚拟网桥将主机上的网卡与虚拟交换机Vmnet0连接在一起，虚拟机上的虚拟网卡都连接在虚拟交换机Vmnet0上，所以桥接模式的虚拟机IP必须与主机在同一网段且子网掩码、网关与DNS也要与主机网卡一致。</p>\n</blockquote>\n<p>在桥接模式下，虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问局域网内的任何一台主机，局域网内的任何一台主机也可以访问它。</p>\n<p>应用场景：当前虚拟机为整个局域网的用户提供访问服务，其他局域网用户都能访问到当前主机。</p>\n<h4 id=\"NAT模式\"><a href=\"#NAT模式\" class=\"headerlink\" title=\"NAT模式\"></a>NAT模式</h4><p><strong>地址转换模式</strong></p>\n<p>在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。</p>\n<blockquote>\n<p>在连接Vmnet8虚拟交换机时，虚拟机会将虚拟NAT设备以及虚拟DHCP服务器连接到Vmnet8虚拟交换机上，同时也会将主机上的虚拟网卡VMWare Network Adapter Vmnet8连接到Vmnet8虚拟交换机上。</p>\n<p>网卡VMWare Network Adapter Vmnet8只是作为主机与虚拟机通信的接口，虚拟机并不是依靠网卡VMWare Network Adapter Vmnet8来联网的。</p>\n</blockquote>\n<p>虚拟机借助NAT功能，<strong>通过宿主机器所在的网络来访问公网</strong>，使用NAT模式可以实现虚拟机访问互联网。</p>\n<p>NAT模式下虚拟机的TCP/IP配置信息是由VMnet8虚拟网络的DHCP服务器提供的，<strong>局域网中的其他真实主机将无法访问本虚拟机</strong>，但该主机上其他同一个网段的虚拟机可以访问。</p>\n<p>可以理解成我们自己家里的宽带，你可以访问百度，但是其他人无法访问到你。应用场景：只是通过虚拟机上网，其他用户不能访问你的虚拟机。</p>\n<h4 id=\"Host-only\"><a href=\"#Host-only\" class=\"headerlink\" title=\"Host-only\"></a>Host-only</h4><p><strong>主机模式</strong></p>\n<p>Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只能与主机相互通讯。</p>\n<blockquote>\n<p>Host-Only模式通过主机的虚拟网卡VMWare Network Adapter VMnet1来连接虚拟交换机VMnet1，从而达到与虚拟机通信的目的。如果想要在Host-Only模式下联网，可以将能联网的主机网卡共享给VMWare Network Adapter VMnet1，以实现虚拟机联网。</p>\n<p>Host-Only模式的配置过程和NAT模式基本相同。</p>\n</blockquote>\n<h2 id=\"Linux基本内容\"><a href=\"#Linux基本内容\" class=\"headerlink\" title=\"Linux基本内容\"></a>Linux基本内容</h2><ol>\n<li><p>linux的文件系统是采用层级式的树状目录结构，在此结构的最上层是根目录<code>&quot;/&quot;</code>，然后再此目录下再创建其他的目录。</p>\n</li>\n<li><p>在linux的世界里，一切皆文件。cpu、磁盘、硬盘等等都会当成文件对待。</p>\n</li>\n<li>linux的目录是规定好的，和windows可以随意设置盘符名称不一样，而且不同的目录的作用也各有安排，不可更改。</li>\n<li>学习linux一定要熟记各个目录。</li>\n</ol>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><ol>\n<li><p><code>/</code> 根目录</p>\n</li>\n<li><p><code>/bin</code> 是binary的缩写，这个目录存放最经常使用的命令。所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。</p>\n<ol>\n<li><code>/usr/bin</code> 是系统安装时自带的一些可执行程序,即系统程序。</li>\n<li><code>/usr/local/bin</code> 是用户自行编译安装时默认的可执行程序的安装位置。</li>\n</ol>\n</li>\n<li><p><code>/sbin</code> s就是super user的意思，(<code>/usr/sbin</code>,<code>/usr/local/sbin</code>)这里存放的是系统管理员使用的系统管理程序。</p>\n</li>\n<li><p><code>/home</code> 存放普通用户的主目录，在Linux中每个用户都有自己的目录，一般该里面的子目录名都以用户的账号命名。</p>\n</li>\n<li><p><code>/root</code> 该目录是系统管理员，也称为超级权限者的用户主目录。</p>\n</li>\n<li><p><code>/lib</code> 系统开机所需要的最基本的动态链接共享库，其作用类似Windows的dll文件，几乎所有的应用程序都需要用到这些共享库。</p>\n</li>\n<li><p><code>/ect</code> 这个目录里面是所有的系统管理所需要的配置文件和子目录。</p>\n</li>\n<li><p><code>/usr</code> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与Windows下的program files目录。</p>\n<ol>\n<li><code>/usr/local</code> 这是给主机额外安装软件所安装的目录，是软件安装包的目标安装目录，一般通过编译源码的方式安装软件。</li>\n</ol>\n</li>\n<li><p><code>/opt</code> 这是给主机额外安装软件的安装包源码所摆放的位置，例如安装Oracle数据库的源码就一般约定俗成放到这个目录下，默认为空。</p>\n</li>\n<li><p><code>/var</code> 这个目录中存放着在不断扩充的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</p>\n<hr>\n</li>\n<li><p><code>/dev</code> 该目录类似Windows的设备管理器，把所有的硬件（例如磁盘、cpu、串口等）用文件的形式存储起来。</p>\n</li>\n<li><p><code>/mnt</code> 系统提供该目录是为了让用户临时挂载别的文件操作系统，我们可以将外部的存储挂载到 <code>/mnt</code> 上，然后进入这个目录就可以看到外部的存储内容了。注：vmtools可以共享windows的文件就在此目录下。</p>\n</li>\n<li><p><code>/tmp</code> 这个目录是用来存放一些临时文件的。</p>\n</li>\n<li><p><code>/selinux</code> 该目录是security-enhanced linux的缩写，是一种安全子系统，类似windows上的360，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置。</p>\n</li>\n<li><p><code>/proc</code> <strong>[别动]</strong>这个目录是一个虚拟的目录，它是系统内存的映射 ，访问这个目录可以获取系统信息。</p>\n</li>\n<li><p><code>/srv</code> <strong>[别动]</strong>这是service的缩写，该目录存放一些服务启动之后需要提取的数据。</p>\n</li>\n<li><p><code>/sys</code> <strong>[别动]</strong>这是Linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs。</p>\n</li>\n<li><p><code>/boot</code> 存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</p>\n</li>\n<li><p><code>/lost+found</code> 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>\n</li>\n<li><p><code>/media</code> Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别到的设备挂载到这个目录下。</p>\n</li>\n</ol>\n<h3 id=\"Vi与Vim\"><a href=\"#Vi与Vim\" class=\"headerlink\" title=\"Vi与Vim\"></a>Vi与Vim</h3><p>Linux系统会内置<strong>vi文本编辑器</strong>。</p>\n<p><strong>vim</strong>具有程序编辑的能力，可以看成是vi的增强版本，可以主动地以字体颜色辨别语法的正确性，方便程序设计，同时具备代码补全、编译和错误跳转等功能，因此被广泛程序员使用。</p>\n<h4 id=\"常用三种模式\"><a href=\"#常用三种模式\" class=\"headerlink\" title=\"常用三种模式\"></a>常用三种模式</h4><img src=\"/article/23540/%E5%B8%B8%E7%94%A8%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png\" class title=\"常用三种模式\">\n<img src=\"/article/23540/%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2.png\" class title=\"Snipaste_2022-02-20_12-32-53\">\n<img src=\"/article/23540/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%9B%BE.png\" class title=\"Snipaste_2022-02-20_15-32-10\">\n<h4 id=\"正常模式下的快捷键\"><a href=\"#正常模式下的快捷键\" class=\"headerlink\" title=\"正常模式下的快捷键\"></a>正常模式下的快捷键</h4><ol>\n<li><p>拷贝当前行 <code>yy</code> ；</p>\n</li>\n<li><p>拷贝n行 <code>nyy</code> ；注意小键盘数字不行，用自带的数字。</p>\n</li>\n<li><p>粘贴 <code>p</code> ；</p>\n</li>\n<li><p>删除这一行 <code>dd</code> ;</p>\n</li>\n<li><p>删除n行 <code>ndd</code> ；</p>\n</li>\n<li><p>跳转到第一行 <code>gg</code> ；</p>\n</li>\n<li><p>跳转到末尾行 <code>G</code> ；</p>\n</li>\n<li><p>撤销刚才的操作 <code>u</code> ；</p>\n</li>\n<li><p>跳转到第i行 <code>i+shift+g</code> 。</p>\n</li>\n</ol>\n<h4 id=\"命令模式下的快捷键\"><a href=\"#命令模式下的快捷键\" class=\"headerlink\" title=\"命令模式下的快捷键\"></a>命令模式下的快捷键</h4><ol>\n<li>在命令模式下查找关键单词<ol>\n<li>输入<code>/</code>name ，name是你要查找的单词名</li>\n<li>按<code>n</code>查找下一个</li>\n</ol>\n</li>\n<li>在命令模式下设置行号 <code>:set nu</code> ；</li>\n<li>在命令模式下删除行号 <code>:set nonu</code> 。</li>\n</ol>\n<h3 id=\"Linux开机、重启和用户登录注销\"><a href=\"#Linux开机、重启和用户登录注销\" class=\"headerlink\" title=\"Linux开机、重启和用户登录注销\"></a>Linux开机、重启和用户登录注销</h3><h4 id=\"关机和重启\"><a href=\"#关机和重启\" class=\"headerlink\" title=\"关机和重启\"></a>关机和重启</h4><p><strong>注意，不管是重启系统还是关机，最好都执行一次sync指令，再重启或关机</strong></p>\n<ol>\n<li><p><code>shutdown -h now</code> #现在立即关机,h代表halt关机的意思</p>\n</li>\n<li><p><code>shutdown -h 1</code> #1分钟后关机</p>\n</li>\n<li><p><code>shutdown -h</code> #默认1分钟后关机</p>\n</li>\n<li><p><code>shutdown -r now</code> #现在立即重启,r代表reboot</p>\n</li>\n<li><p><code>halt</code> #关机,作用和上面指令一样</p>\n</li>\n<li><p><code>reboot</code> #重启计算机</p>\n</li>\n<li><p><code>sync</code> #把内存数据同步到磁盘</p>\n</li>\n</ol>\n<h4 id=\"用户注销\"><a href=\"#用户注销\" class=\"headerlink\" title=\"用户注销\"></a>用户注销</h4><ol>\n<li>登录时尽量少用root账号登录，可以利用普通用户登录，登录后使用<code>su - 用户名</code> ，来切换系统管理员程序；</li>\n<li>在提示符下输入<code>logout</code>即可注销用户。<ol>\n<li><code>logout</code> 在图形运行级别无效，在运行<a href=\"#指令运行级别\">级别3</a>下有效。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h2><h3 id=\"创建删除设置用户\"><a href=\"#创建删除设置用户\" class=\"headerlink\" title=\"创建删除设置用户\"></a>创建删除设置用户</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个想要使用系统资源的用户，都必须首先向系统管理员root申请一个账号，然后再以这个账号的身份进入系统。</p>\n<p>添加用户默认该用户的家目录在 <code>/home/username</code> ，username是用户的名称，也可以指定目录，但没必要.</p>\n<ol>\n<li><code>useradd milan</code> #添加milan这个用户</li>\n<li><code>useradd -d /home/test milan</code> #添加milan这个用户,但用户文件夹名不是默认的milan，而是指定为 <code>test</code></li>\n<li><code>passwd milan</code> #更改milan这个用户的密码</li>\n<li><code>userdel milan</code> #删除用户milan，但是保留home家目录</li>\n<li><code>userdel -r milan</code> #删除用户milan的所有信息，包括家目录</li>\n</ol>\n<p><strong>pwd ：该命令显示当前所在目录全程</strong></p>\n<h3 id=\"查询切换用户\"><a href=\"#查询切换用户\" class=\"headerlink\" title=\"查询切换用户\"></a>查询切换用户</h3><ol>\n<li>查询基本语法 <code>id 用户名</code> ：当不存在改用户时，返回无此用户；</li>\n<li>切换基本语法 <code>su 用户名</code> ； <code>exit</code> 返回原用户；从权限高的用户切换到权限低的用户，不需要密码；反之需要。</li>\n<li>查看当前登录用户语法 <code>whoami</code> 或者 <code>who am i</code> 。值得注意的是 <code>whoami</code> 返回当前使用的用户， <code>who am i</code> 返回第一次登录服务器的信息。</li>\n<li></li>\n</ol>\n<h3 id=\"用户组\"><a href=\"#用户组\" class=\"headerlink\" title=\"用户组\"></a>用户组</h3><p>用户组，类似于角色，系统可以对有共性的多个用户进行统一的管理。</p>\n<ol>\n<li><p>增加组 <code>groupadd 组名</code>；</p>\n</li>\n<li><p>删除组 <code>groupdel 组名</code>；</p>\n</li>\n<li><p>增加用户是直接加组 `useradd -g 用户组 用户名；</p>\n</li>\n<li><p>修改用户的组 <code>usermod -g 用户组 用户名</code>。</p>\n</li>\n</ol>\n<h3 id=\"用户和组相关文件\"><a href=\"#用户和组相关文件\" class=\"headerlink\" title=\"用户和组相关文件\"></a>用户和组相关文件</h3><ol>\n<li><p><code>/etc/passwd</code> </p>\n<p>用户user的配置文件，记录用户的各种信息</p>\n<p>每行的含义： 用户名：口令：用户表示号：组表示号：注释性描述：主目录：登录Shell</p>\n</li>\n<li><p><code>/etc/shadow</code></p>\n<p>口令的配置文件</p>\n<p>每行的含义： 登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p>\n</li>\n<li><p><code>etc/group</code></p>\n<p>组的配置文件，记录Linux包含的组的信息</p>\n<p>每行的含义：组名：口令：组标示号：组内用户列表</p>\n</li>\n</ol>\n<h2 id=\"实用指令\"><a href=\"#实用指令\" class=\"headerlink\" title=\"实用指令\"></a>实用指令</h2><h3 id=\"指定运行级别\"><a href=\"#指定运行级别\" class=\"headerlink\" title=\"指定运行级别\"></a>指定运行级别</h3><p><strong>运行级别一共有7种</strong></p>\n<ol>\n<li>0：关机</li>\n<li>1：单用户，root权限，可以帮助找回丢失的密码，用于系统维护，禁止远程登录</li>\n<li>2：多用户状态没有网络服务</li>\n<li>3：多用户状态有网络服务，登录后进入控制台命令行模式</li>\n<li>4：系统未使用保留给用户</li>\n<li>5：图形界面</li>\n<li>6：系统重启</li>\n</ol>\n<p>常用运行级别是3和5，也可以指定默认运行级别。</p>\n<p><strong>切换运行级别</strong> <code>init [运行级别]</code></p>\n<p><strong>修改默认运行级别</strong></p>\n<ol>\n<li>在CentOs7之前，需要在<code>/etc/inittab</code>中修改；</li>\n<li>在CentOs之后<ol>\n<li>查看当前运行级别 <code>runlevel</code>；</li>\n<li>查看当前默认运行级别 <code>systemctl get-default</code>；</li>\n<li>设置默认运行级别<code>systemctl set-default multiuser.target</code>。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"找回root密码\"><a href=\"#找回root密码\" class=\"headerlink\" title=\"找回root密码\"></a>找回root密码</h3><p>进入到单用户模式，就可以修改root密码</p>\n<ol>\n<li>首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面；</li>\n<li>进入编辑界面，使用键盘上的上下键把光标往下移动，找到以<code>Linux16</code>开头内容所在的行数，在行的最后面输入：<code>init=/bin/sh</code>；</li>\n<li>接着，输入完成后，直接按快捷键：<code>Ctrl+x</code> 进入单用户模式；</li>\n<li>接着，在光标闪烁的位置中输入：<code>mount -o remount,rw /</code>（注意：各个单词间有空格），完成后按键盘的回车键（Enter）；</li>\n<li>在新的一行最后面输入：<code>passwd</code>， 完成后按键盘的回车键（Enter）。输入密码，<strong>然后再次确认密码即</strong>可(密码长度最好8位以上,但不是必须的), 密码修改成功后，会显示passwd…..的样式，说明密码修改成功；</li>\n<li>接着，在鼠标闪烁的位置中（最后一行中）输入：<code>touch /.autorelabel</code>（注意：touch与 /后面有一个空格），完成后按键盘的回车键（Enter）；</li>\n<li>继续在光标闪烁的位置中，输入：<code>exec /sbin/init</code>，完成后按键盘的回车键（Enter）,等待系统自动修改密码(这个过程时间可能有点长)，完成后，系统会自动重启, 新的密码生效了。</li>\n</ol>\n<h3 id=\"帮助指令\"><a href=\"#帮助指令\" class=\"headerlink\" title=\"帮助指令\"></a>帮助指令</h3><ol>\n<li><p><code>man</code> 命令或配置信息</p>\n<p>基本语法： man [命令或者配置文件]</p>\n<p>(输入<code>q</code>退出)</p>\n</li>\n<li><p><code>help</code> 命令</p>\n<p>基本语法： help [命令]</p>\n</li>\n</ol>\n<h3 id=\"文件操作指令\"><a href=\"#文件操作指令\" class=\"headerlink\" title=\"文件操作指令\"></a>文件操作指令</h3><ol>\n<li>文件目录<ol>\n<li><code>pwd</code> 显示当前工作目录的绝对路径；</li>\n<li><code>ls -a</code> 或者 <code>ls -l</code> ：-a显示当前目录的所有文件和目录，<strong>包括隐藏的</strong>；-l表示以列表的方式显示信息；注意可以组合；</li>\n<li><code>cd [参数]</code> ：切换目录，后面可以是绝对路径或者相对路径，如果是 <code>/</code> 开头，表示绝对路径；否则为相对路径；<ol>\n<li><code>cd ~ 或者 cd</code> ：回到自己的家目录；</li>\n<li><code>cd ..</code> ：回到当前目录的上一级目录。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>文件创建删除<ol>\n<li><code>mkdir 目录名</code> ：创建目录，默认创建一级目录，如果要创建多级，要加 <code>-p</code>；</li>\n<li><code>rmdir 目录名</code> ：默认删除空目录，如果目录下有内容无法删除；</li>\n<li><code>rm -rf 目录名</code>：递归强制删除，可删除有内容的目录；</li>\n<li><code>touch 文件名</code>：创建一个空文件。</li>\n</ol>\n</li>\n<li>文件拷贝删除移动查看<ol>\n<li><code>cp 文件 拷贝路径</code> ：拷贝文件到指定路径；</li>\n<li><code>cp -r 文件夹 拷贝路径</code> ：递归拷贝文件夹到指定路径；</li>\n<li><code>\\cp</code> ：强制覆盖不提示拷贝；</li>\n<li><code>rm 文件或目录</code> ：删除文件；</li>\n<li><code>rm -r 文件夹</code> ：递归删除整个文件夹；</li>\n<li><code>rm -f</code> ：强制删除不显示；</li>\n<li><code>mv src tar</code> ：移动文件或者重命名文件；</li>\n<li><code>cat 文件</code> ：查看文件内容；<ol>\n<li><code>cat -n 文件</code> 显示行号；</li>\n</ol>\n</li>\n<li><code>more 文件</code> ：以全屏按页显示文本文件内容，（more指令是一个基于VI编辑器的文本过滤器，以全屏的方式，按页显示文本文件的内容）；<ol>\n<li><code>q</code> 退出；</li>\n<li><code>=</code> 输出当前行的行号；</li>\n<li><code>:f</code> 输出文件名和当前行的行号；</li>\n</ol>\n</li>\n<li><code>less 文件</code>：用来分屏查看文件内容，和 more 功能类似，但比more功能更强大（支持各种显示终端，less指令在西安市文件内容时，并不是一次将整个文件加载后才显示，而是根据需要加载需要的内容，对于显示大型文件具有较高的效率），<code>q</code>退出。</li>\n<li><code>echo</code> ：输出内容到控制台；<ol>\n<li><code>echo $HOSTNAME</code> ：输出主机名；</li>\n<li><code>echo $PATH</code> ：输出环境变量；</li>\n</ol>\n</li>\n<li><code>head [可选 -n 行数] 文件</code>：用于显示文件的开头部分内容，默认情况显示前10行；</li>\n<li><code>tail [可选 -n 行数] 文件</code>：用于显示文件的尾部内容，默认显示最后10行；<ol>\n<li><code>tail -f 文件名</code> ：实时追踪文档的所有更新，退出按 <code>ctrl+C</code> ，适用于网络抓包、服务器网络监视；</li>\n</ol>\n</li>\n<li><code>&gt;</code> 输出重定向（覆盖原文件）和 <code>&gt;&gt;</code> 追加；</li>\n<li><code>ln</code> ：表示link的意思，软链接，也称为符号链接，类似Windows里面的快捷方式，主要存放了链接其他文件的路径；<ol>\n<li><code>ln -s [原文件目录] [软连接名]</code> 给原文件创建一个软连接；</li>\n<li>删除时不能加 <code>/</code> ,把软连接当成一个文件，而不是目录；</li>\n</ol>\n</li>\n<li><code>history</code> ：查看已经执行过的历史命令；<ol>\n<li><code>history n</code> 显示最近使用过的n个指令；</li>\n<li><code>history !n</code> 执行历史编号为5的指令。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"时间日期指令\"><a href=\"#时间日期指令\" class=\"headerlink\" title=\"时间日期指令\"></a>时间日期指令</h3><ol>\n<li><code>date</code> ：显示当前日期；<ol>\n<li><code>date &quot;+%Y-%m-%d&quot;</code> 显示当前年月日；</li>\n<li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 显示当前年月日时分秒；</li>\n<li><code>data -s &quot;时间&quot;</code> 设置系统时间；</li>\n</ol>\n</li>\n<li><code>cal</code> ：显示本月月历；<ol>\n<li><code>cal 2022</code> ：显示2022年的所有月历。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"查找指令\"><a href=\"#查找指令\" class=\"headerlink\" title=\"查找指令\"></a>查找指令</h3><ol>\n<li><code>find [搜索范围] [选项] [参数]</code> ：从指定目录向下递归的遍历子目录，将满足的文件或目录显示在终端；<ol>\n<li>选项<code>[-name]</code> 按照指定文件名查找模式查找文件；</li>\n<li>选项<code>[-usre]</code> 查找属于指定用户名所有文件；</li>\n<li>选项<code>[-size [+n 大于n][-n 小于n][n 等于n]]</code> 按照指定的文件大小查找文件；</li>\n</ol>\n</li>\n<li><code>locate</code> ：可以利用数据库快速实现文件搜索，但有的linux没有安装，先安装 yum install mlocate ，然后再使用之前更新数据库 <code>updatedb</code> ，才能使用locate；</li>\n<li><code>which 指令</code> ：可以查看某个指令在哪个目录下；</li>\n<li><code>grep</code> ：过滤查找，通常和管道符号 <code>|</code> 一起使用；<ol>\n<li><code>grep -n &quot;内容&quot; 文件</code> -n表示显示匹配的行号；</li>\n<li><code>grep -i &quot;内容&quot; 文件</code> -i表示忽略字母大小写；</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"压缩和解压指令\"><a href=\"#压缩和解压指令\" class=\"headerlink\" title=\"压缩和解压指令\"></a>压缩和解压指令</h3><ol>\n<li><code>gzip</code> 和 <code>gunzip</code> ：对<strong>单个文件</strong>进行压缩和解压，格式是 <em>.gz</em>；</li>\n<li><code>zip</code> 和 <code>unzip</code> ：对<strong>文件夹</strong>压缩和解压，格式是 <em>.zip</em> ；<ol>\n<li><code>zip -r 压缩完成后文件名.zip 文件夹或文件</code> 压缩文件夹以及其里面的文件和子文件夹成为压缩完成后文件名.zip；</li>\n<li><code>unzip -d 解压后的文件或文件夹目录 压缩文件或文件夹目录</code>：-d表示指定的解压目录；</li>\n</ol>\n</li>\n<li><code>tar [选项] xxx.tar.gz 打包的内容</code> ：既可以压缩，也可以解压，打包得到的文件格式是<em>.tar.gz</em>；<ol>\n<li><code>tar -zcvf xxx.tar.gz</code> 打包内容 ：将内容进行打包；</li>\n<li><code>tar -zxvf xxx.tar.gz -C 解压目标目录</code> ：将压缩文件解压到特定位置；</li>\n<li>选项<code>[-c]</code> 产生 <em>.tar</em> 打包文件；</li>\n<li>选项<code>[-v]</code> 显示详细信息；</li>\n<li>选项<code>[-f]</code> 指定压缩后文件名；</li>\n<li>选项<code>[-z]</code> 打包同时压缩；</li>\n<li>选项<code>[-x]</code> 解包 <em>.tar</em> 文件；</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"组管理和权限管理\"><a href=\"#组管理和权限管理\" class=\"headerlink\" title=\"组管理和权限管理\"></a>组管理和权限管理</h2><p><strong>Linux每个用户都必须属于一个组</strong>。</p>\n<p><strong>Linux每个文件都有所有者、所在组、其他组这三个概念。</strong></p>\n<p><strong>修改权限一般要 root 权限</strong></p>\n<h3 id=\"文件和目录的所有者\"><a href=\"#文件和目录的所有者\" class=\"headerlink\" title=\"文件和目录的所有者\"></a>文件和目录的所有者</h3><ol>\n<li><code>chown -R</code> ：change owner，修改所有者。-R表示递归修改；</li>\n<li><code>chown [-R] 用户名 文件名</code> 修改文件所有者；</li>\n<li><code>chown newnwner:newgroup 文件/目录</code> 改变所有者和所在组。</li>\n</ol>\n<h3 id=\"文件和目录的所在组\"><a href=\"#文件和目录的所在组\" class=\"headerlink\" title=\"文件和目录的所在组\"></a>文件和目录的所在组</h3><ol>\n<li><code>chgrp -R</code> ：change group，修改所在组。-R表示递归修改；</li>\n<li><code>chgrp [-R] newgroup 文件/目录</code> 改变所在组；</li>\n</ol>\n<p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组。</p>\n<h3 id=\"改变用户所在组\"><a href=\"#改变用户所在组\" class=\"headerlink\" title=\"改变用户所在组\"></a>改变用户所在组</h3><ol>\n<li><code>usermod -g 新组名 用户名</code> </li>\n<li><code>usermod -d 目录名 用户名</code> 改变该用户登录的初始目录，用户需要有进入新目录的权限；</li>\n</ol>\n<h3 id=\"权限的基本介绍\"><a href=\"#权限的基本介绍\" class=\"headerlink\" title=\"权限的基本介绍\"></a>权限的基本介绍</h3><p>使用 <code>ls -l</code> 得出的信息，开头10个字符表示文件权限；</p>\n<ol>\n<li>第0位确定文件类型（ d,-,l,c,b ）<ol>\n<li><code>d</code> 表示目录；</li>\n<li><code>-</code> 表示普通文件；</li>\n<li><code>l</code> 表示链接；</li>\n<li><code>c</code> 表示字符设备文件，如鼠标、键盘等；</li>\n<li><code>b</code> 表示块设备，比如硬盘等，blog；</li>\n</ol>\n</li>\n<li>第1-3位确定所有者所拥有的权限—User；<ol>\n<li>rwx 三种权限，对于文件和目录的作用分别不用；</li>\n</ol>\n</li>\n<li>第4-6位确定所在组的权限—Group；</li>\n<li>第7-9位确定其他用户所拥有的权限—Other；</li>\n<li>其他说明：<ol>\n<li>第10位： 文件：硬连接数 ；目录：子目录数；</li>\n<li>第11位： 用户；</li>\n<li>第12位： 组；</li>\n<li>第13位： 文件大小（字节），如果是文件夹，显示4096字节；</li>\n<li>第14位： 最后修改日期；</li>\n<li>第15位： 文件名。 </li>\n</ol>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">权限</th>\n<th style=\"text-align:center\">文件</th>\n<th style=\"text-align:center\">目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">r</td>\n<td style=\"text-align:center\">读取、查看</td>\n<td style=\"text-align:center\">读取、<code>ls</code>查看</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w</td>\n<td style=\"text-align:center\">修改（但不代表可以删除，删除的前提条件是对该文件所在的目录有写权限）</td>\n<td style=\"text-align:center\">修改、目录内创建、删除、重命名目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">x</td>\n<td style=\"text-align:center\">执行</td>\n<td style=\"text-align:center\">可以进入该目录</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h3><p><code>chmod</code> ：修改文件或目录的文件；</p>\n<ol>\n<li><p><code>chmod [[u 所有者] [g 所有组] [o 其他人] [a 所有人]][[+ 增加权限] [- 减少权限] [= 设置权限]] 文件/目录</code></p>\n</li>\n<li><p><code>chmod [[u 的权限求和] [g 的权限求和] [a 的权限求和]] 文件/目录</code> : r = 4 、r = 2、 x = 1;</p>\n</li>\n</ol>\n<h2 id=\"定时任务调度\"><a href=\"#定时任务调度\" class=\"headerlink\" title=\"定时任务调度\"></a>定时任务调度</h2><p>任务调度：是指系统在某个时间执行的特定的命令或程序。</p>\n<p>分类：</p>\n<ol>\n<li>系统工作</li>\n<li>个别用户工作</li>\n</ol>\n<h3 id=\"crontab定时任务\"><a href=\"#crontab定时任务\" class=\"headerlink\" title=\"crontab定时任务\"></a>crontab定时任务</h3><p><code>crontab [选项]</code></p>\n<ul>\n<li><code>-e</code>  编辑crontab定时任务；</li>\n<li><code>-l</code>  查询crontab定时任务；</li>\n<li><code>-r</code>  删除当前用户所有的crontab任务。</li>\n</ul>\n<p><code>service crond restart</code> 重启任务调度</p>\n<p>定时参数说明</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">占位符</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">第一个”*”</td>\n<td style=\"text-align:center\">一小时当中的第几分钟</td>\n<td style=\"text-align:center\">0～59</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第二个”*”</td>\n<td style=\"text-align:center\">一天当中的第几小时</td>\n<td style=\"text-align:center\">0～23</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第三个”*”</td>\n<td style=\"text-align:center\">一个月中的第几天</td>\n<td style=\"text-align:center\">1～31</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第四个”*”</td>\n<td style=\"text-align:center\">一年当中第几月</td>\n<td style=\"text-align:center\">1～12</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第五个”*”</td>\n<td style=\"text-align:center\">一周当中的星期几</td>\n<td style=\"text-align:center\">0～7（0和7都代表周日）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">‘</td>\n<td style=\"text-align:center\">代表不连续的时间</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">代表连续的时间</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">*/n</td>\n<td style=\"text-align:center\">代表每个多久执行一次</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"at-定时任务\"><a href=\"#at-定时任务\" class=\"headerlink\" title=\"at 定时任务\"></a>at 定时任务</h3><p>crond是定时的，反复执行的；at命令是一次性定时计划任务。</p>\n<ol>\n<li><code>at</code>命令时一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。</li>\n<li>默认情况下，<strong>atd</strong>守护进程每60s检查作业队列，有作业时，会检查作业运行时间，如果运行时间与当前时间匹配，则运行此作业。</li>\n<li>at命令是一次性定时计划任务，执行完一个任务后，不再执行此任务。</li>\n<li>在使用at命令的时候，一定要保证<strong>atd</strong>进程的启动。</li>\n</ol>\n<p><code>Ctrl + D</code> 连按两次结束at命令的输入；</p>\n<p><code>atq</code> 查看设置的定时任务；</p>\n<p><code>atrm +编号</code> 删除该编号的定时任务;</p>\n<p><code>at [选项] [时间]</code></p>\n<ol>\n<li><code>-m</code> 当指定的任务被完成后，将给用户发送于邮件，即使没有标准输出；</li>\n<li><code>-I</code> atq的别名</li>\n<li><code>-d</code> atrm的别名</li>\n<li><code>-v</code> 显示任务将被执行的时间</li>\n<li><code>-V</code> 显示版本信息</li>\n<li><code>-c</code> 打印任务的内容到标准输出</li>\n<li><code>-q &lt;队列&gt;</code> 使用指定的队列</li>\n<li><code>-f &lt;文件&gt;</code> 从指定文件读入任务而不是从标准输入读入</li>\n<li><code>-t &lt;时间参数&gt;</code> 以时间参数的形式提交要运行的任务</li>\n</ol>\n<p>时间指定方法：</p>\n<ol>\n<li>接受在当天的 hh:mm （小时：分钟）式的时间指定。加入该时间已过去，那么就放在第二天执行。</li>\n<li>midnighr（深夜） noon（中午） teatime（下午四点）</li>\n<li>采用12小时制，在时间后面加上AM或PM</li>\n<li>指定命令执行的具体日期  指定格式为 (month day)(月日) 或 mm/dd/yy(月/日/年) 或 dd.mm.yy (日.月.年)</li>\n<li>使用相对计时法  指定格式为： (now + count time-units) now是当前时间，time-units是时间单位（minutes分钟 hours小时 days天 weeks星期），count是时间的数量</li>\n<li>直接使用today（今天） tomorrow（明天）</li>\n</ol>\n<h2 id=\"Linux-磁盘分区和挂载\"><a href=\"#Linux-磁盘分区和挂载\" class=\"headerlink\" title=\"Linux 磁盘分区和挂载\"></a>Linux 磁盘分区和挂载</h2><h3 id=\"Linux分区\"><a href=\"#Linux分区\" class=\"headerlink\" title=\"Linux分区\"></a>Linux分区</h3><p>Linux无论有几个分区，分给哪一个目录来使用，他归根结底就<strong>只有一个根目录</strong>，一个<strong>独立且唯一的文件结构</strong>，Linux中每个分区都是用来组成整个文件系统的一部分。</p>\n<p>Linux采用了一种叫“<strong>载入</strong>”的处理方式，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来，这时要载入的一个分区将使它的存储空间在一个目录下获得。</p>\n<h3 id=\"硬盘说明\"><a href=\"#硬盘说明\" class=\"headerlink\" title=\"硬盘说明\"></a><strong>硬盘说明</strong></h3><ol>\n<li>linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘；</li>\n<li>对于<strong>IDE硬盘</strong>，驱动器标识符为“hdx~”,其中“hd”表明分区所在设别的类型，这里是指IDE硬盘。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），“~”代表分区，前四个分区用数字1～4表示，他们是主分区或扩展分区，从5开始就是逻辑分区。</li>\n<li>对于SCSI硬盘表示为“sdx~” ,SCSI硬盘是用“sd”来表示分区所在设备类型，其余则和IDE硬盘的表示方法一样。</li>\n</ol>\n<p><code>lsblk</code> ： 查看所有设备的挂载情况</p>\n<p><code>lsblk -f</code> ： 显示的UUID是分区的40位的唯一标识符</p>\n<p><code>fdisk /dev/sdx</code> ：分区命令</p>\n<p><code>mkfs -t ext4 /dev/sdb~</code> 格式化磁盘，ext4是分区类型</p>\n<p><code>mount 设备名称 挂载目录</code> 将一个分区与一个目录联系起来</p>\n<p><code>umount 设备名称/挂载目录</code> 取消一个分区与一个目录的联系</p>\n<p>修改<code>/etc/fstab</code>永久挂载，执行<code>mount -a</code> 即刻生效</p>\n<h3 id=\"虚拟机添加硬盘并连接分区\"><a href=\"#虚拟机添加硬盘并连接分区\" class=\"headerlink\" title=\"虚拟机添加硬盘并连接分区\"></a>虚拟机添加硬盘并连接分区</h3><ol>\n<li><p>虚拟机添加硬盘</p>\n</li>\n<li><p>分区</p>\n<p><code>fdisk /dev/sdb</code></p>\n<p><code>m</code> 显示命令列表</p>\n<p><code>p</code> 显示磁盘分区</p>\n<p><code>n</code> 新增分区</p>\n<p><code>d</code> 删除分区</p>\n<p><code>w</code> 写入并退出</p>\n<ol>\n<li>开始分区后输入n，新增分区</li>\n<li>然后选择p，分区类型为主分区</li>\n<li>两次回车默认剩余全部空间</li>\n<li>最后输入w，写入分区并退出，若不保存退出输入q</li>\n</ol>\n</li>\n<li><p><code>mkfs -t ext4 /dev/sdb1</code> 格式化磁盘，ext4是分区类型</p>\n</li>\n<li><p><code>mount /dev/sdb1 /newdisk</code> 将一个分区与一个目录联系起来（用命令行挂载，重启失效）</p>\n</li>\n<li><p>修改<code>/etc/fstab</code>永久挂载</p>\n<p><code>/dev/sdb1 /newdisk ext4 defaults 0 0</code></p>\n</li>\n</ol>\n<p>​    执行<code>mount -a</code> 即刻生效</p>\n<h3 id=\"磁盘情况查询\"><a href=\"#磁盘情况查询\" class=\"headerlink\" title=\"磁盘情况查询\"></a>磁盘情况查询</h3><ol>\n<li><p><code>df -h</code> 查询系统整体磁盘使用情况</p>\n</li>\n<li><p><code>du [选项] 目录</code> 查询指定目录的磁盘占用情况</p>\n<p><code>-s</code> 指定目录占用大小汇总</p>\n<p><code>-h</code> 带计量单位</p>\n<p><code>-a</code> 含文件</p>\n<p><code>--max-depth=1</code> 子目录深度</p>\n<p><code>-c</code> 列出明细的同时，增加汇总值</p>\n</li>\n<li><p><code>tree 目录</code> 以树状结构得到显示目录结构</p>\n</li>\n</ol>\n<h2 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h2><p><code>ping 目的主机ip</code> 测试当前服务器是否可以连接目的主机</p>\n<h3 id=\"Linux网络环境配置\"><a href=\"#Linux网络环境配置\" class=\"headerlink\" title=\"Linux网络环境配置\"></a>Linux网络环境配置</h3><p><strong>指定ip</strong></p>\n<p>直接修改配置文件来指定IP，并可以连接到外网</p>\n<p>编辑 <code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>\n<blockquote>\n<p>DEVICE=enth0  #接口名（设备网卡）</p>\n<p>HWADDR=xx:xx:xx:xx:xx:xx   #MAC地址</p>\n<p>TYPE=Ethernet   #网络类型（通常是Ethernet）</p>\n<p>UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   #碎解ID</p>\n<p>ONBOOT=yes    #系统启动时网络接口是否有效</p>\n<p>BOOTPROTO=static   #IP的配置方法[none(引导时不使用协议)|static(静态分配IP)|bootp(BOOTP协议)|dhcp(DHCP协议)]</p>\n<p>IPADDR=xxx.xxx.xxx.xxx   #ip地址</p>\n<p>GATEWAY=xxx.xxx.xxx.xxx   #网关</p>\n<p>DNSI=xxx.xxx.xxx.xxx   #域名解析器</p>\n</blockquote>\n<p>重启网络服务或者重启系统生效</p>\n<p><code>service network restart</code> 或 <code>reboot</code></p>\n<h3 id=\"设置主机名\"><a href=\"#设置主机名\" class=\"headerlink\" title=\"设置主机名\"></a>设置主机名</h3><ol>\n<li><p>修改主机名</p>\n<p><code>hostname</code>  查看主机名</p>\n<p>修改文件在<code>/etc/hostname</code> 中指定</p>\n</li>\n<li><p>设置主机映射</p>\n<p>windows ： <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code> 文件指定</p>\n<p>Linux ： <code>/etc/hosts</code> 文件指定</p>\n</li>\n</ol>\n<p><strong>主机名解析机制</strong></p>\n<p>Hosts：一个文本文件，用来记录IP和Hostname（主机名）的映射关系</p>\n<p>DNS：域名解析系统，是互联网上作为域名和IP地址相互映射的一个分布式数据库</p>\n<img src=\"/article/23540/image-20220327230200902.png\" class title=\"image-20220327230200902\">\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><p>在Linux中，每个执行的程序都称为一个进程，每个进程都分配一个ID号（pid，进程号）</p>\n<p>每个进程都可能以两种方式存在，前台与后台。</p>\n<p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，知道关机才结束。</p>\n<h3 id=\"查看进程\"><a href=\"#查看进程\" class=\"headerlink\" title=\"查看进程\"></a>查看进程</h3><p><code>ps [选项]</code> 显示系统执行的进程</p>\n<p><code>-a</code> 显示当前终端的所有进程信息</p>\n<p><code>-u</code> 以用户的格式显示进程信息</p>\n<p><code>-x</code> 显示后台进程运行的参数</p>\n<blockquote>\n<p><code>ps -aux</code></p>\n<p>PID 进程识别号</p>\n<p>TTY 终端机号</p>\n<p>TIME 此进程所消耗CPU时间</p>\n<p>CMD 正在执行的命令或进程名</p>\n<p>%CPU 此进程占用CPU百分比</p>\n<p>%MEM 此进程占用物理内存百分比</p>\n<p>VSZ 此进程占用虚拟内存大小 KB</p>\n<p>RSS 此进程占用物理内存大小 KB</p>\n<p>STAT 此进程运行状态【S-休眠 r-正在运行 s-表示该进程是会话的先导进程 N-表示进程拥有比普通优先级更低的优先级 D-短期等待 Z-僵死进程 T-被跟踪或者被停止等待】</p>\n<p>START 此进程执行开始时间</p>\n<p>COMMAND 执行此进程的指令（过长会被截断）</p>\n</blockquote>\n<p><code>-e</code> 显示所有进程</p>\n<p><code>-f</code> 全格式</p>\n<blockquote>\n<p><code>ps -ef</code></p>\n<p>UID 用户ID</p>\n<p>PID 进程ID</p>\n<p>PPID 父进程ID</p>\n<p>C CPU用于计算执行优先级的因子 </p>\n<p>​    数值越大，表明进程时CPU密集型运算，执行优先级会降低</p>\n<p>​    数值越小，表明进程时I/O密集型运算，执行优先级会提高</p>\n<p>STIME 进程启动时间</p>\n<p>TTY 完整的终端名称</p>\n<p>TIME CPU时间</p>\n<p>CMD 启动进程所用的命令和参数</p>\n</blockquote>\n<h3 id=\"终止进程\"><a href=\"#终止进程\" class=\"headerlink\" title=\"终止进程\"></a>终止进程</h3><ol>\n<li><p><code>kill [选项] pid</code> 杀死某个进程</p>\n<p><code>-9</code> 表示强迫进程立即停止</p>\n</li>\n<li><p><code>killall 进程名称</code> 杀死进程及其子进程</p>\n<p>强制终止一个终端 <code>kill -9 bash 对应进程号</code></p>\n</li>\n</ol>\n<h3 id=\"显示进程树\"><a href=\"#显示进程树\" class=\"headerlink\" title=\"显示进程树\"></a>显示进程树</h3><p><code>pstree [选项]</code> 更直观的查看进程信息</p>\n<p><code>-p</code> 显示进程的PID</p>\n<p><code>-u</code> 显示进程的所属用户</p>\n<h3 id=\"服务管理\"><a href=\"#服务管理\" class=\"headerlink\" title=\"服务管理\"></a>服务管理</h3><p>服务（service）本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，因此我们又称之为守护进程。  </p>\n<p><strong>service 管理指令</strong></p>\n<p><code>service 服务名 [start|stop|restart|reload|status]</code></p>\n<p>service/systemctl</p>\n<p>service 指令管理的服务在 <code>/etc/init.d</code> 查看</p>\n<p><strong>查看service服务名</strong></p>\n<ol>\n<li>使用 setup -&gt; 系统服务 就可以看到全部setup</li>\n<li><code>ls -l /etc/init.d</code></li>\n</ol>\n<p><strong>开机的流程说明</strong></p>\n<p>开机 -&gt; BIOS -&gt; /boot -&gt; systemd进程1 -&gt; <a href=\"#指定运行级别运行级别\">运行级别</a> -&gt; 运行级别对应的服务</p>\n<ol>\n<li><p><code>chkconfig</code> 给服务的各个运行级别设置启动/关闭</p>\n<ol>\n<li><code>chkconfig --list | grep xxx</code> ：查看过滤后的服务service</li>\n<li><code>chkconfig --level 3 服务名 off</code> ：设置服务名的3级别自启动关闭</li>\n</ol>\n<p><code>chkconfig</code> 重新设置服务后自启动或者关闭，需要重启机器<code>reboot</code>生效</p>\n</li>\n<li><p><code>systemctl</code> ：管理服务指令</p>\n<ol>\n<li><code>service [start|stop|restart|reload|status] 服务名</code></li>\n</ol>\n<p>systemctl 指令管理的服务在 <code>usr/lib/systemd/system</code> 查看</p>\n<ol start=\"2\">\n<li>systemctl设置服务自启动状态<ol>\n<li><code>systemctl list-unit-files [|grep 服务名]</code> 查看服务开机启动状态，grep可以进行过滤</li>\n<li><code>systemctl enable 服务名</code> 设置服务开机启动</li>\n<li><code>systemctl disable 服务名</code> 关闭服务开机启动</li>\n<li><code>systemctl is-enable 服务名</code> 查询某个服务是否是自启动的</li>\n</ol>\n</li>\n<li><code>ls -l /usr/lib/systemd/system/ | more</code>：显示systemctl管理的服务名称。</li>\n<li><code>systemctl list-unit-files | grep firewalld</code>：查看防火墙开启还是关闭</li>\n</ol>\n</li>\n</ol>\n<p><strong>firewalld</strong></p>\n<ol>\n<li><code>firewall-cmd --permanent --add-port=端口号/协议</code> 打开端口</li>\n<li><code>firewall-cmd --permanent --remove-port=端口号/协议</code> 打开端口</li>\n<li><code>firewall-cmd --reload</code>  重新载入，才能生效</li>\n<li><code>firewall-cmd --query-port=端口号/协议</code> 查询端口是否开放</li>\n</ol>\n<h3 id=\"动态监控进程\"><a href=\"#动态监控进程\" class=\"headerlink\" title=\"动态监控进程\"></a>动态监控进程</h3><p><code>top</code>与<code>ps</code>命令很相似，他们都用来显示正在执行的进程</p>\n<p>不同：top在执行一段时间可以更新正在运行的进程</p>\n<p><code>top [选项]</code></p>\n<p><code>-d 秒数</code> 指定top命令每个几秒更新，默认是3秒</p>\n<p><code>-i</code> 使top不显示任何闲置或者僵死进程</p>\n<p><code>-p</code> 通过指定监控进程ID来监控某个进程的状态</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>P</td>\n<td>以CPU使用率排序，默认就是此项</td>\n</tr>\n<tr>\n<td>M</td>\n<td>以内存使用率排序</td>\n</tr>\n<tr>\n<td>N</td>\n<td>以PID排序</td>\n</tr>\n<tr>\n<td>q</td>\n<td>退出top</td>\n</tr>\n<tr>\n<td>u + 用户名</td>\n<td>监视特定用户</td>\n</tr>\n<tr>\n<td>k</td>\n<td>终止指定的进程</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"监控网络状态\"><a href=\"#监控网络状态\" class=\"headerlink\" title=\"监控网络状态\"></a>监控网络状态</h3><p><code>netstat [选项]</code> 查看系统网络情况</p>\n<p><code>-an</code> 按一定的顺序排序输出</p>\n<p><code>-p</code> 显示哪个进程在调用</p>\n","more":"<h2 id=\"Linux-梦开始的地方\"><a href=\"#Linux-梦开始的地方\" class=\"headerlink\" title=\"Linux-梦开始的地方\"></a>Linux-梦开始的地方</h2><p>Linux，全称GNU/Linux，是一种免费使用和自由传播的<a href=\"https://baike.baidu.com/item/类UNIX/9032872\">类UNIX</a>操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到<a href=\"https://baike.baidu.com/item/Minix/7106045\">Minix</a>和Unix思想的启发，是一个基于<a href=\"https://baike.baidu.com/item/POSIX\">POSIX</a>的多用户、<a href=\"https://baike.baidu.com/item/多任务/1011764\">多任务</a>、支持<a href=\"https://baike.baidu.com/item/多线程/1190404\">多线程</a>和多<a href=\"https://baike.baidu.com/item/CPU\">CPU</a>的操作系统。它能运行主要的<a href=\"https://baike.baidu.com/item/Unix/219943\">Unix</a>工具软件、应用程序和网络协议。</p>\n<p><a href=\"https://www.kernel.org\">Linux源码</a></p>\n<h3 id=\"网络连接三种模式\"><a href=\"#网络连接三种模式\" class=\"headerlink\" title=\"网络连接三种模式\"></a>网络连接三种模式</h3><img src=\"/article/23540/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png\" class title=\"网络连接三种模式\">\n<h4 id=\"Bridged\"><a href=\"#Bridged\" class=\"headerlink\" title=\"Bridged\"></a><strong>Bridged</strong></h4><p><strong>桥接模式</strong></p>\n<p>桥接模式是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。</p>\n<blockquote>\n<p>类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中。桥接模式通过虚拟网桥将主机上的网卡与虚拟交换机Vmnet0连接在一起，虚拟机上的虚拟网卡都连接在虚拟交换机Vmnet0上，所以桥接模式的虚拟机IP必须与主机在同一网段且子网掩码、网关与DNS也要与主机网卡一致。</p>\n</blockquote>\n<p>在桥接模式下，虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问局域网内的任何一台主机，局域网内的任何一台主机也可以访问它。</p>\n<p>应用场景：当前虚拟机为整个局域网的用户提供访问服务，其他局域网用户都能访问到当前主机。</p>\n<h4 id=\"NAT模式\"><a href=\"#NAT模式\" class=\"headerlink\" title=\"NAT模式\"></a>NAT模式</h4><p><strong>地址转换模式</strong></p>\n<p>在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网。</p>\n<blockquote>\n<p>在连接Vmnet8虚拟交换机时，虚拟机会将虚拟NAT设备以及虚拟DHCP服务器连接到Vmnet8虚拟交换机上，同时也会将主机上的虚拟网卡VMWare Network Adapter Vmnet8连接到Vmnet8虚拟交换机上。</p>\n<p>网卡VMWare Network Adapter Vmnet8只是作为主机与虚拟机通信的接口，虚拟机并不是依靠网卡VMWare Network Adapter Vmnet8来联网的。</p>\n</blockquote>\n<p>虚拟机借助NAT功能，<strong>通过宿主机器所在的网络来访问公网</strong>，使用NAT模式可以实现虚拟机访问互联网。</p>\n<p>NAT模式下虚拟机的TCP/IP配置信息是由VMnet8虚拟网络的DHCP服务器提供的，<strong>局域网中的其他真实主机将无法访问本虚拟机</strong>，但该主机上其他同一个网段的虚拟机可以访问。</p>\n<p>可以理解成我们自己家里的宽带，你可以访问百度，但是其他人无法访问到你。应用场景：只是通过虚拟机上网，其他用户不能访问你的虚拟机。</p>\n<h4 id=\"Host-only\"><a href=\"#Host-only\" class=\"headerlink\" title=\"Host-only\"></a>Host-only</h4><p><strong>主机模式</strong></p>\n<p>Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只能与主机相互通讯。</p>\n<blockquote>\n<p>Host-Only模式通过主机的虚拟网卡VMWare Network Adapter VMnet1来连接虚拟交换机VMnet1，从而达到与虚拟机通信的目的。如果想要在Host-Only模式下联网，可以将能联网的主机网卡共享给VMWare Network Adapter VMnet1，以实现虚拟机联网。</p>\n<p>Host-Only模式的配置过程和NAT模式基本相同。</p>\n</blockquote>\n<h2 id=\"Linux基本内容\"><a href=\"#Linux基本内容\" class=\"headerlink\" title=\"Linux基本内容\"></a>Linux基本内容</h2><ol>\n<li><p>linux的文件系统是采用层级式的树状目录结构，在此结构的最上层是根目录<code>&quot;/&quot;</code>，然后再此目录下再创建其他的目录。</p>\n</li>\n<li><p>在linux的世界里，一切皆文件。cpu、磁盘、硬盘等等都会当成文件对待。</p>\n</li>\n<li>linux的目录是规定好的，和windows可以随意设置盘符名称不一样，而且不同的目录的作用也各有安排，不可更改。</li>\n<li>学习linux一定要熟记各个目录。</li>\n</ol>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><ol>\n<li><p><code>/</code> 根目录</p>\n</li>\n<li><p><code>/bin</code> 是binary的缩写，这个目录存放最经常使用的命令。所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。</p>\n<ol>\n<li><code>/usr/bin</code> 是系统安装时自带的一些可执行程序,即系统程序。</li>\n<li><code>/usr/local/bin</code> 是用户自行编译安装时默认的可执行程序的安装位置。</li>\n</ol>\n</li>\n<li><p><code>/sbin</code> s就是super user的意思，(<code>/usr/sbin</code>,<code>/usr/local/sbin</code>)这里存放的是系统管理员使用的系统管理程序。</p>\n</li>\n<li><p><code>/home</code> 存放普通用户的主目录，在Linux中每个用户都有自己的目录，一般该里面的子目录名都以用户的账号命名。</p>\n</li>\n<li><p><code>/root</code> 该目录是系统管理员，也称为超级权限者的用户主目录。</p>\n</li>\n<li><p><code>/lib</code> 系统开机所需要的最基本的动态链接共享库，其作用类似Windows的dll文件，几乎所有的应用程序都需要用到这些共享库。</p>\n</li>\n<li><p><code>/ect</code> 这个目录里面是所有的系统管理所需要的配置文件和子目录。</p>\n</li>\n<li><p><code>/usr</code> 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与Windows下的program files目录。</p>\n<ol>\n<li><code>/usr/local</code> 这是给主机额外安装软件所安装的目录，是软件安装包的目标安装目录，一般通过编译源码的方式安装软件。</li>\n</ol>\n</li>\n<li><p><code>/opt</code> 这是给主机额外安装软件的安装包源码所摆放的位置，例如安装Oracle数据库的源码就一般约定俗成放到这个目录下，默认为空。</p>\n</li>\n<li><p><code>/var</code> 这个目录中存放着在不断扩充的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</p>\n<hr>\n</li>\n<li><p><code>/dev</code> 该目录类似Windows的设备管理器，把所有的硬件（例如磁盘、cpu、串口等）用文件的形式存储起来。</p>\n</li>\n<li><p><code>/mnt</code> 系统提供该目录是为了让用户临时挂载别的文件操作系统，我们可以将外部的存储挂载到 <code>/mnt</code> 上，然后进入这个目录就可以看到外部的存储内容了。注：vmtools可以共享windows的文件就在此目录下。</p>\n</li>\n<li><p><code>/tmp</code> 这个目录是用来存放一些临时文件的。</p>\n</li>\n<li><p><code>/selinux</code> 该目录是security-enhanced linux的缩写，是一种安全子系统，类似windows上的360，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置。</p>\n</li>\n<li><p><code>/proc</code> <strong>[别动]</strong>这个目录是一个虚拟的目录，它是系统内存的映射 ，访问这个目录可以获取系统信息。</p>\n</li>\n<li><p><code>/srv</code> <strong>[别动]</strong>这是service的缩写，该目录存放一些服务启动之后需要提取的数据。</p>\n</li>\n<li><p><code>/sys</code> <strong>[别动]</strong>这是Linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs。</p>\n</li>\n<li><p><code>/boot</code> 存放的是启动Linux时使用的一些核心文件，包括一些链接文件以及镜像文件</p>\n</li>\n<li><p><code>/lost+found</code> 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>\n</li>\n<li><p><code>/media</code> Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别到的设备挂载到这个目录下。</p>\n</li>\n</ol>\n<h3 id=\"Vi与Vim\"><a href=\"#Vi与Vim\" class=\"headerlink\" title=\"Vi与Vim\"></a>Vi与Vim</h3><p>Linux系统会内置<strong>vi文本编辑器</strong>。</p>\n<p><strong>vim</strong>具有程序编辑的能力，可以看成是vi的增强版本，可以主动地以字体颜色辨别语法的正确性，方便程序设计，同时具备代码补全、编译和错误跳转等功能，因此被广泛程序员使用。</p>\n<h4 id=\"常用三种模式\"><a href=\"#常用三种模式\" class=\"headerlink\" title=\"常用三种模式\"></a>常用三种模式</h4><img src=\"/article/23540/%E5%B8%B8%E7%94%A8%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png\" class title=\"常用三种模式\">\n<img src=\"/article/23540/%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2.png\" class title=\"Snipaste_2022-02-20_12-32-53\">\n<img src=\"/article/23540/%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%9B%BE.png\" class title=\"Snipaste_2022-02-20_15-32-10\">\n<h4 id=\"正常模式下的快捷键\"><a href=\"#正常模式下的快捷键\" class=\"headerlink\" title=\"正常模式下的快捷键\"></a>正常模式下的快捷键</h4><ol>\n<li><p>拷贝当前行 <code>yy</code> ；</p>\n</li>\n<li><p>拷贝n行 <code>nyy</code> ；注意小键盘数字不行，用自带的数字。</p>\n</li>\n<li><p>粘贴 <code>p</code> ；</p>\n</li>\n<li><p>删除这一行 <code>dd</code> ;</p>\n</li>\n<li><p>删除n行 <code>ndd</code> ；</p>\n</li>\n<li><p>跳转到第一行 <code>gg</code> ；</p>\n</li>\n<li><p>跳转到末尾行 <code>G</code> ；</p>\n</li>\n<li><p>撤销刚才的操作 <code>u</code> ；</p>\n</li>\n<li><p>跳转到第i行 <code>i+shift+g</code> 。</p>\n</li>\n</ol>\n<h4 id=\"命令模式下的快捷键\"><a href=\"#命令模式下的快捷键\" class=\"headerlink\" title=\"命令模式下的快捷键\"></a>命令模式下的快捷键</h4><ol>\n<li>在命令模式下查找关键单词<ol>\n<li>输入<code>/</code>name ，name是你要查找的单词名</li>\n<li>按<code>n</code>查找下一个</li>\n</ol>\n</li>\n<li>在命令模式下设置行号 <code>:set nu</code> ；</li>\n<li>在命令模式下删除行号 <code>:set nonu</code> 。</li>\n</ol>\n<h3 id=\"Linux开机、重启和用户登录注销\"><a href=\"#Linux开机、重启和用户登录注销\" class=\"headerlink\" title=\"Linux开机、重启和用户登录注销\"></a>Linux开机、重启和用户登录注销</h3><h4 id=\"关机和重启\"><a href=\"#关机和重启\" class=\"headerlink\" title=\"关机和重启\"></a>关机和重启</h4><p><strong>注意，不管是重启系统还是关机，最好都执行一次sync指令，再重启或关机</strong></p>\n<ol>\n<li><p><code>shutdown -h now</code> #现在立即关机,h代表halt关机的意思</p>\n</li>\n<li><p><code>shutdown -h 1</code> #1分钟后关机</p>\n</li>\n<li><p><code>shutdown -h</code> #默认1分钟后关机</p>\n</li>\n<li><p><code>shutdown -r now</code> #现在立即重启,r代表reboot</p>\n</li>\n<li><p><code>halt</code> #关机,作用和上面指令一样</p>\n</li>\n<li><p><code>reboot</code> #重启计算机</p>\n</li>\n<li><p><code>sync</code> #把内存数据同步到磁盘</p>\n</li>\n</ol>\n<h4 id=\"用户注销\"><a href=\"#用户注销\" class=\"headerlink\" title=\"用户注销\"></a>用户注销</h4><ol>\n<li>登录时尽量少用root账号登录，可以利用普通用户登录，登录后使用<code>su - 用户名</code> ，来切换系统管理员程序；</li>\n<li>在提示符下输入<code>logout</code>即可注销用户。<ol>\n<li><code>logout</code> 在图形运行级别无效，在运行<a href=\"#指令运行级别\">级别3</a>下有效。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h2><h3 id=\"创建删除设置用户\"><a href=\"#创建删除设置用户\" class=\"headerlink\" title=\"创建删除设置用户\"></a>创建删除设置用户</h3><p>Linux系统是一个多用户多任务的操作系统，任何一个想要使用系统资源的用户，都必须首先向系统管理员root申请一个账号，然后再以这个账号的身份进入系统。</p>\n<p>添加用户默认该用户的家目录在 <code>/home/username</code> ，username是用户的名称，也可以指定目录，但没必要.</p>\n<ol>\n<li><code>useradd milan</code> #添加milan这个用户</li>\n<li><code>useradd -d /home/test milan</code> #添加milan这个用户,但用户文件夹名不是默认的milan，而是指定为 <code>test</code></li>\n<li><code>passwd milan</code> #更改milan这个用户的密码</li>\n<li><code>userdel milan</code> #删除用户milan，但是保留home家目录</li>\n<li><code>userdel -r milan</code> #删除用户milan的所有信息，包括家目录</li>\n</ol>\n<p><strong>pwd ：该命令显示当前所在目录全程</strong></p>\n<h3 id=\"查询切换用户\"><a href=\"#查询切换用户\" class=\"headerlink\" title=\"查询切换用户\"></a>查询切换用户</h3><ol>\n<li>查询基本语法 <code>id 用户名</code> ：当不存在改用户时，返回无此用户；</li>\n<li>切换基本语法 <code>su 用户名</code> ； <code>exit</code> 返回原用户；从权限高的用户切换到权限低的用户，不需要密码；反之需要。</li>\n<li>查看当前登录用户语法 <code>whoami</code> 或者 <code>who am i</code> 。值得注意的是 <code>whoami</code> 返回当前使用的用户， <code>who am i</code> 返回第一次登录服务器的信息。</li>\n<li></li>\n</ol>\n<h3 id=\"用户组\"><a href=\"#用户组\" class=\"headerlink\" title=\"用户组\"></a>用户组</h3><p>用户组，类似于角色，系统可以对有共性的多个用户进行统一的管理。</p>\n<ol>\n<li><p>增加组 <code>groupadd 组名</code>；</p>\n</li>\n<li><p>删除组 <code>groupdel 组名</code>；</p>\n</li>\n<li><p>增加用户是直接加组 `useradd -g 用户组 用户名；</p>\n</li>\n<li><p>修改用户的组 <code>usermod -g 用户组 用户名</code>。</p>\n</li>\n</ol>\n<h3 id=\"用户和组相关文件\"><a href=\"#用户和组相关文件\" class=\"headerlink\" title=\"用户和组相关文件\"></a>用户和组相关文件</h3><ol>\n<li><p><code>/etc/passwd</code> </p>\n<p>用户user的配置文件，记录用户的各种信息</p>\n<p>每行的含义： 用户名：口令：用户表示号：组表示号：注释性描述：主目录：登录Shell</p>\n</li>\n<li><p><code>/etc/shadow</code></p>\n<p>口令的配置文件</p>\n<p>每行的含义： 登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p>\n</li>\n<li><p><code>etc/group</code></p>\n<p>组的配置文件，记录Linux包含的组的信息</p>\n<p>每行的含义：组名：口令：组标示号：组内用户列表</p>\n</li>\n</ol>\n<h2 id=\"实用指令\"><a href=\"#实用指令\" class=\"headerlink\" title=\"实用指令\"></a>实用指令</h2><h3 id=\"指定运行级别\"><a href=\"#指定运行级别\" class=\"headerlink\" title=\"指定运行级别\"></a>指定运行级别</h3><p><strong>运行级别一共有7种</strong></p>\n<ol>\n<li>0：关机</li>\n<li>1：单用户，root权限，可以帮助找回丢失的密码，用于系统维护，禁止远程登录</li>\n<li>2：多用户状态没有网络服务</li>\n<li>3：多用户状态有网络服务，登录后进入控制台命令行模式</li>\n<li>4：系统未使用保留给用户</li>\n<li>5：图形界面</li>\n<li>6：系统重启</li>\n</ol>\n<p>常用运行级别是3和5，也可以指定默认运行级别。</p>\n<p><strong>切换运行级别</strong> <code>init [运行级别]</code></p>\n<p><strong>修改默认运行级别</strong></p>\n<ol>\n<li>在CentOs7之前，需要在<code>/etc/inittab</code>中修改；</li>\n<li>在CentOs之后<ol>\n<li>查看当前运行级别 <code>runlevel</code>；</li>\n<li>查看当前默认运行级别 <code>systemctl get-default</code>；</li>\n<li>设置默认运行级别<code>systemctl set-default multiuser.target</code>。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"找回root密码\"><a href=\"#找回root密码\" class=\"headerlink\" title=\"找回root密码\"></a>找回root密码</h3><p>进入到单用户模式，就可以修改root密码</p>\n<ol>\n<li>首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面；</li>\n<li>进入编辑界面，使用键盘上的上下键把光标往下移动，找到以<code>Linux16</code>开头内容所在的行数，在行的最后面输入：<code>init=/bin/sh</code>；</li>\n<li>接着，输入完成后，直接按快捷键：<code>Ctrl+x</code> 进入单用户模式；</li>\n<li>接着，在光标闪烁的位置中输入：<code>mount -o remount,rw /</code>（注意：各个单词间有空格），完成后按键盘的回车键（Enter）；</li>\n<li>在新的一行最后面输入：<code>passwd</code>， 完成后按键盘的回车键（Enter）。输入密码，<strong>然后再次确认密码即</strong>可(密码长度最好8位以上,但不是必须的), 密码修改成功后，会显示passwd…..的样式，说明密码修改成功；</li>\n<li>接着，在鼠标闪烁的位置中（最后一行中）输入：<code>touch /.autorelabel</code>（注意：touch与 /后面有一个空格），完成后按键盘的回车键（Enter）；</li>\n<li>继续在光标闪烁的位置中，输入：<code>exec /sbin/init</code>，完成后按键盘的回车键（Enter）,等待系统自动修改密码(这个过程时间可能有点长)，完成后，系统会自动重启, 新的密码生效了。</li>\n</ol>\n<h3 id=\"帮助指令\"><a href=\"#帮助指令\" class=\"headerlink\" title=\"帮助指令\"></a>帮助指令</h3><ol>\n<li><p><code>man</code> 命令或配置信息</p>\n<p>基本语法： man [命令或者配置文件]</p>\n<p>(输入<code>q</code>退出)</p>\n</li>\n<li><p><code>help</code> 命令</p>\n<p>基本语法： help [命令]</p>\n</li>\n</ol>\n<h3 id=\"文件操作指令\"><a href=\"#文件操作指令\" class=\"headerlink\" title=\"文件操作指令\"></a>文件操作指令</h3><ol>\n<li>文件目录<ol>\n<li><code>pwd</code> 显示当前工作目录的绝对路径；</li>\n<li><code>ls -a</code> 或者 <code>ls -l</code> ：-a显示当前目录的所有文件和目录，<strong>包括隐藏的</strong>；-l表示以列表的方式显示信息；注意可以组合；</li>\n<li><code>cd [参数]</code> ：切换目录，后面可以是绝对路径或者相对路径，如果是 <code>/</code> 开头，表示绝对路径；否则为相对路径；<ol>\n<li><code>cd ~ 或者 cd</code> ：回到自己的家目录；</li>\n<li><code>cd ..</code> ：回到当前目录的上一级目录。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>文件创建删除<ol>\n<li><code>mkdir 目录名</code> ：创建目录，默认创建一级目录，如果要创建多级，要加 <code>-p</code>；</li>\n<li><code>rmdir 目录名</code> ：默认删除空目录，如果目录下有内容无法删除；</li>\n<li><code>rm -rf 目录名</code>：递归强制删除，可删除有内容的目录；</li>\n<li><code>touch 文件名</code>：创建一个空文件。</li>\n</ol>\n</li>\n<li>文件拷贝删除移动查看<ol>\n<li><code>cp 文件 拷贝路径</code> ：拷贝文件到指定路径；</li>\n<li><code>cp -r 文件夹 拷贝路径</code> ：递归拷贝文件夹到指定路径；</li>\n<li><code>\\cp</code> ：强制覆盖不提示拷贝；</li>\n<li><code>rm 文件或目录</code> ：删除文件；</li>\n<li><code>rm -r 文件夹</code> ：递归删除整个文件夹；</li>\n<li><code>rm -f</code> ：强制删除不显示；</li>\n<li><code>mv src tar</code> ：移动文件或者重命名文件；</li>\n<li><code>cat 文件</code> ：查看文件内容；<ol>\n<li><code>cat -n 文件</code> 显示行号；</li>\n</ol>\n</li>\n<li><code>more 文件</code> ：以全屏按页显示文本文件内容，（more指令是一个基于VI编辑器的文本过滤器，以全屏的方式，按页显示文本文件的内容）；<ol>\n<li><code>q</code> 退出；</li>\n<li><code>=</code> 输出当前行的行号；</li>\n<li><code>:f</code> 输出文件名和当前行的行号；</li>\n</ol>\n</li>\n<li><code>less 文件</code>：用来分屏查看文件内容，和 more 功能类似，但比more功能更强大（支持各种显示终端，less指令在西安市文件内容时，并不是一次将整个文件加载后才显示，而是根据需要加载需要的内容，对于显示大型文件具有较高的效率），<code>q</code>退出。</li>\n<li><code>echo</code> ：输出内容到控制台；<ol>\n<li><code>echo $HOSTNAME</code> ：输出主机名；</li>\n<li><code>echo $PATH</code> ：输出环境变量；</li>\n</ol>\n</li>\n<li><code>head [可选 -n 行数] 文件</code>：用于显示文件的开头部分内容，默认情况显示前10行；</li>\n<li><code>tail [可选 -n 行数] 文件</code>：用于显示文件的尾部内容，默认显示最后10行；<ol>\n<li><code>tail -f 文件名</code> ：实时追踪文档的所有更新，退出按 <code>ctrl+C</code> ，适用于网络抓包、服务器网络监视；</li>\n</ol>\n</li>\n<li><code>&gt;</code> 输出重定向（覆盖原文件）和 <code>&gt;&gt;</code> 追加；</li>\n<li><code>ln</code> ：表示link的意思，软链接，也称为符号链接，类似Windows里面的快捷方式，主要存放了链接其他文件的路径；<ol>\n<li><code>ln -s [原文件目录] [软连接名]</code> 给原文件创建一个软连接；</li>\n<li>删除时不能加 <code>/</code> ,把软连接当成一个文件，而不是目录；</li>\n</ol>\n</li>\n<li><code>history</code> ：查看已经执行过的历史命令；<ol>\n<li><code>history n</code> 显示最近使用过的n个指令；</li>\n<li><code>history !n</code> 执行历史编号为5的指令。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"时间日期指令\"><a href=\"#时间日期指令\" class=\"headerlink\" title=\"时间日期指令\"></a>时间日期指令</h3><ol>\n<li><code>date</code> ：显示当前日期；<ol>\n<li><code>date &quot;+%Y-%m-%d&quot;</code> 显示当前年月日；</li>\n<li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 显示当前年月日时分秒；</li>\n<li><code>data -s &quot;时间&quot;</code> 设置系统时间；</li>\n</ol>\n</li>\n<li><code>cal</code> ：显示本月月历；<ol>\n<li><code>cal 2022</code> ：显示2022年的所有月历。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"查找指令\"><a href=\"#查找指令\" class=\"headerlink\" title=\"查找指令\"></a>查找指令</h3><ol>\n<li><code>find [搜索范围] [选项] [参数]</code> ：从指定目录向下递归的遍历子目录，将满足的文件或目录显示在终端；<ol>\n<li>选项<code>[-name]</code> 按照指定文件名查找模式查找文件；</li>\n<li>选项<code>[-usre]</code> 查找属于指定用户名所有文件；</li>\n<li>选项<code>[-size [+n 大于n][-n 小于n][n 等于n]]</code> 按照指定的文件大小查找文件；</li>\n</ol>\n</li>\n<li><code>locate</code> ：可以利用数据库快速实现文件搜索，但有的linux没有安装，先安装 yum install mlocate ，然后再使用之前更新数据库 <code>updatedb</code> ，才能使用locate；</li>\n<li><code>which 指令</code> ：可以查看某个指令在哪个目录下；</li>\n<li><code>grep</code> ：过滤查找，通常和管道符号 <code>|</code> 一起使用；<ol>\n<li><code>grep -n &quot;内容&quot; 文件</code> -n表示显示匹配的行号；</li>\n<li><code>grep -i &quot;内容&quot; 文件</code> -i表示忽略字母大小写；</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"压缩和解压指令\"><a href=\"#压缩和解压指令\" class=\"headerlink\" title=\"压缩和解压指令\"></a>压缩和解压指令</h3><ol>\n<li><code>gzip</code> 和 <code>gunzip</code> ：对<strong>单个文件</strong>进行压缩和解压，格式是 <em>.gz</em>；</li>\n<li><code>zip</code> 和 <code>unzip</code> ：对<strong>文件夹</strong>压缩和解压，格式是 <em>.zip</em> ；<ol>\n<li><code>zip -r 压缩完成后文件名.zip 文件夹或文件</code> 压缩文件夹以及其里面的文件和子文件夹成为压缩完成后文件名.zip；</li>\n<li><code>unzip -d 解压后的文件或文件夹目录 压缩文件或文件夹目录</code>：-d表示指定的解压目录；</li>\n</ol>\n</li>\n<li><code>tar [选项] xxx.tar.gz 打包的内容</code> ：既可以压缩，也可以解压，打包得到的文件格式是<em>.tar.gz</em>；<ol>\n<li><code>tar -zcvf xxx.tar.gz</code> 打包内容 ：将内容进行打包；</li>\n<li><code>tar -zxvf xxx.tar.gz -C 解压目标目录</code> ：将压缩文件解压到特定位置；</li>\n<li>选项<code>[-c]</code> 产生 <em>.tar</em> 打包文件；</li>\n<li>选项<code>[-v]</code> 显示详细信息；</li>\n<li>选项<code>[-f]</code> 指定压缩后文件名；</li>\n<li>选项<code>[-z]</code> 打包同时压缩；</li>\n<li>选项<code>[-x]</code> 解包 <em>.tar</em> 文件；</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"组管理和权限管理\"><a href=\"#组管理和权限管理\" class=\"headerlink\" title=\"组管理和权限管理\"></a>组管理和权限管理</h2><p><strong>Linux每个用户都必须属于一个组</strong>。</p>\n<p><strong>Linux每个文件都有所有者、所在组、其他组这三个概念。</strong></p>\n<p><strong>修改权限一般要 root 权限</strong></p>\n<h3 id=\"文件和目录的所有者\"><a href=\"#文件和目录的所有者\" class=\"headerlink\" title=\"文件和目录的所有者\"></a>文件和目录的所有者</h3><ol>\n<li><code>chown -R</code> ：change owner，修改所有者。-R表示递归修改；</li>\n<li><code>chown [-R] 用户名 文件名</code> 修改文件所有者；</li>\n<li><code>chown newnwner:newgroup 文件/目录</code> 改变所有者和所在组。</li>\n</ol>\n<h3 id=\"文件和目录的所在组\"><a href=\"#文件和目录的所在组\" class=\"headerlink\" title=\"文件和目录的所在组\"></a>文件和目录的所在组</h3><ol>\n<li><code>chgrp -R</code> ：change group，修改所在组。-R表示递归修改；</li>\n<li><code>chgrp [-R] newgroup 文件/目录</code> 改变所在组；</li>\n</ol>\n<p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组。</p>\n<h3 id=\"改变用户所在组\"><a href=\"#改变用户所在组\" class=\"headerlink\" title=\"改变用户所在组\"></a>改变用户所在组</h3><ol>\n<li><code>usermod -g 新组名 用户名</code> </li>\n<li><code>usermod -d 目录名 用户名</code> 改变该用户登录的初始目录，用户需要有进入新目录的权限；</li>\n</ol>\n<h3 id=\"权限的基本介绍\"><a href=\"#权限的基本介绍\" class=\"headerlink\" title=\"权限的基本介绍\"></a>权限的基本介绍</h3><p>使用 <code>ls -l</code> 得出的信息，开头10个字符表示文件权限；</p>\n<ol>\n<li>第0位确定文件类型（ d,-,l,c,b ）<ol>\n<li><code>d</code> 表示目录；</li>\n<li><code>-</code> 表示普通文件；</li>\n<li><code>l</code> 表示链接；</li>\n<li><code>c</code> 表示字符设备文件，如鼠标、键盘等；</li>\n<li><code>b</code> 表示块设备，比如硬盘等，blog；</li>\n</ol>\n</li>\n<li>第1-3位确定所有者所拥有的权限—User；<ol>\n<li>rwx 三种权限，对于文件和目录的作用分别不用；</li>\n</ol>\n</li>\n<li>第4-6位确定所在组的权限—Group；</li>\n<li>第7-9位确定其他用户所拥有的权限—Other；</li>\n<li>其他说明：<ol>\n<li>第10位： 文件：硬连接数 ；目录：子目录数；</li>\n<li>第11位： 用户；</li>\n<li>第12位： 组；</li>\n<li>第13位： 文件大小（字节），如果是文件夹，显示4096字节；</li>\n<li>第14位： 最后修改日期；</li>\n<li>第15位： 文件名。 </li>\n</ol>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">权限</th>\n<th style=\"text-align:center\">文件</th>\n<th style=\"text-align:center\">目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">r</td>\n<td style=\"text-align:center\">读取、查看</td>\n<td style=\"text-align:center\">读取、<code>ls</code>查看</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w</td>\n<td style=\"text-align:center\">修改（但不代表可以删除，删除的前提条件是对该文件所在的目录有写权限）</td>\n<td style=\"text-align:center\">修改、目录内创建、删除、重命名目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">x</td>\n<td style=\"text-align:center\">执行</td>\n<td style=\"text-align:center\">可以进入该目录</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h3><p><code>chmod</code> ：修改文件或目录的文件；</p>\n<ol>\n<li><p><code>chmod [[u 所有者] [g 所有组] [o 其他人] [a 所有人]][[+ 增加权限] [- 减少权限] [= 设置权限]] 文件/目录</code></p>\n</li>\n<li><p><code>chmod [[u 的权限求和] [g 的权限求和] [a 的权限求和]] 文件/目录</code> : r = 4 、r = 2、 x = 1;</p>\n</li>\n</ol>\n<h2 id=\"定时任务调度\"><a href=\"#定时任务调度\" class=\"headerlink\" title=\"定时任务调度\"></a>定时任务调度</h2><p>任务调度：是指系统在某个时间执行的特定的命令或程序。</p>\n<p>分类：</p>\n<ol>\n<li>系统工作</li>\n<li>个别用户工作</li>\n</ol>\n<h3 id=\"crontab定时任务\"><a href=\"#crontab定时任务\" class=\"headerlink\" title=\"crontab定时任务\"></a>crontab定时任务</h3><p><code>crontab [选项]</code></p>\n<ul>\n<li><code>-e</code>  编辑crontab定时任务；</li>\n<li><code>-l</code>  查询crontab定时任务；</li>\n<li><code>-r</code>  删除当前用户所有的crontab任务。</li>\n</ul>\n<p><code>service crond restart</code> 重启任务调度</p>\n<p>定时参数说明</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">占位符</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">第一个”*”</td>\n<td style=\"text-align:center\">一小时当中的第几分钟</td>\n<td style=\"text-align:center\">0～59</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第二个”*”</td>\n<td style=\"text-align:center\">一天当中的第几小时</td>\n<td style=\"text-align:center\">0～23</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第三个”*”</td>\n<td style=\"text-align:center\">一个月中的第几天</td>\n<td style=\"text-align:center\">1～31</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第四个”*”</td>\n<td style=\"text-align:center\">一年当中第几月</td>\n<td style=\"text-align:center\">1～12</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第五个”*”</td>\n<td style=\"text-align:center\">一周当中的星期几</td>\n<td style=\"text-align:center\">0～7（0和7都代表周日）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">‘</td>\n<td style=\"text-align:center\">代表不连续的时间</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">代表连续的时间</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">*/n</td>\n<td style=\"text-align:center\">代表每个多久执行一次</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"at-定时任务\"><a href=\"#at-定时任务\" class=\"headerlink\" title=\"at 定时任务\"></a>at 定时任务</h3><p>crond是定时的，反复执行的；at命令是一次性定时计划任务。</p>\n<ol>\n<li><code>at</code>命令时一次性定时计划任务，at的守护进程atd会以后台模式运行，检查作业队列来运行。</li>\n<li>默认情况下，<strong>atd</strong>守护进程每60s检查作业队列，有作业时，会检查作业运行时间，如果运行时间与当前时间匹配，则运行此作业。</li>\n<li>at命令是一次性定时计划任务，执行完一个任务后，不再执行此任务。</li>\n<li>在使用at命令的时候，一定要保证<strong>atd</strong>进程的启动。</li>\n</ol>\n<p><code>Ctrl + D</code> 连按两次结束at命令的输入；</p>\n<p><code>atq</code> 查看设置的定时任务；</p>\n<p><code>atrm +编号</code> 删除该编号的定时任务;</p>\n<p><code>at [选项] [时间]</code></p>\n<ol>\n<li><code>-m</code> 当指定的任务被完成后，将给用户发送于邮件，即使没有标准输出；</li>\n<li><code>-I</code> atq的别名</li>\n<li><code>-d</code> atrm的别名</li>\n<li><code>-v</code> 显示任务将被执行的时间</li>\n<li><code>-V</code> 显示版本信息</li>\n<li><code>-c</code> 打印任务的内容到标准输出</li>\n<li><code>-q &lt;队列&gt;</code> 使用指定的队列</li>\n<li><code>-f &lt;文件&gt;</code> 从指定文件读入任务而不是从标准输入读入</li>\n<li><code>-t &lt;时间参数&gt;</code> 以时间参数的形式提交要运行的任务</li>\n</ol>\n<p>时间指定方法：</p>\n<ol>\n<li>接受在当天的 hh:mm （小时：分钟）式的时间指定。加入该时间已过去，那么就放在第二天执行。</li>\n<li>midnighr（深夜） noon（中午） teatime（下午四点）</li>\n<li>采用12小时制，在时间后面加上AM或PM</li>\n<li>指定命令执行的具体日期  指定格式为 (month day)(月日) 或 mm/dd/yy(月/日/年) 或 dd.mm.yy (日.月.年)</li>\n<li>使用相对计时法  指定格式为： (now + count time-units) now是当前时间，time-units是时间单位（minutes分钟 hours小时 days天 weeks星期），count是时间的数量</li>\n<li>直接使用today（今天） tomorrow（明天）</li>\n</ol>\n<h2 id=\"Linux-磁盘分区和挂载\"><a href=\"#Linux-磁盘分区和挂载\" class=\"headerlink\" title=\"Linux 磁盘分区和挂载\"></a>Linux 磁盘分区和挂载</h2><h3 id=\"Linux分区\"><a href=\"#Linux分区\" class=\"headerlink\" title=\"Linux分区\"></a>Linux分区</h3><p>Linux无论有几个分区，分给哪一个目录来使用，他归根结底就<strong>只有一个根目录</strong>，一个<strong>独立且唯一的文件结构</strong>，Linux中每个分区都是用来组成整个文件系统的一部分。</p>\n<p>Linux采用了一种叫“<strong>载入</strong>”的处理方式，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来，这时要载入的一个分区将使它的存储空间在一个目录下获得。</p>\n<h3 id=\"硬盘说明\"><a href=\"#硬盘说明\" class=\"headerlink\" title=\"硬盘说明\"></a><strong>硬盘说明</strong></h3><ol>\n<li>linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘；</li>\n<li>对于<strong>IDE硬盘</strong>，驱动器标识符为“hdx~”,其中“hd”表明分区所在设别的类型，这里是指IDE硬盘。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），“~”代表分区，前四个分区用数字1～4表示，他们是主分区或扩展分区，从5开始就是逻辑分区。</li>\n<li>对于SCSI硬盘表示为“sdx~” ,SCSI硬盘是用“sd”来表示分区所在设备类型，其余则和IDE硬盘的表示方法一样。</li>\n</ol>\n<p><code>lsblk</code> ： 查看所有设备的挂载情况</p>\n<p><code>lsblk -f</code> ： 显示的UUID是分区的40位的唯一标识符</p>\n<p><code>fdisk /dev/sdx</code> ：分区命令</p>\n<p><code>mkfs -t ext4 /dev/sdb~</code> 格式化磁盘，ext4是分区类型</p>\n<p><code>mount 设备名称 挂载目录</code> 将一个分区与一个目录联系起来</p>\n<p><code>umount 设备名称/挂载目录</code> 取消一个分区与一个目录的联系</p>\n<p>修改<code>/etc/fstab</code>永久挂载，执行<code>mount -a</code> 即刻生效</p>\n<h3 id=\"虚拟机添加硬盘并连接分区\"><a href=\"#虚拟机添加硬盘并连接分区\" class=\"headerlink\" title=\"虚拟机添加硬盘并连接分区\"></a>虚拟机添加硬盘并连接分区</h3><ol>\n<li><p>虚拟机添加硬盘</p>\n</li>\n<li><p>分区</p>\n<p><code>fdisk /dev/sdb</code></p>\n<p><code>m</code> 显示命令列表</p>\n<p><code>p</code> 显示磁盘分区</p>\n<p><code>n</code> 新增分区</p>\n<p><code>d</code> 删除分区</p>\n<p><code>w</code> 写入并退出</p>\n<ol>\n<li>开始分区后输入n，新增分区</li>\n<li>然后选择p，分区类型为主分区</li>\n<li>两次回车默认剩余全部空间</li>\n<li>最后输入w，写入分区并退出，若不保存退出输入q</li>\n</ol>\n</li>\n<li><p><code>mkfs -t ext4 /dev/sdb1</code> 格式化磁盘，ext4是分区类型</p>\n</li>\n<li><p><code>mount /dev/sdb1 /newdisk</code> 将一个分区与一个目录联系起来（用命令行挂载，重启失效）</p>\n</li>\n<li><p>修改<code>/etc/fstab</code>永久挂载</p>\n<p><code>/dev/sdb1 /newdisk ext4 defaults 0 0</code></p>\n</li>\n</ol>\n<p>​    执行<code>mount -a</code> 即刻生效</p>\n<h3 id=\"磁盘情况查询\"><a href=\"#磁盘情况查询\" class=\"headerlink\" title=\"磁盘情况查询\"></a>磁盘情况查询</h3><ol>\n<li><p><code>df -h</code> 查询系统整体磁盘使用情况</p>\n</li>\n<li><p><code>du [选项] 目录</code> 查询指定目录的磁盘占用情况</p>\n<p><code>-s</code> 指定目录占用大小汇总</p>\n<p><code>-h</code> 带计量单位</p>\n<p><code>-a</code> 含文件</p>\n<p><code>--max-depth=1</code> 子目录深度</p>\n<p><code>-c</code> 列出明细的同时，增加汇总值</p>\n</li>\n<li><p><code>tree 目录</code> 以树状结构得到显示目录结构</p>\n</li>\n</ol>\n<h2 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h2><p><code>ping 目的主机ip</code> 测试当前服务器是否可以连接目的主机</p>\n<h3 id=\"Linux网络环境配置\"><a href=\"#Linux网络环境配置\" class=\"headerlink\" title=\"Linux网络环境配置\"></a>Linux网络环境配置</h3><p><strong>指定ip</strong></p>\n<p>直接修改配置文件来指定IP，并可以连接到外网</p>\n<p>编辑 <code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>\n<blockquote>\n<p>DEVICE=enth0  #接口名（设备网卡）</p>\n<p>HWADDR=xx:xx:xx:xx:xx:xx   #MAC地址</p>\n<p>TYPE=Ethernet   #网络类型（通常是Ethernet）</p>\n<p>UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   #碎解ID</p>\n<p>ONBOOT=yes    #系统启动时网络接口是否有效</p>\n<p>BOOTPROTO=static   #IP的配置方法[none(引导时不使用协议)|static(静态分配IP)|bootp(BOOTP协议)|dhcp(DHCP协议)]</p>\n<p>IPADDR=xxx.xxx.xxx.xxx   #ip地址</p>\n<p>GATEWAY=xxx.xxx.xxx.xxx   #网关</p>\n<p>DNSI=xxx.xxx.xxx.xxx   #域名解析器</p>\n</blockquote>\n<p>重启网络服务或者重启系统生效</p>\n<p><code>service network restart</code> 或 <code>reboot</code></p>\n<h3 id=\"设置主机名\"><a href=\"#设置主机名\" class=\"headerlink\" title=\"设置主机名\"></a>设置主机名</h3><ol>\n<li><p>修改主机名</p>\n<p><code>hostname</code>  查看主机名</p>\n<p>修改文件在<code>/etc/hostname</code> 中指定</p>\n</li>\n<li><p>设置主机映射</p>\n<p>windows ： <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code> 文件指定</p>\n<p>Linux ： <code>/etc/hosts</code> 文件指定</p>\n</li>\n</ol>\n<p><strong>主机名解析机制</strong></p>\n<p>Hosts：一个文本文件，用来记录IP和Hostname（主机名）的映射关系</p>\n<p>DNS：域名解析系统，是互联网上作为域名和IP地址相互映射的一个分布式数据库</p>\n<img src=\"/article/23540/image-20220327230200902.png\" class title=\"image-20220327230200902\">\n<h2 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h2><p>在Linux中，每个执行的程序都称为一个进程，每个进程都分配一个ID号（pid，进程号）</p>\n<p>每个进程都可能以两种方式存在，前台与后台。</p>\n<p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，知道关机才结束。</p>\n<h3 id=\"查看进程\"><a href=\"#查看进程\" class=\"headerlink\" title=\"查看进程\"></a>查看进程</h3><p><code>ps [选项]</code> 显示系统执行的进程</p>\n<p><code>-a</code> 显示当前终端的所有进程信息</p>\n<p><code>-u</code> 以用户的格式显示进程信息</p>\n<p><code>-x</code> 显示后台进程运行的参数</p>\n<blockquote>\n<p><code>ps -aux</code></p>\n<p>PID 进程识别号</p>\n<p>TTY 终端机号</p>\n<p>TIME 此进程所消耗CPU时间</p>\n<p>CMD 正在执行的命令或进程名</p>\n<p>%CPU 此进程占用CPU百分比</p>\n<p>%MEM 此进程占用物理内存百分比</p>\n<p>VSZ 此进程占用虚拟内存大小 KB</p>\n<p>RSS 此进程占用物理内存大小 KB</p>\n<p>STAT 此进程运行状态【S-休眠 r-正在运行 s-表示该进程是会话的先导进程 N-表示进程拥有比普通优先级更低的优先级 D-短期等待 Z-僵死进程 T-被跟踪或者被停止等待】</p>\n<p>START 此进程执行开始时间</p>\n<p>COMMAND 执行此进程的指令（过长会被截断）</p>\n</blockquote>\n<p><code>-e</code> 显示所有进程</p>\n<p><code>-f</code> 全格式</p>\n<blockquote>\n<p><code>ps -ef</code></p>\n<p>UID 用户ID</p>\n<p>PID 进程ID</p>\n<p>PPID 父进程ID</p>\n<p>C CPU用于计算执行优先级的因子 </p>\n<p>​    数值越大，表明进程时CPU密集型运算，执行优先级会降低</p>\n<p>​    数值越小，表明进程时I/O密集型运算，执行优先级会提高</p>\n<p>STIME 进程启动时间</p>\n<p>TTY 完整的终端名称</p>\n<p>TIME CPU时间</p>\n<p>CMD 启动进程所用的命令和参数</p>\n</blockquote>\n<h3 id=\"终止进程\"><a href=\"#终止进程\" class=\"headerlink\" title=\"终止进程\"></a>终止进程</h3><ol>\n<li><p><code>kill [选项] pid</code> 杀死某个进程</p>\n<p><code>-9</code> 表示强迫进程立即停止</p>\n</li>\n<li><p><code>killall 进程名称</code> 杀死进程及其子进程</p>\n<p>强制终止一个终端 <code>kill -9 bash 对应进程号</code></p>\n</li>\n</ol>\n<h3 id=\"显示进程树\"><a href=\"#显示进程树\" class=\"headerlink\" title=\"显示进程树\"></a>显示进程树</h3><p><code>pstree [选项]</code> 更直观的查看进程信息</p>\n<p><code>-p</code> 显示进程的PID</p>\n<p><code>-u</code> 显示进程的所属用户</p>\n<h3 id=\"服务管理\"><a href=\"#服务管理\" class=\"headerlink\" title=\"服务管理\"></a>服务管理</h3><p>服务（service）本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，因此我们又称之为守护进程。  </p>\n<p><strong>service 管理指令</strong></p>\n<p><code>service 服务名 [start|stop|restart|reload|status]</code></p>\n<p>service/systemctl</p>\n<p>service 指令管理的服务在 <code>/etc/init.d</code> 查看</p>\n<p><strong>查看service服务名</strong></p>\n<ol>\n<li>使用 setup -&gt; 系统服务 就可以看到全部setup</li>\n<li><code>ls -l /etc/init.d</code></li>\n</ol>\n<p><strong>开机的流程说明</strong></p>\n<p>开机 -&gt; BIOS -&gt; /boot -&gt; systemd进程1 -&gt; <a href=\"#指定运行级别运行级别\">运行级别</a> -&gt; 运行级别对应的服务</p>\n<ol>\n<li><p><code>chkconfig</code> 给服务的各个运行级别设置启动/关闭</p>\n<ol>\n<li><code>chkconfig --list | grep xxx</code> ：查看过滤后的服务service</li>\n<li><code>chkconfig --level 3 服务名 off</code> ：设置服务名的3级别自启动关闭</li>\n</ol>\n<p><code>chkconfig</code> 重新设置服务后自启动或者关闭，需要重启机器<code>reboot</code>生效</p>\n</li>\n<li><p><code>systemctl</code> ：管理服务指令</p>\n<ol>\n<li><code>service [start|stop|restart|reload|status] 服务名</code></li>\n</ol>\n<p>systemctl 指令管理的服务在 <code>usr/lib/systemd/system</code> 查看</p>\n<ol start=\"2\">\n<li>systemctl设置服务自启动状态<ol>\n<li><code>systemctl list-unit-files [|grep 服务名]</code> 查看服务开机启动状态，grep可以进行过滤</li>\n<li><code>systemctl enable 服务名</code> 设置服务开机启动</li>\n<li><code>systemctl disable 服务名</code> 关闭服务开机启动</li>\n<li><code>systemctl is-enable 服务名</code> 查询某个服务是否是自启动的</li>\n</ol>\n</li>\n<li><code>ls -l /usr/lib/systemd/system/ | more</code>：显示systemctl管理的服务名称。</li>\n<li><code>systemctl list-unit-files | grep firewalld</code>：查看防火墙开启还是关闭</li>\n</ol>\n</li>\n</ol>\n<p><strong>firewalld</strong></p>\n<ol>\n<li><code>firewall-cmd --permanent --add-port=端口号/协议</code> 打开端口</li>\n<li><code>firewall-cmd --permanent --remove-port=端口号/协议</code> 打开端口</li>\n<li><code>firewall-cmd --reload</code>  重新载入，才能生效</li>\n<li><code>firewall-cmd --query-port=端口号/协议</code> 查询端口是否开放</li>\n</ol>\n<h3 id=\"动态监控进程\"><a href=\"#动态监控进程\" class=\"headerlink\" title=\"动态监控进程\"></a>动态监控进程</h3><p><code>top</code>与<code>ps</code>命令很相似，他们都用来显示正在执行的进程</p>\n<p>不同：top在执行一段时间可以更新正在运行的进程</p>\n<p><code>top [选项]</code></p>\n<p><code>-d 秒数</code> 指定top命令每个几秒更新，默认是3秒</p>\n<p><code>-i</code> 使top不显示任何闲置或者僵死进程</p>\n<p><code>-p</code> 通过指定监控进程ID来监控某个进程的状态</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>P</td>\n<td>以CPU使用率排序，默认就是此项</td>\n</tr>\n<tr>\n<td>M</td>\n<td>以内存使用率排序</td>\n</tr>\n<tr>\n<td>N</td>\n<td>以PID排序</td>\n</tr>\n<tr>\n<td>q</td>\n<td>退出top</td>\n</tr>\n<tr>\n<td>u + 用户名</td>\n<td>监视特定用户</td>\n</tr>\n<tr>\n<td>k</td>\n<td>终止指定的进程</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"监控网络状态\"><a href=\"#监控网络状态\" class=\"headerlink\" title=\"监控网络状态\"></a>监控网络状态</h3><p><code>netstat [选项]</code> 查看系统网络情况</p>\n<p><code>-an</code> 按一定的顺序排序输出</p>\n<p><code>-p</code> 显示哪个进程在调用</p>\n","categories":[{"name":"Linux","path":"api/categories/Linux.json"},{"name":"基础","path":"api/categories/基础.json"}],"tags":[{"name":"Linux","path":"api/tags/Linux.json"}]}