{"title":"位图","slug":"位图","date":"2022-06-09T07:48:52.000Z","updated":"2022-07-11T13:10:18.135Z","comments":true,"path":"api/articles/位图.json","realPath":null,"excerpt":null,"covers":["/article/9386/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AF%E5%88%A4%E6%83%85%E5%86%B5.jpg"],"cover":"/images/theme/coverphoto/位图.jpg","content":"<h2 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h2><p>位图是通过将数组下标与应用中的一些值关联映射，数组中该下标所指定的位置上的元素可以用来标识应用中值的情况（是否存在或者数目 或者计数等），位图数组中每个元素在内存中占用1位，所以可以节省存储空间。位图是一种非常简洁快速的数据结构，它能同时使存储空间和速度最优化。</p>\n<blockquote>\n<p>有 1 千万个整数，整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？</p>\n</blockquote>\n<blockquote>\n<p>可以使用一种比较“特殊”的散列表，那就是位图。</p>\n<p>申请一个大小为 1 亿、数据类型为布尔类型（true 或者 false）的数组。<br>将这 1 千万个整数作为数组下标，将对应的数组值设置成 true。比如，整数 5 对应下标为 5 的数组值设置为 true，也就是 array[5]=true。</p>\n<p>查询某个整数 K 是否在这 1 千万个整数中的时候，只需要将对应的数组值 array[K]取出来，看是否等于 true。如果等于 true，那说明 1 千万整数中包含这个整数 K；相反，就表示不包含这个整数 K。</p>\n</blockquote>\n<p>很多语言中提供的布尔类型，大小是 1 个字节的，并不能节省太多内存空间。实际上，表示 true 和 false 两个值，只需要用一个二进制位（bit）就可以了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BitMap</span> </span>&#123; <span class=\"hljs-comment\">// Java中char类型占16bit，也即是2个字节</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">char</span>[] bytes;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> nbits;<br>  <br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BitMap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> nbits)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.nbits = nbits;<br>    <span class=\"hljs-keyword\">this</span>.bytes = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">char</span>[nbits/<span class=\"hljs-number\">16</span>+<span class=\"hljs-number\">1</span>];<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">set</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (k &gt; nbits) <span class=\"hljs-keyword\">return</span>;<br>    <span class=\"hljs-keyword\">int</span> byteIndex = k / <span class=\"hljs-number\">16</span>;<br>    <span class=\"hljs-keyword\">int</span> bitIndex = k % <span class=\"hljs-number\">16</span>;<br>    bytes[byteIndex] |= (<span class=\"hljs-number\">1</span> &lt;&lt; bitIndex);<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (k &gt; nbits) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    <span class=\"hljs-keyword\">int</span> byteIndex = k / <span class=\"hljs-number\">16</span>;<br>    <span class=\"hljs-keyword\">int</span> bitIndex = k % <span class=\"hljs-number\">16</span>;<br>    <span class=\"hljs-keyword\">return</span> (bytes[byteIndex] &amp; (<span class=\"hljs-number\">1</span> &lt;&lt; bitIndex)) != <span class=\"hljs-number\">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>散列表是存储已有数据，而位图存储的是范围</p>\n<blockquote>\n<p>比如有1、1000、1000000 ，散列表只需要存储三次，而位图首先需要1000000位才可以存储</p>\n<p><strong>问题：</strong></p>\n<p>如果数字的范围很大，数字范围不是 1 到 1 亿，而是 1 到 10 亿，那位图的大小就是 10 亿个二进制位，消耗内存就很大</p>\n<p><strong>解决方法：布隆过滤器</strong></p>\n</blockquote>\n<h3 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h3><p>对位图这种数据结构的一种改进</p>\n<blockquote>\n<p>数据个数是 1 千万，数据的范围是 1 到 10 亿</p>\n<p><strong>布隆过滤器</strong>的做法是，仍然使用一个 1 亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这 1 到 1 亿范围内。</p>\n<p>比如把哈希函数设计成 f(x)=x%n。其中，x 表示数字，n 表示位图的大小（1 亿），也就是，对数字跟位图的大小进行取模求余。</p>\n<p><strong>问题：</strong>哈希函数会存在冲突</p>\n</blockquote>\n<p>一个哈希函数可能会存在冲突，用多个哈希函数一块儿定位一个数据</p>\n<p><strong>布隆过滤器</strong></p>\n<ol>\n<li>使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值分别记作 X<sub>1</sub>，X<sub>2</sub>，X<sub>3</sub>，…，X<sub>k</sub></li>\n<li>把这 K 个数字作为位图中的下标，将对应的 BitMap[X<sub>1</sub>]，BitMap[X<sub>2</sub>]，BitMap[X<sub>3</sub>]，…，BitMap[X<sub>k</sub>]都设置成 true</li>\n<li>用 K 个二进制位，来表示一个数字的存在。当查询某个数字是否存在的时候，用同样的 K 个哈希函数，对这个数字求哈希值，分别得到 Y<sub>1</sub>，Y<sub>2</sub>，Y<sub>3</sub>，…，Y<sub>k</sub>。</li>\n<li>看这 K 个哈希值，对应位图中的数值是否都为 true，如果都是 true，则说明，这个数字存在，如果有其中任意一个不为 true，那就说明这个数字不存在。</li>\n</ol>\n<blockquote>\n<p><strong>问题：容易误判</strong></p>\n<img src=\"/article/9386/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AF%E5%88%A4%E6%83%85%E5%86%B5.jpg\" class title=\"布隆过滤器误判情况\">\n</blockquote>\n<p>尽管布隆过滤器会存在误判，但是，这并不影响它发挥大作用。</p>\n<blockquote>\n<p><strong>布隆过滤器与散列表</strong></p>\n<p>布隆过滤器用多个哈希函数对同一个网页链接进行处理，CPU 只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是 CPU 密集型的。而在散列表的处理方式中，需要读取散列值相同（散列冲突）的多个网页链接，分别跟待判重的网页链接，进行字符串匹配。这个操作涉及很多内存数据的读取，所以是内存密集型的。</p>\n<p>CPU 计算可能是要比内存访问更快速的，所以，理论上讲，布隆过滤器的判重方式，更加快速。</p>\n</blockquote>\n","more":"<h2 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h2><p>位图是通过将数组下标与应用中的一些值关联映射，数组中该下标所指定的位置上的元素可以用来标识应用中值的情况（是否存在或者数目 或者计数等），位图数组中每个元素在内存中占用1位，所以可以节省存储空间。位图是一种非常简洁快速的数据结构，它能同时使存储空间和速度最优化。</p>\n<blockquote>\n<p>有 1 千万个整数，整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？</p>\n</blockquote>\n<blockquote>\n<p>可以使用一种比较“特殊”的散列表，那就是位图。</p>\n<p>申请一个大小为 1 亿、数据类型为布尔类型（true 或者 false）的数组。<br>将这 1 千万个整数作为数组下标，将对应的数组值设置成 true。比如，整数 5 对应下标为 5 的数组值设置为 true，也就是 array[5]=true。</p>\n<p>查询某个整数 K 是否在这 1 千万个整数中的时候，只需要将对应的数组值 array[K]取出来，看是否等于 true。如果等于 true，那说明 1 千万整数中包含这个整数 K；相反，就表示不包含这个整数 K。</p>\n</blockquote>\n<p>很多语言中提供的布尔类型，大小是 1 个字节的，并不能节省太多内存空间。实际上，表示 true 和 false 两个值，只需要用一个二进制位（bit）就可以了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BitMap</span> </span>&#123; <span class=\"hljs-comment\">// Java中char类型占16bit，也即是2个字节</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">char</span>[] bytes;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> nbits;<br>  <br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BitMap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> nbits)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.nbits = nbits;<br>    <span class=\"hljs-keyword\">this</span>.bytes = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">char</span>[nbits/<span class=\"hljs-number\">16</span>+<span class=\"hljs-number\">1</span>];<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">set</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (k &gt; nbits) <span class=\"hljs-keyword\">return</span>;<br>    <span class=\"hljs-keyword\">int</span> byteIndex = k / <span class=\"hljs-number\">16</span>;<br>    <span class=\"hljs-keyword\">int</span> bitIndex = k % <span class=\"hljs-number\">16</span>;<br>    bytes[byteIndex] |= (<span class=\"hljs-number\">1</span> &lt;&lt; bitIndex);<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (k &gt; nbits) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    <span class=\"hljs-keyword\">int</span> byteIndex = k / <span class=\"hljs-number\">16</span>;<br>    <span class=\"hljs-keyword\">int</span> bitIndex = k % <span class=\"hljs-number\">16</span>;<br>    <span class=\"hljs-keyword\">return</span> (bytes[byteIndex] &amp; (<span class=\"hljs-number\">1</span> &lt;&lt; bitIndex)) != <span class=\"hljs-number\">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>散列表是存储已有数据，而位图存储的是范围</p>\n<blockquote>\n<p>比如有1、1000、1000000 ，散列表只需要存储三次，而位图首先需要1000000位才可以存储</p>\n<p><strong>问题：</strong></p>\n<p>如果数字的范围很大，数字范围不是 1 到 1 亿，而是 1 到 10 亿，那位图的大小就是 10 亿个二进制位，消耗内存就很大</p>\n<p><strong>解决方法：布隆过滤器</strong></p>\n</blockquote>\n<h3 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h3><p>对位图这种数据结构的一种改进</p>\n<blockquote>\n<p>数据个数是 1 千万，数据的范围是 1 到 10 亿</p>\n<p><strong>布隆过滤器</strong>的做法是，仍然使用一个 1 亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这 1 到 1 亿范围内。</p>\n<p>比如把哈希函数设计成 f(x)=x%n。其中，x 表示数字，n 表示位图的大小（1 亿），也就是，对数字跟位图的大小进行取模求余。</p>\n<p><strong>问题：</strong>哈希函数会存在冲突</p>\n</blockquote>\n<p>一个哈希函数可能会存在冲突，用多个哈希函数一块儿定位一个数据</p>\n<p><strong>布隆过滤器</strong></p>\n<ol>\n<li>使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值分别记作 X<sub>1</sub>，X<sub>2</sub>，X<sub>3</sub>，…，X<sub>k</sub></li>\n<li>把这 K 个数字作为位图中的下标，将对应的 BitMap[X<sub>1</sub>]，BitMap[X<sub>2</sub>]，BitMap[X<sub>3</sub>]，…，BitMap[X<sub>k</sub>]都设置成 true</li>\n<li>用 K 个二进制位，来表示一个数字的存在。当查询某个数字是否存在的时候，用同样的 K 个哈希函数，对这个数字求哈希值，分别得到 Y<sub>1</sub>，Y<sub>2</sub>，Y<sub>3</sub>，…，Y<sub>k</sub>。</li>\n<li>看这 K 个哈希值，对应位图中的数值是否都为 true，如果都是 true，则说明，这个数字存在，如果有其中任意一个不为 true，那就说明这个数字不存在。</li>\n</ol>\n<blockquote>\n<p><strong>问题：容易误判</strong></p>\n<img src=\"/article/9386/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AF%E5%88%A4%E6%83%85%E5%86%B5.jpg\" class title=\"布隆过滤器误判情况\">\n</blockquote>\n<p>尽管布隆过滤器会存在误判，但是，这并不影响它发挥大作用。</p>\n<blockquote>\n<p><strong>布隆过滤器与散列表</strong></p>\n<p>布隆过滤器用多个哈希函数对同一个网页链接进行处理，CPU 只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是 CPU 密集型的。而在散列表的处理方式中，需要读取散列值相同（散列冲突）的多个网页链接，分别跟待判重的网页链接，进行字符串匹配。这个操作涉及很多内存数据的读取，所以是内存密集型的。</p>\n<p>CPU 计算可能是要比内存访问更快速的，所以，理论上讲，布隆过滤器的判重方式，更加快速。</p>\n</blockquote>\n","categories":[{"name":"数据结构与算法","path":"api/categories/数据结构与算法.json"},{"name":"位图","path":"api/categories/位图.json"}],"tags":[{"name":"数据结构与算法,位图","path":"api/tags/数据结构与算法,位图.json"}]}