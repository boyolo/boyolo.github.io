{"title":"Java：梦开始的地方","slug":"Java：梦开始的地方","date":"2021-12-10T02:39:44.000Z","updated":"2021-12-30T03:30:25.283Z","comments":true,"path":"api/articles/Java：梦开始的地方.json","realPath":null,"excerpt":null,"covers":["/article/33685/image-20211210124950047-9111795.png","/article/33685/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png","/article/33685/%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98.png","/article/33685/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%A8%A0%E5%AF%86%E7%9F%A9%E9%98%B5.png","/article/33685/java-extends.png","/article/33685/Java%E5%A4%9A%E6%80%81.jpg"],"cover":"/images/theme/coverphoto/Java基础封面.jpg","content":"<blockquote>\n<p>What language is thine, o sea?</p>\n<p>The language of eternal question.</p>\n<p>What language is thy answer, o sky?</p>\n<p>The language of eternal silence.</p>\n</blockquote>\n<blockquote>\n<p>记性越来越差！能怎么办！</p>\n<p>做个博客记录记录吧～</p>\n<p>虽然整个java相关都快学完了，但总是觉得看了后面忘了前面，所以决定写个博客，正好感觉之前基础学的感觉不扎实，那就把容易忘记的东西复习一遍吧，准备明年的实习，在实习之前把所有的java相关再来一次～</p>\n<p>永不放弃！</p>\n</blockquote>\n<img src=\"/article/33685/image-20211210124950047-9111795.png\" class=\"slug\">\n<h2 id=\"编译型语言和解释型语言的区别\"><a href=\"#编译型语言和解释型语言的区别\" class=\"headerlink\" title=\"编译型语言和解释型语言的区别\"></a>编译型语言和解释型语言的区别</h2><img src=\"/article/33685/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png\" class=\"slug\">\n<h3 id=\"解释性语言和编译型语言的优缺点\"><a href=\"#解释性语言和编译型语言的优缺点\" class=\"headerlink\" title=\"解释性语言和编译型语言的优缺点\"></a><strong>解释性语言和编译型语言</strong>的优缺点</h3><p><a href=\"https://blog.csdn.net/xwx_100/article/details/83212067\">原文链接</a> <a href=\"本文为CSDN博主「xwx_100」的原创文章，遵循CC4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\">版权声明</a></p>\n<p><strong>编译型语言</strong></p>\n<ul>\n<li>编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%；</li>\n<li>编译型程序比解释型程序消耗的内存更少；</li>\n<li>不利的一面——编译器比解释器要难写得多；</li>\n<li>编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置；</li>\n<li>可执行的编译型代码要比相同的解释型代码大许多。例如C/C++的.exe文件要比同样功能的Java的.class文件大很多；</li>\n<li>编译型程序是面向特定平台的因而是平台依赖的；</li>\n<li>编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的）；</li>\n<li>由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。</li>\n</ul>\n<p><strong>解释型语言</strong></p>\n<ul>\n<li>解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的；</li>\n<li>另一个优势是解释器比编译器容易实现；</li>\n<li>解释型语言最大的优势之一是其平台独立性</li>\n<li>解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的；</li>\n<li>中间语言代码的大小比编译型可执行代码小很多；</li>\n<li>平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素；</li>\n<li>解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存；</li>\n<li>由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多；</li>\n<li>解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>原理</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>编译型语言</td>\n<td>通过专门的编译器，将所有源代码一次性转换成特定平台（Windows、Linux 等）执行的机器码（以可执行文件的形式存在）。</td>\n<td>编译一次后，脱离了编译器也可以运行，并且运行效率高。</td>\n<td>可移植性差，不够灵活。</td>\n</tr>\n<tr>\n<td>解释型语言</td>\n<td>由专门的解释器，根据需要将部分源代码临时转换成特定平台的机器码。</td>\n<td>跨平台性好，通过不同的解释器，将相同的源代码解释成不同平台下的机器码。</td>\n<td>一边执行一边转换，效率很低。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Java注释\"><a href=\"#Java注释\" class=\"headerlink\" title=\"Java注释\"></a>Java注释</h2><ol>\n<li><p>单行注释</p>\n<p>以双斜杠“//”标识，只能注释一行内容，用在注释信息内容少的地方；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//这是单行注释</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>多行注释</p>\n<p>包含在“/<em>”和“</em>/”之间，能注释很多行的内容。为了可读性比较好，一般首行和尾行不写注释信息（这样也比较美观好看）；</p>\n<ul>\n<li>多行注释可以嵌套单行注释，但是不能嵌套多行注释和文档注释。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">这是多行注释</span><br><span class=\"hljs-comment\">这里也是</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>文档注释</p>\n<p>包含在“/*<em>”和“</em>/”之间，也能注释多行内容，一般用在类、方法和变量上面，用来描述其作用；</p>\n<p>注释后，鼠标放在类和变量上面会自动显示出我们注释的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">*这是文档注释</span><br><span class=\"hljs-comment\">*<span class=\"hljs-doctag\">@Description</span> HelloWorld</span><br><span class=\"hljs-comment\">*这是有功能的注释</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Java命名规范\"><a href=\"#Java命名规范\" class=\"headerlink\" title=\"Java命名规范\"></a>Java命名规范</h2><ul>\n<li><p><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</p>\n</li>\n<li><p><strong>常量：</strong>大写字母和下划线组成。例如<strong>MAX_VALUE</strong></p>\n</li>\n<li><p><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong>。</p>\n</li>\n<li><p><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。例如 <strong>myFirstJavaMethod</strong>。</p>\n<p><strong>类成员变量、局部变量</strong>同样遵守这个规则</p>\n<p><strong>方法名</strong>不使用连接符,但下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如 <code>testPop_emptyStack</code></p>\n</li>\n<li><p><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</p>\n</li>\n<li><p><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</p>\n</li>\n<li><p><strong>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符：</strong></p>\n<ul>\n<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>\n<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>\n<li>关键字不能用作标识符</li>\n<li>标识符是大小写敏感的</li>\n<li>合法标识符举例：age、$salary、_value、__1_value</li>\n<li>非法标识符举例：123abc、-salary</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p><a href=\"https://www.runoob.com/java/java-tutorial.html\">部分内容引用菜鸟教程</a></p>\n<blockquote>\n<p>程序员就要知道CV ， CV完了千万记得理解呀！！！</p>\n</blockquote>\n<p>Java是一种强类型语言</p>\n<ul>\n<li>要求变量的使用要严格符合规定，所有变量都必须先定义以后才能使用</li>\n</ul>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p><strong>byte：</strong></p>\n<ul>\n<li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>\n<li>最小值是 <strong>-128（-2^7）</strong>；</li>\n<li>最大值是 <strong>127（2^7-1）</strong>；</li>\n<li>默认值是 <strong>0</strong>；</li>\n<li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li>\n</ul>\n<p><strong>short：</strong></p>\n<ul>\n<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>\n<li>最小值是 <strong>-32768（-2^15）</strong>；</li>\n<li>最大值是 <strong>32767（2^15 - 1）</strong>；</li>\n<li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>\n<li>默认值是 <strong>0</strong>；</li>\n</ul>\n<p><strong>int：</strong></p>\n<ul>\n<li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li>\n<li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li>\n<li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li>\n<li>一般地整型变量默认为 int 类型；</li>\n<li>默认值是 <strong>0</strong> ；</li>\n</ul>\n<p><strong>long：</strong></p>\n<ul>\n<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>\n<li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li>\n<li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li>\n<li>这种类型主要使用在需要比较大整数的系统上；</li>\n<li>默认值是 <strong>0L</strong>；</li>\n<li>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li>\n</ul>\n<p><strong>float：</strong></p>\n<ul>\n<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>\n<li>float 在储存大型浮点数组的时候可节省内存空间；</li>\n<li>默认值是 <strong>0.0f</strong>；</li>\n<li>浮点数不能用来表示精确的值，如货币；</li>\n<li>最好完全避免使用浮点数进行比较；</li>\n</ul>\n<p><strong>double：</strong></p>\n<ul>\n<li><p>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；</p>\n</li>\n<li><p>浮点数的默认类型为 double 类型；</p>\n</li>\n<li><p>double类型同样不能表示精确的值，如货币；</p>\n</li>\n<li><p>默认值是 <strong>0.0d</strong>；</p>\n</li>\n<li><p>最好完全避免使用浮点数进行比较；</p>\n</li>\n<li><p>例子：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">double</span>   d<span class=\"hljs-number\">1</span>  = <span class=\"hljs-number\">7</span>D ;<br><span class=\"hljs-attribute\">double</span>   d<span class=\"hljs-number\">2</span>  = <span class=\"hljs-number\">7</span>.; <br><span class=\"hljs-attribute\">double</span>   d<span class=\"hljs-number\">3</span>  =  <span class=\"hljs-number\">8</span>.<span class=\"hljs-number\">0</span>; <br><span class=\"hljs-attribute\">double</span>   d<span class=\"hljs-number\">4</span>  =  <span class=\"hljs-number\">8</span>.D; <br><span class=\"hljs-attribute\">double</span>   d<span class=\"hljs-number\">5</span>  =  <span class=\"hljs-number\">12</span>.<span class=\"hljs-number\">9867</span>; <br></code></pre></td></tr></table></figure>\n<p>7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。</p>\n</li>\n</ul>\n<p><strong>boolean：</strong></p>\n<ul>\n<li>boolean数据类型表示一位的信息；</li>\n<li>只有两个取值：true 和 false；</li>\n<li>这种类型只作为一种标志来记录 true/false 情况；</li>\n<li>默认值是 <strong>false</strong>；</li>\n</ul>\n<p><strong>char：</strong></p>\n<ul>\n<li>char 类型是一个单一的 16 位 Unicode 字符；</li>\n<li>最小值是 <strong>\\u0000</strong>（十进制等效值为 0）；</li>\n<li>最大值是 <strong>\\uffff</strong>（即为 65535）；</li>\n<li>char 数据类型可以储存任何字符；</li>\n</ul>\n<h4 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h4><p><strong>自动类型转换：整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">低  ------------------------------------&gt;  高<br><br><span class=\"hljs-keyword\">byte</span>,<span class=\"hljs-keyword\">short</span>,<span class=\"hljs-keyword\">char</span>—&gt; <span class=\"hljs-keyword\">int</span> —&gt; <span class=\"hljs-keyword\">long</span>—&gt; <span class=\"hljs-keyword\">float</span> —&gt; <span class=\"hljs-keyword\">double</span> <br></code></pre></td></tr></table></figure>\n<p>数据类型转换必须满足如下规则：</p>\n<ul>\n<li>不能对boolean类型进行类型转换</li>\n<li>不能把对象类型转换成不相关类的对象</li>\n<li>在把容量大的类型转换为容量小的类型时必须使用<strong>强制类型转换</strong></li>\n<li>转换过程中可能导致溢出或损失精度</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ZiDongLeiZhuan</span></span>&#123;<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>    \t\t<span class=\"hljs-keyword\">char</span> c1=<span class=\"hljs-string\">&#x27;a&#x27;</span>;<span class=\"hljs-comment\">//定义一个char类型</span><br>        <span class=\"hljs-keyword\">int</span> i1 = c1;<span class=\"hljs-comment\">//char自动类型转换为int</span><br>        System.out.println(<span class=\"hljs-string\">&quot;char自动类型转换为int后的值等于&quot;</span>+i1);<br>        <span class=\"hljs-keyword\">char</span> c2 = <span class=\"hljs-string\">&#x27;A&#x27;</span>;<span class=\"hljs-comment\">//定义一个char类型</span><br>        <span class=\"hljs-keyword\">int</span> i2 = c2+<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//char 类型和 int 类型计算</span><br>        System.out.println(<span class=\"hljs-string\">&quot;char类型和int计算后的值等于&quot;</span>+i2);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">char自动类型转换为int后的值等于97</span><br><span class=\"hljs-comment\">char类型和int计算后的值等于66</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p><strong>强制类型转换：</strong></p>\n<ul>\n<li>条件是转换的数据类型必须是兼容的</li>\n<li>格式：(type)value type是要强制类型转换后的数据类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QiangZhiZhuanHuan</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>        <span class=\"hljs-keyword\">int</span> i1 = <span class=\"hljs-number\">123</span>;<br>        <span class=\"hljs-keyword\">byte</span> b = (<span class=\"hljs-keyword\">byte</span>)i1;<span class=\"hljs-comment\">//强制类型转换为byte</span><br>        System.out.println(<span class=\"hljs-string\">&quot;int强制类型转换为byte后的值等于&quot;</span>+b);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">int强制类型转换为byte后的值等于123</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p><strong>隐含强制类型转换：</strong></p>\n<ul>\n<li>整数的默认类型是 int</li>\n<li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f</li>\n</ul>\n<hr>\n<h3 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h3><ul>\n<li>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时候被指定为一个特定的类型，声明之后不能改变。</li>\n<li>引用数据类型包括：类（对象）、接口、数组</li>\n<li>所有引用类型默认值都是null.</li>\n<li>一个引用变量可以用于引用任何与之兼容的类型。</li>\n</ul>\n<img src=\"/article/33685/%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98.png\" class title=\"引用数据类型内存\">\n<hr>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上</li>\n<li>引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。</li>\n</ul>\n<h2 id=\"Java变量类型\"><a href=\"#Java变量类型\" class=\"headerlink\" title=\"Java变量类型\"></a>Java变量类型</h2><p><strong>Java语言支持的变量类型有：</strong></p>\n<ul>\n<li>类变量：独立于方法之外的变量，用 static 修饰。</li>\n<li>实例变量：独立于方法之外的变量，不过没有 static 修饰。 </li>\n<li>局部变量：类的方法中的变量。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Variable</span></span>&#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> allClicks=<span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">// 类变量</span><br>    String str=<span class=\"hljs-string\">&quot;hello world&quot;</span>;  <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">method</span><span class=\"hljs-params\">()</span></span>&#123;<br>        <span class=\"hljs-keyword\">int</span> i =<span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 局部变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><ul>\n<li>局部变量声明在方法、构造方法或者语句块中</li>\n<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，<strong>当它们执行完成后，变量将会被销毁</strong></li>\n<li>访问修饰符不能用于局部变量(<strong>default</strong> <strong>private</strong>  <strong>public</strong> <strong>protected</strong>)</li>\n<li>局部变量只在声明它的方法、构造方法或者语句块中可见</li>\n<li>局部变量是在<strong>栈</strong>上分配的</li>\n<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span></span>&#123; <br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pupAge</span><span class=\"hljs-params\">()</span></span>&#123;<br>      <span class=\"hljs-keyword\">int</span> age = <span class=\"hljs-number\">0</span>;<br>      age = age + <span class=\"hljs-number\">7</span>;<br>      System.out.println(<span class=\"hljs-string\">&quot;小狗的年龄是: &quot;</span> + age);<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>      Test test = <span class=\"hljs-keyword\">new</span> Test();<br>      test.pupAge();<br>   &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">小狗的年龄是: 7</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h3><ul>\n<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外</li>\n<li>当一个对象被实例化之后，每个实例变量的值就跟着确定</li>\n<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁</li>\n<li>实例变量的值应该<strong>至少</strong>被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息</li>\n<li>实例变量可以声明在使用前或者使用后</li>\n<li>访问修饰符可以修饰实例变量(<strong>default</strong> <strong>private</strong>  <strong>public</strong> <strong>protected</strong>)</li>\n<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见</li>\n<li>实例变量具有默认值。<strong>数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。</strong>变量的值可以在声明时指定，也可以在构造方法中指定</li>\n<li><strong>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.*;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Employee</span></span>&#123;<br>   <span class=\"hljs-comment\">// 这个实例变量对子类可见</span><br>   <span class=\"hljs-keyword\">public</span> String name;<br>   <span class=\"hljs-comment\">// 私有变量，仅在该类可见</span><br>   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">double</span> salary;<br>   <span class=\"hljs-comment\">//在构造器中对name赋值</span><br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Employee</span> <span class=\"hljs-params\">(String empName)</span></span>&#123;<br>      name = empName;<br>   &#125;<br>   <span class=\"hljs-comment\">//设定salary的值</span><br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setSalary</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> empSal)</span></span>&#123;<br>      salary = empSal;<br>   &#125;  <br>   <span class=\"hljs-comment\">// 打印信息</span><br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">printEmp</span><span class=\"hljs-params\">()</span></span>&#123;<br>      System.out.println(<span class=\"hljs-string\">&quot;名字 : &quot;</span> + name );<br>      System.out.println(<span class=\"hljs-string\">&quot;薪水 : &quot;</span> + salary);<br>   &#125;<br> <br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>      Employee empOne = <span class=\"hljs-keyword\">new</span> Employee(<span class=\"hljs-string\">&quot;BOBO&quot;</span>);<br>      empOne.setSalary(<span class=\"hljs-number\">1000.0</span>);<br>      empOne.printEmp();<br>   &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">$ javac Employee.java </span><br><span class=\"hljs-comment\">$ java Employee</span><br><span class=\"hljs-comment\">名字 : BOBO</span><br><span class=\"hljs-comment\">薪水 : 1000.0</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"类变量\"><a href=\"#类变量\" class=\"headerlink\" title=\"类变量\"></a>类变量</h3><p><a href=\"#静态变量\"><code>点击跳转静态变量</code></a></p>\n<ul>\n<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外</li>\n<li>无论一个类创建了多少个对象，<strong>类只拥有类变量的一份拷贝</strong></li>\n<li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变</li>\n<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li>\n<li><strong>静态变量在第一次被访问时创建，在程序结束时销毁</strong></li>\n<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型</li>\n<li>默认值和实例变量相似。<strong>数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。</strong>变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化</li>\n<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问</li>\n<li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.*;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Employee</span> </span>&#123;<br>    <span class=\"hljs-comment\">//salary是静态的私有变量</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">double</span> salary;<br>    <span class=\"hljs-comment\">// DEPARTMENT是一个常量</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String DEPARTMENT = <span class=\"hljs-string\">&quot;开发人员&quot;</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>    salary = <span class=\"hljs-number\">10000</span>;<br>        System.out.println(DEPARTMENT+<span class=\"hljs-string\">&quot;平均工资:&quot;</span>+salary);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">开发人员平均工资:10000.0</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Java方法\"><a href=\"#Java方法\" class=\"headerlink\" title=\"Java方法\"></a>Java方法</h2><h4 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h4><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>\n<p>方法的可变参数的声明如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">typeName... parameterName<br></code></pre></td></tr></table></figure>\n<p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p>\n<p>一个方法中只能指定一个可变参数，它<strong>必须是方法的最后一个参数</strong>。任何普通的参数必须在它之前声明。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VarargsDemo</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String args[])</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 调用可变参数的方法</span><br>        printMax(<span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">56.5</span>);<br>        printMax(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">double</span>[]&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;);<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">printMax</span><span class=\"hljs-params\">( <span class=\"hljs-keyword\">double</span>... numbers)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (numbers.length == <span class=\"hljs-number\">0</span>) &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;No argument passed&quot;</span>);<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">double</span> result = numbers[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;  numbers.length; i++)&#123;<br>            <span class=\"hljs-keyword\">if</span> (numbers[i] &gt;  result) &#123;<br>                result = numbers[i];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class=\"hljs-string\">&quot;The max value is &quot;</span> + result);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">The max value is 56.5</span><br><span class=\"hljs-comment\">The max value is 3.0</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><ul>\n<li>构造方法也称为构造器</li>\n<li><strong>当一个对象被创建时候，构造方法用来初始化该对象</strong></li>\n<li><strong>构造方法和它所在类的名字相同</strong>，但构造方法没有返回值，也不能写void</li>\n<li>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象</li>\n<li>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)</li>\n<li>一旦你定义了自己的构造方法，默认构造方法就会失效</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 一个简单的构造函数</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyClass</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span> x;<br> <br>  <span class=\"hljs-comment\">// 以下是构造函数</span><br>  MyClass() &#123;<br>    x = <span class=\"hljs-number\">10</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Java-静态类、静态方法和静态变量\"><a href=\"#Java-静态类、静态方法和静态变量\" class=\"headerlink\" title=\"Java 静态类、静态方法和静态变量\"></a>Java 静态类、静态方法和静态变量</h2><p><strong>static</strong> 是Java中的一个关键字，我们不能声明普通外层类或者包为静态的</p>\n<h3 id=\"静态变量\"><a href=\"#静态变量\" class=\"headerlink\" title=\"静态变量\"></a>静态变量</h3><p><a href=\"#类变量\"><code>点击跳转类变量</code></a></p>\n<p>静态变量即类变量，静态变量是属于类的，而不是属于类创建的对象或实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//静态变量的例子</span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> count;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String str;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String DB_USER = <span class=\"hljs-string\">&quot;myuser&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><ul>\n<li>类似于静态变量</li>\n<li>静态方法也属于类，不属于实例</li>\n<li>静态方法只能访问类的静态变量，或调用类的静态方法</li>\n<li>通常静态方法作为工具方法，被其它类使用，而不需要创建类的实例</li>\n<li>通常java程序的开始就是一个<code>main()</code>方法，它就是个静态方法</li>\n<li>静态方法只会在第一次执行一次</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//静态方法的例子</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setCount</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> count)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(count &gt; <span class=\"hljs-number\">0</span>)<br>    StaticExample.count = count;<br>&#125;<br><br><span class=\"hljs-comment\">//静态工具方法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">addInts</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span>...js)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum=i;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> x : js) sum+=x;<br>    <span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"静态块\"><a href=\"#静态块\" class=\"headerlink\" title=\"静态块\"></a>静态块</h3><ul>\n<li>静态块就是类加载器加载对象时，要执行的一组语句</li>\n<li>用于初始化静态变量</li>\n<li>通常用于类加载的时候创建静态资源</li>\n<li>我们在静态块中不能访问非静态变量</li>\n<li>我们可以在一个类中有多个静态块，尽管这么做没什么意义</li>\n<li>静态块只会在类加载到内存中的时候执行一次</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span>&#123;<br>    <span class=\"hljs-comment\">//在类被加载的时候用于初始化资源</span><br>    System.out.println(<span class=\"hljs-string\">&quot;StaticExample static block&quot;</span>);<br>    <span class=\"hljs-comment\">//仅能访问静态变量和静态方法</span><br>    str=<span class=\"hljs-string\">&quot;Test&quot;</span>;<br>    setCount(<span class=\"hljs-number\">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"静态类\"><a href=\"#静态类\" class=\"headerlink\" title=\"静态类\"></a>静态类</h3><p><a href=\"#内部类\"><code>点击跳转内部类</code></a></p>\n<ul>\n<li>我们对嵌套类使用static关键字</li>\n<li>static不能用于最外层的类</li>\n<li>静态的嵌套类和其它外层的类别无二致，嵌套只是为了方便打包</li>\n</ul>\n<h3 id=\"静态导入包\"><a href=\"#静态导入包\" class=\"headerlink\" title=\"静态导入包\"></a>静态导入包</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> java.lang.Math.random;<br></code></pre></td></tr></table></figure>\n<p>可以在类中直接使用random方法</p>\n<h2 id=\"Java数组\"><a href=\"#Java数组\" class=\"headerlink\" title=\"Java数组\"></a>Java数组</h2><h3 id=\"普通数组\"><a href=\"#普通数组\" class=\"headerlink\" title=\"普通数组\"></a>普通数组</h3><p>数组是<strong>相同类型数据</strong>的<strong>有序集合</strong></p>\n<ul>\n<li>长度确定，一旦被创建，大小就不可以被改变</li>\n<li>其元素必须是相同类型，不允许出现混合类型</li>\n<li>数组中的元素可以是任何数据类型</li>\n<li>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量</li>\n</ul>\n<p>初始化数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 首选的方法</span><br>dataType[] arrayRefVar;  <br><span class=\"hljs-comment\">//或</span><br><span class=\"hljs-comment\">// 效果相同，但不是首选方法 </span><br><span class=\"hljs-comment\">// 来自 C/C++ 语言 </span><br>dataType arrayRefVar[];  <br></code></pre></td></tr></table></figure>\n<p>初始化多维数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//直接为每一维分配空间</span><br><span class=\"hljs-comment\">//type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数</span><br>type[][] typeName = <span class=\"hljs-keyword\">new</span> type[typeLength1][typeLength2];<br><span class=\"hljs-comment\">//或</span><br><span class=\"hljs-comment\">//为最高维分配引用空间</span><br><span class=\"hljs-comment\">//再为其每个数组元素单独分配空间</span><br>String[][] s = <span class=\"hljs-keyword\">new</span> String[<span class=\"hljs-number\">2</span>][];<br>s[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-keyword\">new</span> String[<span class=\"hljs-number\">2</span>];<br>s[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-keyword\">new</span> String[<span class=\"hljs-number\">3</span>];<br>s[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">&quot;Good&quot;</span>);<br>s[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">&quot;Luck&quot;</span>);<br>s[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">&quot;to&quot;</span>);<br>s[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">&quot;you&quot;</span>);<br>s[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">&quot;!&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"稀疏数组\"><a href=\"#稀疏数组\" class=\"headerlink\" title=\"稀疏数组\"></a>稀疏数组</h3><p>稀疏矩阵（英语：sparse matrix）指的是在数值分析中绝大多数数值为零的矩阵。反之，如果大部分元素都非零，则这个矩阵是稠密的(Dense)。</p>\n<img src=\"/article/33685/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%A8%A0%E5%AF%86%E7%9F%A9%E9%98%B5.png\" class title=\"稀疏矩阵与稠密矩阵\">\n<blockquote>\n<p> 上图中左边就是一个稀疏矩阵，可以看到包含了很多 0 元素，右边是稠密的矩阵，大部分元素不是 0</p>\n</blockquote>\n<p>转化为稀疏数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[][] sparseMatrix(<span class=\"hljs-keyword\">int</span>[][] array)&#123;<br>  <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; array.length; i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; array[i].length)&#123;<br>      <span class=\"hljs-keyword\">if</span>(array[i][j] != <span class=\"hljs-number\">0</span>)<br>        sum++;<br>    &#125;<br>  &#125;<br>  System.out.println(<span class=\"hljs-string\">&quot;有效值的个数：&quot;</span> + sum);<br>  <br>  <span class=\"hljs-comment\">//创建一个稀疏数组</span><br>  <span class=\"hljs-keyword\">int</span>[][] sparse = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[sum + <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>];<br>  sparse[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = array.length;<br>  sparse[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] = array[<span class=\"hljs-number\">0</span>].length;<br>  sparse[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">2</span>] = sum;<br>  <br>  <span class=\"hljs-comment\">//遍历二维数组，将非零的值，存放数组中</span><br>  <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span> ; i &lt; array.length ; i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span> ; j &lt; array[<span class=\"hljs-number\">0</span>].length ; j++)&#123;<br>      <span class=\"hljs-keyword\">if</span>(array[i][j] != <span class=\"hljs-number\">0</span>)&#123;<br>        count++;<br>        sparse[count][<span class=\"hljs-number\">0</span>] = i;<br>        sparse[count][<span class=\"hljs-number\">1</span>] = j;<br>        sparse[count][<span class=\"hljs-number\">2</span>] = array[i][j];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> sparse;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Java类\"><a href=\"#Java类\" class=\"headerlink\" title=\"Java类\"></a>Java类</h2><h3 id=\"Java-Scanner-类\"><a href=\"#Java-Scanner-类\" class=\"headerlink\" title=\"Java Scanner 类\"></a>Java Scanner 类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Scanner s = <span class=\"hljs-keyword\">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure>\n<p>通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据.</p>\n<p><strong>next方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner; <br> <br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ScannerDemo</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        Scanner scan = <span class=\"hljs-keyword\">new</span> Scanner(System.in);<br>        <span class=\"hljs-comment\">// 从键盘接收数据</span><br> <br>        <span class=\"hljs-comment\">// next方式接收字符串</span><br>        System.out.println(<span class=\"hljs-string\">&quot;next方式接收：&quot;</span>);<br>        <span class=\"hljs-comment\">// 判断是否还有输入</span><br>        <span class=\"hljs-keyword\">if</span> (scan.hasNext()) &#123;<br>            String str1 = scan.next();<br>            System.out.println(<span class=\"hljs-string\">&quot;输入的数据为：&quot;</span> + str1);<br>        &#125;<br>        scan.close();<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">$ javac ScannerDemo.java</span><br><span class=\"hljs-comment\">$ java ScannerDemo</span><br><span class=\"hljs-comment\">next方式接收：</span><br><span class=\"hljs-comment\">bobo com</span><br><span class=\"hljs-comment\">输入的数据为：bobo</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p><strong>nextLine 方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br> <br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ScannerDemo</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        Scanner scan = <span class=\"hljs-keyword\">new</span> Scanner(System.in);<br>        <span class=\"hljs-comment\">// 从键盘接收数据</span><br> <br>        <span class=\"hljs-comment\">// nextLine方式接收字符串</span><br>        System.out.println(<span class=\"hljs-string\">&quot;nextLine方式接收：&quot;</span>);<br>        <span class=\"hljs-comment\">// 判断是否还有输入</span><br>        <span class=\"hljs-keyword\">if</span> (scan.hasNextLine()) &#123;<br>            String str2 = scan.nextLine();<br>            System.out.println(<span class=\"hljs-string\">&quot;输入的数据为：&quot;</span> + str2);<br>        &#125;<br>        scan.close();<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">$ javac ScannerDemo.java</span><br><span class=\"hljs-comment\">$ java ScannerDemo</span><br><span class=\"hljs-comment\">nextLine方式接收：</span><br><span class=\"hljs-comment\">bobo com</span><br><span class=\"hljs-comment\">输入的数据为：bobo com</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p><strong>next() 与 nextLine() 区别</strong></p>\n<p>next():</p>\n<ul>\n<li>一定要读取到有效字符后才可以结束输入。</li>\n<li>对输入有效字符之前遇到的空白，next() 方法会自动将其去。</li>\n<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 </li>\n<li>next() 不能得到带有空格的字符串。</li>\n</ul>\n<p>nextLine()： </p>\n<ul>\n<li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 </li>\n<li>可以获得空白。</li>\n</ul>\n<blockquote>\n<p><strong>相较于 hasnext()</strong>，针对int、float等其他基本数据类型，还有scan.hasNextInt()、hasNextFloat()等方法，返回布尔值；</p>\n</blockquote>\n<blockquote>\n<p> <strong>相较于 nextLine()</strong>，针对int、float等其他基本数据类型，还有、scan.nextInt()、scan.nextFloat()等方法，返回输出类型值；</p>\n</blockquote>\n<h3 id=\"Java-Arrays-类\"><a href=\"#Java-Arrays-类\" class=\"headerlink\" title=\"Java Arrays 类\"></a>Java Arrays 类</h3><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>\n<p>具有以下功能：</p>\n<ul>\n<li>给数组赋值：通过 fill 方法 ,将指定的值分配给数组的每个元素</li>\n<li>对数组排序：通过 sort 方法,按升序</li>\n<li>比较数组：通过 equals 方法比较数组中元素值是否相等</li>\n<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作</li>\n</ul>\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p>\n<p><strong>成员内部类</strong></p>\n<p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> </span>&#123;<br>    <span class=\"hljs-keyword\">double</span> radius = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Circle</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> radius)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>.radius = radius;<br>    &#125;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Draw</span> </span>&#123;     <span class=\"hljs-comment\">//内部类</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawSahpe</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;drawshape&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以<strong>无条件访问外部类的所有成员属性和成员方法</strong>（包括private成员和静态成员）。</p>\n<hr>\n<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">外部类.<span class=\"hljs-keyword\">this</span>.成员变量<br>外部类.<span class=\"hljs-keyword\">this</span>.成员方法<br></code></pre></td></tr></table></figure>\n<hr>\n<p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> </span>&#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">double</span> radius = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Circle</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> radius)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>.radius = radius;<br>        getDrawInstance().drawSahpe();   <span class=\"hljs-comment\">//必须先创建成员内部类的对象，再进行访问</span><br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Draw <span class=\"hljs-title\">getDrawInstance</span><span class=\"hljs-params\">()</span> </span>&#123;   <span class=\"hljs-comment\">//创建成员内部类的对象</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Draw();<br>    &#125;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Draw</span> </span>&#123;     <span class=\"hljs-comment\">//内部类</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawSahpe</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            System.out.println(radius);  <span class=\"hljs-comment\">//外部类的private成员</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span>  </span>&#123;<br>        <span class=\"hljs-comment\">//第一种方式：</span><br>        Outter outter = <span class=\"hljs-keyword\">new</span> Outter();<br>        Outter.Inner inner = outter.<span class=\"hljs-function\">new <span class=\"hljs-title\">Inner</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">//必须通过Outter对象来创建</span><br>         <br>        <span class=\"hljs-comment\">//第二种方式：</span><br>        Outter.Inner inner1 = outter.getInnerInstance();<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Outter</span> </span>&#123;<br>    <span class=\"hljs-keyword\">private</span> Inner inner = <span class=\"hljs-keyword\">null</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Outter</span><span class=\"hljs-params\">()</span> </span>&#123;<br>         <br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Inner <span class=\"hljs-title\">getInnerInstance</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(inner == <span class=\"hljs-keyword\">null</span>)<br>            inner = <span class=\"hljs-keyword\">new</span> Inner();<br>        <span class=\"hljs-keyword\">return</span> inner;<br>    &#125;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Inner</span> </span>&#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Inner</span><span class=\"hljs-params\">()</span> </span>&#123;    <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。</p>\n<hr>\n<p><strong>局部内部类</strong></p>\n<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">People</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">People</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Man</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Man</span><span class=\"hljs-params\">()</span></span>&#123;    <br>    &#125;   <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> People <span class=\"hljs-title\">getWoman</span><span class=\"hljs-params\">()</span></span>&#123;<br>        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Woman</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">People</span></span>&#123;   <span class=\"hljs-comment\">//局部内部类</span><br>            <span class=\"hljs-keyword\">int</span> age =<span class=\"hljs-number\">0</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Woman();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>注意</strong>: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p>\n<hr>\n<p><strong>匿名内部类</strong></p>\n<p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。</p>\n<p>下面是一段匿名内部类的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">new</span> OnClickListener() &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>下面这段代码是一段 Android 事件监听代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">scan_bt.setOnClickListener(<span class=\"hljs-keyword\">new</span> OnClickListener() &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;);<br> <br>history_bt.setOnClickListener(<span class=\"hljs-keyword\">new</span> OnClickListener() &#123;<br>     <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>这就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。</p>\n<hr>\n<p><strong>静态内部类</strong></p>\n<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</p>\n<p>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span>  </span>&#123;<br>        Outter.Inner inner = <span class=\"hljs-keyword\">new</span> Outter.Inner();<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Outter</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Outter</span><span class=\"hljs-params\">()</span> </span>&#123;<br>         <br>    &#125;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Inner</span> </span>&#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Inner</span><span class=\"hljs-params\">()</span> </span>&#123;<br>             <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<p><strong>静态内部类与内部类的区别</strong></p>\n<p><strong>内部类</strong></p>\n<ul>\n<li>内部类拥有普通类的所有特性，也拥有类成员变量的特性 </li>\n<li>内部类可以访问其外部类的成员变量，属性，方法，其它内部类</li>\n</ul>\n<p><strong>静态内部类</strong></p>\n<ul>\n<li>只有内部类才能声明为static，也可以说是静态内部类 </li>\n<li>只有静态内部类才能拥有静态成员，普通内部类只能定义普通成员 </li>\n<li>静态类跟静态方法一样，只能访问其外部类的静态成员 </li>\n<li>如果在外部类的静态方法中访问内部类，这时候只能访问静态内部类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 外部类，不能声明为 static</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OuterClass</span> </span>&#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> ab = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> sab = <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 普通内部类</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NormalInnerClass</span> </span>&#123;<br>        <span class=\"hljs-comment\">// private static int age = 22;</span><br>        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> age = <span class=\"hljs-number\">22</span>; <span class=\"hljs-comment\">// 不能声明为static</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">NormalInnerClass</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            <span class=\"hljs-comment\">// 可以访问外部类静态与非静态成员</span><br>            System.out.println(ab);<br>            System.out.println(sab);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 静态内部类</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StaticInnerClass</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 定义静态与非静态成员都是可以的</span><br>        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> age = <span class=\"hljs-number\">22</span>;<br>        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> age2 = <span class=\"hljs-number\">22</span>;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">echo</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            <span class=\"hljs-comment\">// System.out.println(ab);</span><br>            System.out.println(sab);<span class=\"hljs-comment\">// 只能访问外部类的静态成员</span><br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>\n<hr>\n<p><strong>练习</strong></p>\n<p>1.根据注释填写(1)，(2)，(3)处的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>           <span class=\"hljs-comment\">// 初始化Bean1</span><br>           (<span class=\"hljs-number\">1</span>)<br>           bean1.I++;<br>           <span class=\"hljs-comment\">// 初始化Bean2</span><br>           (<span class=\"hljs-number\">2</span>)<br>           bean2.J++;<br>           <span class=\"hljs-comment\">//初始化Bean3</span><br>           (<span class=\"hljs-number\">3</span>)<br>           bean3.k++;<br>    &#125;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bean1</span></span>&#123;<br>           <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> I = <span class=\"hljs-number\">0</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bean2</span></span>&#123;<br>           <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> J = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bean</span></span>&#123;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bean3</span></span>&#123;<br>           <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>\n<p>创建静态内部类对象的一般形式为：<code>外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</code></p>\n<p>创建成员内部类对象的一般形式为： <code>外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</code></p>\n<p>因此，（1），（2），（3）处的代码分别为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Test test = <span class=\"hljs-keyword\">new</span> Test();    <br>Test.Bean1 bean1 = test.n<span class=\"hljs-function\">ew <span class=\"hljs-title\">Bean1</span><span class=\"hljs-params\">()</span></span>;<br>---------------------------------------<br>Test.Bean2 b2 = <span class=\"hljs-keyword\">new</span> Test.Bean2();<br>Bean bean = <span class=\"hljs-keyword\">new</span> Bean();     <br>---------------------------------------<br>Bean.Bean3 bean3 =  bean.n<span class=\"hljs-function\">ew <span class=\"hljs-title\">Bean3</span><span class=\"hljs-params\">()</span></span>;<br></code></pre></td></tr></table></figure>\n<p>2.下面这段代码的输出结果是什么？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span>  </span>&#123;<br>        Outter outter = <span class=\"hljs-keyword\">new</span> Outter();<br>        outter.n<span class=\"hljs-function\">ew <span class=\"hljs-title\">Inner</span><span class=\"hljs-params\">()</span>.<span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span></span>;<br>    &#125;<br>&#125;<br> <br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Outter</span></span><br><span class=\"hljs-class\"></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Inner</span> </span>&#123;<br>        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">3</span>;<br>            System.out.println(<span class=\"hljs-string\">&quot;局部变量：&quot;</span> + a);<br>            System.out.println(<span class=\"hljs-string\">&quot;内部类变量：&quot;</span> + <span class=\"hljs-keyword\">this</span>.a);<br>            System.out.println(<span class=\"hljs-string\">&quot;外部类变量：&quot;</span> + Outter.<span class=\"hljs-keyword\">this</span>.a);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">局部变量：3</span><br><span class=\"hljs-comment\">内部类变量：2</span><br><span class=\"hljs-comment\">外部类变量：1</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<hr>\n<p>关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>\n<ul>\n<li>成员内部类的引用方式必须为 Outter.Inner </li>\n<li>构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WithInner</span> </span>&#123;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Inner</span></span>&#123;<br>         <br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">InheritInner</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WithInner</span>.<span class=\"hljs-title\">Inner</span> </span>&#123;<br>      <br>    <span class=\"hljs-comment\">// InheritInner() 是不能通过编译的，一定要加上形参</span><br>    InheritInner(WithInner wi) &#123;<br>        wi.<span class=\"hljs-keyword\">super</span>(); <span class=\"hljs-comment\">//必须有这句调用</span><br>    &#125;<br>  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        WithInner wi = <span class=\"hljs-keyword\">new</span> WithInner();<br>        InheritInner obj = <span class=\"hljs-keyword\">new</span> InheritInner(wi);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样</p>\n</li>\n<li><p>抽象方法必须在抽象类中</p>\n<ul>\n<li><p>如果一个类包含抽象方法，那么该类必须是抽象类</p>\n</li>\n<li><p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类</p>\n</li>\n</ul>\n</li>\n<li><p>由于抽象类不能实例化对象，所以<strong>抽象类必须被继承</strong>，才能被使用</p>\n</li>\n<li><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法</p>\n</li>\n<li><p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而<strong>一个类却可以实现多个<a href=\"#接口\"><code>接口</code></a></strong>,接口可以多继承</p>\n</li>\n<li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p>\n</li>\n<li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能</p>\n</li>\n<li><p><strong>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</strong></p>\n</li>\n<li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</p>\n</li>\n</ul>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><ul>\n<li>普通类：只有具体实现</li>\n<li>抽象类：具体实现和规范（抽象方法）都有</li>\n<li>接口：只有规范！</li>\n</ul>\n<ol>\n<li>是抽象方法的集合，接口通常以interface来声明；</li>\n<li>一个类通过继承接口的方式，从而来继承接口的抽象方法；</li>\n<li>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法；</li>\n<li>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法；</li>\n<li>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类；</li>\n<li>在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或<strong>是被绑定在一个以此接口实现的对象</strong>。</li>\n</ol>\n<p><strong>接口与类相似点</strong></p>\n<ul>\n<li>一个接口可以有多个方法；</li>\n<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名；</li>\n<li>接口的字节码文件保存在 .class 结尾的文件中；</li>\n<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>\n</ul>\n<p><strong>接口与类的区别</strong></p>\n<ul>\n<li>接口不能用于实例化对象；</li>\n<li>接口没有构造方法；</li>\n<li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法；</li>\n<li>接口不能包含成员变量，除了 static 和 final 变量；</li>\n<li>接口不是被类继承了，而是要被类实现；</li>\n<li>接口支持多继承。</li>\n</ul>\n<p><strong>接口特性</strong></p>\n<ul>\n<li>接口与接口中的每一个方法都是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）；</li>\n<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）；</li>\n<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法；</li>\n<li>接口中的方法都是公有的。</li>\n</ul>\n<p><strong>抽象类和接口的区别</strong></p>\n<ul>\n<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行；</li>\n<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的；</li>\n<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法；</li>\n<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> 接口名称 [<span class=\"hljs-keyword\">extends</span> 其他的接口名] </span>&#123;<br>  <span class=\"hljs-comment\">// 声明变量</span><br>  <span class=\"hljs-comment\">// 抽象方法</span><br>&#125;<br><br>...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...<br></code></pre></td></tr></table></figure>\n<p><strong>重写接口中声明的方法时，需要注意以下规则</strong></p>\n<ul>\n<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常；</li>\n<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型；</li>\n<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法；</li>\n</ul>\n<p><strong>在实现接口的时候，也要注意一些规则</strong></p>\n<ul>\n<li>一个类可以同时实现多个接口；</li>\n<li>一个类只能继承一个类，但是能实现多个接口；</li>\n<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>\n</ul>\n<p><strong>标记接口</strong></p>\n<ul>\n<li>最常用的继承接口是没有包含任何方法的接口；</li>\n<li>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情；</li>\n<li>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</li>\n</ul>\n<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> java.util;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">EventListener</span></span><br><span class=\"hljs-class\"></span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>\n<ul>\n<li><p>建立一个公共的父接口：</p>\n<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>\n</li>\n<li><p>向一个类添加数据类型：</p>\n<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>\n</li>\n</ul>\n<h2 id=\"值传递-引用传递\"><a href=\"#值传递-引用传递\" class=\"headerlink\" title=\"值传递-引用传递\"></a>值传递-引用传递</h2><p><strong>值传递</strong></p>\n<p>实参传递给形参的是值 形参和实参在内存上是两个<strong>独立</strong>的变量,对<strong>形参做任何修改不会影响实参</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Demo</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> b =<span class=\"hljs-number\">20</span>;<br>        change(b);<span class=\"hljs-comment\">// 实参 实际上的参数</span><br>        System.out.println(b);<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;<span class=\"hljs-comment\">//形参 形式上的参数</span><br>        a=<span class=\"hljs-number\">100</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>引用传递</strong></p>\n<p>实参传递给形参的是参数对于堆内存上的引用地址，实参和形参在内存上指向了同一块区域，对<strong>形参的修改会影响实参</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Demo</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> [] a=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;;<br>        System.out.println(a[<span class=\"hljs-number\">0</span>]);<br>        change(a);<br>        System.out.println(a[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br>   <span class=\"hljs-comment\">//实参和形参在内存上指向了同一块区域</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a )</span></span>&#123;<br>        a[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">100</span>;  <span class=\"hljs-comment\">//形参的修改会影响实参</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Java三大特性\"><a href=\"#Java三大特性\" class=\"headerlink\" title=\"Java三大特性\"></a>Java三大特性</h2><h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><blockquote>\n<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法;</p>\n<p>要访问该类的代码和数据，必须通过严格的接口控制;</p>\n</blockquote>\n<p><strong>优点</strong></p>\n<ul>\n<li>良好的封装能够减少耦合；</li>\n<li>类内部的结构可以自由修改；</li>\n<li>可以对成员变量进行更精确的控制；</li>\n<li>隐藏信息，实现细节。</li>\n</ul>\n<p><strong>实现步骤</strong></p>\n<ol>\n<li>修改属性的可见性来限制对属性的访问（一般限制为private）</li>\n<li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问（get、set方法）</li>\n<li>采用 <strong>this</strong> 关键字是为了解决实例变量和局部变量之间发生的同名的冲突</li>\n</ol>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><blockquote>\n<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类;</p>\n<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//类的继承格式</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 父类 </span>&#123;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 子类 <span class=\"hljs-keyword\">extends</span> 父类 </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/33685/java-extends.png\" class title=\"java-extends\">\n<p><strong>特性</strong></p>\n<ul>\n<li>子类拥有父类<strong>非 private </strong>的属性、方法；</li>\n<li>final修饰的类，不能被继承；</li>\n<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展；</li>\n<li>子类可以用自己的方式实现父类的方法；</li>\n<li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li>\n<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li>\n</ul>\n<p><strong>关键字</strong></p>\n<p><strong>super 与 this 关键字</strong></p>\n<p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类</p>\n<p>this关键字：指向自己的引用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;animal : eat&quot;</span>);<br>  &#125;<br>&#125;<br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;dog : eat&quot;</span>);<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eatTest</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.eat();   <span class=\"hljs-comment\">// this 调用自己的方法</span><br>    <span class=\"hljs-keyword\">super</span>.eat();  <span class=\"hljs-comment\">// super 调用父类方法</span><br>  &#125;<br>&#125;<br> <br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>    Animal a = <span class=\"hljs-keyword\">new</span> Animal();<br>    a.eat();<br>    Dog d = <span class=\"hljs-keyword\">new</span> Dog();<br>    d.eatTest();<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">输出结果为：</span><br><span class=\"hljs-comment\">animal : eat</span><br><span class=\"hljs-comment\">dog : eat</span><br><span class=\"hljs-comment\">animal : eat</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>super调用父类的构造方法，必须在构造方法的第一个</li>\n<li>super必须只能出现在子类的方法或者构造方法中</li>\n<li>super和this不能同时调用构造方法</li>\n</ul>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><blockquote>\n<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>\n<p>多态就是同一个接口，使用不同的实例而执行不同操作.</p>\n</blockquote>\n<p><strong>注意</strong></p>\n<ul>\n<li>对象能执行哪些方法，主要看左边的类型，和右边关系不大</li>\n<li>父类可以指向子类，但是不能调用子类<strong>独有</strong>的方法</li>\n<li></li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>消除类型之间的耦合关系</li>\n<li>可替换性</li>\n<li>可扩充性</li>\n<li>接口性</li>\n<li>灵活性</li>\n<li>简化性</li>\n</ul>\n<p><strong>多态存在的三个必要条件</strong></p>\n<ul>\n<li>继承</li>\n<li>重写 <a href=\"#Java重写与重载\"><code>点击跳转重写与重载</code></a></li>\n<li>父类引用指向子类对象：<strong>Parent p = new Child();</strong></li>\n</ul>\n<img src=\"/article/33685/Java%E5%A4%9A%E6%80%81.jpg\" class title=\"Java多态\">\n<p><em>简单的多态实例</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>      show(<span class=\"hljs-keyword\">new</span> Cat());  <span class=\"hljs-comment\">// 以 Cat 对象调用 show 方法</span><br>      show(<span class=\"hljs-keyword\">new</span> Dog());  <span class=\"hljs-comment\">// 以 Dog 对象调用 show 方法</span><br>                <br>      Animal a = <span class=\"hljs-keyword\">new</span> Cat();  <span class=\"hljs-comment\">// 向上转型  </span><br>      a.eat();               <span class=\"hljs-comment\">// 调用的是 Cat 的 eat</span><br>      Cat c = (Cat)a;        <span class=\"hljs-comment\">// 向下转型  </span><br>      c.work();        <span class=\"hljs-comment\">// 调用的是 Cat 的 work</span><br>  &#125;  <br>            <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(Animal a)</span>  </span>&#123;<br>      a.eat();  <br>        <span class=\"hljs-comment\">// 类型判断</span><br>        <span class=\"hljs-keyword\">if</span> (a <span class=\"hljs-keyword\">instanceof</span> Cat)  &#123;  <span class=\"hljs-comment\">// 猫做的事情 </span><br>            Cat c = (Cat)a;  <br>            c.work();  <br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (a <span class=\"hljs-keyword\">instanceof</span> Dog) &#123; <span class=\"hljs-comment\">// 狗做的事情 </span><br>            Dog c = (Dog)a;  <br>            c.work();  <br>        &#125;  <br>    &#125;  <br>&#125;<br> <br><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span></span>;  <br>&#125;  <br>  <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span> </span>&#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;吃鱼&quot;</span>);  <br>    &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">work</span><span class=\"hljs-params\">()</span> </span>&#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;抓老鼠&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span> </span>&#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;吃骨头&quot;</span>);  <br>    &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">work</span><span class=\"hljs-params\">()</span> </span>&#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;看家&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>\n<p><em>稍微复杂的多态</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Employee</span> </span>&#123;<br>   <span class=\"hljs-keyword\">private</span> String name;<br>   <span class=\"hljs-keyword\">private</span> String address;<br>   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Employee</span><span class=\"hljs-params\">(String name, String address, <span class=\"hljs-keyword\">int</span> number)</span> </span>&#123;<br>      System.out.println(<span class=\"hljs-string\">&quot;Employee 构造函数&quot;</span>);<br>      <span class=\"hljs-keyword\">this</span>.name = name;<br>      <span class=\"hljs-keyword\">this</span>.address = address;<br>      <span class=\"hljs-keyword\">this</span>.number = number;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mailCheck</span><span class=\"hljs-params\">()</span> </span>&#123;<br>      System.out.println(<span class=\"hljs-string\">&quot;邮寄支票给： &quot;</span> + <span class=\"hljs-keyword\">this</span>.name<br>       + <span class=\"hljs-string\">&quot; &quot;</span> + <span class=\"hljs-keyword\">this</span>.address);<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> name + <span class=\"hljs-string\">&quot; &quot;</span> + address + <span class=\"hljs-string\">&quot; &quot;</span> + number;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span> </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> name;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getAddress</span><span class=\"hljs-params\">()</span> </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> address;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setAddress</span><span class=\"hljs-params\">(String newAddress)</span> </span>&#123;<br>      address = newAddress;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getNumber</span><span class=\"hljs-params\">()</span> </span>&#123;<br>     <span class=\"hljs-keyword\">return</span> number;<br>   &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Salary</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Employee</span></span><br><span class=\"hljs-class\"></span>&#123;<br>   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">double</span> salary; <span class=\"hljs-comment\">// 全年工资</span><br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Salary</span><span class=\"hljs-params\">(String name, String address, <span class=\"hljs-keyword\">int</span> number, <span class=\"hljs-keyword\">double</span> salary)</span> </span>&#123;<br>       <span class=\"hljs-keyword\">super</span>(name, address, number);<br>       setSalary(salary);<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mailCheck</span><span class=\"hljs-params\">()</span> </span>&#123;<br>       System.out.println(<span class=\"hljs-string\">&quot;Salary 类的 mailCheck 方法 &quot;</span>);<br>       System.out.println(<span class=\"hljs-string\">&quot;邮寄支票给：&quot;</span> + getName()<br>       + <span class=\"hljs-string\">&quot; ，工资为：&quot;</span> + salary);<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getSalary</span><span class=\"hljs-params\">()</span> </span>&#123;<br>       <span class=\"hljs-keyword\">return</span> salary;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setSalary</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> newSalary)</span> </span>&#123;<br>       <span class=\"hljs-keyword\">if</span>(newSalary &gt;= <span class=\"hljs-number\">0.0</span>) &#123;<br>          salary = newSalary;<br>       &#125;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">computePay</span><span class=\"hljs-params\">()</span> </span>&#123;<br>      System.out.println(<span class=\"hljs-string\">&quot;计算工资，付给：&quot;</span> + getName());<br>      <span class=\"hljs-keyword\">return</span> salary/<span class=\"hljs-number\">52</span>;<br>   &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VirtualDemo</span> </span>&#123;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String [] args)</span> </span>&#123;<br>      Salary s = <span class=\"hljs-keyword\">new</span> Salary(<span class=\"hljs-string\">&quot;员工 A&quot;</span>, <span class=\"hljs-string\">&quot;北京&quot;</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3600.00</span>);<br>      Employee e = <span class=\"hljs-keyword\">new</span> Salary(<span class=\"hljs-string\">&quot;员工 B&quot;</span>, <span class=\"hljs-string\">&quot;上海&quot;</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2400.00</span>);<br>      System.out.println(<span class=\"hljs-string\">&quot;使用 Salary 的引用调用 mailCheck -- &quot;</span>);<br>      s.mailCheck();<br>      System.out.println(<span class=\"hljs-string\">&quot;\\n使用 Employee 的引用调用 mailCheck--&quot;</span>);<br>      e.mailCheck();<br>    &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Employee 构造函数</span><br><span class=\"hljs-comment\">Employee 构造函数</span><br><span class=\"hljs-comment\">使用 Salary 的引用调用 mailCheck -- </span><br><span class=\"hljs-comment\">Salary 类的 mailCheck 方法 </span><br><span class=\"hljs-comment\">邮寄支票给：员工 A ，工资为：3600.0</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">使用 Employee 的引用调用 mailCheck--</span><br><span class=\"hljs-comment\">Salary 类的 mailCheck 方法 </span><br><span class=\"hljs-comment\">邮寄支票给：员工 B ，工资为：2400.0</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p>理解：</p>\n<ol>\n<li>主函数初始化<code>new Salary</code>时，因为继承关系，所以执行父类构造方法，初始化两次，执行了两次</li>\n<li><code>s.mailCheck();</code>正常调用类Salary中的方法</li>\n<li><code>e.mailCheck();</code> 父类的引用指向了子类的对象，因为类Salary重写了父类的方法，所以，调用类Salary中的方法</li>\n</ol>\n<h2 id=\"Java重写与重载\"><a href=\"#Java重写与重载\" class=\"headerlink\" title=\"Java重写与重载\"></a>Java重写与重载</h2><h2 id=\"⚠️⚠️⚠️注意细节⚠️⚠️⚠️\"><a href=\"#⚠️⚠️⚠️注意细节⚠️⚠️⚠️\" class=\"headerlink\" title=\"⚠️⚠️⚠️注意细节⚠️⚠️⚠️\"></a>⚠️⚠️⚠️注意细节⚠️⚠️⚠️</h2><h3 id=\"类中方法加载顺序\"><a href=\"#类中方法加载顺序\" class=\"headerlink\" title=\"类中方法加载顺序\"></a>类中方法加载顺序</h3><p>静态代码块——匿名代码块——构造方法</p>\n<h3 id=\"字符输出问题\"><a href=\"#字符输出问题\" class=\"headerlink\" title=\"字符输出问题\"></a>字符输出问题</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ZiDongLeiZhuan</span></span>&#123;<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>    \t\t<span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">10</span>;<br>      \t<span class=\"hljs-keyword\">int</span> b = <span class=\"hljs-number\">20</span>;<br>      \tSystem.out.println(<span class=\"hljs-string\">&quot;&quot;</span> + a + b);<br>      \tSystem.out.println(a + b + <span class=\"hljs-string\">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">1020</span><br><span class=\"hljs-comment\">30</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p>如果<code>&quot;&quot;</code>在前 则字符串拼接！如果<code>&quot;&quot;</code>在后 则为数学相加！</p>\n<h3 id=\"关于调用静态方法与非静态方法的区别\"><a href=\"#关于调用静态方法与非静态方法的区别\" class=\"headerlink\" title=\"关于调用静态方法与非静态方法的区别\"></a><strong>关于调用静态方法与非静态方法的区别</strong></h3><p><strong>例子</strong>：注意看 输出是不同的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//主启动类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span></span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>    <span class=\"hljs-comment\">//调用静态方法时 方法的调用只和  左边  定义的数据类型有关</span><br>    A a = <span class=\"hljs-keyword\">new</span> A();<br>    a.test();<br>    <span class=\"hljs-comment\">//父类的引用指向了子类</span><br>    B b = <span class=\"hljs-keyword\">new</span> A();  <span class=\"hljs-comment\">//子类重写了父类的方法  只和非静态方法有关</span><br>    b.test()<br>  &#125;<br>&#125;  <br><br>---非静态方法---<br><span class=\"hljs-comment\">//父类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;B=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">//子类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">B</span></span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;A=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">A=&gt;test()</span><br><span class=\"hljs-comment\">A=&gt;test()</span><br><span class=\"hljs-comment\">*/</span><br>---静态方法---<br><span class=\"hljs-comment\">//父类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;B=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">//子类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">B</span></span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span>  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;A=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">A=&gt;test()</span><br><span class=\"hljs-comment\">B=&gt;test()</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p><strong>理解</strong>：</p>\n<p>静态方法属于类的方法，非静态方法属于对象的方法</p>\n<p>调用静态方法时，b调用了B类的方法，因为b是B类定义的，只和 <code>**左边**</code>  定义的数据类型有关</p>\n<p>调用非静态方法时，b调用的是对象的方法，而b这个对象是用A类new的，所以调用A的方法</p>\n<h3 id=\"Java程序初始化顺序\"><a href=\"#Java程序初始化顺序\" class=\"headerlink\" title=\"Java程序初始化顺序\"></a>Java程序初始化顺序</h3><ol>\n<li>父类的静态变量</li>\n<li>父类的静态代码块</li>\n<li>子类的静态变量</li>\n<li>子类的静态代码块</li>\n<li>父类的非静态变量</li>\n<li>父类的非静态代码块</li>\n<li>父类的构造方法</li>\n<li>子类的非静态变量</li>\n<li>子类的非静态代码块</li>\n<li>子类的构造方法</li>\n</ol>\n","more":"<blockquote>\n<p>What language is thine, o sea?</p>\n<p>The language of eternal question.</p>\n<p>What language is thy answer, o sky?</p>\n<p>The language of eternal silence.</p>\n</blockquote>\n<blockquote>\n<p>记性越来越差！能怎么办！</p>\n<p>做个博客记录记录吧～</p>\n<p>虽然整个java相关都快学完了，但总是觉得看了后面忘了前面，所以决定写个博客，正好感觉之前基础学的感觉不扎实，那就把容易忘记的东西复习一遍吧，准备明年的实习，在实习之前把所有的java相关再来一次～</p>\n<p>永不放弃！</p>\n</blockquote>\n<img src=\"/article/33685/image-20211210124950047-9111795.png\" class=\"slug\">\n<h2 id=\"编译型语言和解释型语言的区别\"><a href=\"#编译型语言和解释型语言的区别\" class=\"headerlink\" title=\"编译型语言和解释型语言的区别\"></a>编译型语言和解释型语言的区别</h2><img src=\"/article/33685/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png\" class=\"slug\">\n<h3 id=\"解释性语言和编译型语言的优缺点\"><a href=\"#解释性语言和编译型语言的优缺点\" class=\"headerlink\" title=\"解释性语言和编译型语言的优缺点\"></a><strong>解释性语言和编译型语言</strong>的优缺点</h3><p><a href=\"https://blog.csdn.net/xwx_100/article/details/83212067\">原文链接</a> <a href=\"本文为CSDN博主「xwx_100」的原创文章，遵循CC4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\">版权声明</a></p>\n<p><strong>编译型语言</strong></p>\n<ul>\n<li>编译型语言最大的优势之一就是其执行速度。用C/C++编写的程序运行速度要比用Java编写的相同程序快30%-70%；</li>\n<li>编译型程序比解释型程序消耗的内存更少；</li>\n<li>不利的一面——编译器比解释器要难写得多；</li>\n<li>编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置；</li>\n<li>可执行的编译型代码要比相同的解释型代码大许多。例如C/C++的.exe文件要比同样功能的Java的.class文件大很多；</li>\n<li>编译型程序是面向特定平台的因而是平台依赖的；</li>\n<li>编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的）；</li>\n<li>由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。</li>\n</ul>\n<p><strong>解释型语言</strong></p>\n<ul>\n<li>解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的；</li>\n<li>另一个优势是解释器比编译器容易实现；</li>\n<li>解释型语言最大的优势之一是其平台独立性</li>\n<li>解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的；</li>\n<li>中间语言代码的大小比编译型可执行代码小很多；</li>\n<li>平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素；</li>\n<li>解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存；</li>\n<li>由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多；</li>\n<li>解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>原理</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>编译型语言</td>\n<td>通过专门的编译器，将所有源代码一次性转换成特定平台（Windows、Linux 等）执行的机器码（以可执行文件的形式存在）。</td>\n<td>编译一次后，脱离了编译器也可以运行，并且运行效率高。</td>\n<td>可移植性差，不够灵活。</td>\n</tr>\n<tr>\n<td>解释型语言</td>\n<td>由专门的解释器，根据需要将部分源代码临时转换成特定平台的机器码。</td>\n<td>跨平台性好，通过不同的解释器，将相同的源代码解释成不同平台下的机器码。</td>\n<td>一边执行一边转换，效率很低。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Java注释\"><a href=\"#Java注释\" class=\"headerlink\" title=\"Java注释\"></a>Java注释</h2><ol>\n<li><p>单行注释</p>\n<p>以双斜杠“//”标识，只能注释一行内容，用在注释信息内容少的地方；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//这是单行注释</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>多行注释</p>\n<p>包含在“/<em>”和“</em>/”之间，能注释很多行的内容。为了可读性比较好，一般首行和尾行不写注释信息（这样也比较美观好看）；</p>\n<ul>\n<li>多行注释可以嵌套单行注释，但是不能嵌套多行注释和文档注释。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">这是多行注释</span><br><span class=\"hljs-comment\">这里也是</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>文档注释</p>\n<p>包含在“/*<em>”和“</em>/”之间，也能注释多行内容，一般用在类、方法和变量上面，用来描述其作用；</p>\n<p>注释后，鼠标放在类和变量上面会自动显示出我们注释的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">*这是文档注释</span><br><span class=\"hljs-comment\">*<span class=\"hljs-doctag\">@Description</span> HelloWorld</span><br><span class=\"hljs-comment\">*这是有功能的注释</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Java命名规范\"><a href=\"#Java命名规范\" class=\"headerlink\" title=\"Java命名规范\"></a>Java命名规范</h2><ul>\n<li><p><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</p>\n</li>\n<li><p><strong>常量：</strong>大写字母和下划线组成。例如<strong>MAX_VALUE</strong></p>\n</li>\n<li><p><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong>。</p>\n</li>\n<li><p><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。例如 <strong>myFirstJavaMethod</strong>。</p>\n<p><strong>类成员变量、局部变量</strong>同样遵守这个规则</p>\n<p><strong>方法名</strong>不使用连接符,但下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如 <code>testPop_emptyStack</code></p>\n</li>\n<li><p><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</p>\n</li>\n<li><p><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</p>\n</li>\n<li><p><strong>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符：</strong></p>\n<ul>\n<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>\n<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>\n<li>关键字不能用作标识符</li>\n<li>标识符是大小写敏感的</li>\n<li>合法标识符举例：age、$salary、_value、__1_value</li>\n<li>非法标识符举例：123abc、-salary</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p><a href=\"https://www.runoob.com/java/java-tutorial.html\">部分内容引用菜鸟教程</a></p>\n<blockquote>\n<p>程序员就要知道CV ， CV完了千万记得理解呀！！！</p>\n</blockquote>\n<p>Java是一种强类型语言</p>\n<ul>\n<li>要求变量的使用要严格符合规定，所有变量都必须先定义以后才能使用</li>\n</ul>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p><strong>byte：</strong></p>\n<ul>\n<li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>\n<li>最小值是 <strong>-128（-2^7）</strong>；</li>\n<li>最大值是 <strong>127（2^7-1）</strong>；</li>\n<li>默认值是 <strong>0</strong>；</li>\n<li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li>\n</ul>\n<p><strong>short：</strong></p>\n<ul>\n<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>\n<li>最小值是 <strong>-32768（-2^15）</strong>；</li>\n<li>最大值是 <strong>32767（2^15 - 1）</strong>；</li>\n<li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>\n<li>默认值是 <strong>0</strong>；</li>\n</ul>\n<p><strong>int：</strong></p>\n<ul>\n<li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li>\n<li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li>\n<li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li>\n<li>一般地整型变量默认为 int 类型；</li>\n<li>默认值是 <strong>0</strong> ；</li>\n</ul>\n<p><strong>long：</strong></p>\n<ul>\n<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>\n<li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li>\n<li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li>\n<li>这种类型主要使用在需要比较大整数的系统上；</li>\n<li>默认值是 <strong>0L</strong>；</li>\n<li>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li>\n</ul>\n<p><strong>float：</strong></p>\n<ul>\n<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>\n<li>float 在储存大型浮点数组的时候可节省内存空间；</li>\n<li>默认值是 <strong>0.0f</strong>；</li>\n<li>浮点数不能用来表示精确的值，如货币；</li>\n<li>最好完全避免使用浮点数进行比较；</li>\n</ul>\n<p><strong>double：</strong></p>\n<ul>\n<li><p>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；</p>\n</li>\n<li><p>浮点数的默认类型为 double 类型；</p>\n</li>\n<li><p>double类型同样不能表示精确的值，如货币；</p>\n</li>\n<li><p>默认值是 <strong>0.0d</strong>；</p>\n</li>\n<li><p>最好完全避免使用浮点数进行比较；</p>\n</li>\n<li><p>例子：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">double</span>   d<span class=\"hljs-number\">1</span>  = <span class=\"hljs-number\">7</span>D ;<br><span class=\"hljs-attribute\">double</span>   d<span class=\"hljs-number\">2</span>  = <span class=\"hljs-number\">7</span>.; <br><span class=\"hljs-attribute\">double</span>   d<span class=\"hljs-number\">3</span>  =  <span class=\"hljs-number\">8</span>.<span class=\"hljs-number\">0</span>; <br><span class=\"hljs-attribute\">double</span>   d<span class=\"hljs-number\">4</span>  =  <span class=\"hljs-number\">8</span>.D; <br><span class=\"hljs-attribute\">double</span>   d<span class=\"hljs-number\">5</span>  =  <span class=\"hljs-number\">12</span>.<span class=\"hljs-number\">9867</span>; <br></code></pre></td></tr></table></figure>\n<p>7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。</p>\n</li>\n</ul>\n<p><strong>boolean：</strong></p>\n<ul>\n<li>boolean数据类型表示一位的信息；</li>\n<li>只有两个取值：true 和 false；</li>\n<li>这种类型只作为一种标志来记录 true/false 情况；</li>\n<li>默认值是 <strong>false</strong>；</li>\n</ul>\n<p><strong>char：</strong></p>\n<ul>\n<li>char 类型是一个单一的 16 位 Unicode 字符；</li>\n<li>最小值是 <strong>\\u0000</strong>（十进制等效值为 0）；</li>\n<li>最大值是 <strong>\\uffff</strong>（即为 65535）；</li>\n<li>char 数据类型可以储存任何字符；</li>\n</ul>\n<h4 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h4><p><strong>自动类型转换：整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">低  ------------------------------------&gt;  高<br><br><span class=\"hljs-keyword\">byte</span>,<span class=\"hljs-keyword\">short</span>,<span class=\"hljs-keyword\">char</span>—&gt; <span class=\"hljs-keyword\">int</span> —&gt; <span class=\"hljs-keyword\">long</span>—&gt; <span class=\"hljs-keyword\">float</span> —&gt; <span class=\"hljs-keyword\">double</span> <br></code></pre></td></tr></table></figure>\n<p>数据类型转换必须满足如下规则：</p>\n<ul>\n<li>不能对boolean类型进行类型转换</li>\n<li>不能把对象类型转换成不相关类的对象</li>\n<li>在把容量大的类型转换为容量小的类型时必须使用<strong>强制类型转换</strong></li>\n<li>转换过程中可能导致溢出或损失精度</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ZiDongLeiZhuan</span></span>&#123;<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>    \t\t<span class=\"hljs-keyword\">char</span> c1=<span class=\"hljs-string\">&#x27;a&#x27;</span>;<span class=\"hljs-comment\">//定义一个char类型</span><br>        <span class=\"hljs-keyword\">int</span> i1 = c1;<span class=\"hljs-comment\">//char自动类型转换为int</span><br>        System.out.println(<span class=\"hljs-string\">&quot;char自动类型转换为int后的值等于&quot;</span>+i1);<br>        <span class=\"hljs-keyword\">char</span> c2 = <span class=\"hljs-string\">&#x27;A&#x27;</span>;<span class=\"hljs-comment\">//定义一个char类型</span><br>        <span class=\"hljs-keyword\">int</span> i2 = c2+<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//char 类型和 int 类型计算</span><br>        System.out.println(<span class=\"hljs-string\">&quot;char类型和int计算后的值等于&quot;</span>+i2);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">char自动类型转换为int后的值等于97</span><br><span class=\"hljs-comment\">char类型和int计算后的值等于66</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p><strong>强制类型转换：</strong></p>\n<ul>\n<li>条件是转换的数据类型必须是兼容的</li>\n<li>格式：(type)value type是要强制类型转换后的数据类型</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QiangZhiZhuanHuan</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>        <span class=\"hljs-keyword\">int</span> i1 = <span class=\"hljs-number\">123</span>;<br>        <span class=\"hljs-keyword\">byte</span> b = (<span class=\"hljs-keyword\">byte</span>)i1;<span class=\"hljs-comment\">//强制类型转换为byte</span><br>        System.out.println(<span class=\"hljs-string\">&quot;int强制类型转换为byte后的值等于&quot;</span>+b);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">int强制类型转换为byte后的值等于123</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p><strong>隐含强制类型转换：</strong></p>\n<ul>\n<li>整数的默认类型是 int</li>\n<li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f</li>\n</ul>\n<hr>\n<h3 id=\"引用数据类型\"><a href=\"#引用数据类型\" class=\"headerlink\" title=\"引用数据类型\"></a>引用数据类型</h3><ul>\n<li>引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时候被指定为一个特定的类型，声明之后不能改变。</li>\n<li>引用数据类型包括：类（对象）、接口、数组</li>\n<li>所有引用类型默认值都是null.</li>\n<li>一个引用变量可以用于引用任何与之兼容的类型。</li>\n</ul>\n<img src=\"/article/33685/%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98.png\" class title=\"引用数据类型内存\">\n<hr>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><ul>\n<li>基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上</li>\n<li>引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址。</li>\n</ul>\n<h2 id=\"Java变量类型\"><a href=\"#Java变量类型\" class=\"headerlink\" title=\"Java变量类型\"></a>Java变量类型</h2><p><strong>Java语言支持的变量类型有：</strong></p>\n<ul>\n<li>类变量：独立于方法之外的变量，用 static 修饰。</li>\n<li>实例变量：独立于方法之外的变量，不过没有 static 修饰。 </li>\n<li>局部变量：类的方法中的变量。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Variable</span></span>&#123;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> allClicks=<span class=\"hljs-number\">0</span>;    <span class=\"hljs-comment\">// 类变量</span><br>    String str=<span class=\"hljs-string\">&quot;hello world&quot;</span>;  <span class=\"hljs-comment\">// 实例变量</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">method</span><span class=\"hljs-params\">()</span></span>&#123;<br>        <span class=\"hljs-keyword\">int</span> i =<span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 局部变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><ul>\n<li>局部变量声明在方法、构造方法或者语句块中</li>\n<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，<strong>当它们执行完成后，变量将会被销毁</strong></li>\n<li>访问修饰符不能用于局部变量(<strong>default</strong> <strong>private</strong>  <strong>public</strong> <strong>protected</strong>)</li>\n<li>局部变量只在声明它的方法、构造方法或者语句块中可见</li>\n<li>局部变量是在<strong>栈</strong>上分配的</li>\n<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span></span>&#123; <br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pupAge</span><span class=\"hljs-params\">()</span></span>&#123;<br>      <span class=\"hljs-keyword\">int</span> age = <span class=\"hljs-number\">0</span>;<br>      age = age + <span class=\"hljs-number\">7</span>;<br>      System.out.println(<span class=\"hljs-string\">&quot;小狗的年龄是: &quot;</span> + age);<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>      Test test = <span class=\"hljs-keyword\">new</span> Test();<br>      test.pupAge();<br>   &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">小狗的年龄是: 7</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h3><ul>\n<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外</li>\n<li>当一个对象被实例化之后，每个实例变量的值就跟着确定</li>\n<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁</li>\n<li>实例变量的值应该<strong>至少</strong>被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息</li>\n<li>实例变量可以声明在使用前或者使用后</li>\n<li>访问修饰符可以修饰实例变量(<strong>default</strong> <strong>private</strong>  <strong>public</strong> <strong>protected</strong>)</li>\n<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见</li>\n<li>实例变量具有默认值。<strong>数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。</strong>变量的值可以在声明时指定，也可以在构造方法中指定</li>\n<li><strong>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</strong></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.*;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Employee</span></span>&#123;<br>   <span class=\"hljs-comment\">// 这个实例变量对子类可见</span><br>   <span class=\"hljs-keyword\">public</span> String name;<br>   <span class=\"hljs-comment\">// 私有变量，仅在该类可见</span><br>   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">double</span> salary;<br>   <span class=\"hljs-comment\">//在构造器中对name赋值</span><br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Employee</span> <span class=\"hljs-params\">(String empName)</span></span>&#123;<br>      name = empName;<br>   &#125;<br>   <span class=\"hljs-comment\">//设定salary的值</span><br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setSalary</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> empSal)</span></span>&#123;<br>      salary = empSal;<br>   &#125;  <br>   <span class=\"hljs-comment\">// 打印信息</span><br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">printEmp</span><span class=\"hljs-params\">()</span></span>&#123;<br>      System.out.println(<span class=\"hljs-string\">&quot;名字 : &quot;</span> + name );<br>      System.out.println(<span class=\"hljs-string\">&quot;薪水 : &quot;</span> + salary);<br>   &#125;<br> <br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>      Employee empOne = <span class=\"hljs-keyword\">new</span> Employee(<span class=\"hljs-string\">&quot;BOBO&quot;</span>);<br>      empOne.setSalary(<span class=\"hljs-number\">1000.0</span>);<br>      empOne.printEmp();<br>   &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">$ javac Employee.java </span><br><span class=\"hljs-comment\">$ java Employee</span><br><span class=\"hljs-comment\">名字 : BOBO</span><br><span class=\"hljs-comment\">薪水 : 1000.0</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"类变量\"><a href=\"#类变量\" class=\"headerlink\" title=\"类变量\"></a>类变量</h3><p><a href=\"#静态变量\"><code>点击跳转静态变量</code></a></p>\n<ul>\n<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外</li>\n<li>无论一个类创建了多少个对象，<strong>类只拥有类变量的一份拷贝</strong></li>\n<li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变</li>\n<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li>\n<li><strong>静态变量在第一次被访问时创建，在程序结束时销毁</strong></li>\n<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型</li>\n<li>默认值和实例变量相似。<strong>数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。</strong>变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化</li>\n<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问</li>\n<li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.io.*;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Employee</span> </span>&#123;<br>    <span class=\"hljs-comment\">//salary是静态的私有变量</span><br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">double</span> salary;<br>    <span class=\"hljs-comment\">// DEPARTMENT是一个常量</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String DEPARTMENT = <span class=\"hljs-string\">&quot;开发人员&quot;</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>    salary = <span class=\"hljs-number\">10000</span>;<br>        System.out.println(DEPARTMENT+<span class=\"hljs-string\">&quot;平均工资:&quot;</span>+salary);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">开发人员平均工资:10000.0</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Java方法\"><a href=\"#Java方法\" class=\"headerlink\" title=\"Java方法\"></a>Java方法</h2><h4 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h4><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>\n<p>方法的可变参数的声明如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">typeName... parameterName<br></code></pre></td></tr></table></figure>\n<p>在方法声明中，在指定参数类型后加一个省略号(…) 。</p>\n<p>一个方法中只能指定一个可变参数，它<strong>必须是方法的最后一个参数</strong>。任何普通的参数必须在它之前声明。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VarargsDemo</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String args[])</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 调用可变参数的方法</span><br>        printMax(<span class=\"hljs-number\">34</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">56.5</span>);<br>        printMax(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">double</span>[]&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>&#125;);<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">printMax</span><span class=\"hljs-params\">( <span class=\"hljs-keyword\">double</span>... numbers)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (numbers.length == <span class=\"hljs-number\">0</span>) &#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;No argument passed&quot;</span>);<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">double</span> result = numbers[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;  numbers.length; i++)&#123;<br>            <span class=\"hljs-keyword\">if</span> (numbers[i] &gt;  result) &#123;<br>                result = numbers[i];<br>            &#125;<br>        &#125;<br>        System.out.println(<span class=\"hljs-string\">&quot;The max value is &quot;</span> + result);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">The max value is 56.5</span><br><span class=\"hljs-comment\">The max value is 3.0</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><ul>\n<li>构造方法也称为构造器</li>\n<li><strong>当一个对象被创建时候，构造方法用来初始化该对象</strong></li>\n<li><strong>构造方法和它所在类的名字相同</strong>，但构造方法没有返回值，也不能写void</li>\n<li>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象</li>\n<li>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)</li>\n<li>一旦你定义了自己的构造方法，默认构造方法就会失效</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 一个简单的构造函数</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyClass</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span> x;<br> <br>  <span class=\"hljs-comment\">// 以下是构造函数</span><br>  MyClass() &#123;<br>    x = <span class=\"hljs-number\">10</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Java-静态类、静态方法和静态变量\"><a href=\"#Java-静态类、静态方法和静态变量\" class=\"headerlink\" title=\"Java 静态类、静态方法和静态变量\"></a>Java 静态类、静态方法和静态变量</h2><p><strong>static</strong> 是Java中的一个关键字，我们不能声明普通外层类或者包为静态的</p>\n<h3 id=\"静态变量\"><a href=\"#静态变量\" class=\"headerlink\" title=\"静态变量\"></a>静态变量</h3><p><a href=\"#类变量\"><code>点击跳转类变量</code></a></p>\n<p>静态变量即类变量，静态变量是属于类的，而不是属于类创建的对象或实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//静态变量的例子</span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> count;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String str;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String DB_USER = <span class=\"hljs-string\">&quot;myuser&quot;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><ul>\n<li>类似于静态变量</li>\n<li>静态方法也属于类，不属于实例</li>\n<li>静态方法只能访问类的静态变量，或调用类的静态方法</li>\n<li>通常静态方法作为工具方法，被其它类使用，而不需要创建类的实例</li>\n<li>通常java程序的开始就是一个<code>main()</code>方法，它就是个静态方法</li>\n<li>静态方法只会在第一次执行一次</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//静态方法的例子</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setCount</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> count)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(count &gt; <span class=\"hljs-number\">0</span>)<br>    StaticExample.count = count;<br>&#125;<br><br><span class=\"hljs-comment\">//静态工具方法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">addInts</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span>...js)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum=i;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> x : js) sum+=x;<br>    <span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"静态块\"><a href=\"#静态块\" class=\"headerlink\" title=\"静态块\"></a>静态块</h3><ul>\n<li>静态块就是类加载器加载对象时，要执行的一组语句</li>\n<li>用于初始化静态变量</li>\n<li>通常用于类加载的时候创建静态资源</li>\n<li>我们在静态块中不能访问非静态变量</li>\n<li>我们可以在一个类中有多个静态块，尽管这么做没什么意义</li>\n<li>静态块只会在类加载到内存中的时候执行一次</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">static</span>&#123;<br>    <span class=\"hljs-comment\">//在类被加载的时候用于初始化资源</span><br>    System.out.println(<span class=\"hljs-string\">&quot;StaticExample static block&quot;</span>);<br>    <span class=\"hljs-comment\">//仅能访问静态变量和静态方法</span><br>    str=<span class=\"hljs-string\">&quot;Test&quot;</span>;<br>    setCount(<span class=\"hljs-number\">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"静态类\"><a href=\"#静态类\" class=\"headerlink\" title=\"静态类\"></a>静态类</h3><p><a href=\"#内部类\"><code>点击跳转内部类</code></a></p>\n<ul>\n<li>我们对嵌套类使用static关键字</li>\n<li>static不能用于最外层的类</li>\n<li>静态的嵌套类和其它外层的类别无二致，嵌套只是为了方便打包</li>\n</ul>\n<h3 id=\"静态导入包\"><a href=\"#静态导入包\" class=\"headerlink\" title=\"静态导入包\"></a>静态导入包</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> java.lang.Math.random;<br></code></pre></td></tr></table></figure>\n<p>可以在类中直接使用random方法</p>\n<h2 id=\"Java数组\"><a href=\"#Java数组\" class=\"headerlink\" title=\"Java数组\"></a>Java数组</h2><h3 id=\"普通数组\"><a href=\"#普通数组\" class=\"headerlink\" title=\"普通数组\"></a>普通数组</h3><p>数组是<strong>相同类型数据</strong>的<strong>有序集合</strong></p>\n<ul>\n<li>长度确定，一旦被创建，大小就不可以被改变</li>\n<li>其元素必须是相同类型，不允许出现混合类型</li>\n<li>数组中的元素可以是任何数据类型</li>\n<li>数组变量属于引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量</li>\n</ul>\n<p>初始化数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 首选的方法</span><br>dataType[] arrayRefVar;  <br><span class=\"hljs-comment\">//或</span><br><span class=\"hljs-comment\">// 效果相同，但不是首选方法 </span><br><span class=\"hljs-comment\">// 来自 C/C++ 语言 </span><br>dataType arrayRefVar[];  <br></code></pre></td></tr></table></figure>\n<p>初始化多维数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//直接为每一维分配空间</span><br><span class=\"hljs-comment\">//type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数</span><br>type[][] typeName = <span class=\"hljs-keyword\">new</span> type[typeLength1][typeLength2];<br><span class=\"hljs-comment\">//或</span><br><span class=\"hljs-comment\">//为最高维分配引用空间</span><br><span class=\"hljs-comment\">//再为其每个数组元素单独分配空间</span><br>String[][] s = <span class=\"hljs-keyword\">new</span> String[<span class=\"hljs-number\">2</span>][];<br>s[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-keyword\">new</span> String[<span class=\"hljs-number\">2</span>];<br>s[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-keyword\">new</span> String[<span class=\"hljs-number\">3</span>];<br>s[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">&quot;Good&quot;</span>);<br>s[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">&quot;Luck&quot;</span>);<br>s[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">&quot;to&quot;</span>);<br>s[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">&quot;you&quot;</span>);<br>s[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-keyword\">new</span> String(<span class=\"hljs-string\">&quot;!&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"稀疏数组\"><a href=\"#稀疏数组\" class=\"headerlink\" title=\"稀疏数组\"></a>稀疏数组</h3><p>稀疏矩阵（英语：sparse matrix）指的是在数值分析中绝大多数数值为零的矩阵。反之，如果大部分元素都非零，则这个矩阵是稠密的(Dense)。</p>\n<img src=\"/article/33685/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B8%8E%E7%A8%A0%E5%AF%86%E7%9F%A9%E9%98%B5.png\" class title=\"稀疏矩阵与稠密矩阵\">\n<blockquote>\n<p> 上图中左边就是一个稀疏矩阵，可以看到包含了很多 0 元素，右边是稠密的矩阵，大部分元素不是 0</p>\n</blockquote>\n<p>转化为稀疏数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[][] sparseMatrix(<span class=\"hljs-keyword\">int</span>[][] array)&#123;<br>  <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; array.length; i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; array[i].length)&#123;<br>      <span class=\"hljs-keyword\">if</span>(array[i][j] != <span class=\"hljs-number\">0</span>)<br>        sum++;<br>    &#125;<br>  &#125;<br>  System.out.println(<span class=\"hljs-string\">&quot;有效值的个数：&quot;</span> + sum);<br>  <br>  <span class=\"hljs-comment\">//创建一个稀疏数组</span><br>  <span class=\"hljs-keyword\">int</span>[][] sparse = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[sum + <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">3</span>];<br>  sparse[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = array.length;<br>  sparse[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] = array[<span class=\"hljs-number\">0</span>].length;<br>  sparse[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">2</span>] = sum;<br>  <br>  <span class=\"hljs-comment\">//遍历二维数组，将非零的值，存放数组中</span><br>  <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span> ; i &lt; array.length ; i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span> ; j &lt; array[<span class=\"hljs-number\">0</span>].length ; j++)&#123;<br>      <span class=\"hljs-keyword\">if</span>(array[i][j] != <span class=\"hljs-number\">0</span>)&#123;<br>        count++;<br>        sparse[count][<span class=\"hljs-number\">0</span>] = i;<br>        sparse[count][<span class=\"hljs-number\">1</span>] = j;<br>        sparse[count][<span class=\"hljs-number\">2</span>] = array[i][j];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> sparse;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Java类\"><a href=\"#Java类\" class=\"headerlink\" title=\"Java类\"></a>Java类</h2><h3 id=\"Java-Scanner-类\"><a href=\"#Java-Scanner-类\" class=\"headerlink\" title=\"Java Scanner 类\"></a>Java Scanner 类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Scanner s = <span class=\"hljs-keyword\">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure>\n<p>通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据.</p>\n<p><strong>next方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner; <br> <br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ScannerDemo</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        Scanner scan = <span class=\"hljs-keyword\">new</span> Scanner(System.in);<br>        <span class=\"hljs-comment\">// 从键盘接收数据</span><br> <br>        <span class=\"hljs-comment\">// next方式接收字符串</span><br>        System.out.println(<span class=\"hljs-string\">&quot;next方式接收：&quot;</span>);<br>        <span class=\"hljs-comment\">// 判断是否还有输入</span><br>        <span class=\"hljs-keyword\">if</span> (scan.hasNext()) &#123;<br>            String str1 = scan.next();<br>            System.out.println(<span class=\"hljs-string\">&quot;输入的数据为：&quot;</span> + str1);<br>        &#125;<br>        scan.close();<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">$ javac ScannerDemo.java</span><br><span class=\"hljs-comment\">$ java ScannerDemo</span><br><span class=\"hljs-comment\">next方式接收：</span><br><span class=\"hljs-comment\">bobo com</span><br><span class=\"hljs-comment\">输入的数据为：bobo</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p><strong>nextLine 方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<br> <br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ScannerDemo</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        Scanner scan = <span class=\"hljs-keyword\">new</span> Scanner(System.in);<br>        <span class=\"hljs-comment\">// 从键盘接收数据</span><br> <br>        <span class=\"hljs-comment\">// nextLine方式接收字符串</span><br>        System.out.println(<span class=\"hljs-string\">&quot;nextLine方式接收：&quot;</span>);<br>        <span class=\"hljs-comment\">// 判断是否还有输入</span><br>        <span class=\"hljs-keyword\">if</span> (scan.hasNextLine()) &#123;<br>            String str2 = scan.nextLine();<br>            System.out.println(<span class=\"hljs-string\">&quot;输入的数据为：&quot;</span> + str2);<br>        &#125;<br>        scan.close();<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">$ javac ScannerDemo.java</span><br><span class=\"hljs-comment\">$ java ScannerDemo</span><br><span class=\"hljs-comment\">nextLine方式接收：</span><br><span class=\"hljs-comment\">bobo com</span><br><span class=\"hljs-comment\">输入的数据为：bobo com</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p><strong>next() 与 nextLine() 区别</strong></p>\n<p>next():</p>\n<ul>\n<li>一定要读取到有效字符后才可以结束输入。</li>\n<li>对输入有效字符之前遇到的空白，next() 方法会自动将其去。</li>\n<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 </li>\n<li>next() 不能得到带有空格的字符串。</li>\n</ul>\n<p>nextLine()： </p>\n<ul>\n<li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 </li>\n<li>可以获得空白。</li>\n</ul>\n<blockquote>\n<p><strong>相较于 hasnext()</strong>，针对int、float等其他基本数据类型，还有scan.hasNextInt()、hasNextFloat()等方法，返回布尔值；</p>\n</blockquote>\n<blockquote>\n<p> <strong>相较于 nextLine()</strong>，针对int、float等其他基本数据类型，还有、scan.nextInt()、scan.nextFloat()等方法，返回输出类型值；</p>\n</blockquote>\n<h3 id=\"Java-Arrays-类\"><a href=\"#Java-Arrays-类\" class=\"headerlink\" title=\"Java Arrays 类\"></a>Java Arrays 类</h3><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>\n<p>具有以下功能：</p>\n<ul>\n<li>给数组赋值：通过 fill 方法 ,将指定的值分配给数组的每个元素</li>\n<li>对数组排序：通过 sort 方法,按升序</li>\n<li>比较数组：通过 equals 方法比较数组中元素值是否相等</li>\n<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作</li>\n</ul>\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。</p>\n<p><strong>成员内部类</strong></p>\n<p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> </span>&#123;<br>    <span class=\"hljs-keyword\">double</span> radius = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Circle</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> radius)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>.radius = radius;<br>    &#125;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Draw</span> </span>&#123;     <span class=\"hljs-comment\">//内部类</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawSahpe</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            System.out.println(<span class=\"hljs-string\">&quot;drawshape&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以<strong>无条件访问外部类的所有成员属性和成员方法</strong>（包括private成员和静态成员）。</p>\n<hr>\n<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">外部类.<span class=\"hljs-keyword\">this</span>.成员变量<br>外部类.<span class=\"hljs-keyword\">this</span>.成员方法<br></code></pre></td></tr></table></figure>\n<hr>\n<p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> </span>&#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">double</span> radius = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Circle</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> radius)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>.radius = radius;<br>        getDrawInstance().drawSahpe();   <span class=\"hljs-comment\">//必须先创建成员内部类的对象，再进行访问</span><br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Draw <span class=\"hljs-title\">getDrawInstance</span><span class=\"hljs-params\">()</span> </span>&#123;   <span class=\"hljs-comment\">//创建成员内部类的对象</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Draw();<br>    &#125;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Draw</span> </span>&#123;     <span class=\"hljs-comment\">//内部类</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawSahpe</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            System.out.println(radius);  <span class=\"hljs-comment\">//外部类的private成员</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span>  </span>&#123;<br>        <span class=\"hljs-comment\">//第一种方式：</span><br>        Outter outter = <span class=\"hljs-keyword\">new</span> Outter();<br>        Outter.Inner inner = outter.<span class=\"hljs-function\">new <span class=\"hljs-title\">Inner</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">//必须通过Outter对象来创建</span><br>         <br>        <span class=\"hljs-comment\">//第二种方式：</span><br>        Outter.Inner inner1 = outter.getInnerInstance();<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Outter</span> </span>&#123;<br>    <span class=\"hljs-keyword\">private</span> Inner inner = <span class=\"hljs-keyword\">null</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Outter</span><span class=\"hljs-params\">()</span> </span>&#123;<br>         <br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Inner <span class=\"hljs-title\">getInnerInstance</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(inner == <span class=\"hljs-keyword\">null</span>)<br>            inner = <span class=\"hljs-keyword\">new</span> Inner();<br>        <span class=\"hljs-keyword\">return</span> inner;<br>    &#125;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Inner</span> </span>&#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Inner</span><span class=\"hljs-params\">()</span> </span>&#123;    <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。</p>\n<hr>\n<p><strong>局部内部类</strong></p>\n<p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">People</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">People</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Man</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Man</span><span class=\"hljs-params\">()</span></span>&#123;    <br>    &#125;   <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> People <span class=\"hljs-title\">getWoman</span><span class=\"hljs-params\">()</span></span>&#123;<br>        <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Woman</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">People</span></span>&#123;   <span class=\"hljs-comment\">//局部内部类</span><br>            <span class=\"hljs-keyword\">int</span> age =<span class=\"hljs-number\">0</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Woman();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>注意</strong>: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p>\n<hr>\n<p><strong>匿名内部类</strong></p>\n<p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。</p>\n<p>下面是一段匿名内部类的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">new</span> OnClickListener() &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>下面这段代码是一段 Android 事件监听代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">scan_bt.setOnClickListener(<span class=\"hljs-keyword\">new</span> OnClickListener() &#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;);<br> <br>history_bt.setOnClickListener(<span class=\"hljs-keyword\">new</span> OnClickListener() &#123;<br>     <br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO Auto-generated method stub</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>这就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。</p>\n<hr>\n<p><strong>静态内部类</strong></p>\n<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</p>\n<p>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span>  </span>&#123;<br>        Outter.Inner inner = <span class=\"hljs-keyword\">new</span> Outter.Inner();<br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Outter</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Outter</span><span class=\"hljs-params\">()</span> </span>&#123;<br>         <br>    &#125;<br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Inner</span> </span>&#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Inner</span><span class=\"hljs-params\">()</span> </span>&#123;<br>             <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<p><strong>静态内部类与内部类的区别</strong></p>\n<p><strong>内部类</strong></p>\n<ul>\n<li>内部类拥有普通类的所有特性，也拥有类成员变量的特性 </li>\n<li>内部类可以访问其外部类的成员变量，属性，方法，其它内部类</li>\n</ul>\n<p><strong>静态内部类</strong></p>\n<ul>\n<li>只有内部类才能声明为static，也可以说是静态内部类 </li>\n<li>只有静态内部类才能拥有静态成员，普通内部类只能定义普通成员 </li>\n<li>静态类跟静态方法一样，只能访问其外部类的静态成员 </li>\n<li>如果在外部类的静态方法中访问内部类，这时候只能访问静态内部类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 外部类，不能声明为 static</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OuterClass</span> </span>&#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> ab = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> sab = <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 普通内部类</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NormalInnerClass</span> </span>&#123;<br>        <span class=\"hljs-comment\">// private static int age = 22;</span><br>        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> age = <span class=\"hljs-number\">22</span>; <span class=\"hljs-comment\">// 不能声明为static</span><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">NormalInnerClass</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            <span class=\"hljs-comment\">// 可以访问外部类静态与非静态成员</span><br>            System.out.println(ab);<br>            System.out.println(sab);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 静态内部类</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StaticInnerClass</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 定义静态与非静态成员都是可以的</span><br>        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> age = <span class=\"hljs-number\">22</span>;<br>        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> age2 = <span class=\"hljs-number\">22</span>;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">echo</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            <span class=\"hljs-comment\">// System.out.println(ab);</span><br>            System.out.println(sab);<span class=\"hljs-comment\">// 只能访问外部类的静态成员</span><br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>\n<hr>\n<p><strong>练习</strong></p>\n<p>1.根据注释填写(1)，(2)，(3)处的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span></span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>           <span class=\"hljs-comment\">// 初始化Bean1</span><br>           (<span class=\"hljs-number\">1</span>)<br>           bean1.I++;<br>           <span class=\"hljs-comment\">// 初始化Bean2</span><br>           (<span class=\"hljs-number\">2</span>)<br>           bean2.J++;<br>           <span class=\"hljs-comment\">//初始化Bean3</span><br>           (<span class=\"hljs-number\">3</span>)<br>           bean3.k++;<br>    &#125;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bean1</span></span>&#123;<br>           <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> I = <span class=\"hljs-number\">0</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bean2</span></span>&#123;<br>           <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> J = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bean</span></span>&#123;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bean3</span></span>&#123;<br>           <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>\n<p>创建静态内部类对象的一般形式为：<code>外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</code></p>\n<p>创建成员内部类对象的一般形式为： <code>外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</code></p>\n<p>因此，（1），（2），（3）处的代码分别为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Test test = <span class=\"hljs-keyword\">new</span> Test();    <br>Test.Bean1 bean1 = test.n<span class=\"hljs-function\">ew <span class=\"hljs-title\">Bean1</span><span class=\"hljs-params\">()</span></span>;<br>---------------------------------------<br>Test.Bean2 b2 = <span class=\"hljs-keyword\">new</span> Test.Bean2();<br>Bean bean = <span class=\"hljs-keyword\">new</span> Bean();     <br>---------------------------------------<br>Bean.Bean3 bean3 =  bean.n<span class=\"hljs-function\">ew <span class=\"hljs-title\">Bean3</span><span class=\"hljs-params\">()</span></span>;<br></code></pre></td></tr></table></figure>\n<p>2.下面这段代码的输出结果是什么？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span>  </span>&#123;<br>        Outter outter = <span class=\"hljs-keyword\">new</span> Outter();<br>        outter.n<span class=\"hljs-function\">ew <span class=\"hljs-title\">Inner</span><span class=\"hljs-params\">()</span>.<span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span></span>;<br>    &#125;<br>&#125;<br> <br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Outter</span></span><br><span class=\"hljs-class\"></span>&#123;<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Inner</span> </span>&#123;<br>        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>            <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">3</span>;<br>            System.out.println(<span class=\"hljs-string\">&quot;局部变量：&quot;</span> + a);<br>            System.out.println(<span class=\"hljs-string\">&quot;内部类变量：&quot;</span> + <span class=\"hljs-keyword\">this</span>.a);<br>            System.out.println(<span class=\"hljs-string\">&quot;外部类变量：&quot;</span> + Outter.<span class=\"hljs-keyword\">this</span>.a);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">局部变量：3</span><br><span class=\"hljs-comment\">内部类变量：2</span><br><span class=\"hljs-comment\">外部类变量：1</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<hr>\n<p>关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>\n<ul>\n<li>成员内部类的引用方式必须为 Outter.Inner </li>\n<li>构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">WithInner</span> </span>&#123;<br>    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Inner</span></span>&#123;<br>         <br>    &#125;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">InheritInner</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">WithInner</span>.<span class=\"hljs-title\">Inner</span> </span>&#123;<br>      <br>    <span class=\"hljs-comment\">// InheritInner() 是不能通过编译的，一定要加上形参</span><br>    InheritInner(WithInner wi) &#123;<br>        wi.<span class=\"hljs-keyword\">super</span>(); <span class=\"hljs-comment\">//必须有这句调用</span><br>    &#125;<br>  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        WithInner wi = <span class=\"hljs-keyword\">new</span> WithInner();<br>        InheritInner obj = <span class=\"hljs-keyword\">new</span> InheritInner(wi);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><ul>\n<li><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样</p>\n</li>\n<li><p>抽象方法必须在抽象类中</p>\n<ul>\n<li><p>如果一个类包含抽象方法，那么该类必须是抽象类</p>\n</li>\n<li><p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类</p>\n</li>\n</ul>\n</li>\n<li><p>由于抽象类不能实例化对象，所以<strong>抽象类必须被继承</strong>，才能被使用</p>\n</li>\n<li><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法</p>\n</li>\n<li><p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而<strong>一个类却可以实现多个<a href=\"#接口\"><code>接口</code></a></strong>,接口可以多继承</p>\n</li>\n<li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p>\n</li>\n<li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能</p>\n</li>\n<li><p><strong>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</strong></p>\n</li>\n<li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</p>\n</li>\n</ul>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><ul>\n<li>普通类：只有具体实现</li>\n<li>抽象类：具体实现和规范（抽象方法）都有</li>\n<li>接口：只有规范！</li>\n</ul>\n<ol>\n<li>是抽象方法的集合，接口通常以interface来声明；</li>\n<li>一个类通过继承接口的方式，从而来继承接口的抽象方法；</li>\n<li>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法；</li>\n<li>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法；</li>\n<li>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类；</li>\n<li>在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或<strong>是被绑定在一个以此接口实现的对象</strong>。</li>\n</ol>\n<p><strong>接口与类相似点</strong></p>\n<ul>\n<li>一个接口可以有多个方法；</li>\n<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名；</li>\n<li>接口的字节码文件保存在 .class 结尾的文件中；</li>\n<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>\n</ul>\n<p><strong>接口与类的区别</strong></p>\n<ul>\n<li>接口不能用于实例化对象；</li>\n<li>接口没有构造方法；</li>\n<li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法；</li>\n<li>接口不能包含成员变量，除了 static 和 final 变量；</li>\n<li>接口不是被类继承了，而是要被类实现；</li>\n<li>接口支持多继承。</li>\n</ul>\n<p><strong>接口特性</strong></p>\n<ul>\n<li>接口与接口中的每一个方法都是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）；</li>\n<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）；</li>\n<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法；</li>\n<li>接口中的方法都是公有的。</li>\n</ul>\n<p><strong>抽象类和接口的区别</strong></p>\n<ul>\n<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行；</li>\n<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的；</li>\n<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法；</li>\n<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> 接口名称 [<span class=\"hljs-keyword\">extends</span> 其他的接口名] </span>&#123;<br>  <span class=\"hljs-comment\">// 声明变量</span><br>  <span class=\"hljs-comment\">// 抽象方法</span><br>&#125;<br><br>...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...<br></code></pre></td></tr></table></figure>\n<p><strong>重写接口中声明的方法时，需要注意以下规则</strong></p>\n<ul>\n<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常；</li>\n<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型；</li>\n<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法；</li>\n</ul>\n<p><strong>在实现接口的时候，也要注意一些规则</strong></p>\n<ul>\n<li>一个类可以同时实现多个接口；</li>\n<li>一个类只能继承一个类，但是能实现多个接口；</li>\n<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>\n</ul>\n<p><strong>标记接口</strong></p>\n<ul>\n<li>最常用的继承接口是没有包含任何方法的接口；</li>\n<li>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情；</li>\n<li>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</li>\n</ul>\n<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> java.util;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">EventListener</span></span><br><span class=\"hljs-class\"></span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>\n<ul>\n<li><p>建立一个公共的父接口：</p>\n<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>\n</li>\n<li><p>向一个类添加数据类型：</p>\n<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>\n</li>\n</ul>\n<h2 id=\"值传递-引用传递\"><a href=\"#值传递-引用传递\" class=\"headerlink\" title=\"值传递-引用传递\"></a>值传递-引用传递</h2><p><strong>值传递</strong></p>\n<p>实参传递给形参的是值 形参和实参在内存上是两个<strong>独立</strong>的变量,对<strong>形参做任何修改不会影响实参</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Demo</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> b =<span class=\"hljs-number\">20</span>;<br>        change(b);<span class=\"hljs-comment\">// 实参 实际上的参数</span><br>        System.out.println(b);<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;<span class=\"hljs-comment\">//形参 形式上的参数</span><br>        a=<span class=\"hljs-number\">100</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>引用传递</strong></p>\n<p>实参传递给形参的是参数对于堆内存上的引用地址，实参和形参在内存上指向了同一块区域，对<strong>形参的修改会影响实参</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Demo</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> [] a=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;;<br>        System.out.println(a[<span class=\"hljs-number\">0</span>]);<br>        change(a);<br>        System.out.println(a[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br>   <span class=\"hljs-comment\">//实参和形参在内存上指向了同一块区域</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">change</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a )</span></span>&#123;<br>        a[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">100</span>;  <span class=\"hljs-comment\">//形参的修改会影响实参</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Java三大特性\"><a href=\"#Java三大特性\" class=\"headerlink\" title=\"Java三大特性\"></a>Java三大特性</h2><h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><blockquote>\n<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法;</p>\n<p>要访问该类的代码和数据，必须通过严格的接口控制;</p>\n</blockquote>\n<p><strong>优点</strong></p>\n<ul>\n<li>良好的封装能够减少耦合；</li>\n<li>类内部的结构可以自由修改；</li>\n<li>可以对成员变量进行更精确的控制；</li>\n<li>隐藏信息，实现细节。</li>\n</ul>\n<p><strong>实现步骤</strong></p>\n<ol>\n<li>修改属性的可见性来限制对属性的访问（一般限制为private）</li>\n<li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问（get、set方法）</li>\n<li>采用 <strong>this</strong> 关键字是为了解决实例变量和局部变量之间发生的同名的冲突</li>\n</ol>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><blockquote>\n<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类;</p>\n<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//类的继承格式</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 父类 </span>&#123;<br>&#125;<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 子类 <span class=\"hljs-keyword\">extends</span> 父类 </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/33685/java-extends.png\" class title=\"java-extends\">\n<p><strong>特性</strong></p>\n<ul>\n<li>子类拥有父类<strong>非 private </strong>的属性、方法；</li>\n<li>final修饰的类，不能被继承；</li>\n<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展；</li>\n<li>子类可以用自己的方式实现父类的方法；</li>\n<li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li>\n<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li>\n</ul>\n<p><strong>关键字</strong></p>\n<p><strong>super 与 this 关键字</strong></p>\n<p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类</p>\n<p>this关键字：指向自己的引用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;animal : eat&quot;</span>);<br>  &#125;<br>&#125;<br> <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;dog : eat&quot;</span>);<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eatTest</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.eat();   <span class=\"hljs-comment\">// this 调用自己的方法</span><br>    <span class=\"hljs-keyword\">super</span>.eat();  <span class=\"hljs-comment\">// super 调用父类方法</span><br>  &#125;<br>&#125;<br> <br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>    Animal a = <span class=\"hljs-keyword\">new</span> Animal();<br>    a.eat();<br>    Dog d = <span class=\"hljs-keyword\">new</span> Dog();<br>    d.eatTest();<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">输出结果为：</span><br><span class=\"hljs-comment\">animal : eat</span><br><span class=\"hljs-comment\">dog : eat</span><br><span class=\"hljs-comment\">animal : eat</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>super调用父类的构造方法，必须在构造方法的第一个</li>\n<li>super必须只能出现在子类的方法或者构造方法中</li>\n<li>super和this不能同时调用构造方法</li>\n</ul>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><blockquote>\n<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>\n<p>多态就是同一个接口，使用不同的实例而执行不同操作.</p>\n</blockquote>\n<p><strong>注意</strong></p>\n<ul>\n<li>对象能执行哪些方法，主要看左边的类型，和右边关系不大</li>\n<li>父类可以指向子类，但是不能调用子类<strong>独有</strong>的方法</li>\n<li></li>\n</ul>\n<p><strong>优点</strong></p>\n<ul>\n<li>消除类型之间的耦合关系</li>\n<li>可替换性</li>\n<li>可扩充性</li>\n<li>接口性</li>\n<li>灵活性</li>\n<li>简化性</li>\n</ul>\n<p><strong>多态存在的三个必要条件</strong></p>\n<ul>\n<li>继承</li>\n<li>重写 <a href=\"#Java重写与重载\"><code>点击跳转重写与重载</code></a></li>\n<li>父类引用指向子类对象：<strong>Parent p = new Child();</strong></li>\n</ul>\n<img src=\"/article/33685/Java%E5%A4%9A%E6%80%81.jpg\" class title=\"Java多态\">\n<p><em>简单的多态实例</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>      show(<span class=\"hljs-keyword\">new</span> Cat());  <span class=\"hljs-comment\">// 以 Cat 对象调用 show 方法</span><br>      show(<span class=\"hljs-keyword\">new</span> Dog());  <span class=\"hljs-comment\">// 以 Dog 对象调用 show 方法</span><br>                <br>      Animal a = <span class=\"hljs-keyword\">new</span> Cat();  <span class=\"hljs-comment\">// 向上转型  </span><br>      a.eat();               <span class=\"hljs-comment\">// 调用的是 Cat 的 eat</span><br>      Cat c = (Cat)a;        <span class=\"hljs-comment\">// 向下转型  </span><br>      c.work();        <span class=\"hljs-comment\">// 调用的是 Cat 的 work</span><br>  &#125;  <br>            <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(Animal a)</span>  </span>&#123;<br>      a.eat();  <br>        <span class=\"hljs-comment\">// 类型判断</span><br>        <span class=\"hljs-keyword\">if</span> (a <span class=\"hljs-keyword\">instanceof</span> Cat)  &#123;  <span class=\"hljs-comment\">// 猫做的事情 </span><br>            Cat c = (Cat)a;  <br>            c.work();  <br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (a <span class=\"hljs-keyword\">instanceof</span> Dog) &#123; <span class=\"hljs-comment\">// 狗做的事情 </span><br>            Dog c = (Dog)a;  <br>            c.work();  <br>        &#125;  <br>    &#125;  <br>&#125;<br> <br><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>&#123;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span></span>;  <br>&#125;  <br>  <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span> </span>&#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;吃鱼&quot;</span>);  <br>    &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">work</span><span class=\"hljs-params\">()</span> </span>&#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;抓老鼠&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>&#123;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">eat</span><span class=\"hljs-params\">()</span> </span>&#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;吃骨头&quot;</span>);  <br>    &#125;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">work</span><span class=\"hljs-params\">()</span> </span>&#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;看家&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>\n<p><em>稍微复杂的多态</em></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Employee</span> </span>&#123;<br>   <span class=\"hljs-keyword\">private</span> String name;<br>   <span class=\"hljs-keyword\">private</span> String address;<br>   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> number;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Employee</span><span class=\"hljs-params\">(String name, String address, <span class=\"hljs-keyword\">int</span> number)</span> </span>&#123;<br>      System.out.println(<span class=\"hljs-string\">&quot;Employee 构造函数&quot;</span>);<br>      <span class=\"hljs-keyword\">this</span>.name = name;<br>      <span class=\"hljs-keyword\">this</span>.address = address;<br>      <span class=\"hljs-keyword\">this</span>.number = number;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mailCheck</span><span class=\"hljs-params\">()</span> </span>&#123;<br>      System.out.println(<span class=\"hljs-string\">&quot;邮寄支票给： &quot;</span> + <span class=\"hljs-keyword\">this</span>.name<br>       + <span class=\"hljs-string\">&quot; &quot;</span> + <span class=\"hljs-keyword\">this</span>.address);<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span> </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> name + <span class=\"hljs-string\">&quot; &quot;</span> + address + <span class=\"hljs-string\">&quot; &quot;</span> + number;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span> </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> name;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getAddress</span><span class=\"hljs-params\">()</span> </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> address;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setAddress</span><span class=\"hljs-params\">(String newAddress)</span> </span>&#123;<br>      address = newAddress;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getNumber</span><span class=\"hljs-params\">()</span> </span>&#123;<br>     <span class=\"hljs-keyword\">return</span> number;<br>   &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Salary</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Employee</span></span><br><span class=\"hljs-class\"></span>&#123;<br>   <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">double</span> salary; <span class=\"hljs-comment\">// 全年工资</span><br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Salary</span><span class=\"hljs-params\">(String name, String address, <span class=\"hljs-keyword\">int</span> number, <span class=\"hljs-keyword\">double</span> salary)</span> </span>&#123;<br>       <span class=\"hljs-keyword\">super</span>(name, address, number);<br>       setSalary(salary);<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mailCheck</span><span class=\"hljs-params\">()</span> </span>&#123;<br>       System.out.println(<span class=\"hljs-string\">&quot;Salary 类的 mailCheck 方法 &quot;</span>);<br>       System.out.println(<span class=\"hljs-string\">&quot;邮寄支票给：&quot;</span> + getName()<br>       + <span class=\"hljs-string\">&quot; ，工资为：&quot;</span> + salary);<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getSalary</span><span class=\"hljs-params\">()</span> </span>&#123;<br>       <span class=\"hljs-keyword\">return</span> salary;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setSalary</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> newSalary)</span> </span>&#123;<br>       <span class=\"hljs-keyword\">if</span>(newSalary &gt;= <span class=\"hljs-number\">0.0</span>) &#123;<br>          salary = newSalary;<br>       &#125;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">computePay</span><span class=\"hljs-params\">()</span> </span>&#123;<br>      System.out.println(<span class=\"hljs-string\">&quot;计算工资，付给：&quot;</span> + getName());<br>      <span class=\"hljs-keyword\">return</span> salary/<span class=\"hljs-number\">52</span>;<br>   &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VirtualDemo</span> </span>&#123;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String [] args)</span> </span>&#123;<br>      Salary s = <span class=\"hljs-keyword\">new</span> Salary(<span class=\"hljs-string\">&quot;员工 A&quot;</span>, <span class=\"hljs-string\">&quot;北京&quot;</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3600.00</span>);<br>      Employee e = <span class=\"hljs-keyword\">new</span> Salary(<span class=\"hljs-string\">&quot;员工 B&quot;</span>, <span class=\"hljs-string\">&quot;上海&quot;</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2400.00</span>);<br>      System.out.println(<span class=\"hljs-string\">&quot;使用 Salary 的引用调用 mailCheck -- &quot;</span>);<br>      s.mailCheck();<br>      System.out.println(<span class=\"hljs-string\">&quot;\\n使用 Employee 的引用调用 mailCheck--&quot;</span>);<br>      e.mailCheck();<br>    &#125;<br>&#125;<br>-------------------------------------------------------------<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Employee 构造函数</span><br><span class=\"hljs-comment\">Employee 构造函数</span><br><span class=\"hljs-comment\">使用 Salary 的引用调用 mailCheck -- </span><br><span class=\"hljs-comment\">Salary 类的 mailCheck 方法 </span><br><span class=\"hljs-comment\">邮寄支票给：员工 A ，工资为：3600.0</span><br><span class=\"hljs-comment\"></span><br><span class=\"hljs-comment\">使用 Employee 的引用调用 mailCheck--</span><br><span class=\"hljs-comment\">Salary 类的 mailCheck 方法 </span><br><span class=\"hljs-comment\">邮寄支票给：员工 B ，工资为：2400.0</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p>理解：</p>\n<ol>\n<li>主函数初始化<code>new Salary</code>时，因为继承关系，所以执行父类构造方法，初始化两次，执行了两次</li>\n<li><code>s.mailCheck();</code>正常调用类Salary中的方法</li>\n<li><code>e.mailCheck();</code> 父类的引用指向了子类的对象，因为类Salary重写了父类的方法，所以，调用类Salary中的方法</li>\n</ol>\n<h2 id=\"Java重写与重载\"><a href=\"#Java重写与重载\" class=\"headerlink\" title=\"Java重写与重载\"></a>Java重写与重载</h2><h2 id=\"⚠️⚠️⚠️注意细节⚠️⚠️⚠️\"><a href=\"#⚠️⚠️⚠️注意细节⚠️⚠️⚠️\" class=\"headerlink\" title=\"⚠️⚠️⚠️注意细节⚠️⚠️⚠️\"></a>⚠️⚠️⚠️注意细节⚠️⚠️⚠️</h2><h3 id=\"类中方法加载顺序\"><a href=\"#类中方法加载顺序\" class=\"headerlink\" title=\"类中方法加载顺序\"></a>类中方法加载顺序</h3><p>静态代码块——匿名代码块——构造方法</p>\n<h3 id=\"字符输出问题\"><a href=\"#字符输出问题\" class=\"headerlink\" title=\"字符输出问题\"></a>字符输出问题</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ZiDongLeiZhuan</span></span>&#123;<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>    \t\t<span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">10</span>;<br>      \t<span class=\"hljs-keyword\">int</span> b = <span class=\"hljs-number\">20</span>;<br>      \tSystem.out.println(<span class=\"hljs-string\">&quot;&quot;</span> + a + b);<br>      \tSystem.out.println(a + b + <span class=\"hljs-string\">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">/* </span><br><span class=\"hljs-comment\">运行结果</span><br><span class=\"hljs-comment\">1020</span><br><span class=\"hljs-comment\">30</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p>如果<code>&quot;&quot;</code>在前 则字符串拼接！如果<code>&quot;&quot;</code>在后 则为数学相加！</p>\n<h3 id=\"关于调用静态方法与非静态方法的区别\"><a href=\"#关于调用静态方法与非静态方法的区别\" class=\"headerlink\" title=\"关于调用静态方法与非静态方法的区别\"></a><strong>关于调用静态方法与非静态方法的区别</strong></h3><p><strong>例子</strong>：注意看 输出是不同的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//主启动类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span></span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;<br>    <span class=\"hljs-comment\">//调用静态方法时 方法的调用只和  左边  定义的数据类型有关</span><br>    A a = <span class=\"hljs-keyword\">new</span> A();<br>    a.test();<br>    <span class=\"hljs-comment\">//父类的引用指向了子类</span><br>    B b = <span class=\"hljs-keyword\">new</span> A();  <span class=\"hljs-comment\">//子类重写了父类的方法  只和非静态方法有关</span><br>    b.test()<br>  &#125;<br>&#125;  <br><br>---非静态方法---<br><span class=\"hljs-comment\">//父类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;B=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">//子类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">B</span></span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;A=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">A=&gt;test()</span><br><span class=\"hljs-comment\">A=&gt;test()</span><br><span class=\"hljs-comment\">*/</span><br>---静态方法---<br><span class=\"hljs-comment\">//父类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span></span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;B=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">//子类</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">B</span></span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span>  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;A=&gt;test()&quot;</span>);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">A=&gt;test()</span><br><span class=\"hljs-comment\">B=&gt;test()</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<p><strong>理解</strong>：</p>\n<p>静态方法属于类的方法，非静态方法属于对象的方法</p>\n<p>调用静态方法时，b调用了B类的方法，因为b是B类定义的，只和 <code>**左边**</code>  定义的数据类型有关</p>\n<p>调用非静态方法时，b调用的是对象的方法，而b这个对象是用A类new的，所以调用A的方法</p>\n<h3 id=\"Java程序初始化顺序\"><a href=\"#Java程序初始化顺序\" class=\"headerlink\" title=\"Java程序初始化顺序\"></a>Java程序初始化顺序</h3><ol>\n<li>父类的静态变量</li>\n<li>父类的静态代码块</li>\n<li>子类的静态变量</li>\n<li>子类的静态代码块</li>\n<li>父类的非静态变量</li>\n<li>父类的非静态代码块</li>\n<li>父类的构造方法</li>\n<li>子类的非静态变量</li>\n<li>子类的非静态代码块</li>\n<li>子类的构造方法</li>\n</ol>\n","categories":[{"name":"语言","path":"api/categories/语言.json"},{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Java","path":"api/tags/Java.json"}]}