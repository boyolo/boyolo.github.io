{"title":"排序算法","slug":"Java-排序算法","date":"2021-12-13T02:15:47.000Z","updated":"2022-05-12T04:32:03.035Z","comments":true,"path":"api/articles/Java-排序算法.json","realPath":null,"excerpt":null,"covers":["/article/50722/sort.png","/article/50722/%E5%88%86%E7%B1%BB.jpg","/article/50722/bubbleSort.gif","/article/50722/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif","/article/50722/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif","/article/50722/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%88%86%E8%A7%A3%E5%9B%BE.jpg","/article/50722/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif","/article/50722/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png","/article/50722/quickSort.gif","/article/50722/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpeg","/article/50722/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif","/article/50722/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif","/article/50722/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif","/article/50722/%E5%A0%86%E6%8E%92%E5%BA%8F.gif","/article/50722/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg"],"cover":"/images/theme/coverphoto/Java排序算法.jpg","content":"<blockquote>\n<p>The mystery of creation is like the darkness of night–it is great.</p>\n<p>Delusions of knowledge are like the fog of the morning.</p>\n</blockquote>\n<p><a href=\"https://www.cnblogs.com/l199616j/p/10742603.html#_label0_0\">https://www.cnblogs.com/l199616j/p/10742603.html#_label0_0</a></p>\n<img src=\"/article/50722/sort.png\" class title=\"sort\">\n<img src=\"/article/50722/%E5%88%86%E7%B1%BB.jpg\" class title=\"分类\">\n<h2 id=\"如何分析一个“排序算法”？\"><a href=\"#如何分析一个“排序算法”？\" class=\"headerlink\" title=\"如何分析一个“排序算法”？\"></a>如何分析一个“排序算法”？</h2><h3 id=\"排序算法的执行效率\"><a href=\"#排序算法的执行效率\" class=\"headerlink\" title=\"排序算法的执行效率\"></a>排序算法的执行效率</h3><ol>\n<li>最好情况、最坏情况、平均情况时间复杂度</li>\n<li>时间复杂度的系数、常数 、低阶</li>\n<li>比较次数和交换（或移动）次数</li>\n</ol>\n<h3 id=\"排序算法的内存消耗\"><a href=\"#排序算法的内存消耗\" class=\"headerlink\" title=\"排序算法的内存消耗\"></a>排序算法的内存消耗</h3><p><strong>原地排序（Sorted in place）</strong></p>\n<p>原地排序算法，就是特指空间复杂度是 O(1) 的排序算法</p>\n<p>原地排序算法：冒泡排序、插入排序、选择排序</p>\n<h3 id=\"排序算法的稳定性\"><a href=\"#排序算法的稳定性\" class=\"headerlink\" title=\"排序算法的稳定性\"></a>排序算法的稳定性</h3><p>稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>\n<h3 id=\"“有序度”和“逆序度”\"><a href=\"#“有序度”和“逆序度”\" class=\"headerlink\" title=\"“有序度”和“逆序度”\"></a>“有序度”和“逆序度”</h3><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。</p>\n<p>完全有序的数组的有序度叫作<strong>满有序度</strong>：<strong>n*(n-1)/2</strong></p>\n<p><strong>逆序度</strong>是数组中不具有有序关系的元素对的个数。</p>\n<p><strong>逆序度 = 满有序度 - 有序度</strong></p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>\n<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以<strong>冒泡排序是稳定的排序算法</strong>。</p>\n<h3 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们的位置；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ol>\n<img src=\"/article/50722/bubbleSort.gif\" class title=\"bubbleSort\">\n<h3 id=\"Java算法实现\"><a href=\"#Java算法实现\" class=\"headerlink\" title=\"Java算法实现\"></a>Java算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] bubbleSort(<span class=\"hljs-keyword\">int</span>[] array)&#123;<br>  <span class=\"hljs-comment\">//外层循环 判断循环走多少次</span><br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; array.length - <span class=\"hljs-number\">1</span>; i++)&#123;<br>    <span class=\"hljs-comment\">//比较相邻的元素。如果第一个比第二个大，就交换他们的位置</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; array.length - <span class=\"hljs-number\">1</span> - i; j++)&#123;<br>      <span class=\"hljs-keyword\">if</span>(array[j+<span class=\"hljs-number\">1</span>] &lt; array[j])&#123;<br>        <span class=\"hljs-keyword\">int</span> temp = array[j];<br>        array[j] = array[j+<span class=\"hljs-number\">1</span>];<br>        array[j+<span class=\"hljs-number\">1</span>] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"算法增加标志位改进\"><a href=\"#算法增加标志位改进\" class=\"headerlink\" title=\"算法增加标志位改进\"></a>算法增加标志位改进</h4><ul>\n<li>增加标志位，减少没有意义的比较</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] bubbleSort(<span class=\"hljs-keyword\">int</span>[] array)&#123;<br>  <span class=\"hljs-comment\">//外层循环 判断循环走多少次</span><br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; array.length - <span class=\"hljs-number\">1</span>; i++)&#123;<br>    <span class=\"hljs-comment\">//设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成</span><br>    <span class=\"hljs-keyword\">boolean</span> flag = <span class=\"hljs-keyword\">true</span>;<br>    <span class=\"hljs-comment\">//比较相邻的元素。如果第一个比第二个大，就交换他们的位置</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; array.length - <span class=\"hljs-number\">1</span> - i; j++)&#123;<br>      <span class=\"hljs-keyword\">if</span>(array[j+<span class=\"hljs-number\">1</span>] &lt; array[j])&#123;<br>        <span class=\"hljs-keyword\">int</span> temp = array[j];<br>        array[j] = array[j+<span class=\"hljs-number\">1</span>];<br>        array[j+<span class=\"hljs-number\">1</span>] = temp;<br>        <span class=\"hljs-comment\">//相邻数字排序完成后，置为true</span><br>        flag = <span class=\"hljs-keyword\">false</span>;<br>      &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//如果其中一轮完全没有进入第二次循环中的置换顺序，说明没有需要置换的相邻元素，那么说明已经不需要再次进行排序，flag为true，可以直接跳出循环</span><br>    <span class=\"hljs-keyword\">if</span>(flag)&#123;<br>      <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>  &#125;<br>  reyurn array;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个<strong>原地排序算法</strong>。</p>\n<p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<strong>稳定的排序算法</strong>。</p>\n<p>选择排序是一种<strong>不稳定的排序算法</strong></p>\n<img src=\"/article/50722/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<ol>\n<li>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。</li>\n<li>初始已排序区间只有一个元素，就是数组的第一个元素。</li>\n<li>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。</li>\n<li>重复这个过程，直到未排序区间中元素为空，算法结束。</li>\n</ol>\n<h3 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 插入排序，a表示数组，n表示数组大小</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insertionSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i) &#123;<br>    <span class=\"hljs-keyword\">int</span> value = a[i];<br>    <span class=\"hljs-keyword\">int</span> j = i - <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-comment\">// 查找插入的位置</span><br>    <span class=\"hljs-keyword\">for</span> (; j &gt;= <span class=\"hljs-number\">0</span>; --j) &#123;<br>      <span class=\"hljs-keyword\">if</span> (a[j] &gt; value) &#123;<br>        a[j+<span class=\"hljs-number\">1</span>] = a[j];  <span class=\"hljs-comment\">// 数据移动</span><br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">break</span>;<br>      &#125;<br>    &#125;<br>    a[j+<span class=\"hljs-number\">1</span>] = value; <span class=\"hljs-comment\">// 插入数据</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>\n<p>选择排序空间复杂度为 O(1)，是一种<strong>原地排序算法</strong></p>\n<h3 id=\"算法步骤-1\"><a href=\"#算法步骤-1\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li><p>第一个跟后面的所有数相比较，如果小于（或等于）第一个数的时候，暂存较小数的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）</p>\n</li>\n<li><p>下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数</p>\n</li>\n<li>重复以上步骤，直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。</li>\n</ol>\n<img src=\"/article/50722/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<h3 id=\"算法实现-1\"><a href=\"#算法实现-1\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Arrays;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Main</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span>[] n = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[]&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">33</span>,<span class=\"hljs-number\">27</span>,<span class=\"hljs-number\">66</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">88</span>&#125;;<br>    <span class=\"hljs-keyword\">int</span> temp,index = -<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n.length-<span class=\"hljs-number\">1</span>; i++) &#123;<br>      index=i;<br>      <span class=\"hljs-comment\">//如果大于，暂存较小的数的下标</span><br>      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = i+<span class=\"hljs-number\">1</span>; j &lt;n.length; j++) &#123;<br>        <span class=\"hljs-keyword\">if</span>(n[index]&gt;n[j])&#123;<br>          index = j;<br>        &#125;<br>      &#125;<br>      <span class=\"hljs-comment\">////将一趟下来求出的最小数，与这个数交换</span><br>      <span class=\"hljs-keyword\">if</span>(index&gt;<span class=\"hljs-number\">0</span>)&#123;<br>        temp = n[i];<br>        n[i] = n[index];<br>        n[index] = temp;<br>      &#125;<br>      System.out.println(Arrays.toString(n));<br>    &#125;<br>    System.out.println(Arrays.toString(n));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>核心思想:如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>\n<p>在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素，先把 A[p…q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，<strong>归并排序是一个稳定的排序算法</strong>。</p>\n<p><strong>时间复杂度：</strong></p>\n<blockquote>\n<p><strong>T(a) = T(b) + T(c) + K</strong></p>\n<p>其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。</p>\n<p>我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。我们知道，merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</p>\n<p><strong>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</strong><br><strong>T(n) = 2*T(n/2) + n； n&gt;1</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">T(n) = 2*T(n/2) + n<br>     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n<br>     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n<br>     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n<br>     ......<br>     = 2^k * T(n/2^k) + k * n<br>     ......<br></code></pre></td></tr></table></figure>\n<p>通过这样一步一步分解推导，我们可以得到 <strong>T(n) = 2^kT(n/2^k)+kn</strong>。当 <strong>T(n/2^k)=T(1)</strong> 时，也就是 n/2^k=1，我们得到 <strong>k=log2n</strong> 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。</p>\n<p>如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以<strong>归并排序的时间复杂度是 O(nlogn)</strong>。</p>\n<p>归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)</p>\n</blockquote>\n<p><strong>空间复杂度</strong>是 O(n)</p>\n<blockquote>\n<img src=\"/article/50722/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%88%86%E8%A7%A3%E5%9B%BE.jpg\" class title=\"归并排序分解图\">\n</blockquote>\n<p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。</p>\n<blockquote>\n<p>分治是一种解决问题的处理思想，递归是一种编程技巧</p>\n</blockquote>\n<img src=\"/article/50722/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<blockquote>\n<p>递推公式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//递推公式：</span><br>merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+<span class=\"hljs-number\">1</span>…r))<br><br><span class=\"hljs-comment\">//终止条件：</span><br>p &gt;= r 不用再继续分解<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"算法实现-2\"><a href=\"#算法实现-2\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Arrays;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Main</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span>[] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[]&#123;<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>&#125;;<br>    merge(arr,<span class=\"hljs-number\">0</span>,arr.length-<span class=\"hljs-number\">1</span>);<br>    System.out.println(Arrays.toString(arr));<br>  &#125;<br><br>  <span class=\"hljs-comment\">//归并</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr,<span class=\"hljs-keyword\">int</span> low,<span class=\"hljs-keyword\">int</span> high)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> center = (high+low)/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span>(low&lt;high)&#123;<br>      <span class=\"hljs-comment\">//递归，直到low==high，也就是数组已不能再分了，</span><br>      merge(arr,low,center);<br>      merge(arr,center+<span class=\"hljs-number\">1</span>,high);<br><br>      <span class=\"hljs-comment\">//当数组不能再分，开始归并排序</span><br>      mergeSort(arr,low,center,high);<br>      System.out.println(Arrays.toString(arr));<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-comment\">//排序</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mergeSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr,<span class=\"hljs-keyword\">int</span> low,<span class=\"hljs-keyword\">int</span> center,<span class=\"hljs-keyword\">int</span> high)</span></span>&#123;<br>    <span class=\"hljs-comment\">//用于暂存排序后的数组的临时数组</span><br>    <span class=\"hljs-keyword\">int</span>[] tempArr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[arr.length];<br>    <span class=\"hljs-keyword\">int</span> i = low,j = center+<span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-comment\">//临时数组的下标</span><br>    <span class=\"hljs-keyword\">int</span> index = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">//循环遍历两个数组的数字，将小的插入到临时数组里</span><br>    <span class=\"hljs-keyword\">while</span>(i&lt;=center &amp;&amp; j&lt;= high)&#123;<br><br>      <span class=\"hljs-comment\">//左边数组的数小，插入到新数组</span><br>      <span class=\"hljs-keyword\">if</span>(arr[i]&lt;arr[j])&#123;<br>        tempArr[index] = arr[i];<br>        i++;<br>      &#125;<span class=\"hljs-keyword\">else</span>&#123;<span class=\"hljs-comment\">//右边数组的数小，插入到新数组</span><br>        tempArr[index] = arr[j];<br>        j++;<br>      &#125;<br>      index++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//处理左半边数组多余的数据，将左半边多余的数据直接追加的临时数组的后面</span><br>    <span class=\"hljs-keyword\">while</span>(i&lt;=center)&#123;<br>      tempArr[index] = arr[i];<br>      i++;<br>      index++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//处理右半边数组多余的数据，将右半边多余的数据直接追加的临时数组的后面</span><br>    <span class=\"hljs-keyword\">while</span>(j&lt;= high)&#123;<br>      tempArr[index] = arr[j];<br>      j++;<br>      index++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//将临时数组中的数据重新放进原数组</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; index; k++) &#123;<br>      arr[k+low] = tempArr[k];<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p>\n<p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p>\n<p><strong>快排是一种原地、不稳定的排序算法</strong></p>\n<p><strong>时间复杂度：</strong></p>\n<blockquote>\n<p>快排的时间复杂度递推求解公式跟归并是相同的。所以，<strong>快排的时间复杂度也是 O(nlogn)</strong>。</p>\n<p>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。<br>T(n) = 2*T(n/2) + n； n&gt;1</p>\n<p>公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p>\n<p><strong>最坏情况时间复杂度:O(n2)</strong></p>\n<p>T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)</p>\n</blockquote>\n<img src=\"/article/50722/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png\" class title=\"快速排序\">\n<img src=\"/article/50722/quickSort.gif\" class title=\"img\">\n<blockquote>\n<p>递推公式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><span class=\"hljs-comment\">//递推公式：</span><br>quick_sort(p…r) = quick_sort(p…q-<span class=\"hljs-number\">1</span>) + quick_sort(q+<span class=\"hljs-number\">1</span>… r)<br><br><span class=\"hljs-comment\">//终止条件：</span><br>p &gt;= r<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"算法实现-3\"><a href=\"#算法实现-3\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QuickSort</span> </span>&#123;<br><br>  <span class=\"hljs-comment\">// 快速排序，a是数组，n表示数组的大小</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    quickSortInternally(a, <span class=\"hljs-number\">0</span>, n-<span class=\"hljs-number\">1</span>);<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 快速排序递归函数，p,r为下标</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSortInternally</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (p &gt;= r) <span class=\"hljs-keyword\">return</span>;<br><br>    <span class=\"hljs-keyword\">int</span> q = partition(a, p, r); <span class=\"hljs-comment\">// 获取分区点</span><br>    quickSortInternally(a, p, q-<span class=\"hljs-number\">1</span>);<br>    quickSortInternally(a, q+<span class=\"hljs-number\">1</span>, r);<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">partition</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> pivot = a[r];<br>    <span class=\"hljs-keyword\">int</span> i = p;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = p; j &lt; r; ++j) &#123;<br>      <span class=\"hljs-keyword\">if</span> (a[j] &lt; pivot) &#123;<br>        <span class=\"hljs-keyword\">if</span> (i == j) &#123;<br>          ++i;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>          <span class=\"hljs-keyword\">int</span> tmp = a[i];<br>          a[i++] = a[j];<br>          a[j] = tmp;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">int</span> tmp = a[i];<br>    a[i] = a[r];<br>    a[r] = tmp;<br><br>    System.out.println(<span class=\"hljs-string\">&quot;i=&quot;</span> + i);<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"优化快速排序\"><a href=\"#优化快速排序\" class=\"headerlink\" title=\"优化快速排序\"></a>优化快速排序</h3><blockquote>\n<p>为什么最坏情况下快速排序的时间复杂度是 O(n<sup>2</sup>) 呢？</p>\n<p>如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n<sup>2</sup>)。实际上，<strong>这种 O(n<sup>2</sup>) 时间复杂度出现的主要原因还是因为我们分区点选得不够合理。</strong></p>\n</blockquote>\n<p>最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多。</strong></p>\n<ol>\n<li><p>三数取中法</p>\n<p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。</p>\n<p>这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。</p>\n<p>但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p>\n</li>\n<li><p>随机法</p>\n<p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。</p>\n</li>\n</ol>\n<h3 id=\"警惕堆栈溢出\"><a href=\"#警惕堆栈溢出\" class=\"headerlink\" title=\"警惕堆栈溢出\"></a>警惕堆栈溢出</h3><p>为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：</p>\n<ol>\n<li>第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。</li>\n<li>第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</li>\n</ol>\n<hr>\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>\n<p><strong>桶排序的时间复杂度是 O(n)</strong></p>\n<blockquote>\n<p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。</p>\n<p>每个桶内部使用快速排序，时间复杂度为 O(k <em> logk)。m 个桶排序的时间复杂度就是 O(m </em> k <em> logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n</em>log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p>\n</blockquote>\n<p>桶排序对要排序数据的要求是非常苛刻的:</p>\n<ol>\n<li>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</li>\n<li>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了</li>\n</ol>\n<img src=\"/article/50722/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpeg\" class title=\"桶排序\">\n<h3 id=\"算法实现-4\"><a href=\"#算法实现-4\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BucketSort</span> </span>&#123;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 桶排序</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr 数组</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> bucketSize 桶容量</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bucketSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> bucketSize)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (arr.length &lt; <span class=\"hljs-number\">2</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 数组最小值</span><br>    <span class=\"hljs-keyword\">int</span> minValue = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-comment\">// 数组最大值</span><br>    <span class=\"hljs-keyword\">int</span> maxValue = arr[<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; minValue) &#123;<br>        minValue = arr[i];<br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (arr[i] &gt; maxValue) &#123;<br>        maxValue = arr[i];<br>      &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 桶数量</span><br>    <span class=\"hljs-keyword\">int</span> bucketCount = (maxValue - minValue) / bucketSize + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">int</span>[][] buckets = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[bucketCount][bucketSize];<br>    <span class=\"hljs-keyword\">int</span>[] indexArr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[bucketCount];<br><br>    <span class=\"hljs-comment\">// 将数组中值分配到各个桶里</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>      <span class=\"hljs-keyword\">int</span> bucketIndex = (arr[i] - minValue) / bucketSize;<br>      <span class=\"hljs-keyword\">if</span> (indexArr[bucketIndex] == buckets[bucketIndex].length) &#123;<br>        ensureCapacity(buckets, bucketIndex);<br>      &#125;<br>      buckets[bucketIndex][indexArr[bucketIndex]++] = arr[i];<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 对每个桶进行排序，这里使用了快速排序</span><br>    <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; buckets.length; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (indexArr[i] == <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">continue</span>;<br>      &#125;<br>      quickSortC(buckets[i], <span class=\"hljs-number\">0</span>, indexArr[i] - <span class=\"hljs-number\">1</span>);<br>      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; indexArr[i]; j++) &#123;<br>        arr[k++] = buckets[i][j];<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 数组扩容</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> buckets</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> bucketIndex</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ensureCapacity</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] buckets, <span class=\"hljs-keyword\">int</span> bucketIndex)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span>[] tempArr = buckets[bucketIndex];<br>    <span class=\"hljs-keyword\">int</span>[] newArr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[tempArr.length * <span class=\"hljs-number\">2</span>];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; tempArr.length; j++) &#123;<br>      newArr[j] = tempArr[j];<br>    &#125;<br>    buckets[bucketIndex] = newArr;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 快速排序递归函数</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> p</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> r</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSortC</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (p &gt;= r) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">int</span> q = partition(arr, p, r);<br>    quickSortC(arr, p, q - <span class=\"hljs-number\">1</span>);<br>    quickSortC(arr, q + <span class=\"hljs-number\">1</span>, r);<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 分区函数</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> p</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> r</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span> 分区点位置</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">partition</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> pivot = arr[r];<br>    <span class=\"hljs-keyword\">int</span> i = p;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = p; j &lt; r; j++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (arr[j] &lt;= pivot) &#123;<br>        swap(arr, i, j);<br>        i++;<br>      &#125;<br>    &#125;<br><br>    swap(arr, i, r);<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 交换</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> i</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> j</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> j)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (i == j) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">int</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p><strong>计数排序其实是桶排序的一种特殊情况</strong></p>\n<p>当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>\n<p><strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong></p>\n<img src=\"/article/50722/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<h3 id=\"算法实现-5\"><a href=\"#算法实现-5\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><span class=\"hljs-comment\">// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">countingSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;<br><br>  <span class=\"hljs-comment\">// 查找数组中数据的范围</span><br>  <span class=\"hljs-keyword\">int</span> max = a[<span class=\"hljs-number\">0</span>];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i) &#123;<br>    <span class=\"hljs-keyword\">if</span> (max &lt; a[i]) &#123;<br>      max = a[i];<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">int</span>[] c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[max + <span class=\"hljs-number\">1</span>]; <span class=\"hljs-comment\">// 申请一个计数数组c，下标大小[0,max]</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= max; ++i) &#123;<br>    c[i] = <span class=\"hljs-number\">0</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 计算每个元素的个数，放入c中</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>    c[a[i]]++;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 依次累加</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= max; ++i) &#123;<br>    c[i] = c[i-<span class=\"hljs-number\">1</span>] + c[i];<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 临时数组r，存储排序之后的结果</span><br>  <span class=\"hljs-keyword\">int</span>[] r = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n];<br>  <span class=\"hljs-comment\">// 计算排序的关键步骤，有点难理解</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = n - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i) &#123;<br>    <span class=\"hljs-keyword\">int</span> index = c[a[i]]-<span class=\"hljs-number\">1</span>;<br>    r[index] = a[i];<br>    c[a[i]]--;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 将结果拷贝给a数组</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>    a[i] = r[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><p>先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。</p>\n<p><strong>这里按照每位来排序的排序算法要是稳定的</strong></p>\n<p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</strong></p>\n<img src=\"/article/50722/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<h3 id=\"实现算法\"><a href=\"#实现算法\" class=\"headerlink\" title=\"实现算法\"></a>实现算法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RadixSort</span> </span>&#123;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 基数排序</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">radixSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> max = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (arr[i] &gt; max) &#123;<br>        max = arr[i];<br>      &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 从个位开始，对数组arr按&quot;指数&quot;进行排序</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> exp = <span class=\"hljs-number\">1</span>; max / exp &gt; <span class=\"hljs-number\">0</span>; exp *= <span class=\"hljs-number\">10</span>) &#123;<br>      countingSort(arr, exp);<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 计数排序-对数组按照&quot;某个位数&quot;进行排序</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> exp 指数</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">countingSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> exp)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (arr.length &lt;= <span class=\"hljs-number\">1</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 计算每个元素的个数</span><br>    <span class=\"hljs-keyword\">int</span>[] c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">10</span>];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>      c[(arr[i] / exp) % <span class=\"hljs-number\">10</span>]++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 计算排序后的位置</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; c.length; i++) &#123;<br>      c[i] += c[i - <span class=\"hljs-number\">1</span>];<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 临时数组r，存储排序之后的结果</span><br>    <span class=\"hljs-keyword\">int</span>[] r = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[arr.length];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = arr.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;<br>      r[c[(arr[i] / exp) % <span class=\"hljs-number\">10</span>] - <span class=\"hljs-number\">1</span>] = arr[i];<br>      c[(arr[i] / exp) % <span class=\"hljs-number\">10</span>]--;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>      arr[i] = r[i];<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><img src=\"/article/50722/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><img src=\"/article/50722/%E5%A0%86%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<h2 id=\"排序优化：如何实现一个通用的、高性能的排序函数？\"><a href=\"#排序优化：如何实现一个通用的、高性能的排序函数？\" class=\"headerlink\" title=\"排序优化：如何实现一个通用的、高性能的排序函数？\"></a>排序优化：如何实现一个通用的、高性能的排序函数？</h2><img src=\"/article/50722/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg\" class title=\"排序算法总结\">\n<p>线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p>\n<p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n<sup>2</sup>) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。</p>\n<h3 id=\"举例分析排序函数\"><a href=\"#举例分析排序函数\" class=\"headerlink\" title=\"举例分析排序函数\"></a>举例分析排序函数</h3><p>qsort() 会<strong>优先使用归并排序</strong>来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序问题不大。</p>\n<p>但要排序的数据量比较大的时候，qsort() 会改为用<strong>快速排序算法</strong>来排序。qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的。</p>\n<p>实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为<strong>插入排序</strong>，不再继续用递归来做快速排序，<strong>因为在小规模数据面前，O(n<sup>2</sup>) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。</strong></p>\n","more":"<blockquote>\n<p>The mystery of creation is like the darkness of night–it is great.</p>\n<p>Delusions of knowledge are like the fog of the morning.</p>\n</blockquote>\n<p><a href=\"https://www.cnblogs.com/l199616j/p/10742603.html#_label0_0\">https://www.cnblogs.com/l199616j/p/10742603.html#_label0_0</a></p>\n<img src=\"/article/50722/sort.png\" class title=\"sort\">\n<img src=\"/article/50722/%E5%88%86%E7%B1%BB.jpg\" class title=\"分类\">\n<h2 id=\"如何分析一个“排序算法”？\"><a href=\"#如何分析一个“排序算法”？\" class=\"headerlink\" title=\"如何分析一个“排序算法”？\"></a>如何分析一个“排序算法”？</h2><h3 id=\"排序算法的执行效率\"><a href=\"#排序算法的执行效率\" class=\"headerlink\" title=\"排序算法的执行效率\"></a>排序算法的执行效率</h3><ol>\n<li>最好情况、最坏情况、平均情况时间复杂度</li>\n<li>时间复杂度的系数、常数 、低阶</li>\n<li>比较次数和交换（或移动）次数</li>\n</ol>\n<h3 id=\"排序算法的内存消耗\"><a href=\"#排序算法的内存消耗\" class=\"headerlink\" title=\"排序算法的内存消耗\"></a>排序算法的内存消耗</h3><p><strong>原地排序（Sorted in place）</strong></p>\n<p>原地排序算法，就是特指空间复杂度是 O(1) 的排序算法</p>\n<p>原地排序算法：冒泡排序、插入排序、选择排序</p>\n<h3 id=\"排序算法的稳定性\"><a href=\"#排序算法的稳定性\" class=\"headerlink\" title=\"排序算法的稳定性\"></a>排序算法的稳定性</h3><p>稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>\n<h3 id=\"“有序度”和“逆序度”\"><a href=\"#“有序度”和“逆序度”\" class=\"headerlink\" title=\"“有序度”和“逆序度”\"></a>“有序度”和“逆序度”</h3><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。</p>\n<p>完全有序的数组的有序度叫作<strong>满有序度</strong>：<strong>n*(n-1)/2</strong></p>\n<p><strong>逆序度</strong>是数组中不具有有序关系的元素对的个数。</p>\n<p><strong>逆序度 = 满有序度 - 有序度</strong></p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>\n<p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以<strong>冒泡排序是稳定的排序算法</strong>。</p>\n<h3 id=\"算法步骤\"><a href=\"#算法步骤\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们的位置；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ol>\n<img src=\"/article/50722/bubbleSort.gif\" class title=\"bubbleSort\">\n<h3 id=\"Java算法实现\"><a href=\"#Java算法实现\" class=\"headerlink\" title=\"Java算法实现\"></a>Java算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] bubbleSort(<span class=\"hljs-keyword\">int</span>[] array)&#123;<br>  <span class=\"hljs-comment\">//外层循环 判断循环走多少次</span><br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; array.length - <span class=\"hljs-number\">1</span>; i++)&#123;<br>    <span class=\"hljs-comment\">//比较相邻的元素。如果第一个比第二个大，就交换他们的位置</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; array.length - <span class=\"hljs-number\">1</span> - i; j++)&#123;<br>      <span class=\"hljs-keyword\">if</span>(array[j+<span class=\"hljs-number\">1</span>] &lt; array[j])&#123;<br>        <span class=\"hljs-keyword\">int</span> temp = array[j];<br>        array[j] = array[j+<span class=\"hljs-number\">1</span>];<br>        array[j+<span class=\"hljs-number\">1</span>] = temp;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"算法增加标志位改进\"><a href=\"#算法增加标志位改进\" class=\"headerlink\" title=\"算法增加标志位改进\"></a>算法增加标志位改进</h4><ul>\n<li>增加标志位，减少没有意义的比较</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span>[] bubbleSort(<span class=\"hljs-keyword\">int</span>[] array)&#123;<br>  <span class=\"hljs-comment\">//外层循环 判断循环走多少次</span><br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; array.length - <span class=\"hljs-number\">1</span>; i++)&#123;<br>    <span class=\"hljs-comment\">//设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成</span><br>    <span class=\"hljs-keyword\">boolean</span> flag = <span class=\"hljs-keyword\">true</span>;<br>    <span class=\"hljs-comment\">//比较相邻的元素。如果第一个比第二个大，就交换他们的位置</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; array.length - <span class=\"hljs-number\">1</span> - i; j++)&#123;<br>      <span class=\"hljs-keyword\">if</span>(array[j+<span class=\"hljs-number\">1</span>] &lt; array[j])&#123;<br>        <span class=\"hljs-keyword\">int</span> temp = array[j];<br>        array[j] = array[j+<span class=\"hljs-number\">1</span>];<br>        array[j+<span class=\"hljs-number\">1</span>] = temp;<br>        <span class=\"hljs-comment\">//相邻数字排序完成后，置为true</span><br>        flag = <span class=\"hljs-keyword\">false</span>;<br>      &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//如果其中一轮完全没有进入第二次循环中的置换顺序，说明没有需要置换的相邻元素，那么说明已经不需要再次进行排序，flag为true，可以直接跳出循环</span><br>    <span class=\"hljs-keyword\">if</span>(flag)&#123;<br>      <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>  &#125;<br>  reyurn array;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个<strong>原地排序算法</strong>。</p>\n<p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是<strong>稳定的排序算法</strong>。</p>\n<p>选择排序是一种<strong>不稳定的排序算法</strong></p>\n<img src=\"/article/50722/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<ol>\n<li>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。</li>\n<li>初始已排序区间只有一个元素，就是数组的第一个元素。</li>\n<li>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。</li>\n<li>重复这个过程，直到未排序区间中元素为空，算法结束。</li>\n</ol>\n<h3 id=\"算法实现\"><a href=\"#算法实现\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 插入排序，a表示数组，n表示数组大小</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insertionSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;<br><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i) &#123;<br>    <span class=\"hljs-keyword\">int</span> value = a[i];<br>    <span class=\"hljs-keyword\">int</span> j = i - <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-comment\">// 查找插入的位置</span><br>    <span class=\"hljs-keyword\">for</span> (; j &gt;= <span class=\"hljs-number\">0</span>; --j) &#123;<br>      <span class=\"hljs-keyword\">if</span> (a[j] &gt; value) &#123;<br>        a[j+<span class=\"hljs-number\">1</span>] = a[j];  <span class=\"hljs-comment\">// 数据移动</span><br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">break</span>;<br>      &#125;<br>    &#125;<br>    a[j+<span class=\"hljs-number\">1</span>] = value; <span class=\"hljs-comment\">// 插入数据</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p>\n<p>选择排序空间复杂度为 O(1)，是一种<strong>原地排序算法</strong></p>\n<h3 id=\"算法步骤-1\"><a href=\"#算法步骤-1\" class=\"headerlink\" title=\"算法步骤\"></a>算法步骤</h3><ol>\n<li><p>第一个跟后面的所有数相比较，如果小于（或等于）第一个数的时候，暂存较小数的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）</p>\n</li>\n<li><p>下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数</p>\n</li>\n<li>重复以上步骤，直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。</li>\n</ol>\n<img src=\"/article/50722/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<h3 id=\"算法实现-1\"><a href=\"#算法实现-1\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Arrays;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Main</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span>[] n = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[]&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">33</span>,<span class=\"hljs-number\">27</span>,<span class=\"hljs-number\">66</span>,<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">88</span>&#125;;<br>    <span class=\"hljs-keyword\">int</span> temp,index = -<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n.length-<span class=\"hljs-number\">1</span>; i++) &#123;<br>      index=i;<br>      <span class=\"hljs-comment\">//如果大于，暂存较小的数的下标</span><br>      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = i+<span class=\"hljs-number\">1</span>; j &lt;n.length; j++) &#123;<br>        <span class=\"hljs-keyword\">if</span>(n[index]&gt;n[j])&#123;<br>          index = j;<br>        &#125;<br>      &#125;<br>      <span class=\"hljs-comment\">////将一趟下来求出的最小数，与这个数交换</span><br>      <span class=\"hljs-keyword\">if</span>(index&gt;<span class=\"hljs-number\">0</span>)&#123;<br>        temp = n[i];<br>        n[i] = n[index];<br>        n[index] = temp;<br>      &#125;<br>      System.out.println(Arrays.toString(n));<br>    &#125;<br>    System.out.println(Arrays.toString(n));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>核心思想:如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p>\n<p>在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素，先把 A[p…q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，<strong>归并排序是一个稳定的排序算法</strong>。</p>\n<p><strong>时间复杂度：</strong></p>\n<blockquote>\n<p><strong>T(a) = T(b) + T(c) + K</strong></p>\n<p>其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。</p>\n<p>我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。我们知道，merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</p>\n<p><strong>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。</strong><br><strong>T(n) = 2*T(n/2) + n； n&gt;1</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">T(n) = 2*T(n/2) + n<br>     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n<br>     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n<br>     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n<br>     ......<br>     = 2^k * T(n/2^k) + k * n<br>     ......<br></code></pre></td></tr></table></figure>\n<p>通过这样一步一步分解推导，我们可以得到 <strong>T(n) = 2^kT(n/2^k)+kn</strong>。当 <strong>T(n/2^k)=T(1)</strong> 时，也就是 n/2^k=1，我们得到 <strong>k=log2n</strong> 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。</p>\n<p>如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以<strong>归并排序的时间复杂度是 O(nlogn)</strong>。</p>\n<p>归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)</p>\n</blockquote>\n<p><strong>空间复杂度</strong>是 O(n)</p>\n<blockquote>\n<img src=\"/article/50722/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%88%86%E8%A7%A3%E5%9B%BE.jpg\" class title=\"归并排序分解图\">\n</blockquote>\n<p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。</p>\n<blockquote>\n<p>分治是一种解决问题的处理思想，递归是一种编程技巧</p>\n</blockquote>\n<img src=\"/article/50722/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<blockquote>\n<p>递推公式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//递推公式：</span><br>merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+<span class=\"hljs-number\">1</span>…r))<br><br><span class=\"hljs-comment\">//终止条件：</span><br>p &gt;= r 不用再继续分解<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"算法实现-2\"><a href=\"#算法实现-2\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Arrays;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Main</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span>[] arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[]&#123;<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>&#125;;<br>    merge(arr,<span class=\"hljs-number\">0</span>,arr.length-<span class=\"hljs-number\">1</span>);<br>    System.out.println(Arrays.toString(arr));<br>  &#125;<br><br>  <span class=\"hljs-comment\">//归并</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr,<span class=\"hljs-keyword\">int</span> low,<span class=\"hljs-keyword\">int</span> high)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> center = (high+low)/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span>(low&lt;high)&#123;<br>      <span class=\"hljs-comment\">//递归，直到low==high，也就是数组已不能再分了，</span><br>      merge(arr,low,center);<br>      merge(arr,center+<span class=\"hljs-number\">1</span>,high);<br><br>      <span class=\"hljs-comment\">//当数组不能再分，开始归并排序</span><br>      mergeSort(arr,low,center,high);<br>      System.out.println(Arrays.toString(arr));<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-comment\">//排序</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mergeSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr,<span class=\"hljs-keyword\">int</span> low,<span class=\"hljs-keyword\">int</span> center,<span class=\"hljs-keyword\">int</span> high)</span></span>&#123;<br>    <span class=\"hljs-comment\">//用于暂存排序后的数组的临时数组</span><br>    <span class=\"hljs-keyword\">int</span>[] tempArr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[arr.length];<br>    <span class=\"hljs-keyword\">int</span> i = low,j = center+<span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-comment\">//临时数组的下标</span><br>    <span class=\"hljs-keyword\">int</span> index = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-comment\">//循环遍历两个数组的数字，将小的插入到临时数组里</span><br>    <span class=\"hljs-keyword\">while</span>(i&lt;=center &amp;&amp; j&lt;= high)&#123;<br><br>      <span class=\"hljs-comment\">//左边数组的数小，插入到新数组</span><br>      <span class=\"hljs-keyword\">if</span>(arr[i]&lt;arr[j])&#123;<br>        tempArr[index] = arr[i];<br>        i++;<br>      &#125;<span class=\"hljs-keyword\">else</span>&#123;<span class=\"hljs-comment\">//右边数组的数小，插入到新数组</span><br>        tempArr[index] = arr[j];<br>        j++;<br>      &#125;<br>      index++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//处理左半边数组多余的数据，将左半边多余的数据直接追加的临时数组的后面</span><br>    <span class=\"hljs-keyword\">while</span>(i&lt;=center)&#123;<br>      tempArr[index] = arr[i];<br>      i++;<br>      index++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//处理右半边数组多余的数据，将右半边多余的数据直接追加的临时数组的后面</span><br>    <span class=\"hljs-keyword\">while</span>(j&lt;= high)&#123;<br>      tempArr[index] = arr[j];<br>      j++;<br>      index++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">//将临时数组中的数据重新放进原数组</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; index; k++) &#123;<br>      arr[k+low] = tempArr[k];<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p>\n<p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p>\n<p><strong>快排是一种原地、不稳定的排序算法</strong></p>\n<p><strong>时间复杂度：</strong></p>\n<blockquote>\n<p>快排的时间复杂度递推求解公式跟归并是相同的。所以，<strong>快排的时间复杂度也是 O(nlogn)</strong>。</p>\n<p>T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。<br>T(n) = 2*T(n/2) + n； n&gt;1</p>\n<p>公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p>\n<p><strong>最坏情况时间复杂度:O(n2)</strong></p>\n<p>T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)</p>\n</blockquote>\n<img src=\"/article/50722/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png\" class title=\"快速排序\">\n<img src=\"/article/50722/quickSort.gif\" class title=\"img\">\n<blockquote>\n<p>递推公式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><span class=\"hljs-comment\">//递推公式：</span><br>quick_sort(p…r) = quick_sort(p…q-<span class=\"hljs-number\">1</span>) + quick_sort(q+<span class=\"hljs-number\">1</span>… r)<br><br><span class=\"hljs-comment\">//终止条件：</span><br>p &gt;= r<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"算法实现-3\"><a href=\"#算法实现-3\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QuickSort</span> </span>&#123;<br><br>  <span class=\"hljs-comment\">// 快速排序，a是数组，n表示数组的大小</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    quickSortInternally(a, <span class=\"hljs-number\">0</span>, n-<span class=\"hljs-number\">1</span>);<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 快速排序递归函数，p,r为下标</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSortInternally</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (p &gt;= r) <span class=\"hljs-keyword\">return</span>;<br><br>    <span class=\"hljs-keyword\">int</span> q = partition(a, p, r); <span class=\"hljs-comment\">// 获取分区点</span><br>    quickSortInternally(a, p, q-<span class=\"hljs-number\">1</span>);<br>    quickSortInternally(a, q+<span class=\"hljs-number\">1</span>, r);<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">partition</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> pivot = a[r];<br>    <span class=\"hljs-keyword\">int</span> i = p;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j = p; j &lt; r; ++j) &#123;<br>      <span class=\"hljs-keyword\">if</span> (a[j] &lt; pivot) &#123;<br>        <span class=\"hljs-keyword\">if</span> (i == j) &#123;<br>          ++i;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>          <span class=\"hljs-keyword\">int</span> tmp = a[i];<br>          a[i++] = a[j];<br>          a[j] = tmp;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">int</span> tmp = a[i];<br>    a[i] = a[r];<br>    a[r] = tmp;<br><br>    System.out.println(<span class=\"hljs-string\">&quot;i=&quot;</span> + i);<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"优化快速排序\"><a href=\"#优化快速排序\" class=\"headerlink\" title=\"优化快速排序\"></a>优化快速排序</h3><blockquote>\n<p>为什么最坏情况下快速排序的时间复杂度是 O(n<sup>2</sup>) 呢？</p>\n<p>如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n<sup>2</sup>)。实际上，<strong>这种 O(n<sup>2</sup>) 时间复杂度出现的主要原因还是因为我们分区点选得不够合理。</strong></p>\n</blockquote>\n<p>最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多。</strong></p>\n<ol>\n<li><p>三数取中法</p>\n<p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。</p>\n<p>这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。</p>\n<p>但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p>\n</li>\n<li><p>随机法</p>\n<p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。</p>\n</li>\n</ol>\n<h3 id=\"警惕堆栈溢出\"><a href=\"#警惕堆栈溢出\" class=\"headerlink\" title=\"警惕堆栈溢出\"></a>警惕堆栈溢出</h3><p>为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：</p>\n<ol>\n<li>第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。</li>\n<li>第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</li>\n</ol>\n<hr>\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>\n<p><strong>桶排序的时间复杂度是 O(n)</strong></p>\n<blockquote>\n<p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。</p>\n<p>每个桶内部使用快速排序，时间复杂度为 O(k <em> logk)。m 个桶排序的时间复杂度就是 O(m </em> k <em> logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n</em>log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p>\n</blockquote>\n<p>桶排序对要排序数据的要求是非常苛刻的:</p>\n<ol>\n<li>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</li>\n<li>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了</li>\n</ol>\n<img src=\"/article/50722/%E6%A1%B6%E6%8E%92%E5%BA%8F.jpeg\" class title=\"桶排序\">\n<h3 id=\"算法实现-4\"><a href=\"#算法实现-4\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BucketSort</span> </span>&#123;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 桶排序</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr 数组</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> bucketSize 桶容量</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bucketSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> bucketSize)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (arr.length &lt; <span class=\"hljs-number\">2</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 数组最小值</span><br>    <span class=\"hljs-keyword\">int</span> minValue = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-comment\">// 数组最大值</span><br>    <span class=\"hljs-keyword\">int</span> maxValue = arr[<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; minValue) &#123;<br>        minValue = arr[i];<br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (arr[i] &gt; maxValue) &#123;<br>        maxValue = arr[i];<br>      &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 桶数量</span><br>    <span class=\"hljs-keyword\">int</span> bucketCount = (maxValue - minValue) / bucketSize + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">int</span>[][] buckets = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[bucketCount][bucketSize];<br>    <span class=\"hljs-keyword\">int</span>[] indexArr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[bucketCount];<br><br>    <span class=\"hljs-comment\">// 将数组中值分配到各个桶里</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>      <span class=\"hljs-keyword\">int</span> bucketIndex = (arr[i] - minValue) / bucketSize;<br>      <span class=\"hljs-keyword\">if</span> (indexArr[bucketIndex] == buckets[bucketIndex].length) &#123;<br>        ensureCapacity(buckets, bucketIndex);<br>      &#125;<br>      buckets[bucketIndex][indexArr[bucketIndex]++] = arr[i];<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 对每个桶进行排序，这里使用了快速排序</span><br>    <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; buckets.length; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (indexArr[i] == <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">continue</span>;<br>      &#125;<br>      quickSortC(buckets[i], <span class=\"hljs-number\">0</span>, indexArr[i] - <span class=\"hljs-number\">1</span>);<br>      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; indexArr[i]; j++) &#123;<br>        arr[k++] = buckets[i][j];<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 数组扩容</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> buckets</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> bucketIndex</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ensureCapacity</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[][] buckets, <span class=\"hljs-keyword\">int</span> bucketIndex)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span>[] tempArr = buckets[bucketIndex];<br>    <span class=\"hljs-keyword\">int</span>[] newArr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[tempArr.length * <span class=\"hljs-number\">2</span>];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; tempArr.length; j++) &#123;<br>      newArr[j] = tempArr[j];<br>    &#125;<br>    buckets[bucketIndex] = newArr;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 快速排序递归函数</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> p</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> r</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSortC</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (p &gt;= r) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">int</span> q = partition(arr, p, r);<br>    quickSortC(arr, p, q - <span class=\"hljs-number\">1</span>);<br>    quickSortC(arr, q + <span class=\"hljs-number\">1</span>, r);<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 分区函数</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> p</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> r</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@return</span> 分区点位置</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">partition</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> pivot = arr[r];<br>    <span class=\"hljs-keyword\">int</span> i = p;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = p; j &lt; r; j++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (arr[j] &lt;= pivot) &#123;<br>        swap(arr, i, j);<br>        i++;<br>      &#125;<br>    &#125;<br><br>    swap(arr, i, r);<br>    <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 交换</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> i</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> j</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> j)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (i == j) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">int</span> tmp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h2><p><strong>计数排序其实是桶排序的一种特殊情况</strong></p>\n<p>当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p>\n<p><strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong></p>\n<img src=\"/article/50722/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<h3 id=\"算法实现-5\"><a href=\"#算法实现-5\" class=\"headerlink\" title=\"算法实现\"></a>算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><span class=\"hljs-comment\">// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">countingSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span>;<br><br>  <span class=\"hljs-comment\">// 查找数组中数据的范围</span><br>  <span class=\"hljs-keyword\">int</span> max = a[<span class=\"hljs-number\">0</span>];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i) &#123;<br>    <span class=\"hljs-keyword\">if</span> (max &lt; a[i]) &#123;<br>      max = a[i];<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-keyword\">int</span>[] c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[max + <span class=\"hljs-number\">1</span>]; <span class=\"hljs-comment\">// 申请一个计数数组c，下标大小[0,max]</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= max; ++i) &#123;<br>    c[i] = <span class=\"hljs-number\">0</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 计算每个元素的个数，放入c中</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>    c[a[i]]++;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 依次累加</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= max; ++i) &#123;<br>    c[i] = c[i-<span class=\"hljs-number\">1</span>] + c[i];<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 临时数组r，存储排序之后的结果</span><br>  <span class=\"hljs-keyword\">int</span>[] r = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n];<br>  <span class=\"hljs-comment\">// 计算排序的关键步骤，有点难理解</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = n - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i) &#123;<br>    <span class=\"hljs-keyword\">int</span> index = c[a[i]]-<span class=\"hljs-number\">1</span>;<br>    r[index] = a[i];<br>    c[a[i]]--;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 将结果拷贝给a数组</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>    a[i] = r[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><p>先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。</p>\n<p><strong>这里按照每位来排序的排序算法要是稳定的</strong></p>\n<p><strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</strong></p>\n<img src=\"/article/50722/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<h3 id=\"实现算法\"><a href=\"#实现算法\" class=\"headerlink\" title=\"实现算法\"></a>实现算法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RadixSort</span> </span>&#123;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 基数排序</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">radixSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> max = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (arr[i] &gt; max) &#123;<br>        max = arr[i];<br>      &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 从个位开始，对数组arr按&quot;指数&quot;进行排序</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> exp = <span class=\"hljs-number\">1</span>; max / exp &gt; <span class=\"hljs-number\">0</span>; exp *= <span class=\"hljs-number\">10</span>) &#123;<br>      countingSort(arr, exp);<br>    &#125;<br>  &#125;<br><br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * 计数排序-对数组按照&quot;某个位数&quot;进行排序</span><br><span class=\"hljs-comment\">     *</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> arr</span><br><span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> exp 指数</span><br><span class=\"hljs-comment\">     */</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">countingSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] arr, <span class=\"hljs-keyword\">int</span> exp)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (arr.length &lt;= <span class=\"hljs-number\">1</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 计算每个元素的个数</span><br>    <span class=\"hljs-keyword\">int</span>[] c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">10</span>];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>      c[(arr[i] / exp) % <span class=\"hljs-number\">10</span>]++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 计算排序后的位置</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; c.length; i++) &#123;<br>      c[i] += c[i - <span class=\"hljs-number\">1</span>];<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 临时数组r，存储排序之后的结果</span><br>    <span class=\"hljs-keyword\">int</span>[] r = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[arr.length];<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = arr.length - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;<br>      r[c[(arr[i] / exp) % <span class=\"hljs-number\">10</span>] - <span class=\"hljs-number\">1</span>] = arr[i];<br>      c[(arr[i] / exp) % <span class=\"hljs-number\">10</span>]--;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.length; i++) &#123;<br>      arr[i] = r[i];<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><img src=\"/article/50722/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><img src=\"/article/50722/%E5%A0%86%E6%8E%92%E5%BA%8F.gif\" class title=\"img\">\n<h2 id=\"排序优化：如何实现一个通用的、高性能的排序函数？\"><a href=\"#排序优化：如何实现一个通用的、高性能的排序函数？\" class=\"headerlink\" title=\"排序优化：如何实现一个通用的、高性能的排序函数？\"></a>排序优化：如何实现一个通用的、高性能的排序函数？</h2><img src=\"/article/50722/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.jpg\" class title=\"排序算法总结\">\n<p>线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p>\n<p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n<sup>2</sup>) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。</p>\n<h3 id=\"举例分析排序函数\"><a href=\"#举例分析排序函数\" class=\"headerlink\" title=\"举例分析排序函数\"></a>举例分析排序函数</h3><p>qsort() 会<strong>优先使用归并排序</strong>来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序问题不大。</p>\n<p>但要排序的数据量比较大的时候，qsort() 会改为用<strong>快速排序算法</strong>来排序。qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的。</p>\n<p>实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为<strong>插入排序</strong>，不再继续用递归来做快速排序，<strong>因为在小规模数据面前，O(n<sup>2</sup>) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。</strong></p>\n","categories":[{"name":"语言","path":"api/categories/语言.json"},{"name":"Java","path":"api/categories/Java.json"},{"name":"数据结构与算法","path":"api/categories/数据结构与算法.json"},{"name":"排序","path":"api/categories/排序.json"}],"tags":[{"name":"Java,数据结构与算法","path":"api/tags/Java,数据结构与算法.json"}]}