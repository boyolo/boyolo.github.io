{"title":"Redis核心技术与实战","slug":"Redis核心技术与实战","date":"2022-05-20T16:03:36.000Z","updated":"2022-05-22T03:10:48.406Z","comments":true,"path":"api/articles/Redis核心技术与实战.json","realPath":null,"excerpt":null,"covers":["/article/undefined/Redis%E9%97%AE%E9%A2%98%E7%94%BB%E5%83%8F.jpeg","/article/undefined/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg","/article/undefined/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.jpg","/article/undefined/%E8%B7%B3%E8%A1%A8.jpg","/article/undefined/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.jpg","/article/undefined/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg","/article/undefined/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg","/article/undefined/Redis%E5%9F%BA%E6%9C%ACIO%E6%A8%A1%E5%9E%8B.jpg","/article/undefined/Redis%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AE%BE%E7%BD%AE.jpg","/article/undefined/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B.webp"],"cover":"/images/theme/coverphoto/redis.jpg","content":"<p><a href=\"https://time.geekbang.org/column/article/268247\">参考</a></p>\n<p><strong>Redis 知识全景图包括“两大维度，三大主线”</strong></p>\n<p><img src=\"/article/Redis 知识全景图.jpg\"><span class=\"image-caption\">Redis 知识全景图</span></p>\n<p><strong>Redis问题画像</strong></p>\n<img src=\"/article/undefined/Redis%E9%97%AE%E9%A2%98%E7%94%BB%E5%83%8F.jpeg\" class title=\"Redis问题画像\">\n<h2 id=\"Redis数据结构\"><a href=\"#Redis数据结构\" class=\"headerlink\" title=\"Redis数据结构\"></a>Redis数据结构</h2><blockquote>\n<p><strong>Redis 的快，到底是快在哪里呢？</strong></p>\n<p><strong>一方面</strong>，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。</p>\n<p><strong>另一方面</strong>，这要归功于它的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。</p>\n</blockquote>\n<p>底层数据结构一共有 6 种，分别是<strong>简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组</strong></p>\n<img src=\"/article/undefined/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg\" class title=\"底层数据结构\">\n<p>List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p>\n<p><strong>压缩列表</strong>实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 <strong>zlbytes、zltail 和 zllen</strong>，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 <strong>zlend</strong>，表示列表结束。</p>\n<img src=\"/article/undefined/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.jpg\" class title=\"压缩列表\">\n<p><strong>跳表</strong>在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</p>\n<img src=\"/article/undefined/%E8%B7%B3%E8%A1%A8.jpg\" class title=\"跳表\">\n<h3 id=\"键和值用什么结构组织？\"><a href=\"#键和值用什么结构组织？\" class=\"headerlink\" title=\"键和值用什么结构组织？\"></a>键和值用什么结构组织？</h3><p><strong>Redis 使用了一个哈希表来保存所有键值对：</strong>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶，哈希桶中的元素保存的并不是值本身，而是<strong>指向具体值的指针</strong>。</p>\n<p>哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值</p>\n<img src=\"/article/undefined/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.jpg\" class title=\"全局哈希表\">\n<p>可以用 <strong>O(1) 的时间复杂度</strong>来快速查找到键值对——只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素</p>\n<h3 id=\"哈希冲突\"><a href=\"#哈希冲突\" class=\"headerlink\" title=\"哈希冲突\"></a>哈希冲突</h3><p>两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中</p>\n<ol>\n<li><p>链式哈希</p>\n<p>Redis 解决哈希冲突的方式，就是链式哈希。<strong>指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。</strong></p>\n<img src=\"/article/undefined/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg\" class title=\"链表法\">\n</li>\n<li><p>rehash</p>\n<p>如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低</p>\n<p><strong>Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突</strong></p>\n<blockquote>\n<p>Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>\n<ol>\n<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>\n<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>\n<li>释放哈希表 1 的空间。</li>\n</ol>\n<p>从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用</p>\n<p><strong>问题：第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求</strong></p>\n</blockquote>\n<p><strong>渐进式 rehash</strong></p>\n<p>在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：</p>\n<p><img src=\"/article/渐进式 rehash.jpg\"><span class=\"image-caption\">渐进式 rehash</span></p>\n</li>\n</ol>\n<h3 id=\"不同数据结构查找的时间复杂度\"><a href=\"#不同数据结构查找的时间复杂度\" class=\"headerlink\" title=\"不同数据结构查找的时间复杂度\"></a>不同数据结构查找的时间复杂度</h3><img src=\"/article/undefined/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg\" class title=\"时间复杂度\">\n<ol>\n<li>单元素操作，是指每一种集合类型对单个数据实现的增删改查操作，复杂度都是 O(1)</li>\n<li>范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。</li>\n<li>统计操作，是指集合类型对集合中所有元素个数的记录。这类操作复杂度只有 O(1)。</li>\n<li>例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</li>\n</ol>\n<h2 id=\"Redis：高性能IO模型\"><a href=\"#Redis：高性能IO模型\" class=\"headerlink\" title=\"Redis：高性能IO模型\"></a>Redis：高性能IO模型</h2><p><strong>Redis 是单线程，主要是指 Redis 的<u>网络 IO 和键值对读写</u>是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。</strong></p>\n<p><strong>采用单线程的一个核心原因是避免多线程开发的并发控制问题</strong></p>\n<p>一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，这是它实现高性能的一个重要原因。</p>\n<p>另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p>\n<h3 id=\"Socket-网络模型的非阻塞模式\"><a href=\"#Socket-网络模型的非阻塞模式\" class=\"headerlink\" title=\"Socket 网络模型的非阻塞模式\"></a>Socket 网络模型的非阻塞模式</h3><blockquote>\n<p>以 Get 请求为例，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。</p>\n<img src=\"/article/undefined/Redis%E5%9F%BA%E6%9C%ACIO%E6%A8%A1%E5%9E%8B.jpg\" class title=\"Redis基本IO模型\">\n<p>但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。</p>\n</blockquote>\n<p>在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。</p>\n<img src=\"/article/undefined/Redis%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AE%BE%E7%BD%AE.jpg\" class title=\"Redis套接字类型与非阻塞设置\">\n<p>针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 accept() 时，已经存在监听套接字了。</p>\n<blockquote>\n<p>要有机制继续监听监听套接字或已连接套接字，并在有数据达到时通知 Redis。</p>\n</blockquote>\n<h3 id=\"基于多路复用的高性能-I-O-模型\"><a href=\"#基于多路复用的高性能-I-O-模型\" class=\"headerlink\" title=\"基于多路复用的高性能 I/O 模型\"></a>基于多路复用的高性能 I/O 模型</h3><p>Linux 中的 IO 多路复用机制是指<strong>一个线程处理多个 IO 流</strong>，就是select/epoll 机制。</p>\n<p>在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>\n<img src=\"/article/undefined/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B.webp\" class title=\"基于多路复用的Redis高性能IO模型\">\n<p>图中的多个 FD 就是多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。</p>\n<p><strong>回调机制</strong></p>\n<p>为了在请求到达时能通知到 Redis 线程，<strong>select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数</strong>。</p>\n<p>select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。</p>\n","more":"<p><a href=\"https://time.geekbang.org/column/article/268247\">参考</a></p>\n<p><strong>Redis 知识全景图包括“两大维度，三大主线”</strong></p>\n<p><img src=\"/article/Redis 知识全景图.jpg\"><span class=\"image-caption\">Redis 知识全景图</span></p>\n<p><strong>Redis问题画像</strong></p>\n<img src=\"/article/undefined/Redis%E9%97%AE%E9%A2%98%E7%94%BB%E5%83%8F.jpeg\" class title=\"Redis问题画像\">\n<h2 id=\"Redis数据结构\"><a href=\"#Redis数据结构\" class=\"headerlink\" title=\"Redis数据结构\"></a>Redis数据结构</h2><blockquote>\n<p><strong>Redis 的快，到底是快在哪里呢？</strong></p>\n<p><strong>一方面</strong>，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。</p>\n<p><strong>另一方面</strong>，这要归功于它的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。</p>\n</blockquote>\n<p>底层数据结构一共有 6 种，分别是<strong>简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组</strong></p>\n<img src=\"/article/undefined/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg\" class title=\"底层数据结构\">\n<p>List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p>\n<p><strong>压缩列表</strong>实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 <strong>zlbytes、zltail 和 zllen</strong>，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 <strong>zlend</strong>，表示列表结束。</p>\n<img src=\"/article/undefined/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.jpg\" class title=\"压缩列表\">\n<p><strong>跳表</strong>在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</p>\n<img src=\"/article/undefined/%E8%B7%B3%E8%A1%A8.jpg\" class title=\"跳表\">\n<h3 id=\"键和值用什么结构组织？\"><a href=\"#键和值用什么结构组织？\" class=\"headerlink\" title=\"键和值用什么结构组织？\"></a>键和值用什么结构组织？</h3><p><strong>Redis 使用了一个哈希表来保存所有键值对：</strong>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶，哈希桶中的元素保存的并不是值本身，而是<strong>指向具体值的指针</strong>。</p>\n<p>哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值</p>\n<img src=\"/article/undefined/%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.jpg\" class title=\"全局哈希表\">\n<p>可以用 <strong>O(1) 的时间复杂度</strong>来快速查找到键值对——只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素</p>\n<h3 id=\"哈希冲突\"><a href=\"#哈希冲突\" class=\"headerlink\" title=\"哈希冲突\"></a>哈希冲突</h3><p>两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中</p>\n<ol>\n<li><p>链式哈希</p>\n<p>Redis 解决哈希冲突的方式，就是链式哈希。<strong>指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。</strong></p>\n<img src=\"/article/undefined/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg\" class title=\"链表法\">\n</li>\n<li><p>rehash</p>\n<p>如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低</p>\n<p><strong>Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突</strong></p>\n<blockquote>\n<p>Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>\n<ol>\n<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>\n<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>\n<li>释放哈希表 1 的空间。</li>\n</ol>\n<p>从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用</p>\n<p><strong>问题：第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求</strong></p>\n</blockquote>\n<p><strong>渐进式 rehash</strong></p>\n<p>在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：</p>\n<p><img src=\"/article/渐进式 rehash.jpg\"><span class=\"image-caption\">渐进式 rehash</span></p>\n</li>\n</ol>\n<h3 id=\"不同数据结构查找的时间复杂度\"><a href=\"#不同数据结构查找的时间复杂度\" class=\"headerlink\" title=\"不同数据结构查找的时间复杂度\"></a>不同数据结构查找的时间复杂度</h3><img src=\"/article/undefined/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.jpg\" class title=\"时间复杂度\">\n<ol>\n<li>单元素操作，是指每一种集合类型对单个数据实现的增删改查操作，复杂度都是 O(1)</li>\n<li>范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。</li>\n<li>统计操作，是指集合类型对集合中所有元素个数的记录。这类操作复杂度只有 O(1)。</li>\n<li>例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</li>\n</ol>\n<h2 id=\"Redis：高性能IO模型\"><a href=\"#Redis：高性能IO模型\" class=\"headerlink\" title=\"Redis：高性能IO模型\"></a>Redis：高性能IO模型</h2><p><strong>Redis 是单线程，主要是指 Redis 的<u>网络 IO 和键值对读写</u>是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。</strong></p>\n<p><strong>采用单线程的一个核心原因是避免多线程开发的并发控制问题</strong></p>\n<p>一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，这是它实现高性能的一个重要原因。</p>\n<p>另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p>\n<h3 id=\"Socket-网络模型的非阻塞模式\"><a href=\"#Socket-网络模型的非阻塞模式\" class=\"headerlink\" title=\"Socket 网络模型的非阻塞模式\"></a>Socket 网络模型的非阻塞模式</h3><blockquote>\n<p>以 Get 请求为例，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。</p>\n<img src=\"/article/undefined/Redis%E5%9F%BA%E6%9C%ACIO%E6%A8%A1%E5%9E%8B.jpg\" class title=\"Redis基本IO模型\">\n<p>但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。</p>\n</blockquote>\n<p>在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。</p>\n<img src=\"/article/undefined/Redis%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AE%BE%E7%BD%AE.jpg\" class title=\"Redis套接字类型与非阻塞设置\">\n<p>针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 accept() 时，已经存在监听套接字了。</p>\n<blockquote>\n<p>要有机制继续监听监听套接字或已连接套接字，并在有数据达到时通知 Redis。</p>\n</blockquote>\n<h3 id=\"基于多路复用的高性能-I-O-模型\"><a href=\"#基于多路复用的高性能-I-O-模型\" class=\"headerlink\" title=\"基于多路复用的高性能 I/O 模型\"></a>基于多路复用的高性能 I/O 模型</h3><p>Linux 中的 IO 多路复用机制是指<strong>一个线程处理多个 IO 流</strong>，就是select/epoll 机制。</p>\n<p>在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>\n<img src=\"/article/undefined/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84Redis%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B.webp\" class title=\"基于多路复用的Redis高性能IO模型\">\n<p>图中的多个 FD 就是多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。</p>\n<p><strong>回调机制</strong></p>\n<p>为了在请求到达时能通知到 Redis 线程，<strong>select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数</strong>。</p>\n<p>select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。</p>\n","categories":[{"name":"Redis","path":"api/categories/Redis.json"}],"tags":[{"name":"Redis","path":"api/tags/Redis.json"}]}