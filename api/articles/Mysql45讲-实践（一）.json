{"title":"Mysql45讲-实践（一）","slug":"Mysql45讲-实践（一）","date":"2022-03-30T06:49:39.000Z","updated":"2022-04-13T15:28:31.252Z","comments":true,"path":"api/articles/Mysql45讲-实践（一）.json","realPath":null,"excerpt":null,"covers":["/article/46662/%E5%81%87%E8%AE%BE%E6%89%AB%E6%8F%8F%E5%88%B0%E7%9A%84%E8%A1%8C%E9%83%BD%E8%A2%AB%E5%8A%A0%E4%B8%8A%E4%BA%86%E8%A1%8C%E9%94%81.png","/article/46662/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8A%E7%9A%84%E8%A1%8C%E9%94%81%E5%92%8C%E9%97%B4%E9%9A%99%E9%94%81.png","/article/46662/%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%97%B4%E9%9A%99%E9%94%81.png","/article/46662/%E5%8F%AA%E5%8A%A0%E5%9C%A8%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8A%E7%9A%84%E9%94%81.png","/article/46662/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8A%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%94%81.png","/article/46662/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81.png","/article/46662/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E7%9A%84%E4%BE%8B%E5%AD%90.png","/article/46662/%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97.png"],"cover":"/images/theme/coverphoto/Mysql.jpg","content":"<h2 id=\"普通索引和唯一索引，应该怎么选择？\"><a href=\"#普通索引和唯一索引，应该怎么选择？\" class=\"headerlink\" title=\"普通索引和唯一索引，应该怎么选择？\"></a>普通索引和唯一索引，应该怎么选择？</h2><h3 id=\"更新过程\"><a href=\"#更新过程\" class=\"headerlink\" title=\"更新过程\"></a>更新过程</h3><p><strong>change buffer</strong></p>\n<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些<strong>更新操作</strong>缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>\n<p>需要说明的是，虽然名字叫作 change buffer，实际上它是<strong>可以持久化的数据</strong>。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p>\n<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 <strong>merge</strong>。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p>\n<blockquote>\n<p>merge 的执行流程是这样的：</p>\n<ol>\n<li>从磁盘读入数据页到内存（老版本的数据页）；</li>\n<li>从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；</li>\n<li>写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。</li>\n</ol>\n<p>这时候，数据页和内存中 change buffer 对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</p>\n</blockquote>\n<p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够<strong>避免占用内存，提高内存利用率。</strong></p>\n<blockquote>\n<p><strong>问题：什么条件下可以使用 change buffer 呢？</strong></p>\n<p>对于<strong>唯一索引</strong>来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p>\n<p><strong>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</strong></p>\n</blockquote>\n<p>change buffer 用的是 buffer pool 里的内存，因此<strong>不能无限增大</strong>。change buffer 的大小，可以通过参数 <code>innodb_change_buffer_max_size</code> 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p>\n<p><strong>在表中插入一个新纪录，InnoDB处理流程：</strong></p>\n<ol>\n<li>这个记录要更新的目标页在内存中<ol>\n<li>对于唯一索引来说，找到位置，判断到没有冲突，插入这个值，语句执行结束；</li>\n<li>对于普通索引来说，找到位置，插入这个值，语句执行结束。</li>\n</ol>\n</li>\n<li><strong>这个记录要更新的目标页不在内存中</strong><ol>\n<li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li>\n<li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li>\n</ol>\n</li>\n</ol>\n<p>将数据从磁盘读入内存涉及<strong>随机 IO 的访问，是数据库里面成本最高的操作之一</strong>。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>\n<blockquote>\n<p>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p>\n<p>反过来，假设一个业务的更新模式是<strong>写入之后马上会做查询</strong>，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p>\n</blockquote>\n<h3 id=\"索引选择和实践\"><a href=\"#索引选择和实践\" class=\"headerlink\" title=\"索引选择和实践\"></a>索引选择和实践</h3><p><strong>建议尽量选择普通索引</strong></p>\n<p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p>\n<ol>\n<li>首先，业务正确性优先。</li>\n<li>然后，在一些“归档库”的场景，你是可以考虑使用普通索引的。</li>\n</ol>\n<h3 id=\"change-buffer-和-redo-log\"><a href=\"#change-buffer-和-redo-log\" class=\"headerlink\" title=\"change buffer 和 redo log\"></a>change buffer 和 redo log</h3><p>如果要简单地对比这两个机制在提升更新性能上的收益的话</p>\n<p><strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写）</strong>，</p>\n<p><strong>change buffer 主要节省的则是随机读磁盘的 IO 消耗</strong></p>\n<hr>\n<p><strong>问题：change buffer 一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？change buffer 丢失可不是小事儿，再从磁盘读入数据可就没有了 merge 过程，就等于是数据丢失了。会不会出现这种情况呢？</strong></p>\n<blockquote>\n<p><strong>不会丢失</strong></p>\n<p>虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。</p>\n</blockquote>\n<hr>\n<h2 id=\"MySQL为什么有时候会选错索引？\"><a href=\"#MySQL为什么有时候会选错索引？\" class=\"headerlink\" title=\"MySQL为什么有时候会选错索引？\"></a>MySQL为什么有时候会选错索引？</h2><h3 id=\"优化器的逻辑\"><a href=\"#优化器的逻辑\" class=\"headerlink\" title=\"优化器的逻辑\"></a>优化器的逻辑</h3><p><strong>选择索引是优化器的工作。</strong></p>\n<p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p>\n<p><strong>扫描行数</strong>并不是唯一的判断标准，优化器还会结合<strong>是否使用临时表、是否排序</strong>等因素进行综合判断。</p>\n<h3 id=\"扫描行数是怎么判断的？\"><a href=\"#扫描行数是怎么判断的？\" class=\"headerlink\" title=\"扫描行数是怎么判断的？\"></a>扫描行数是怎么判断的？</h3><p><strong>区分度</strong></p>\n<p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据<strong>统计信息</strong>来估算记录数。这个统计信息就是索引的“<strong>区分度</strong>”。</p>\n<p><strong>基数</strong></p>\n<p>显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“<strong>基数</strong>”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p>\n<p><strong>采样统计</strong></p>\n<p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p>\n<p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数</p>\n<p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</p>\n<p>在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 <code>innodb_stats_persistent</code> 的值来选择：</p>\n<ol>\n<li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li>\n<li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li>\n</ol>\n<p>对于由于索引统计信息不准确导致的问题，你可以用 <code>analyze table</code> 来解决。</p>\n<h3 id=\"索引选择异常和处理\"><a href=\"#索引选择异常和处理\" class=\"headerlink\" title=\"索引选择异常和处理\"></a>索引选择异常和处理</h3><p><strong>原本可以执行得很快的 SQL 语句，执行速度却比你预期的慢很多，你应该怎么办呢？</strong></p>\n<ol>\n<li><p>采用 <code>force index</code> 强行选择一个索引</p>\n<p>MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果 force index 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p>\n</li>\n<li><p>考虑修改语句，引导 MySQL 使用我们期望的索引</p>\n</li>\n<li><p>在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引</p>\n</li>\n</ol>\n<h2 id=\"怎么给字符串字段加索引？\"><a href=\"#怎么给字符串字段加索引？\" class=\"headerlink\" title=\"怎么给字符串字段加索引？\"></a>怎么给字符串字段加索引？</h2><p><strong>用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>\n<blockquote>\n<p>当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p>\n</blockquote>\n<p>我们在建立索引时关注的是<strong>区分度</strong>，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p>\n<p>使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例。</p>\n<h3 id=\"前缀索引对覆盖索引的影响\"><a href=\"#前缀索引对覆盖索引的影响\" class=\"headerlink\" title=\"前缀索引对覆盖索引的影响\"></a>前缀索引对覆盖索引的影响</h3><ol>\n<li><p>使用前缀索引可能会增加扫描行数</p>\n</li>\n<li><p>使用前缀索引就用不上覆盖索引对查询性能的优化</p>\n<blockquote>\n<p>即使查询到的信息已经包含了所有的信息，但是系统并不确定前缀索引的定义是否截断了完整信息，依然需要回到主键索引再查一次</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h3><ol>\n<li>使用倒序存储</li>\n<li>使用 hash 字段</li>\n</ol>\n<blockquote>\n<p>使用倒序存储和使用 hash 字段这两种方法的<strong>异同点</strong></p>\n<ol>\n<li>相同点：都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的。同样地，hash 字段的方式也只能支持等值查询。</li>\n<li>区别：<ol>\n<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</li>\n<li>在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li>\n<li>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"为什么我的MySQL会“抖”一下？\"><a href=\"#为什么我的MySQL会“抖”一下？\" class=\"headerlink\" title=\"为什么我的MySQL会“抖”一下？\"></a>为什么我的MySQL会“抖”一下？</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。</p>\n<p>内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>\n<p><strong>不论是脏页还是干净页，都在内存中。</strong></p>\n<p>InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</p>\n<p>第一种是，还没有使用的；</p>\n<p>第二种是，使用了并且是干净页；</p>\n<p>第三种是，使用了并且是脏页。</p>\n<p>InnoDB 的策略是<strong>尽量使用内存</strong>，因此对于一个长时间运行的库来说，未被使用的页面很少。</p>\n<p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p>\n<blockquote>\n<p>刷脏页出现以下这两种情况，都是会明显影响性能的：</p>\n<ol>\n<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>\n<li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</li>\n</ol>\n</blockquote>\n<h3 id=\"InnoDB-刷脏页的控制策略\"><a href=\"#InnoDB-刷脏页的控制策略\" class=\"headerlink\" title=\"InnoDB 刷脏页的控制策略\"></a>InnoDB 刷脏页的控制策略</h3><p><code>innodb_io_capacity</code> 这个参数，会告诉 InnoDB 你的磁盘能力。建议设置成磁盘的 IOPS。</p>\n<p>测试磁盘随机读写的命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest <br></code></pre></td></tr></table></figure>\n<p>InnoDB 的刷盘速度就是要参考这两个因素：</p>\n<ol>\n<li>一个是脏页比例</li>\n<li>一个是 redo log 写盘速度</li>\n</ol>\n<blockquote>\n<p>InnoDB 会根据这两个因素先单独算出两个数字</p>\n<p>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是 75%。InnoDB 会根据当前的<strong>脏页比例（假设为 M）</strong>，算出一个范围在 0 到 100 之间的数字：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">F1(M)<br>&#123;<br>  if M&gt;=innodb_max_dirty_pages_pct then<br>      return 100;<br>  return 100*M/innodb_max_dirty_pages_pct;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的<strong>差值，我们假设为 N</strong>。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。</p>\n<p>根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 <strong>R</strong>，之后引擎就可以按照 <code>innodb_io_capacity</code> 定义的能力<strong>乘以 R%</strong> 来控制刷脏页的速度。</p>\n</blockquote>\n<p>InnoDB 会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到 MySQL“抖”了一下的原因。</p>\n<p><strong>要尽量避免这种情况，你就要合理地设置 innodb_io_capacity 的值，并且平时要多关注脏页比例(Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total)，不要让它经常接近 75%。</strong></p>\n<h2 id=\"为什么表数据删掉一半，表文件大小不变？\"><a href=\"#为什么表数据删掉一半，表文件大小不变？\" class=\"headerlink\" title=\"为什么表数据删掉一半，表文件大小不变？\"></a>为什么表数据删掉一半，表文件大小不变？</h2><p>一个 InnoDB 表包含两部分，即：<strong>表结构定义和数据</strong>。在 MySQL 8.0 版本以前，表结构是存在以 <code>.frm</code> 为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。</p>\n<p>表结构定义占用的空间很小</p>\n<p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 <code>innodb_file_per_table</code> 控制的：</p>\n<ol>\n<li>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li>\n<li>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 <code>.ibd</code> 为后缀的文件中。</li>\n</ol>\n<p>建议将这个值设置为 ON:因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 <code>drop table</code> 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的</p>\n<h3 id=\"数据删除流程\"><a href=\"#数据删除流程\" class=\"headerlink\" title=\"数据删除流程\"></a>数据删除流程</h3><p>InnoDB 里的数据都是用 B+ 树的结构组织的,如果我们删掉了一个数据页上的记录，InnoDB 引擎只会把删除的记录标记为删除，如果之后要再插入一个记录时，可能会复用这个位置<strong>（记录的复用，只限于符合范围条件的数据）</strong>。</p>\n<p>如果删掉了一个数据页上的所有记录，整个数据页就可以被复用了<strong>（当整个页从 B+ 树里面摘掉以后，可以复用到任何位置）</strong>。</p>\n<p><strong>delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。</strong></p>\n<h3 id=\"重建表\"><a href=\"#重建表\" class=\"headerlink\" title=\"重建表\"></a>重建表</h3><p>不止是删除数据会造成空洞，插入数据也会造成空洞。</p>\n<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>\n<blockquote>\n<p>经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。而<strong>重建表</strong> <code>alter table</code>，就可以达到这样的目的。</p>\n</blockquote>\n<p>Online DDL 之后，重建表的流程：</p>\n<ol>\n<li>建立一个临时文件，扫描表 A 主键的所有数据页；</li>\n<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li>\n<li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中；</li>\n<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件；</li>\n<li>用临时文件替换表 A 的数据文件。</li>\n</ol>\n<h2 id=\"count-这么慢，我该怎么办？\"><a href=\"#count-这么慢，我该怎么办？\" class=\"headerlink\" title=\"count(*)这么慢，我该怎么办？\"></a>count(*)这么慢，我该怎么办？</h2><p><strong>count(*) 的实现方式</strong></p>\n<ol>\n<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li>\n<li>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>\n</ol>\n<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。</p>\n<p>对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</strong></p>\n<blockquote>\n<p><strong>问题：<code>TABLE_ROWS</code> 能代替 count(*) 吗？</strong></p>\n<p>索引统计的值是通过采样来估算的。TABLE_ROWS 就是从这个采样估算得来的，因此它也很不准。</p>\n<p>官方文档说误差可能达到 40% 到 50%。所以，show table status 命令显示的行数也不能直接使用。</p>\n</blockquote>\n<h3 id=\"用缓存系统保存计数\"><a href=\"#用缓存系统保存计数\" class=\"headerlink\" title=\"用缓存系统保存计数\"></a>用缓存系统保存计数</h3><p>对于更新很频繁的库来说,可以用一个 Redis 服务来保存这个表的总行数。</p>\n<blockquote>\n<p><strong>问题1：缓存系统可能会丢失更新</strong></p>\n<p>Redis 异常重启以后，到数据库里面单独执行一次 count(*) 获取真实的行数，再把这个值写回到 Redis 里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p>\n<hr>\n<p><strong>问题2：将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。</strong></p>\n<ol>\n<li>一种是，查到的结果里面有最新插入记录，而 Redis 的计数里还没加 1；</li>\n<li>另一种是，查到的结果里没有最新插入的记录，而 Redis 的计数里已经加了 1。</li>\n</ol>\n<p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的。</p>\n</blockquote>\n<h3 id=\"在数据库保存计数\"><a href=\"#在数据库保存计数\" class=\"headerlink\" title=\"在数据库保存计数\"></a>在数据库保存计数</h3><p>把这个计数直接放到数据库里单独的一张计数表中</p>\n<ol>\n<li>解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的；</li>\n<li>解决计数不精确的问题，利用“事务”这个特性，解决问题。</li>\n</ol>\n<h3 id=\"不同的-count-用法\"><a href=\"#不同的-count-用法\" class=\"headerlink\" title=\"不同的 count 用法\"></a>不同的 count 用法</h3><p>count() 的语义：</p>\n<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p>\n<p>count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>\n<blockquote>\n<p>分析性能差别的时候，三个原则：</p>\n<ol>\n<li>server 层要什么就给什么；</li>\n<li>InnoDB 只给必要的值；</li>\n<li>现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。</li>\n</ol>\n</blockquote>\n<ol>\n<li><p><code>count(主键 id)</code> </p>\n<p>InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>\n</li>\n<li><p><code>count(1)</code></p>\n<p>InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>\n</li>\n<li><p><code>count(字段)</code></p>\n<ol>\n<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li>\n<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li>\n</ol>\n</li>\n<li><p><code>count(*)</code></p>\n<p>不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p>\n</li>\n</ol>\n<p>按照效率排序的话，<strong>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)</strong></p>\n<p>所以尽量使用 count(*)。</p>\n<h2 id=\"“order-by”是怎么工作的？\"><a href=\"#“order-by”是怎么工作的？\" class=\"headerlink\" title=\"“order by”是怎么工作的？\"></a>“order by”是怎么工作的？</h2><h3 id=\"全字段排序\"><a href=\"#全字段排序\" class=\"headerlink\" title=\"全字段排序\"></a>全字段排序</h3><p>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer</p>\n<p>排序时，可能在内存 sort_buffer 中排序 ，也可能需要使用外部排序，<strong>这取决于排序所需的内存和参数 sort_buffer_size。</strong></p>\n<p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>\n<blockquote>\n<p>通过查看 <code>OPTIMIZER_TRACE</code> 的结果来确认</p>\n<p><code>number_of_tmp_files</code> 表示是否使用了临时文件：</p>\n<ol>\n<li>如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。</li>\n<li>如果 sort_buffer_size 太小，number_of_tmp_files 就是 n，表示排序过程中使用 n 个临时文件。</li>\n</ol>\n</blockquote>\n<p>sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。</p>\n<h3 id=\"rowid-排序\"><a href=\"#rowid-排序\" class=\"headerlink\" title=\"rowid 排序\"></a>rowid 排序</h3><p>全字段排序<strong>问题</strong>：如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p>\n<p><strong>解决：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SET max_length_for_sort_data = 16;<br></code></pre></td></tr></table></figure>\n<p><code>max_length_for_sort_data</code> ，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p>\n<p><strong>新的算法放入 sort_buffer 的字段，只有要排序的列和主键 id。</strong></p>\n<p>最后的“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p>\n<h3 id=\"全字段排序-VS-rowid-排序\"><a href=\"#全字段排序-VS-rowid-排序\" class=\"headerlink\" title=\"全字段排序 VS rowid 排序\"></a>全字段排序 VS rowid 排序</h3><ol>\n<li>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</li>\n<li>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</li>\n</ol>\n<p><strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p>\n<blockquote>\n<p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</p>\n</blockquote>\n<h2 id=\"如何正确地显示随机消息？\"><a href=\"#如何正确地显示随机消息？\" class=\"headerlink\" title=\"如何正确地显示随机消息？\"></a>如何正确地显示随机消息？</h2><h3 id=\"内存临时表\"><a href=\"#内存临时表\" class=\"headerlink\" title=\"内存临时表\"></a>内存临时表</h3><p>用 order by rand() 来实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select word from words order by rand() limit 3;<br></code></pre></td></tr></table></figure>\n<p>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL 这时就会选择 rowid 排序。</p>\n<p><strong>rowid:每个引擎用来唯一标识数据行的信息</strong></p>\n<ol>\n<li><p>对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；</p>\n</li>\n<li><p>对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的。</p>\n</li>\n</ol>\n<p><strong>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</strong></p>\n<h3 id=\"磁盘临时表\"><a href=\"#磁盘临时表\" class=\"headerlink\" title=\"磁盘临时表\"></a>磁盘临时表</h3><p><code>tmp_table_size</code> 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 <code>tmp_table_size</code>，那么内存临时表就会转成磁盘临时表。</p>\n<p>磁盘临时表使用的引擎默认是 InnoDB，是由参数 <code>internal_tmp_disk_storage_engine</code> 控制的。</p>\n<p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。</p>\n<p><strong>优先队列排序算法</strong></p>\n<p>（当存在 limit 时，并且 limit 需要的维护的最大堆的大小小于 sort_buffer，就会使用这个算法。）</p>\n<ol>\n<li>对于这 n 个准备排序的 (R,rowid)，先取前三行，构造成一个堆；</li>\n<li>取下一个行 (R’,rowid’)，跟当前堆里面最大的 R 比较，如果 R’小于 R，把这个 (R,rowid) 从堆中去掉，换成 (R’,rowid’)；</li>\n<li>重复第 2 步，直到第 n 个 (R’,rowid’) 完成比较。</li>\n</ol>\n<h2 id=\"为什么我只查一行的语句，也执行这么慢？\"><a href=\"#为什么我只查一行的语句，也执行这么慢？\" class=\"headerlink\" title=\"为什么我只查一行的语句，也执行这么慢？\"></a>为什么我只查一行的语句，也执行这么慢？</h2><h3 id=\"第一类：查询长时间不返回\"><a href=\"#第一类：查询长时间不返回\" class=\"headerlink\" title=\"第一类：查询长时间不返回\"></a>第一类：查询长时间不返回</h3><blockquote>\n<p>出现情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from t where id=1;<br></code></pre></td></tr></table></figure>\n<p>一般碰到这种情况的话，大概率是表 t 被锁住了。</p>\n</blockquote>\n<p>查看当前语句处于什么状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">show processlist;<br></code></pre></td></tr></table></figure>\n<ol>\n<li><p>等 MDL 锁</p>\n<p>使用 show processlist 命令查看 Waiting for table metadata lock</p>\n<p>表示的是，现在有一个线程正在请求或者持有 MDL 写锁，把 select 语句堵住了。</p>\n<p><strong>处理方法：找到谁持有 MDL 写锁，然后把它 kill 掉</strong></p>\n<p>(MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失，建议可以开启mysql的 performance_schema 功能，这个可以定位被锁的线程情况)</p>\n<p>通过查询 sys.schema_table_lock_waits 这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。</p>\n</li>\n<li><p>等 flush</p>\n<blockquote>\n<p>mysql&gt; select * from information_schema.processlist where id=1;</p>\n</blockquote>\n<p>查出来这个线程的状态是 <strong>Waiting for table flush</strong></p>\n<p>这个状态表示的是，现在有一个线程正要做 flush 操作。MySQL 里面对表做 flush 操作的用法，一般有以下两个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">#如果指定表 t 的话，代表的是只关闭表 t；<br>flush tables t with read lock;<br>#如果没有指定具体的表名，则表示关闭 MySQL 里所有打开的表。<br>flush tables with read lock;<br></code></pre></td></tr></table></figure>\n<p>但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p>\n<p>所以，出现 <strong>Waiting for table flush</strong> 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句。</p>\n</li>\n<li><p>等行锁</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from t where id=1 lock in share mode; <br>#读锁（S 锁，共享锁） 由于访问 id=1 这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的 select 语句就会被堵住。<br>mysql&gt; select k from t where id=1 for update; <br>#写锁（X 锁，排他锁）<br></code></pre></td></tr></table></figure>\n<p>MySQL 5.7，通过 <strong>sys.innodb_lock_waits</strong> 表查到是谁占着这个写锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from sys.innodb_lock_waits where locked_table=&#x27;`test`.`t`&#x27;\\G<br></code></pre></td></tr></table></figure>\n<p><strong>直接断开这个连接</strong>。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了 id=1 上的行锁。</p>\n</li>\n</ol>\n<h3 id=\"第二类：查询慢\"><a href=\"#第二类：查询慢\" class=\"headerlink\" title=\"第二类：查询慢\"></a>第二类：查询慢</h3><p>一致性读导致回滚日志过大引起的一致性读慢，当前读快</p>\n<h2 id=\"幻读是什么，幻读有什么问题？\"><a href=\"#幻读是什么，幻读有什么问题？\" class=\"headerlink\" title=\"幻读是什么，幻读有什么问题？\"></a>幻读是什么，幻读有什么问题？</h2><h3 id=\"幻读是什么？\"><a href=\"#幻读是什么？\" class=\"headerlink\" title=\"幻读是什么？\"></a>幻读是什么？</h3><p>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>\n<p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，<strong>幻读在“当前读”下才会出现。</strong></p>\n<h3 id=\"幻读有什么问题？\"><a href=\"#幻读有什么问题？\" class=\"headerlink\" title=\"幻读有什么问题？\"></a>幻读有什么问题？</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  `d` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE=InnoDB;<br><br>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);<br></code></pre></td></tr></table></figure>\n</blockquote>\n<ol>\n<li><p>首先是语义上的。</p>\n<blockquote>\n<p><img src=\"/article/假设只在 id=5 这一行加行锁 -- 语义被破坏.png\"><span class=\"image-caption\">假设只在 id=5 这一行加行锁 -- 语义被破坏</span></p>\n<p>T1: session A 声明，“我要把所有 d=5 的行锁住，不准别的事务进行读写操作”。</p>\n<p>T2:session B 的第二条语句 update t set c=5 where id=0，语义是“我把 id=0、d=5 这一行的 c 值，改成了 5”。由于在 T1 时刻，session A 还只是给 id=5 这一行加了行锁， 并没有给 id=0 这行加上锁。因此，session B 在 T2 时刻，是可以执行这两条 update 语句的。</p>\n<p><strong>这样，就破坏了 session A 里 Q1 语句要锁住所有 d=5 的行的加锁声明。</strong></p>\n</blockquote>\n</li>\n<li><p>其次，是数据一致性的问题。</p>\n<p>锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p>\n<blockquote>\n<p><img src=\"/article/假设只在 id=5 这一行加行锁 -- 数据一致性问题.png\"><span class=\"image-caption\">假设只在 id=5 这一行加行锁 -- 数据一致性问题</span></p>\n<p><strong>update 的加锁语义和 select …for update 是一致的</strong></p>\n<ol>\n<li><p>正常执行</p>\n<p>经过 T1 时刻，id=5 这一行变成 (5,5,100)，当然这个结果最终是在 T6 时刻正式提交的 ;</p>\n<p>经过 T2 时刻，id=0 这一行变成 (0,5,5);</p>\n<p>经过 T4 时刻，表里面多了一行 (1,5,5);</p>\n</li>\n<li><p>binlog 记录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">#T2 时刻，session B 事务提交，写入了两条语句；<br>update t set d=5 where id=0; /*(0,0,5)*/<br>update t set c=5 where id=0; /*(0,5,5)*/<br>#T4 时刻，session C 事务提交，写入了两条语句；<br>insert into t values(1,1,5); /*(1,1,5)*/<br>update t set c=5 where id=1; /*(1,5,5)*/<br>#T6 时刻，session A 事务提交，写入了 update t set d=100 where d=5 这条语句。<br>update t set d=100 where d=5;/*所有d=5的行，d改成100*/<br></code></pre></td></tr></table></figure>\n<p>这个语句序列，不论是拿到备库去执行，还是以后用 binlog 来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100) 和 (5,5,100)。</p>\n<p>id=0 和 id=1 这两行，发生了数据不一致。</p>\n</li>\n</ol>\n<hr>\n<p>为了解决上面数据不一致的问题，假设把扫描过程中碰到的行都加锁</p>\n<img src=\"/article/46662/%E5%81%87%E8%AE%BE%E6%89%AB%E6%8F%8F%E5%88%B0%E7%9A%84%E8%A1%8C%E9%83%BD%E8%A2%AB%E5%8A%A0%E4%B8%8A%E4%BA%86%E8%A1%8C%E9%94%81.png\" class title=\"假设扫描到的行都被加上了行锁\">\n<p>由于 session A 把所有的行都加了写锁，所以 session B 在执行第一个 update 语句的时候就被锁住了。需要等到 T6 时刻 session A 提交以后，session B 才能继续执行。</p>\n<p>binlog:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">insert into t values(1,1,5); /*(1,1,5)*/<br>update t set c=5 where id=1; /*(1,5,5)*/<br><br>update t set d=100 where d=5;/*所有d=5的行，d改成100*/<br><br>update t set d=5 where id=0; /*(0,0,5)*/<br>update t set c=5 where id=0; /*(0,5,5)*/<br></code></pre></td></tr></table></figure>\n<p>按照日志顺序执行，id=0 这一行的最终结果也是 (0,5,5)。所以，id=0 这一行的问题解决了。</p>\n<p>id=1 这一行，在数据库里面的结果是 (1,5,5)，而根据 binlog 的执行结果是 (1,5,100)，也就是说幻读的问题还是没有解决。(因为：在 T3 时刻，我们给所有行加锁的时候，id=1 这一行还不存在，不存在也就加不上锁。)</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>即使把所有的记录都加上锁，还是阻止不了新插入的记录</strong></p>\n<h3 id=\"如何解决幻读？\"><a href=\"#如何解决幻读？\" class=\"headerlink\" title=\"如何解决幻读？\"></a>如何解决幻读？</h3><p>产生幻读的原因是，<strong>行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。</strong></p>\n<p><strong>为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</strong></p>\n<p><strong>间隙锁，锁的就是两个值之间的空隙。</strong></p>\n<blockquote>\n<p>初始化插入了 6 个记录，这就产生了 7 个间隙</p>\n<img src=\"/article/46662/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8A%E7%9A%84%E8%A1%8C%E9%94%81%E5%92%8C%E9%97%B4%E9%9A%99%E9%94%81.png\" class title=\"主键索引上的行锁和间隙锁\">\n<p>当你执行 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from t where d=5 for update<br></code></pre></td></tr></table></figure>\n<p>就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。</p>\n</blockquote>\n<p><strong>在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</strong></p>\n<p>数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。</p>\n<p><strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong>间隙锁之间都不存在冲突关系。</p>\n<p>间隙锁和行锁合称 <strong>next-key lock</strong>，每个 next-key lock 是<strong>前开后闭区间</strong>。</p>\n<blockquote>\n<p>也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p>\n</blockquote>\n<p><strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。</strong></p>\n<blockquote>\n<p><strong>只有在可重复读的隔离级别下，才会有间隙锁。读提交的隔离级别下不会有间隙锁</strong></p>\n</blockquote>\n<h2 id=\"为什么我只改一行的语句，锁这么多？\"><a href=\"#为什么我只改一行的语句，锁这么多？\" class=\"headerlink\" title=\"为什么我只改一行的语句，锁这么多？\"></a>为什么我只改一行的语句，锁这么多？</h2><p><strong>加锁规则</strong>：两个“原则”、两个“优化”和一个“bug”</p>\n<ol>\n<li>原则 1：加锁的基本单位是 <strong>next-key lock</strong>。next-key lock 是前开后闭区间。</li>\n<li>原则 2：查找过程中访问到的对象才会加锁。</li>\n<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>\n<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>\n<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>\n</ol>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  `d` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE=InnoDB;<br><br>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"等值查询间隙锁\"><a href=\"#等值查询间隙锁\" class=\"headerlink\" title=\"等值查询间隙锁\"></a>等值查询间隙锁</h3><blockquote>\n<img src=\"/article/46662/%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%97%B4%E9%9A%99%E9%94%81.png\" class title=\"等值查询的间隙锁\">\n<p>由于表 t 中没有 id=7 的记录</p>\n<ol>\n<li>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</li>\n<li>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</li>\n</ol>\n<p><strong>session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。</strong></p>\n</blockquote>\n<h3 id=\"非唯一索引等值锁\"><a href=\"#非唯一索引等值锁\" class=\"headerlink\" title=\"非唯一索引等值锁\"></a>非唯一索引等值锁</h3><blockquote>\n<img src=\"/article/46662/%E5%8F%AA%E5%8A%A0%E5%9C%A8%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8A%E7%9A%84%E9%94%81.png\" class title=\"只加在非唯一索引上的锁\">\n<ol>\n<li>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5]加上 next-key lock。</li>\n<li>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10]加 next-key lock。</li>\n<li>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</li>\n<li>根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。\u0010(加锁，是加在索引上的。 列上，有索引，就加在索引上； 列上，没有索引，就加在主键上；)</li>\n</ol>\n<p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</p>\n<p><strong>lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁</strong>。</p>\n<p>这个例子说明，<strong>锁是加在索引上的</strong>；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 select d from t where c=5 lock in share mode。（改为select d ，因为索引c，并没有d列的值，需要回表，查主键，这样就会把id=5这行数据加锁。session B会被锁住。 session C 还是会因为session A 在C列上的间隙锁(0,5},(5,10)而不能插入。 实际加锁范围是：id=5的行锁，普通索引c上锁范围(0,5},(5,10)）</p>\n</blockquote>\n<h3 id=\"主键索引范围锁\"><a href=\"#主键索引范围锁\" class=\"headerlink\" title=\"主键索引范围锁\"></a>主键索引范围锁</h3><blockquote>\n<p>这两条查询语句，加锁范围相同吗？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from t where id=10 for update;<br>mysql&gt; select * from t where id&gt;=10 and id&lt;11 for update;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/46662/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8A%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%94%81.png\" class title=\"主键索引上范围查询的锁\">\n<ol>\n<li>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</li>\n<li>范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。</li>\n</ol>\n<p>所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。</p>\n<p>注意：首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</p>\n</blockquote>\n<h3 id=\"非唯一索引范围锁\"><a href=\"#非唯一索引范围锁\" class=\"headerlink\" title=\"非唯一索引范围锁\"></a>非唯一索引范围锁</h3><blockquote>\n<img src=\"/article/46662/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81.png\" class title=\"非唯一索引范围锁\">\n<p>这次 session A 用字段 c 来判断</p>\n<p>加锁规则跟主键索引范围锁唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10]这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。</p>\n</blockquote>\n<h3 id=\"唯一索引范围锁-bug\"><a href=\"#唯一索引范围锁-bug\" class=\"headerlink\" title=\"唯一索引范围锁 bug\"></a>唯一索引范围锁 bug</h3><blockquote>\n<p><img src=\"/article/唯一索引范围锁的 bug.png\"><span class=\"image-caption\">唯一索引范围锁的 bug</span></p>\n<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15]这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了</p>\n<p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20]这个 next-key lock 也会被锁上。</p>\n</blockquote>\n<h3 id=\"非唯一索引上存在”等值”的例子\"><a href=\"#非唯一索引上存在”等值”的例子\" class=\"headerlink\" title=\"非唯一索引上存在”等值”的例子\"></a>非唯一索引上存在”等值”的例子</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; insert into t values(30,10,30);<br></code></pre></td></tr></table></figure>\n<p>新插入的这一行 c=10，也就是说现在表里有两个 c=10 的行。</p>\n<p>由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。</p>\n<img src=\"/article/46662/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E7%9A%84%E4%BE%8B%E5%AD%90.png\" class title=\"非唯一索引等值的例子\">\n<p>可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和 30），因此这两个 c=10 的记录之间，也是有间隙的。</p>\n<p><img src=\"/article/delete 示例.png\"><span class=\"image-caption\">delete 示例</span></p>\n<ol>\n<li>session A 在遍历的时候，先访问第一个 c=10 的记录。同样地，根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。</li>\n<li>session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。</li>\n</ol>\n<p>也就是说，这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。</p>\n<p><img src=\"/article/delete 加锁效果示例.png\"><span class=\"image-caption\">delete 加锁效果示例</span></p>\n</blockquote>\n<h3 id=\"limit-语句加锁\"><a href=\"#limit-语句加锁\" class=\"headerlink\" title=\"limit 语句加锁\"></a>limit 语句加锁</h3><blockquote>\n<p><img src=\"/article/limit 语句加锁.png\"><span class=\"image-caption\">limit 语句加锁</span></p>\n<p>session A 的 delete 语句加了 limit 2。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了。</p>\n<p>这是因为， delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。</p>\n<p>因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间。</p>\n<p><img src=\"/article/带 limit 2 的加锁效果.png\"><span class=\"image-caption\">带 limit 2 的加锁效果</span></p>\n<p><strong>在删除数据的时候尽量加 limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>\n</blockquote>\n<h3 id=\"一个死锁的例子\"><a href=\"#一个死锁的例子\" class=\"headerlink\" title=\"一个死锁的例子\"></a>一个死锁的例子</h3><blockquote>\n<img src=\"/article/46662/%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97.png\" class title=\"操作序列\">\n<ol>\n<li>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</li>\n<li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</li>\n<li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</li>\n</ol>\n<p>session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。</p>\n<p><strong>也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</strong></p>\n</blockquote>\n","more":"<h2 id=\"普通索引和唯一索引，应该怎么选择？\"><a href=\"#普通索引和唯一索引，应该怎么选择？\" class=\"headerlink\" title=\"普通索引和唯一索引，应该怎么选择？\"></a>普通索引和唯一索引，应该怎么选择？</h2><h3 id=\"更新过程\"><a href=\"#更新过程\" class=\"headerlink\" title=\"更新过程\"></a>更新过程</h3><p><strong>change buffer</strong></p>\n<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些<strong>更新操作</strong>缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>\n<p>需要说明的是，虽然名字叫作 change buffer，实际上它是<strong>可以持久化的数据</strong>。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p>\n<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 <strong>merge</strong>。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p>\n<blockquote>\n<p>merge 的执行流程是这样的：</p>\n<ol>\n<li>从磁盘读入数据页到内存（老版本的数据页）；</li>\n<li>从 change buffer 里找出这个数据页的 change buffer 记录 (可能有多个），依次应用，得到新版数据页；</li>\n<li>写 redo log。这个 redo log 包含了数据的变更和 change buffer 的变更。</li>\n</ol>\n<p>这时候，数据页和内存中 change buffer 对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。</p>\n</blockquote>\n<p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够<strong>避免占用内存，提高内存利用率。</strong></p>\n<blockquote>\n<p><strong>问题：什么条件下可以使用 change buffer 呢？</strong></p>\n<p>对于<strong>唯一索引</strong>来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。</p>\n<p><strong>唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</strong></p>\n</blockquote>\n<p>change buffer 用的是 buffer pool 里的内存，因此<strong>不能无限增大</strong>。change buffer 的大小，可以通过参数 <code>innodb_change_buffer_max_size</code> 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p>\n<p><strong>在表中插入一个新纪录，InnoDB处理流程：</strong></p>\n<ol>\n<li>这个记录要更新的目标页在内存中<ol>\n<li>对于唯一索引来说，找到位置，判断到没有冲突，插入这个值，语句执行结束；</li>\n<li>对于普通索引来说，找到位置，插入这个值，语句执行结束。</li>\n</ol>\n</li>\n<li><strong>这个记录要更新的目标页不在内存中</strong><ol>\n<li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li>\n<li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li>\n</ol>\n</li>\n</ol>\n<p>将数据从磁盘读入内存涉及<strong>随机 IO 的访问，是数据库里面成本最高的操作之一</strong>。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>\n<blockquote>\n<p>对于<strong>写多读少</strong>的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。</p>\n<p>反过来，假设一个业务的更新模式是<strong>写入之后马上会做查询</strong>，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。</p>\n</blockquote>\n<h3 id=\"索引选择和实践\"><a href=\"#索引选择和实践\" class=\"headerlink\" title=\"索引选择和实践\"></a>索引选择和实践</h3><p><strong>建议尽量选择普通索引</strong></p>\n<p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p>\n<ol>\n<li>首先，业务正确性优先。</li>\n<li>然后，在一些“归档库”的场景，你是可以考虑使用普通索引的。</li>\n</ol>\n<h3 id=\"change-buffer-和-redo-log\"><a href=\"#change-buffer-和-redo-log\" class=\"headerlink\" title=\"change buffer 和 redo log\"></a>change buffer 和 redo log</h3><p>如果要简单地对比这两个机制在提升更新性能上的收益的话</p>\n<p><strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写）</strong>，</p>\n<p><strong>change buffer 主要节省的则是随机读磁盘的 IO 消耗</strong></p>\n<hr>\n<p><strong>问题：change buffer 一开始是写内存的，那么如果这个时候机器掉电重启，会不会导致 change buffer 丢失呢？change buffer 丢失可不是小事儿，再从磁盘读入数据可就没有了 merge 过程，就等于是数据丢失了。会不会出现这种情况呢？</strong></p>\n<blockquote>\n<p><strong>不会丢失</strong></p>\n<p>虽然是只更新内存，但是在事务提交的时候，我们把 change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来。</p>\n</blockquote>\n<hr>\n<h2 id=\"MySQL为什么有时候会选错索引？\"><a href=\"#MySQL为什么有时候会选错索引？\" class=\"headerlink\" title=\"MySQL为什么有时候会选错索引？\"></a>MySQL为什么有时候会选错索引？</h2><h3 id=\"优化器的逻辑\"><a href=\"#优化器的逻辑\" class=\"headerlink\" title=\"优化器的逻辑\"></a>优化器的逻辑</h3><p><strong>选择索引是优化器的工作。</strong></p>\n<p>而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。</p>\n<p><strong>扫描行数</strong>并不是唯一的判断标准，优化器还会结合<strong>是否使用临时表、是否排序</strong>等因素进行综合判断。</p>\n<h3 id=\"扫描行数是怎么判断的？\"><a href=\"#扫描行数是怎么判断的？\" class=\"headerlink\" title=\"扫描行数是怎么判断的？\"></a>扫描行数是怎么判断的？</h3><p><strong>区分度</strong></p>\n<p>MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据<strong>统计信息</strong>来估算记录数。这个统计信息就是索引的“<strong>区分度</strong>”。</p>\n<p><strong>基数</strong></p>\n<p>显然，一个索引上不同的值越多，这个索引的区分度就越好。而一个索引上不同的值的个数，我们称之为“<strong>基数</strong>”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</p>\n<p><strong>采样统计</strong></p>\n<p>为什么要采样统计呢？因为把整张表取出来一行行统计，虽然可以得到精确的结果，但是代价太高了，所以只能选择“采样统计”。</p>\n<p>采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数</p>\n<p>而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。</p>\n<p>在 MySQL 中，有两种存储索引统计的方式，可以通过设置参数 <code>innodb_stats_persistent</code> 的值来选择：</p>\n<ol>\n<li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li>\n<li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li>\n</ol>\n<p>对于由于索引统计信息不准确导致的问题，你可以用 <code>analyze table</code> 来解决。</p>\n<h3 id=\"索引选择异常和处理\"><a href=\"#索引选择异常和处理\" class=\"headerlink\" title=\"索引选择异常和处理\"></a>索引选择异常和处理</h3><p><strong>原本可以执行得很快的 SQL 语句，执行速度却比你预期的慢很多，你应该怎么办呢？</strong></p>\n<ol>\n<li><p>采用 <code>force index</code> 强行选择一个索引</p>\n<p>MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果 force index 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</p>\n</li>\n<li><p>考虑修改语句，引导 MySQL 使用我们期望的索引</p>\n</li>\n<li><p>在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引</p>\n</li>\n</ol>\n<h2 id=\"怎么给字符串字段加索引？\"><a href=\"#怎么给字符串字段加索引？\" class=\"headerlink\" title=\"怎么给字符串字段加索引？\"></a>怎么给字符串字段加索引？</h2><p><strong>用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>\n<blockquote>\n<p>当要给字符串创建前缀索引时，有什么方法能够确定我应该使用多长的前缀呢？</p>\n</blockquote>\n<p>我们在建立索引时关注的是<strong>区分度</strong>，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p>\n<p>使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例。</p>\n<h3 id=\"前缀索引对覆盖索引的影响\"><a href=\"#前缀索引对覆盖索引的影响\" class=\"headerlink\" title=\"前缀索引对覆盖索引的影响\"></a>前缀索引对覆盖索引的影响</h3><ol>\n<li><p>使用前缀索引可能会增加扫描行数</p>\n</li>\n<li><p>使用前缀索引就用不上覆盖索引对查询性能的优化</p>\n<blockquote>\n<p>即使查询到的信息已经包含了所有的信息，但是系统并不确定前缀索引的定义是否截断了完整信息，依然需要回到主键索引再查一次</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"其他方式\"><a href=\"#其他方式\" class=\"headerlink\" title=\"其他方式\"></a>其他方式</h3><ol>\n<li>使用倒序存储</li>\n<li>使用 hash 字段</li>\n</ol>\n<blockquote>\n<p>使用倒序存储和使用 hash 字段这两种方法的<strong>异同点</strong></p>\n<ol>\n<li>相同点：都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的。同样地，hash 字段的方式也只能支持等值查询。</li>\n<li>区别：<ol>\n<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</li>\n<li>在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li>\n<li>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"为什么我的MySQL会“抖”一下？\"><a href=\"#为什么我的MySQL会“抖”一下？\" class=\"headerlink\" title=\"为什么我的MySQL会“抖”一下？\"></a>为什么我的MySQL会“抖”一下？</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。</p>\n<p>内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p>\n<p><strong>不论是脏页还是干净页，都在内存中。</strong></p>\n<p>InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</p>\n<p>第一种是，还没有使用的；</p>\n<p>第二种是，使用了并且是干净页；</p>\n<p>第三种是，使用了并且是脏页。</p>\n<p>InnoDB 的策略是<strong>尽量使用内存</strong>，因此对于一个长时间运行的库来说，未被使用的页面很少。</p>\n<p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p>\n<blockquote>\n<p>刷脏页出现以下这两种情况，都是会明显影响性能的：</p>\n<ol>\n<li>一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>\n<li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的</li>\n</ol>\n</blockquote>\n<h3 id=\"InnoDB-刷脏页的控制策略\"><a href=\"#InnoDB-刷脏页的控制策略\" class=\"headerlink\" title=\"InnoDB 刷脏页的控制策略\"></a>InnoDB 刷脏页的控制策略</h3><p><code>innodb_io_capacity</code> 这个参数，会告诉 InnoDB 你的磁盘能力。建议设置成磁盘的 IOPS。</p>\n<p>测试磁盘随机读写的命令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest <br></code></pre></td></tr></table></figure>\n<p>InnoDB 的刷盘速度就是要参考这两个因素：</p>\n<ol>\n<li>一个是脏页比例</li>\n<li>一个是 redo log 写盘速度</li>\n</ol>\n<blockquote>\n<p>InnoDB 会根据这两个因素先单独算出两个数字</p>\n<p>参数 <code>innodb_max_dirty_pages_pct</code> 是脏页比例上限，默认值是 75%。InnoDB 会根据当前的<strong>脏页比例（假设为 M）</strong>，算出一个范围在 0 到 100 之间的数字：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">F1(M)<br>&#123;<br>  if M&gt;=innodb_max_dirty_pages_pct then<br>      return 100;<br>  return 100*M/innodb_max_dirty_pages_pct;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的<strong>差值，我们假设为 N</strong>。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公式可以记为 F2(N)。</p>\n<p>根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 <strong>R</strong>，之后引擎就可以按照 <code>innodb_io_capacity</code> 定义的能力<strong>乘以 R%</strong> 来控制刷脏页的速度。</p>\n</blockquote>\n<p>InnoDB 会在后台刷脏页，而刷脏页的过程是要将内存页写入磁盘。所以，无论是你的查询语句在需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用 IO 资源并可能影响到了你的更新语句，都可能是造成你从业务端感知到 MySQL“抖”了一下的原因。</p>\n<p><strong>要尽量避免这种情况，你就要合理地设置 innodb_io_capacity 的值，并且平时要多关注脏页比例(Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total)，不要让它经常接近 75%。</strong></p>\n<h2 id=\"为什么表数据删掉一半，表文件大小不变？\"><a href=\"#为什么表数据删掉一半，表文件大小不变？\" class=\"headerlink\" title=\"为什么表数据删掉一半，表文件大小不变？\"></a>为什么表数据删掉一半，表文件大小不变？</h2><p>一个 InnoDB 表包含两部分，即：<strong>表结构定义和数据</strong>。在 MySQL 8.0 版本以前，表结构是存在以 <code>.frm</code> 为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。</p>\n<p>表结构定义占用的空间很小</p>\n<p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 <code>innodb_file_per_table</code> 控制的：</p>\n<ol>\n<li>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li>\n<li>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 <code>.ibd</code> 为后缀的文件中。</li>\n</ol>\n<p>建议将这个值设置为 ON:因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 <code>drop table</code> 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的</p>\n<h3 id=\"数据删除流程\"><a href=\"#数据删除流程\" class=\"headerlink\" title=\"数据删除流程\"></a>数据删除流程</h3><p>InnoDB 里的数据都是用 B+ 树的结构组织的,如果我们删掉了一个数据页上的记录，InnoDB 引擎只会把删除的记录标记为删除，如果之后要再插入一个记录时，可能会复用这个位置<strong>（记录的复用，只限于符合范围条件的数据）</strong>。</p>\n<p>如果删掉了一个数据页上的所有记录，整个数据页就可以被复用了<strong>（当整个页从 B+ 树里面摘掉以后，可以复用到任何位置）</strong>。</p>\n<p><strong>delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。</strong></p>\n<h3 id=\"重建表\"><a href=\"#重建表\" class=\"headerlink\" title=\"重建表\"></a>重建表</h3><p>不止是删除数据会造成空洞，插入数据也会造成空洞。</p>\n<p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。</p>\n<blockquote>\n<p>经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。而<strong>重建表</strong> <code>alter table</code>，就可以达到这样的目的。</p>\n</blockquote>\n<p>Online DDL 之后，重建表的流程：</p>\n<ol>\n<li>建立一个临时文件，扫描表 A 主键的所有数据页；</li>\n<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li>\n<li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中；</li>\n<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件；</li>\n<li>用临时文件替换表 A 的数据文件。</li>\n</ol>\n<h2 id=\"count-这么慢，我该怎么办？\"><a href=\"#count-这么慢，我该怎么办？\" class=\"headerlink\" title=\"count(*)这么慢，我该怎么办？\"></a>count(*)这么慢，我该怎么办？</h2><p><strong>count(*) 的实现方式</strong></p>\n<ol>\n<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li>\n<li>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>\n</ol>\n<p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。</p>\n<p>对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</strong></p>\n<blockquote>\n<p><strong>问题：<code>TABLE_ROWS</code> 能代替 count(*) 吗？</strong></p>\n<p>索引统计的值是通过采样来估算的。TABLE_ROWS 就是从这个采样估算得来的，因此它也很不准。</p>\n<p>官方文档说误差可能达到 40% 到 50%。所以，show table status 命令显示的行数也不能直接使用。</p>\n</blockquote>\n<h3 id=\"用缓存系统保存计数\"><a href=\"#用缓存系统保存计数\" class=\"headerlink\" title=\"用缓存系统保存计数\"></a>用缓存系统保存计数</h3><p>对于更新很频繁的库来说,可以用一个 Redis 服务来保存这个表的总行数。</p>\n<blockquote>\n<p><strong>问题1：缓存系统可能会丢失更新</strong></p>\n<p>Redis 异常重启以后，到数据库里面单独执行一次 count(*) 获取真实的行数，再把这个值写回到 Redis 里就可以了。异常重启毕竟不是经常出现的情况，这一次全表扫描的成本，还是可以接受的。</p>\n<hr>\n<p><strong>问题2：将计数保存在缓存系统中的方式，还不只是丢失更新的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。</strong></p>\n<ol>\n<li>一种是，查到的结果里面有最新插入记录，而 Redis 的计数里还没加 1；</li>\n<li>另一种是，查到的结果里没有最新插入的记录，而 Redis 的计数里已经加了 1。</li>\n</ol>\n<p>在并发系统里面，我们是无法精确控制不同线程的执行时刻的。</p>\n</blockquote>\n<h3 id=\"在数据库保存计数\"><a href=\"#在数据库保存计数\" class=\"headerlink\" title=\"在数据库保存计数\"></a>在数据库保存计数</h3><p>把这个计数直接放到数据库里单独的一张计数表中</p>\n<ol>\n<li>解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的；</li>\n<li>解决计数不精确的问题，利用“事务”这个特性，解决问题。</li>\n</ol>\n<h3 id=\"不同的-count-用法\"><a href=\"#不同的-count-用法\" class=\"headerlink\" title=\"不同的 count 用法\"></a>不同的 count 用法</h3><p>count() 的语义：</p>\n<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p>\n<p>count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>\n<blockquote>\n<p>分析性能差别的时候，三个原则：</p>\n<ol>\n<li>server 层要什么就给什么；</li>\n<li>InnoDB 只给必要的值；</li>\n<li>现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做。</li>\n</ol>\n</blockquote>\n<ol>\n<li><p><code>count(主键 id)</code> </p>\n<p>InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>\n</li>\n<li><p><code>count(1)</code></p>\n<p>InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>\n</li>\n<li><p><code>count(字段)</code></p>\n<ol>\n<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</li>\n<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。</li>\n</ol>\n</li>\n<li><p><code>count(*)</code></p>\n<p>不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p>\n</li>\n</ol>\n<p>按照效率排序的话，<strong>count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)</strong></p>\n<p>所以尽量使用 count(*)。</p>\n<h2 id=\"“order-by”是怎么工作的？\"><a href=\"#“order-by”是怎么工作的？\" class=\"headerlink\" title=\"“order by”是怎么工作的？\"></a>“order by”是怎么工作的？</h2><h3 id=\"全字段排序\"><a href=\"#全字段排序\" class=\"headerlink\" title=\"全字段排序\"></a>全字段排序</h3><p>MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer</p>\n<p>排序时，可能在内存 sort_buffer 中排序 ，也可能需要使用外部排序，<strong>这取决于排序所需的内存和参数 sort_buffer_size。</strong></p>\n<p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>\n<blockquote>\n<p>通过查看 <code>OPTIMIZER_TRACE</code> 的结果来确认</p>\n<p><code>number_of_tmp_files</code> 表示是否使用了临时文件：</p>\n<ol>\n<li>如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。</li>\n<li>如果 sort_buffer_size 太小，number_of_tmp_files 就是 n，表示排序过程中使用 n 个临时文件。</li>\n</ol>\n</blockquote>\n<p>sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。</p>\n<h3 id=\"rowid-排序\"><a href=\"#rowid-排序\" class=\"headerlink\" title=\"rowid 排序\"></a>rowid 排序</h3><p>全字段排序<strong>问题</strong>：如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p>\n<p><strong>解决：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SET max_length_for_sort_data = 16;<br></code></pre></td></tr></table></figure>\n<p><code>max_length_for_sort_data</code> ，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</p>\n<p><strong>新的算法放入 sort_buffer 的字段，只有要排序的列和主键 id。</strong></p>\n<p>最后的“结果集”是一个逻辑概念，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p>\n<h3 id=\"全字段排序-VS-rowid-排序\"><a href=\"#全字段排序-VS-rowid-排序\" class=\"headerlink\" title=\"全字段排序 VS rowid 排序\"></a>全字段排序 VS rowid 排序</h3><ol>\n<li>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</li>\n<li>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</li>\n</ol>\n<p><strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p>\n<blockquote>\n<p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</p>\n</blockquote>\n<h2 id=\"如何正确地显示随机消息？\"><a href=\"#如何正确地显示随机消息？\" class=\"headerlink\" title=\"如何正确地显示随机消息？\"></a>如何正确地显示随机消息？</h2><h3 id=\"内存临时表\"><a href=\"#内存临时表\" class=\"headerlink\" title=\"内存临时表\"></a>内存临时表</h3><p>用 order by rand() 来实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select word from words order by rand() limit 3;<br></code></pre></td></tr></table></figure>\n<p>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL 这时就会选择 rowid 排序。</p>\n<p><strong>rowid:每个引擎用来唯一标识数据行的信息</strong></p>\n<ol>\n<li><p>对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；</p>\n</li>\n<li><p>对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的。</p>\n</li>\n</ol>\n<p><strong>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</strong></p>\n<h3 id=\"磁盘临时表\"><a href=\"#磁盘临时表\" class=\"headerlink\" title=\"磁盘临时表\"></a>磁盘临时表</h3><p><code>tmp_table_size</code> 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 <code>tmp_table_size</code>，那么内存临时表就会转成磁盘临时表。</p>\n<p>磁盘临时表使用的引擎默认是 InnoDB，是由参数 <code>internal_tmp_disk_storage_engine</code> 控制的。</p>\n<p>当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。</p>\n<p><strong>优先队列排序算法</strong></p>\n<p>（当存在 limit 时，并且 limit 需要的维护的最大堆的大小小于 sort_buffer，就会使用这个算法。）</p>\n<ol>\n<li>对于这 n 个准备排序的 (R,rowid)，先取前三行，构造成一个堆；</li>\n<li>取下一个行 (R’,rowid’)，跟当前堆里面最大的 R 比较，如果 R’小于 R，把这个 (R,rowid) 从堆中去掉，换成 (R’,rowid’)；</li>\n<li>重复第 2 步，直到第 n 个 (R’,rowid’) 完成比较。</li>\n</ol>\n<h2 id=\"为什么我只查一行的语句，也执行这么慢？\"><a href=\"#为什么我只查一行的语句，也执行这么慢？\" class=\"headerlink\" title=\"为什么我只查一行的语句，也执行这么慢？\"></a>为什么我只查一行的语句，也执行这么慢？</h2><h3 id=\"第一类：查询长时间不返回\"><a href=\"#第一类：查询长时间不返回\" class=\"headerlink\" title=\"第一类：查询长时间不返回\"></a>第一类：查询长时间不返回</h3><blockquote>\n<p>出现情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from t where id=1;<br></code></pre></td></tr></table></figure>\n<p>一般碰到这种情况的话，大概率是表 t 被锁住了。</p>\n</blockquote>\n<p>查看当前语句处于什么状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">show processlist;<br></code></pre></td></tr></table></figure>\n<ol>\n<li><p>等 MDL 锁</p>\n<p>使用 show processlist 命令查看 Waiting for table metadata lock</p>\n<p>表示的是，现在有一个线程正在请求或者持有 MDL 写锁，把 select 语句堵住了。</p>\n<p><strong>处理方法：找到谁持有 MDL 写锁，然后把它 kill 掉</strong></p>\n<p>(MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失，建议可以开启mysql的 performance_schema 功能，这个可以定位被锁的线程情况)</p>\n<p>通过查询 sys.schema_table_lock_waits 这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。</p>\n</li>\n<li><p>等 flush</p>\n<blockquote>\n<p>mysql&gt; select * from information_schema.processlist where id=1;</p>\n</blockquote>\n<p>查出来这个线程的状态是 <strong>Waiting for table flush</strong></p>\n<p>这个状态表示的是，现在有一个线程正要做 flush 操作。MySQL 里面对表做 flush 操作的用法，一般有以下两个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">#如果指定表 t 的话，代表的是只关闭表 t；<br>flush tables t with read lock;<br>#如果没有指定具体的表名，则表示关闭 MySQL 里所有打开的表。<br>flush tables with read lock;<br></code></pre></td></tr></table></figure>\n<p>但是正常这两个语句执行起来都很快，除非它们也被别的线程堵住了。</p>\n<p>所以，出现 <strong>Waiting for table flush</strong> 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 select 语句。</p>\n</li>\n<li><p>等行锁</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from t where id=1 lock in share mode; <br>#读锁（S 锁，共享锁） 由于访问 id=1 这个记录时要加读锁，如果这时候已经有一个事务在这行记录上持有一个写锁，我们的 select 语句就会被堵住。<br>mysql&gt; select k from t where id=1 for update; <br>#写锁（X 锁，排他锁）<br></code></pre></td></tr></table></figure>\n<p>MySQL 5.7，通过 <strong>sys.innodb_lock_waits</strong> 表查到是谁占着这个写锁。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from sys.innodb_lock_waits where locked_table=&#x27;`test`.`t`&#x27;\\G<br></code></pre></td></tr></table></figure>\n<p><strong>直接断开这个连接</strong>。这里隐含的一个逻辑就是，连接被断开的时候，会自动回滚这个连接里面正在执行的线程，也就释放了 id=1 上的行锁。</p>\n</li>\n</ol>\n<h3 id=\"第二类：查询慢\"><a href=\"#第二类：查询慢\" class=\"headerlink\" title=\"第二类：查询慢\"></a>第二类：查询慢</h3><p>一致性读导致回滚日志过大引起的一致性读慢，当前读快</p>\n<h2 id=\"幻读是什么，幻读有什么问题？\"><a href=\"#幻读是什么，幻读有什么问题？\" class=\"headerlink\" title=\"幻读是什么，幻读有什么问题？\"></a>幻读是什么，幻读有什么问题？</h2><h3 id=\"幻读是什么？\"><a href=\"#幻读是什么？\" class=\"headerlink\" title=\"幻读是什么？\"></a>幻读是什么？</h3><p>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>\n<p>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，<strong>幻读在“当前读”下才会出现。</strong></p>\n<h3 id=\"幻读有什么问题？\"><a href=\"#幻读有什么问题？\" class=\"headerlink\" title=\"幻读有什么问题？\"></a>幻读有什么问题？</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  `d` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE=InnoDB;<br><br>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);<br></code></pre></td></tr></table></figure>\n</blockquote>\n<ol>\n<li><p>首先是语义上的。</p>\n<blockquote>\n<p><img src=\"/article/假设只在 id=5 这一行加行锁 -- 语义被破坏.png\"><span class=\"image-caption\">假设只在 id=5 这一行加行锁 -- 语义被破坏</span></p>\n<p>T1: session A 声明，“我要把所有 d=5 的行锁住，不准别的事务进行读写操作”。</p>\n<p>T2:session B 的第二条语句 update t set c=5 where id=0，语义是“我把 id=0、d=5 这一行的 c 值，改成了 5”。由于在 T1 时刻，session A 还只是给 id=5 这一行加了行锁， 并没有给 id=0 这行加上锁。因此，session B 在 T2 时刻，是可以执行这两条 update 语句的。</p>\n<p><strong>这样，就破坏了 session A 里 Q1 语句要锁住所有 d=5 的行的加锁声明。</strong></p>\n</blockquote>\n</li>\n<li><p>其次，是数据一致性的问题。</p>\n<p>锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。</p>\n<blockquote>\n<p><img src=\"/article/假设只在 id=5 这一行加行锁 -- 数据一致性问题.png\"><span class=\"image-caption\">假设只在 id=5 这一行加行锁 -- 数据一致性问题</span></p>\n<p><strong>update 的加锁语义和 select …for update 是一致的</strong></p>\n<ol>\n<li><p>正常执行</p>\n<p>经过 T1 时刻，id=5 这一行变成 (5,5,100)，当然这个结果最终是在 T6 时刻正式提交的 ;</p>\n<p>经过 T2 时刻，id=0 这一行变成 (0,5,5);</p>\n<p>经过 T4 时刻，表里面多了一行 (1,5,5);</p>\n</li>\n<li><p>binlog 记录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">#T2 时刻，session B 事务提交，写入了两条语句；<br>update t set d=5 where id=0; /*(0,0,5)*/<br>update t set c=5 where id=0; /*(0,5,5)*/<br>#T4 时刻，session C 事务提交，写入了两条语句；<br>insert into t values(1,1,5); /*(1,1,5)*/<br>update t set c=5 where id=1; /*(1,5,5)*/<br>#T6 时刻，session A 事务提交，写入了 update t set d=100 where d=5 这条语句。<br>update t set d=100 where d=5;/*所有d=5的行，d改成100*/<br></code></pre></td></tr></table></figure>\n<p>这个语句序列，不论是拿到备库去执行，还是以后用 binlog 来克隆一个库，这三行的结果，都变成了 (0,5,100)、(1,5,100) 和 (5,5,100)。</p>\n<p>id=0 和 id=1 这两行，发生了数据不一致。</p>\n</li>\n</ol>\n<hr>\n<p>为了解决上面数据不一致的问题，假设把扫描过程中碰到的行都加锁</p>\n<img src=\"/article/46662/%E5%81%87%E8%AE%BE%E6%89%AB%E6%8F%8F%E5%88%B0%E7%9A%84%E8%A1%8C%E9%83%BD%E8%A2%AB%E5%8A%A0%E4%B8%8A%E4%BA%86%E8%A1%8C%E9%94%81.png\" class title=\"假设扫描到的行都被加上了行锁\">\n<p>由于 session A 把所有的行都加了写锁，所以 session B 在执行第一个 update 语句的时候就被锁住了。需要等到 T6 时刻 session A 提交以后，session B 才能继续执行。</p>\n<p>binlog:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">insert into t values(1,1,5); /*(1,1,5)*/<br>update t set c=5 where id=1; /*(1,5,5)*/<br><br>update t set d=100 where d=5;/*所有d=5的行，d改成100*/<br><br>update t set d=5 where id=0; /*(0,0,5)*/<br>update t set c=5 where id=0; /*(0,5,5)*/<br></code></pre></td></tr></table></figure>\n<p>按照日志顺序执行，id=0 这一行的最终结果也是 (0,5,5)。所以，id=0 这一行的问题解决了。</p>\n<p>id=1 这一行，在数据库里面的结果是 (1,5,5)，而根据 binlog 的执行结果是 (1,5,100)，也就是说幻读的问题还是没有解决。(因为：在 T3 时刻，我们给所有行加锁的时候，id=1 这一行还不存在，不存在也就加不上锁。)</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>即使把所有的记录都加上锁，还是阻止不了新插入的记录</strong></p>\n<h3 id=\"如何解决幻读？\"><a href=\"#如何解决幻读？\" class=\"headerlink\" title=\"如何解决幻读？\"></a>如何解决幻读？</h3><p>产生幻读的原因是，<strong>行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。</strong></p>\n<p><strong>为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</strong></p>\n<p><strong>间隙锁，锁的就是两个值之间的空隙。</strong></p>\n<blockquote>\n<p>初始化插入了 6 个记录，这就产生了 7 个间隙</p>\n<img src=\"/article/46662/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8A%E7%9A%84%E8%A1%8C%E9%94%81%E5%92%8C%E9%97%B4%E9%9A%99%E9%94%81.png\" class title=\"主键索引上的行锁和间隙锁\">\n<p>当你执行 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from t where d=5 for update<br></code></pre></td></tr></table></figure>\n<p>就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。</p>\n</blockquote>\n<p><strong>在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</strong></p>\n<p>数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。</p>\n<p><strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。</strong>间隙锁之间都不存在冲突关系。</p>\n<p>间隙锁和行锁合称 <strong>next-key lock</strong>，每个 next-key lock 是<strong>前开后闭区间</strong>。</p>\n<blockquote>\n<p>也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p>\n</blockquote>\n<p><strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。</strong></p>\n<blockquote>\n<p><strong>只有在可重复读的隔离级别下，才会有间隙锁。读提交的隔离级别下不会有间隙锁</strong></p>\n</blockquote>\n<h2 id=\"为什么我只改一行的语句，锁这么多？\"><a href=\"#为什么我只改一行的语句，锁这么多？\" class=\"headerlink\" title=\"为什么我只改一行的语句，锁这么多？\"></a>为什么我只改一行的语句，锁这么多？</h2><p><strong>加锁规则</strong>：两个“原则”、两个“优化”和一个“bug”</p>\n<ol>\n<li>原则 1：加锁的基本单位是 <strong>next-key lock</strong>。next-key lock 是前开后闭区间。</li>\n<li>原则 2：查找过程中访问到的对象才会加锁。</li>\n<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>\n<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>\n<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>\n</ol>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  `d` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `c` (`c`)<br>) ENGINE=InnoDB;<br><br>insert into t values(0,0,0),(5,5,5),<br>(10,10,10),(15,15,15),(20,20,20),(25,25,25);<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"等值查询间隙锁\"><a href=\"#等值查询间隙锁\" class=\"headerlink\" title=\"等值查询间隙锁\"></a>等值查询间隙锁</h3><blockquote>\n<img src=\"/article/46662/%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%97%B4%E9%9A%99%E9%94%81.png\" class title=\"等值查询的间隙锁\">\n<p>由于表 t 中没有 id=7 的记录</p>\n<ol>\n<li>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</li>\n<li>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</li>\n</ol>\n<p><strong>session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。</strong></p>\n</blockquote>\n<h3 id=\"非唯一索引等值锁\"><a href=\"#非唯一索引等值锁\" class=\"headerlink\" title=\"非唯一索引等值锁\"></a>非唯一索引等值锁</h3><blockquote>\n<img src=\"/article/46662/%E5%8F%AA%E5%8A%A0%E5%9C%A8%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%B8%8A%E7%9A%84%E9%94%81.png\" class title=\"只加在非唯一索引上的锁\">\n<ol>\n<li>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5]加上 next-key lock。</li>\n<li>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10]加 next-key lock。</li>\n<li>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</li>\n<li>根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。\u0010(加锁，是加在索引上的。 列上，有索引，就加在索引上； 列上，没有索引，就加在主键上；)</li>\n</ol>\n<p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</p>\n<p><strong>lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁</strong>。</p>\n<p>这个例子说明，<strong>锁是加在索引上的</strong>；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 select d from t where c=5 lock in share mode。（改为select d ，因为索引c，并没有d列的值，需要回表，查主键，这样就会把id=5这行数据加锁。session B会被锁住。 session C 还是会因为session A 在C列上的间隙锁(0,5},(5,10)而不能插入。 实际加锁范围是：id=5的行锁，普通索引c上锁范围(0,5},(5,10)）</p>\n</blockquote>\n<h3 id=\"主键索引范围锁\"><a href=\"#主键索引范围锁\" class=\"headerlink\" title=\"主键索引范围锁\"></a>主键索引范围锁</h3><blockquote>\n<p>这两条查询语句，加锁范围相同吗？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from t where id=10 for update;<br>mysql&gt; select * from t where id&gt;=10 and id&lt;11 for update;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/46662/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8A%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%94%81.png\" class title=\"主键索引上范围查询的锁\">\n<ol>\n<li>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</li>\n<li>范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。</li>\n</ol>\n<p>所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。</p>\n<p>注意：首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</p>\n</blockquote>\n<h3 id=\"非唯一索引范围锁\"><a href=\"#非唯一索引范围锁\" class=\"headerlink\" title=\"非唯一索引范围锁\"></a>非唯一索引范围锁</h3><blockquote>\n<img src=\"/article/46662/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81.png\" class title=\"非唯一索引范围锁\">\n<p>这次 session A 用字段 c 来判断</p>\n<p>加锁规则跟主键索引范围锁唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10]这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。</p>\n</blockquote>\n<h3 id=\"唯一索引范围锁-bug\"><a href=\"#唯一索引范围锁-bug\" class=\"headerlink\" title=\"唯一索引范围锁 bug\"></a>唯一索引范围锁 bug</h3><blockquote>\n<p><img src=\"/article/唯一索引范围锁的 bug.png\"><span class=\"image-caption\">唯一索引范围锁的 bug</span></p>\n<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15]这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了</p>\n<p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20]这个 next-key lock 也会被锁上。</p>\n</blockquote>\n<h3 id=\"非唯一索引上存在”等值”的例子\"><a href=\"#非唯一索引上存在”等值”的例子\" class=\"headerlink\" title=\"非唯一索引上存在”等值”的例子\"></a>非唯一索引上存在”等值”的例子</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; insert into t values(30,10,30);<br></code></pre></td></tr></table></figure>\n<p>新插入的这一行 c=10，也就是说现在表里有两个 c=10 的行。</p>\n<p>由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。</p>\n<img src=\"/article/46662/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E7%9A%84%E4%BE%8B%E5%AD%90.png\" class title=\"非唯一索引等值的例子\">\n<p>可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和 30），因此这两个 c=10 的记录之间，也是有间隙的。</p>\n<p><img src=\"/article/delete 示例.png\"><span class=\"image-caption\">delete 示例</span></p>\n<ol>\n<li>session A 在遍历的时候，先访问第一个 c=10 的记录。同样地，根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。</li>\n<li>session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。</li>\n</ol>\n<p>也就是说，这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。</p>\n<p><img src=\"/article/delete 加锁效果示例.png\"><span class=\"image-caption\">delete 加锁效果示例</span></p>\n</blockquote>\n<h3 id=\"limit-语句加锁\"><a href=\"#limit-语句加锁\" class=\"headerlink\" title=\"limit 语句加锁\"></a>limit 语句加锁</h3><blockquote>\n<p><img src=\"/article/limit 语句加锁.png\"><span class=\"image-caption\">limit 语句加锁</span></p>\n<p>session A 的 delete 语句加了 limit 2。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了。</p>\n<p>这是因为， delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。</p>\n<p>因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间。</p>\n<p><img src=\"/article/带 limit 2 的加锁效果.png\"><span class=\"image-caption\">带 limit 2 的加锁效果</span></p>\n<p><strong>在删除数据的时候尽量加 limit</strong>。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>\n</blockquote>\n<h3 id=\"一个死锁的例子\"><a href=\"#一个死锁的例子\" class=\"headerlink\" title=\"一个死锁的例子\"></a>一个死锁的例子</h3><blockquote>\n<img src=\"/article/46662/%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97.png\" class title=\"操作序列\">\n<ol>\n<li>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</li>\n<li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</li>\n<li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</li>\n</ol>\n<p>session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。</p>\n<p><strong>也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</strong></p>\n</blockquote>\n","categories":[{"name":"Mysql","path":"api/categories/Mysql.json"},{"name":"面试","path":"api/categories/面试.json"}],"tags":[{"name":"实习,Mysql","path":"api/tags/实习,Mysql.json"}]}