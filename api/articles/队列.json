{"title":"队列","slug":"队列","date":"2022-05-07T05:00:55.000Z","updated":"2022-05-07T06:28:44.777Z","comments":true,"path":"api/articles/队列.json","realPath":null,"excerpt":null,"covers":["/article/undefined/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.jpg","/article/undefined/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.jpg","/article/undefined/%E5%9F%BA%E4%BA%8E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.jpg","/article/undefined/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E9%98%9F%E6%BB%A1.jpg","/article/undefined/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.jpg"],"cover":"/images/theme/coverphoto/队列.jpg","content":"<h2 id=\"队列：队列在线程池等有限资源池中的应用\"><a href=\"#队列：队列在线程池等有限资源池中的应用\" class=\"headerlink\" title=\"队列：队列在线程池等有限资源池中的应用\"></a>队列：队列在线程池等有限资源池中的应用</h2><p>CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。</p>\n<blockquote>\n<p>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</p>\n</blockquote>\n<p><strong>先进者先出，这就是典型的“队列”。</strong></p>\n<p>最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。</p>\n<p>队列跟栈一样，也是<strong>一种操作受限的线性表数据结构</strong>。</p>\n<p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p>\n<h3 id=\"基于数组的队列实现方法\"><a href=\"#基于数组的队列实现方法\" class=\"headerlink\" title=\"基于数组的队列实现方法\"></a>基于数组的队列实现方法</h3><blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 用数组实现的队列</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ArrayQueue</span> </span>&#123;<br>  <span class=\"hljs-comment\">// 数组：items，数组大小：n</span><br>  <span class=\"hljs-keyword\">private</span> String[] items;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-comment\">// head表示队头下标，tail表示队尾下标</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> head = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> tail = <span class=\"hljs-number\">0</span>;<br><br>  <span class=\"hljs-comment\">// 申请一个大小为capacity的数组</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ArrayQueue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> capacity)</span> </span>&#123;<br>    items = <span class=\"hljs-keyword\">new</span> String[capacity];<br>    n = capacity;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 入队</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">enqueue</span><span class=\"hljs-params\">(String item)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 如果tail == n 表示队列已经满了</span><br>    <span class=\"hljs-keyword\">if</span> (tail == n) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    items[tail] = item;<br>    ++tail;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 出队</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">dequeue</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 如果head == tail 表示队列为空</span><br>    <span class=\"hljs-keyword\">if</span> (head == tail) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    <span class=\"hljs-comment\">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span><br>    String ret = items[head];<br>    ++head;<br>    <span class=\"hljs-keyword\">return</span> ret;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>队列需要两个指针：</p>\n<ol>\n<li>一个是 head 指针，指向队头；</li>\n<li>一个是 tail 指针，指向队尾。</li>\n</ol>\n<blockquote>\n<p>每次进行出队操作都相当于删除数组下标为 0 的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的 O(1) 变为 O(n)。能不能优化一下呢？</p>\n</blockquote>\n<p>在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 入队操作，将item放入队尾</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">enqueue</span><span class=\"hljs-params\">(String item)</span> </span>&#123;<br>  <span class=\"hljs-comment\">// tail == n表示队列末尾没有空间了</span><br>  <span class=\"hljs-keyword\">if</span> (tail == n) &#123;<br>    <span class=\"hljs-comment\">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span><br>    <span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    <span class=\"hljs-comment\">// 数据搬移</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = head; i &lt; tail; ++i) &#123;<br>      items[i-head] = items[i];<br>    &#125;<br>    <span class=\"hljs-comment\">// 搬移完之后重新更新head和tail</span><br>    tail -= head;<br>    head = <span class=\"hljs-number\">0</span>;<br>  &#125;<br><br>  items[tail] = item;<br>  ++tail;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/undefined/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.jpg\" class title=\"顺序队列数据迁移\">\n</blockquote>\n<h3 id=\"基于链表的队列实现方法\"><a href=\"#基于链表的队列实现方法\" class=\"headerlink\" title=\"基于链表的队列实现方法\"></a>基于链表的队列实现方法</h3><p>基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。</p>\n<img src=\"/article/undefined/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.jpg\" class title=\"基于链表的队列实现\">\n<p><strong>循环队列</strong></p>\n<img src=\"/article/undefined/%E5%9F%BA%E4%BA%8E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.jpg\" class title=\"基于循环链表的队列实现\">\n<p><strong>确定好队空和队满的判定条件：</strong></p>\n<ol>\n<li><p>队列为空的判断条件是 head == tail</p>\n</li>\n<li><p>当队满时的判断条件是 (tail+1)%n=head</p>\n<img src=\"/article/undefined/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E9%98%9F%E6%BB%A1.jpg\" class title=\"循环队列队满\">\n<p><strong>循环队列会浪费一个数组的存储空间</strong></p>\n</li>\n</ol>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CircularQueue</span> </span>&#123;<br>  <span class=\"hljs-comment\">// 数组：items，数组大小：n</span><br>  <span class=\"hljs-keyword\">private</span> String[] items;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-comment\">// head表示队头下标，tail表示队尾下标</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> head = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> tail = <span class=\"hljs-number\">0</span>;<br><br>  <span class=\"hljs-comment\">// 申请一个大小为capacity的数组</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">CircularQueue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> capacity)</span> </span>&#123;<br>    items = <span class=\"hljs-keyword\">new</span> String[capacity];<br>    n = capacity;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 入队</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">enqueue</span><span class=\"hljs-params\">(String item)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 队列满了</span><br>    <span class=\"hljs-keyword\">if</span> ((tail + <span class=\"hljs-number\">1</span>) % n == head) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    items[tail] = item;<br>    tail = (tail + <span class=\"hljs-number\">1</span>) % n;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 出队</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">dequeue</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 如果head == tail 表示队列为空</span><br>    <span class=\"hljs-keyword\">if</span> (head == tail) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    String ret = items[head];<br>    head = (head + <span class=\"hljs-number\">1</span>) % n;<br>    <span class=\"hljs-keyword\">return</span> ret;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"阻塞队列和并发队列\"><a href=\"#阻塞队列和并发队列\" class=\"headerlink\" title=\"阻塞队列和并发队列\"></a>阻塞队列和并发队列</h3><p><strong>阻塞队列</strong>就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>\n<img src=\"/article/undefined/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.jpg\" class title=\"阻塞队列\">\n<p><strong>并发队列</strong>是线程安全的队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。</p>\n<blockquote>\n<p><strong>问题：线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</strong></p>\n<ol>\n<li>第一种是非阻塞的处理方式，直接拒绝任务请求；</li>\n<li>另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<ol>\n<li>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</li>\n<li>而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n","more":"<h2 id=\"队列：队列在线程池等有限资源池中的应用\"><a href=\"#队列：队列在线程池等有限资源池中的应用\" class=\"headerlink\" title=\"队列：队列在线程池等有限资源池中的应用\"></a>队列：队列在线程池等有限资源池中的应用</h2><p>CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。</p>\n<blockquote>\n<p>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</p>\n</blockquote>\n<p><strong>先进者先出，这就是典型的“队列”。</strong></p>\n<p>最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。</p>\n<p>队列跟栈一样，也是<strong>一种操作受限的线性表数据结构</strong>。</p>\n<p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p>\n<h3 id=\"基于数组的队列实现方法\"><a href=\"#基于数组的队列实现方法\" class=\"headerlink\" title=\"基于数组的队列实现方法\"></a>基于数组的队列实现方法</h3><blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 用数组实现的队列</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ArrayQueue</span> </span>&#123;<br>  <span class=\"hljs-comment\">// 数组：items，数组大小：n</span><br>  <span class=\"hljs-keyword\">private</span> String[] items;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-comment\">// head表示队头下标，tail表示队尾下标</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> head = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> tail = <span class=\"hljs-number\">0</span>;<br><br>  <span class=\"hljs-comment\">// 申请一个大小为capacity的数组</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ArrayQueue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> capacity)</span> </span>&#123;<br>    items = <span class=\"hljs-keyword\">new</span> String[capacity];<br>    n = capacity;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 入队</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">enqueue</span><span class=\"hljs-params\">(String item)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 如果tail == n 表示队列已经满了</span><br>    <span class=\"hljs-keyword\">if</span> (tail == n) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    items[tail] = item;<br>    ++tail;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 出队</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">dequeue</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 如果head == tail 表示队列为空</span><br>    <span class=\"hljs-keyword\">if</span> (head == tail) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    <span class=\"hljs-comment\">// 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span><br>    String ret = items[head];<br>    ++head;<br>    <span class=\"hljs-keyword\">return</span> ret;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>队列需要两个指针：</p>\n<ol>\n<li>一个是 head 指针，指向队头；</li>\n<li>一个是 tail 指针，指向队尾。</li>\n</ol>\n<blockquote>\n<p>每次进行出队操作都相当于删除数组下标为 0 的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的 O(1) 变为 O(n)。能不能优化一下呢？</p>\n</blockquote>\n<p>在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 入队操作，将item放入队尾</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">enqueue</span><span class=\"hljs-params\">(String item)</span> </span>&#123;<br>  <span class=\"hljs-comment\">// tail == n表示队列末尾没有空间了</span><br>  <span class=\"hljs-keyword\">if</span> (tail == n) &#123;<br>    <span class=\"hljs-comment\">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span><br>    <span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    <span class=\"hljs-comment\">// 数据搬移</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = head; i &lt; tail; ++i) &#123;<br>      items[i-head] = items[i];<br>    &#125;<br>    <span class=\"hljs-comment\">// 搬移完之后重新更新head和tail</span><br>    tail -= head;<br>    head = <span class=\"hljs-number\">0</span>;<br>  &#125;<br><br>  items[tail] = item;<br>  ++tail;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/undefined/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.jpg\" class title=\"顺序队列数据迁移\">\n</blockquote>\n<h3 id=\"基于链表的队列实现方法\"><a href=\"#基于链表的队列实现方法\" class=\"headerlink\" title=\"基于链表的队列实现方法\"></a>基于链表的队列实现方法</h3><p>基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。</p>\n<img src=\"/article/undefined/%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.jpg\" class title=\"基于链表的队列实现\">\n<p><strong>循环队列</strong></p>\n<img src=\"/article/undefined/%E5%9F%BA%E4%BA%8E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.jpg\" class title=\"基于循环链表的队列实现\">\n<p><strong>确定好队空和队满的判定条件：</strong></p>\n<ol>\n<li><p>队列为空的判断条件是 head == tail</p>\n</li>\n<li><p>当队满时的判断条件是 (tail+1)%n=head</p>\n<img src=\"/article/undefined/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E9%98%9F%E6%BB%A1.jpg\" class title=\"循环队列队满\">\n<p><strong>循环队列会浪费一个数组的存储空间</strong></p>\n</li>\n</ol>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CircularQueue</span> </span>&#123;<br>  <span class=\"hljs-comment\">// 数组：items，数组大小：n</span><br>  <span class=\"hljs-keyword\">private</span> String[] items;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-comment\">// head表示队头下标，tail表示队尾下标</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> head = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> tail = <span class=\"hljs-number\">0</span>;<br><br>  <span class=\"hljs-comment\">// 申请一个大小为capacity的数组</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">CircularQueue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> capacity)</span> </span>&#123;<br>    items = <span class=\"hljs-keyword\">new</span> String[capacity];<br>    n = capacity;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 入队</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">enqueue</span><span class=\"hljs-params\">(String item)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 队列满了</span><br>    <span class=\"hljs-keyword\">if</span> ((tail + <span class=\"hljs-number\">1</span>) % n == head) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    items[tail] = item;<br>    tail = (tail + <span class=\"hljs-number\">1</span>) % n;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 出队</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">dequeue</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 如果head == tail 表示队列为空</span><br>    <span class=\"hljs-keyword\">if</span> (head == tail) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    String ret = items[head];<br>    head = (head + <span class=\"hljs-number\">1</span>) % n;<br>    <span class=\"hljs-keyword\">return</span> ret;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"阻塞队列和并发队列\"><a href=\"#阻塞队列和并发队列\" class=\"headerlink\" title=\"阻塞队列和并发队列\"></a>阻塞队列和并发队列</h3><p><strong>阻塞队列</strong>就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p>\n<img src=\"/article/undefined/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.jpg\" class title=\"阻塞队列\">\n<p><strong>并发队列</strong>是线程安全的队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。</p>\n<blockquote>\n<p><strong>问题：线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</strong></p>\n<ol>\n<li>第一种是非阻塞的处理方式，直接拒绝任务请求；</li>\n<li>另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<ol>\n<li>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</li>\n<li>而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n","categories":[{"name":"数据结构与算法","path":"api/categories/数据结构与算法.json"},{"name":"队列","path":"api/categories/队列.json"}],"tags":[{"name":"数据结构与算法,队列","path":"api/tags/数据结构与算法,队列.json"}]}