{"title":"分治算法","slug":"分治算法","date":"2022-05-30T01:54:15.000Z","updated":"2022-07-11T13:10:18.131Z","comments":true,"path":"api/articles/分治算法.json","realPath":null,"excerpt":null,"covers":["/article/46607/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E4%B8%AA%E6%95%B0.jpg"],"cover":"/images/theme/coverphoto/分治算法.jpg","content":"<h2 id=\"分治算法\"><a href=\"#分治算法\" class=\"headerlink\" title=\"分治算法\"></a>分治算法</h2><p><strong>分治算法（divide and conquer）的核心思想</strong>其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p>\n<p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong></p>\n<p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p>\n<ol>\n<li>分解：将原问题分解成一系列子问题；</li>\n<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li>\n<li>合并：将子问题的结果合并成原问题。</li>\n</ol>\n<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>\n<ol>\n<li>原问题与分解成的小问题具有相同的模式；</li>\n<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li>\n<li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li>\n<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li>\n</ol>\n<h3 id=\"分治算法应用举例\"><a href=\"#分治算法应用举例\" class=\"headerlink\" title=\"分治算法应用举例\"></a>分治算法应用举例</h3><blockquote>\n<p><strong>如何求出一组数据的有序对个数或者逆序对个数</strong></p>\n</blockquote>\n<p>有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。</p>\n<p>假设有 n 个数据，期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。</p>\n<p>用分治的思想来求数组 A 的逆序对个数。可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p>\n<p><strong>归并排序</strong>中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，就可以计算这两个小数组的逆序对个数了。每次合并操作，都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p>\n<img src=\"/article/46607/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E4%B8%AA%E6%95%B0.jpg\" class title=\"归并排序求逆序对个数\">\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> num = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 全局变量或者成员变量</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">count</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>  num = <span class=\"hljs-number\">0</span>;<br>  mergeSortCounting(a, <span class=\"hljs-number\">0</span>, n-<span class=\"hljs-number\">1</span>);<br>  <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mergeSortCounting</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (p &gt;= r) <span class=\"hljs-keyword\">return</span>;<br>  <span class=\"hljs-keyword\">int</span> q = (p+r)/<span class=\"hljs-number\">2</span>;<br>  mergeSortCounting(a, p, q);<br>  mergeSortCounting(a, q+<span class=\"hljs-number\">1</span>, r);<br>  merge(a, p, q, r);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> q, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span> i = p, j = q+<span class=\"hljs-number\">1</span>, k = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">int</span>[] tmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[r-p+<span class=\"hljs-number\">1</span>];<br>  <span class=\"hljs-keyword\">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;<br>    <span class=\"hljs-keyword\">if</span> (a[i] &lt;= a[j]) &#123;<br>      tmp[k++] = a[i++];<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      num += (q-i+<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 统计p-q之间，比a[j]大的元素个数</span><br>      tmp[k++] = a[j++];<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">while</span> (i &lt;= q) &#123; <span class=\"hljs-comment\">// 处理剩下的</span><br>    tmp[k++] = a[i++];<br>  &#125;<br>  <span class=\"hljs-keyword\">while</span> (j &lt;= r) &#123; <span class=\"hljs-comment\">// 处理剩下的</span><br>    tmp[k++] = a[j++];<br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt;= r-p; ++i) &#123; <span class=\"hljs-comment\">// 从tmp拷贝回a</span><br>    a[p+i] = tmp[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"分治思想在海量数据处理中的应用\"><a href=\"#分治思想在海量数据处理中的应用\" class=\"headerlink\" title=\"分治思想在海量数据处理中的应用\"></a>分治思想在海量数据处理中的应用</h3><blockquote>\n<p>给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而机器的内存可能只有 2、3GB ，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p>\n</blockquote>\n<p>利用分治的思想。可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p>\n<blockquote>\n<p>给 10GB 的订单排序，可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p>\n</blockquote>\n","more":"<h2 id=\"分治算法\"><a href=\"#分治算法\" class=\"headerlink\" title=\"分治算法\"></a>分治算法</h2><p><strong>分治算法（divide and conquer）的核心思想</strong>其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p>\n<p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong></p>\n<p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p>\n<ol>\n<li>分解：将原问题分解成一系列子问题；</li>\n<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li>\n<li>合并：将子问题的结果合并成原问题。</li>\n</ol>\n<p>分治算法能解决的问题，一般需要满足下面这几个条件：</p>\n<ol>\n<li>原问题与分解成的小问题具有相同的模式；</li>\n<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li>\n<li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li>\n<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li>\n</ol>\n<h3 id=\"分治算法应用举例\"><a href=\"#分治算法应用举例\" class=\"headerlink\" title=\"分治算法应用举例\"></a>分治算法应用举例</h3><blockquote>\n<p><strong>如何求出一组数据的有序对个数或者逆序对个数</strong></p>\n</blockquote>\n<p>有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。</p>\n<p>假设有 n 个数据，期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。</p>\n<p>用分治的思想来求数组 A 的逆序对个数。可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p>\n<p><strong>归并排序</strong>中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，就可以计算这两个小数组的逆序对个数了。每次合并操作，都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p>\n<img src=\"/article/46607/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E4%B8%AA%E6%95%B0.jpg\" class title=\"归并排序求逆序对个数\">\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> num = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 全局变量或者成员变量</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">count</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>  num = <span class=\"hljs-number\">0</span>;<br>  mergeSortCounting(a, <span class=\"hljs-number\">0</span>, n-<span class=\"hljs-number\">1</span>);<br>  <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mergeSortCounting</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (p &gt;= r) <span class=\"hljs-keyword\">return</span>;<br>  <span class=\"hljs-keyword\">int</span> q = (p+r)/<span class=\"hljs-number\">2</span>;<br>  mergeSortCounting(a, p, q);<br>  mergeSortCounting(a, q+<span class=\"hljs-number\">1</span>, r);<br>  merge(a, p, q, r);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] a, <span class=\"hljs-keyword\">int</span> p, <span class=\"hljs-keyword\">int</span> q, <span class=\"hljs-keyword\">int</span> r)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span> i = p, j = q+<span class=\"hljs-number\">1</span>, k = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">int</span>[] tmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[r-p+<span class=\"hljs-number\">1</span>];<br>  <span class=\"hljs-keyword\">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;<br>    <span class=\"hljs-keyword\">if</span> (a[i] &lt;= a[j]) &#123;<br>      tmp[k++] = a[i++];<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      num += (q-i+<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 统计p-q之间，比a[j]大的元素个数</span><br>      tmp[k++] = a[j++];<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">while</span> (i &lt;= q) &#123; <span class=\"hljs-comment\">// 处理剩下的</span><br>    tmp[k++] = a[i++];<br>  &#125;<br>  <span class=\"hljs-keyword\">while</span> (j &lt;= r) &#123; <span class=\"hljs-comment\">// 处理剩下的</span><br>    tmp[k++] = a[j++];<br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt;= r-p; ++i) &#123; <span class=\"hljs-comment\">// 从tmp拷贝回a</span><br>    a[p+i] = tmp[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"分治思想在海量数据处理中的应用\"><a href=\"#分治思想在海量数据处理中的应用\" class=\"headerlink\" title=\"分治思想在海量数据处理中的应用\"></a>分治思想在海量数据处理中的应用</h3><blockquote>\n<p>给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而机器的内存可能只有 2、3GB ，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p>\n</blockquote>\n<p>利用分治的思想。可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p>\n<blockquote>\n<p>给 10GB 的订单排序，可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p>\n</blockquote>\n","categories":[{"name":"数据结构与算法","path":"api/categories/数据结构与算法.json"},{"name":"分治算法","path":"api/categories/分治算法.json"}],"tags":[{"name":"数据结构与算法,分治算法","path":"api/tags/数据结构与算法,分治算法.json"}]}