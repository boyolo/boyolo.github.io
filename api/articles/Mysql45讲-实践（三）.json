{"title":"Mysql45讲-实践（三）","slug":"Mysql45讲-实践（三）","date":"2022-04-26T09:41:18.000Z","updated":"2022-05-24T11:41:34.377Z","comments":true,"path":"api/articles/Mysql45讲-实践（三）.json","realPath":null,"excerpt":null,"covers":["/article/10821/%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.jpg","/article/10821/%E5%9F%BA%E6%9C%AC%E5%9B%9E%E8%A1%A8%E6%B5%81%E7%A8%8B.png","/article/10821/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%AE%80%E5%9B%BE.jpg","/article/10821/%E8%B7%A8%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg","/article/10821/%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.jpg"],"cover":"/images/theme/coverphoto/Mysql.jpg","content":"<h2 id=\"如何判断一个数据库是不是出问题了？\"><a href=\"#如何判断一个数据库是不是出问题了？\" class=\"headerlink\" title=\"如何判断一个数据库是不是出问题了？\"></a>如何判断一个数据库是不是出问题了？</h2><h3 id=\"select-1-判断\"><a href=\"#select-1-判断\" class=\"headerlink\" title=\"select 1 判断\"></a>select 1 判断</h3><p>select 1 成功返回，只能说明这个库的进程还在，并不能说明主库没问题。</p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">set global innodb_thread_concurrency=3;<br><br>CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB;<br><br>insert into t values(1,1)<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article/查询 blocked.png\"><span class=\"image-caption\">查询 blocked</span></p>\n<p>设置 innodb_thread_concurrency 参数的目的是，控制 InnoDB 的并发线程上限。</p>\n</blockquote>\n<p>select 1 是能执行成功的，但是查询表 t 的语句会被堵住。</p>\n<p>如果用 select 1 来检测实例是否正常的话，是检测不出问题的。</p>\n<p>通常情况下，建议把 innodb_thread_concurrency 设置为 64~128 之间的值。</p>\n<blockquote>\n<p><strong>并发连接和并发查询</strong>，并不是同一个概念：</p>\n<p>在 <code>show processlist</code> 的结果里，看到的几千个连接，指的就是并发连接。而“当前正在执行”的语句，才是我们所说的并发查询。</p>\n<p>并发连接数达到几千个影响并不大，就是多占一些内存而已。我们应该关注的是并发查询，因为并发查询太高才是 CPU 杀手。</p>\n<p><strong>在线程进入锁等待以后，并发线程的计数会减一</strong></p>\n</blockquote>\n<p>在这个例子中，同时在执行的语句超过了设置的 innodb_thread_concurrency 的值，这时候系统其实已经不行了，但是通过 select 1 来检测系统，会认为系统还是正常的。</p>\n<p>因此，我们使用 select 1 的判断逻辑要修改一下。</p>\n<h3 id=\"查表判断\"><a href=\"#查表判断\" class=\"headerlink\" title=\"查表判断\"></a>查表判断</h3><p>为了能够检测 InnoDB 并发线程数过多导致的系统不可用情况，我们需要找一个访问 InnoDB 的场景。一般的做法是，在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from mysql.health_check; <br></code></pre></td></tr></table></figure>\n<p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。</p>\n<blockquote>\n<p>问题：更新事务要写 binlog，而一旦 binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p>\n<p>因此，我们还是把这条监控语句再改进一下。把查询语句改成更新语句。</p>\n</blockquote>\n<h3 id=\"更新判断\"><a href=\"#更新判断\" class=\"headerlink\" title=\"更新判断\"></a>更新判断</h3><p>既然要更新，就要放个有意义的字段，常见做法是放一个 timestamp 字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; update mysql.health_check set t_modified=now();<br></code></pre></td></tr></table></figure>\n<p>节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。</p>\n<p>但，备库的检测也是要写 binlog 的。由于我们一般会把数据库 A 和 B 的主备关系设计为双 M 结构，所以在备库 B 上执行的检测命令，也要发回给主库 A。</p>\n<p>但是，如果主库 A 和备库 B 都用相同的更新命令，就可能出现行冲突，也就是可能会导致主备同步停止。所以，现在看来 mysql.health_check 这个表就不能只有一行数据了。</p>\n<p><strong>为了让主备之间的更新不产生冲突，我们可以在 mysql.health_check 表上存入多行数据，并用 A、B 的 server_id 做主键。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; CREATE TABLE `health_check` (<br>  `id` int(11) NOT NULL,<br>  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB;<br><br>/* 检测命令 */<br>insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified=now();<br></code></pre></td></tr></table></figure>\n<p>由于 MySQL 规定了主库和备库的 server_id 必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。</p>\n<blockquote>\n<p>问题：更新判断是一个相对比较常用的方案了，不过依然存在一些“判定慢”的问题。</p>\n<p>涉及到的是服务器 IO 资源分配的问题</p>\n<p>首先，所有的检测逻辑都需要一个超时时间 N。执行一条 update 语句，超过 N 秒后还不返回，就认为系统不可用。</p>\n<p>IO 利用率 100% 表示系统的 IO 是在工作的，每个请求都有机会获得 IO 资源，执行自己的任务。而我们的检测使用的 update 命令，需要的资源很少，所以可能在拿到 IO 资源的时候就可以提交成功，并且在超时时间 N 秒未到达之前就返回给了检测系统。</p>\n<p>检测系统一看，update 命令没有超时，于是就得到了“系统正常”的结论。</p>\n<p>也就是说，这时候在业务系统上正常的 SQL 语句已经执行得很慢了，但是 DBA 上去一看，HA 系统还在正常工作，并且认为主库现在处于可用状态。</p>\n<p><strong>根本原因是我们上面说的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随机性。</strong></p>\n</blockquote>\n<h3 id=\"内部统计\"><a href=\"#内部统计\" class=\"headerlink\" title=\"内部统计\"></a>内部统计</h3><p>在 MySQL 内部发现数据库问题的方法</p>\n<p>MySQL 5.6 版本以后提供的 <code>performance_schema 库</code>，就在 <code>file_summary_by_event_name</code> 表里统计了每次 IO 请求的时间。</p>\n<blockquote>\n<p><code>event_name=&#39;wait/io/file/innodb/innodb_log_file’</code></p>\n<p><img src=\"/article/performance_schema.file_summary_by_event_name 的一行.png\"><span class=\"image-caption\">performance_schema.file_summary_by_event_name 的一行</span></p>\n<p>图中这一行表示统计的是 redo log 的写入时间，第一列 EVENT_NAME 表示统计的类型。</p>\n<p>接下来的三组数据，显示的是 redo log 操作的时间统计。</p>\n<p>第一组五列，是所有 IO 类型的统计。其中，COUNT_STAR 是所有 IO 的总次数，接下来四列是具体的统计项， 单位是皮秒；前缀 SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、平均值和最大值。</p>\n<p>第二组六列，是读操作的统计。最后一列 SUM_NUMBER_OF_BYTES_READ 统计的是，总共从 redo log 里读了多少个字节。</p>\n<p>第三组六列，统计的是写操作。</p>\n<p>最后的第四组数据，是对其他类型数据的统计。在 redo log 里，你可以认为它们就是对 fsync 的统计。</p>\n<p>在 <code>performance_schema 库</code>的 <code>file_summary_by_event_name</code> 表里，binlog 对应的是 <code>event_name = &quot;wait/io/file/sql/binlog&quot;</code>这一行。各个字段的统计逻辑，与 redo log 的各个字段完全相同。</p>\n<p>每一次操作数据库，performance_schema 都需要额外地统计这些信息，所以我们打开这个统计功能是有性能损耗。如果打开所有的 performance_schema 项，性能大概会下降 10% 左右。</p>\n<p><strong>建议只打开自己需要的项进行统计</strong></p>\n<p>把这个信息用在实例状态诊断上：可以通过 MAX_TIMER 的值来判断数据库是否出问题了</p>\n</blockquote>\n<h2 id=\"误删数据后除了跑路，还能怎么办？\"><a href=\"#误删数据后除了跑路，还能怎么办？\" class=\"headerlink\" title=\"误删数据后除了跑路，还能怎么办？\"></a>误删数据后除了跑路，还能怎么办？</h2><p>对 MySQL 相关的误删数据，做下分类：</p>\n<ol>\n<li>使用 delete 语句误删数据行；</li>\n<li>使用 drop table 或者 truncate table 语句误删数据表；</li>\n<li>使用 drop database 语句误删数据库；</li>\n<li>使用 rm 命令误删整个 MySQL 实例。</li>\n</ol>\n<h3 id=\"误删行\"><a href=\"#误删行\" class=\"headerlink\" title=\"误删行\"></a>误删行</h3><p>如果是使用 delete 语句误删了数据行，可以用 Flashback 工具通过闪回把数据恢复回来。</p>\n<p>Flashback 恢复数据的原理，是修改 binlog 的内容，拿回原库重放。</p>\n<p><strong>需要确保 <code>binlog_format=row</code> 和 <code>binlog_row_image=FULL</code></strong></p>\n<p>具体恢复数据时，对单个事务做如下处理：</p>\n<ol>\n<li>对于 insert 语句，对应的 binlog event 类型是 <code>Write_rows event</code>，把它改成 <code>Delete_rows event</code> 即可；</li>\n<li>同理，对于 delete 语句，也是将 <code>Delete_rows event</code> 改为 <code>Write_rows event</code>；</li>\n<li>而如果是 Update_rows 的话，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li>\n</ol>\n<p>如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行</p>\n<p><strong>不建议你直接在主库上执行这些操作</strong>:恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。</p>\n<p><strong>更重要是要做到事前预防:</strong></p>\n<ol>\n<li><p>把 <code>sql_safe_updates</code> 参数设置为 <code>on</code>。这样一来，如果我们忘记在 delete 或者 update 语句中写 where 条件，或者 where 条件里面没有包含索引字段的话，这条语句的执行就会报错。</p>\n<blockquote>\n<p>如果你确定这个删除操作没问题的话，可以在 delete 语句中加上 where 条件，比如 where id&gt;=0。</p>\n<p>但是，delete 全表是很慢的，需要生成回滚日志、写 redo、写 binlog。所以，从性能角度考虑，你应该优先考虑使用 <code>truncate table</code> 或者 <code>drop table</code> 命令。</p>\n<p>使用 delete 命令删除的数据，你还可以用 Flashback 来恢复。而使用 <code>truncate /drop table</code> 和 <code>drop database</code> 命令删除的数据，就没办法通过 Flashback 来恢复了</p>\n<p>因为，即使我们配置了 <code>binlog_format=row</code>，执行这三个命令时，记录的 binlog 还是 statement 格式。binlog 里面就只有一个 truncate/drop 语句，这些信息是恢复不出数据的。</p>\n</blockquote>\n</li>\n<li><p>代码上线前，必须经过 SQL 审计。</p>\n</li>\n</ol>\n<h3 id=\"误删库-表\"><a href=\"#误删库-表\" class=\"headerlink\" title=\"误删库 / 表\"></a>误删库 / 表</h3><p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份 binlog。</p>\n<blockquote>\n<p>假如有人中午 12 点误删了一个库，恢复数据的流程如下：</p>\n<ol>\n<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天 0 点；</li>\n<li>用备份恢复出一个临时库；</li>\n<li>从日志备份里面，取出凌晨 0 点之后的日志；</li>\n<li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li>\n</ol>\n<p><img src=\"/article/数据恢复流程 -mysqlbinlog 方法.png\"><span class=\"image-caption\">数据恢复流程 -mysqlbinlog 方法</span></p>\n</blockquote>\n<ol>\n<li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用 mysqlbinlog 命令时，加上一个<code>–database</code> 参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。</li>\n<li>在应用日志的时候，需要跳过 12 点误操作的那个语句的 binlog：<ol>\n<li>如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用<code>–stop-position</code> 参数执行到误操作之前的日志，然后再用<code>–start-position</code> 从误操作之后的日志继续执行；</li>\n<li>如果实例使用了 GTID 模式，就方便多了。假设误操作命令的 GTID 是 gtid1，那么只需要执行 <code>set gtid_next=gtid1;begin;commit;</code> 先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时候，就会自动跳过误操作的语句。</li>\n</ol>\n</li>\n</ol>\n<p><strong>使用 mysqlbinlog 方法恢复数据还是不够快</strong>，主要原因有两个：</p>\n<ol>\n<li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是 mysqlbinlog 工具并不能指定只解析一个表的日志；</li>\n<li>用 mysqlbinlog 解析出日志应用，应用日志的过程就只能是单线程。</li>\n</ol>\n<p><strong>一种加速的方法是</strong>，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：</p>\n<ol>\n<li>在 <code>start slave</code> 之前，先通过执行﻿﻿<code>change replication filter replicate_do_table = (tbl_name)</code> 命令，就可以让临时库只同步误操作的表；</li>\n<li>这样做也可以用上并行复制技术，来加速整个数据恢复过程。</li>\n</ol>\n<p>不论是把 mysqlbinlog 工具解析出的 binlog 文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：<strong>误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用 binlog 的方式。</strong></p>\n<p>这两个方案都要求备份系统定期备份全量日志，而且需要确保 binlog 在被从本地删除之前已经做了备份。</p>\n<h4 id=\"延迟复制备库\"><a href=\"#延迟复制备库\" class=\"headerlink\" title=\"延迟复制备库\"></a>延迟复制备库</h4><blockquote>\n<p>虽然可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。</p>\n<p>如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第 6 天发生误操作，那就需要恢复 6 天的日志，这个恢复时间可能是要按天来计算的。</p>\n</blockquote>\n<p><strong>缩短恢复数据需要的时间:</strong></p>\n<p>如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑<strong>搭建延迟复制的备库</strong>。这个功能是 MySQL 5.6 版本引入的。</p>\n<p>延迟复制的备库是一种特殊的备库，通过 <code>CHANGE MASTER TO MASTER_DELAY = N</code> 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。</p>\n<h4 id=\"预防误删库-表的方法\"><a href=\"#预防误删库-表的方法\" class=\"headerlink\" title=\"预防误删库 / 表的方法\"></a>预防误删库 / 表的方法</h4><ol>\n<li>账号分离，避免写错命令<ol>\n<li>只给业务开发 DML 权限，而不给 truncate/drop 权限。而如果业务开发人员有 DDL 需求的话，也可以通过开发管理系统得到支持。</li>\n<li>即使是 DBA 团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li>\n</ol>\n</li>\n<li>制定操作规范，是避免写错要删除的表名<ol>\n<li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li>\n<li>改表名的时候，要求给表名加固定的后缀（比如加 _to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"rm-删除数据\"><a href=\"#rm-删除数据\" class=\"headerlink\" title=\"rm 删除数据\"></a>rm 删除数据</h3><p>对于一个有高可用机制的 MySQL 集群来说，最不怕的就是 rm 删除数据了。只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA 系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。</p>\n<h2 id=\"为什么还有kill不掉的语句？\"><a href=\"#为什么还有kill不掉的语句？\" class=\"headerlink\" title=\"为什么还有kill不掉的语句？\"></a>为什么还有kill不掉的语句？</h2><p>在 MySQL 中有两个 kill 命令:</p>\n<ol>\n<li>kill query + 线程 id，表示终止这个线程中正在执行的语句；</li>\n<li>kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</li>\n</ol>\n<blockquote>\n<p>问题：使用了 kill 命令，却没能断开这个连接。再执行 show processlist 命令，看到这条语句的 Command 列显示的是 Killed</p>\n</blockquote>\n<h3 id=\"收到-kill-以后，线程做什么？\"><a href=\"#收到-kill-以后，线程做什么？\" class=\"headerlink\" title=\"收到 kill 以后，线程做什么？\"></a>收到 kill 以后，线程做什么？</h3><p>kill 并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。</p>\n<p>当用户执行 kill 时，MySQL 里处理 kill 命令的线程做了两件事：</p>\n<ol>\n<li>把运行状态改成 THD::KILL_QUERY(将变量 killed 赋值为 THD::KILL_QUERY)；</li>\n<li>给执行线程发一个信号。</li>\n</ol>\n<p>所以：</p>\n<ol>\n<li>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑；</li>\n<li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；</li>\n<li>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。</li>\n</ol>\n<p>在执行 show processlist 的时候，有一个特别的逻辑：<strong>如果一个线程的状态是KILL_CONNECTION，就把Command列显示成Killed</strong>。即使是客户端退出了，这个线程的状态仍然是在等待中。只有等到满足进入 InnoDB 的条件后，才有可能判断到线程状态已经变成了 KILL_QUERY 或者 KILL_CONNECTION，再进入终止逻辑阶段。</p>\n<p><strong>kill 无效：</strong></p>\n<ol>\n<li>线程没有执行到判断线程状态的逻辑</li>\n<li>由于 IO 压力过大，读写 IO 的函数一直无法返回，导致不能及时判断线程的状态</li>\n<li>终止逻辑耗时较长<ol>\n<li>超大事务执行期间被 kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</li>\n<li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长。</li>\n<li>DDL 命令执行到最后阶段，如果被 kill，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"两个关于客户端的误解\"><a href=\"#两个关于客户端的误解\" class=\"headerlink\" title=\"两个关于客户端的误解\"></a>两个关于客户端的误解</h4><ol>\n<li><p>如果库里面的表特别多，连接就会很慢</p>\n<blockquote>\n<p>当使用默认参数连接的时候，MySQL 客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</p>\n<ol>\n<li>执行 show databases；</li>\n<li>切到库，执行 show tables；</li>\n<li>把这两个命令的结果用于构建一个本地的哈希表。</li>\n</ol>\n</blockquote>\n<p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。</p>\n<p><strong>我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。</strong></p>\n<blockquote>\n<p>如果在连接命令中加上 <code>-A</code>，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了。</p>\n</blockquote>\n</li>\n<li><p><code>–quick</code> 引起误会的参数</p>\n<p>加<code>–quick</code>(或者简写为 <code>-q</code>) 参数，也可以关掉这个自动补全的功能</p>\n<p>设置了这个参数可能会降低服务端的性能</p>\n<blockquote>\n<p>MySQL 客户端发送请求后，接收服务端返回结果的方式有两种：</p>\n<ol>\n<li>一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果你用 API 开发，对应的就是 mysql_store_result 方法。</li>\n<li>另一种是不缓存，读一个处理一个。如果你用 API 开发，对应的就是 mysql_use_result 方法。</li>\n</ol>\n<p>MySQL 客户端默认采用第一种方式，而如果加上–quick 参数，就会使用第二种不缓存的方式。</p>\n</blockquote>\n<p>采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。</p>\n<p>使用<code>–quick</code>参数可以达到以下三点效果：</p>\n<ol>\n<li>第一点，就是前面提到的，跳过表名自动补全功能。</li>\n<li>第二点，mysql_store_result 需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能；</li>\n<li>第三点，是不会把执行命令记录到本地的命令历史文件。</li>\n</ol>\n<p><code>–quick</code>参数的意思，是让客户端变得更快</p>\n</li>\n</ol>\n<h2 id=\"我查这么多数据，会不会把数据库内存打爆？\"><a href=\"#我查这么多数据，会不会把数据库内存打爆？\" class=\"headerlink\" title=\"我查这么多数据，会不会把数据库内存打爆？\"></a>我查这么多数据，会不会把数据库内存打爆？</h2><h3 id=\"全表扫描对-server-层的影响\"><a href=\"#全表扫描对-server-层的影响\" class=\"headerlink\" title=\"全表扫描对 server 层的影响\"></a>全表扫描对 server 层的影响</h3><blockquote>\n<p>假设，我们现在要对一个 200G 的 InnoDB 表 db1.t，执行一个全表扫描。当然，你要把扫描结果保存在客户端，会使用类似这样的命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql -h<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"8.982ex\" height=\"2.343ex\" style=\"vertical-align: -0.505ex;\" viewbox=\"0 -791.3 3867.4 1008.6\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">host -P</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-68\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6F\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-73\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-74\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-50\" d=\"M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z\"/>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-68\" x=\"0\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-6F\" x=\"576\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-73\" x=\"1062\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-74\" x=\"1531\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMAIN-2212\" x=\"2115\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-50\" x=\"3115\" y=\"0\"/>\n</g>\n</svg>port -u<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"8.562ex\" height=\"2.343ex\" style=\"vertical-align: -0.671ex;\" viewbox=\"0 -719.6 3686.4 1008.6\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">user -p</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-75\" d=\"M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-73\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-65\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-72\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-70\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"/>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-75\" x=\"0\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-73\" x=\"572\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-65\" x=\"1042\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-72\" x=\"1508\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMAIN-2212\" x=\"2182\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-70\" x=\"3182\" y=\"0\"/>\n</g>\n</svg>pwd -e &quot;select * from db1.t&quot; &gt; $target_file<br></code></pre></td></tr></table></figure>\n<p>InnoDB 的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表 t 的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到<strong>结果集</strong>里面，然后返回给客户端。</p>\n<p>实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：</p>\n<ol>\n<li>获取一行，写到 net_buffer 中。这块内存的大小是由参数 <code>net_buffer_length</code> 定义的，默认是 16k。</li>\n<li>重复获取行，直到 net_buffer 写满，调用网络接口发出去。</li>\n<li>如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer。</li>\n<li>如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</li>\n</ol>\n<img src=\"/article/10821/%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.jpg\" class title=\"查询结果发送流程\">\n<ol>\n<li>一个查询在发送过程中，占用的 MySQL 内部的内存最大就是 net_buffer_length 这么大，并不会达到 200G；</li>\n<li>socket send buffer 也不可能达到 200G（默认定义 /proc/sys/net/core/wmem_default），如果 socket send buffer 被写满，就会暂停读数据的流程。</li>\n</ol>\n</blockquote>\n<p>MySQL 是<strong>“边读边发的”</strong>。这就意味着，如果客户端接收得慢，会导致 MySQL 服务端由于结果发不出去，这个事务的执行时间变长。</p>\n<p>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，建议使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。</p>\n<h3 id=\"全表扫描对-InnoDB-的影响\"><a href=\"#全表扫描对-InnoDB-的影响\" class=\"headerlink\" title=\"全表扫描对 InnoDB 的影响\"></a>全表扫描对 InnoDB 的影响</h3><p>内存的数据页是在 Buffer Pool (BP) 中管理的，在 WAL 里 Buffer Pool 起到了加速更新的作用。而实际上，Buffer Pool 还有一个更重要的作用，就是加速查询。</p>\n<p>Buffer Pool 对查询的加速效果，依赖于一个重要的指标，即：<strong>内存命中率</strong>。</p>\n<blockquote>\n<p>可以在 <code>show engine innodb status</code> 结果中，查看一个系统当前的 BP 命中率。一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在 99% 以上。</p>\n</blockquote>\n<p>InnoDB Buffer Pool 的大小是由参数 <code>innodb_buffer_pool_size</code> 确定的，一般建议设置成可用物理内存的 60%~80%。</p>\n<p>InnoDB 内存管理用的是<strong>最近最少使用 (Least Recently Used, LRU) 算法</strong>，这个算法的核心就是淘汰最久未使用的数据。</p>\n<blockquote>\n<p><strong>基础的未改进的LRU算法</strong></p>\n<p><img src=\"/article/基本 LRU 算法.jpg\"><span class=\"image-caption\">基本 LRU 算法</span></p>\n<ol>\n<li>在状态 1 里，链表头部是 P1，表示 P1 是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页；</li>\n<li>这时候有一个读请求访问 P3，因此变成状态 2，P3 被移到最前面；</li>\n<li>状态 3 表示，这次访问的数据页是不存在于链表中的，所以需要在 Buffer Pool 中新申请一个数据页 Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾 Pm 这个数据页的内存，存入 Px 的内容，然后放到链表头部。</li>\n<li>从效果上看，就是最久没有被访问的数据页 Pm，被淘汰了。</li>\n</ol>\n<hr>\n<p><strong>问题：</strong>假设按照这个算法，我们要扫描一个 200G 的表，而这个表是一个历史数据表，平时没有业务访问它。那么，按照这个算法扫描的话，就会把当前的 Buffer Pool 里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。也就是说 Buffer Pool 里面主要放的是这个历史数据表的数据。对于一个正在做业务服务的库，这可不妙。你会看到，Buffer Pool 的内存命中率急剧下降，磁盘压力增加，SQL 语句响应变慢。</p>\n</blockquote>\n<p><strong>InnoDB 对 LRU 算法做了改进</strong></p>\n<blockquote>\n<p><strong>改进的 LRU 算法</strong></p>\n<p><img src=\"/article/改进的 LRU 算法.png\"><span class=\"image-caption\">改进的 LRU 算法</span></p>\n<p>在 InnoDB 实现上，按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。图中 LRU_old 指向的就是 old 区域的第一个位置，是整个链表的 5/8 处。也就是说，靠近链表头部的 5/8 是 young 区域，靠近链表尾部的 3/8 是 old 区域。</p>\n<ol>\n<li>图中状态 1，要访问数据页 P3，由于 P3 在 young 区域，因此和优化前的 LRU 算法一样，将其移到链表头部，变成状态 2。</li>\n<li>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页 Pm，但是新插入的数据页 Px，是放在 LRU_old 处。</li>\n<li>处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：<ol>\n<li>若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；</li>\n<li>如果这个数据页在 LRU 链表中存在的时间短于 1 秒，位置保持不变。1 秒这个时间，是由参数 <code>innodb_old_blocks_time</code> 控制的。其默认值是 1000，单位毫秒。</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"到底可不可以使用join？\"><a href=\"#到底可不可以使用join？\" class=\"headerlink\" title=\"到底可不可以使用join？\"></a>到底可不可以使用join？</h2><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">CREATE TABLE `t2` (<br>  `id` int(11) NOT NULL,<br>  `a` int(11) DEFAULT NULL,<br>  `b` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `a` (`a`)<br>) ENGINE=InnoDB;<br><br>drop procedure idata;<br>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=1;<br>  while(i&lt;=1000)do<br>    insert into t2 values(i, i, i);<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;<br>call idata();<br><br>create table t1 like t2;<br>insert into t1 (select * from t2 where id&lt;=100)<br></code></pre></td></tr></table></figure>\n<p>这两个表都有一个主键索引 id 和一个索引 a，字段 b 上无索引。存储过程 idata() 往表 t2 里插入了 1000 行数据，在表 t1 里插入的是 100 行数据。</p>\n</blockquote>\n<h3 id=\"Index-Nested-Loop-Join\"><a href=\"#Index-Nested-Loop-Join\" class=\"headerlink\" title=\"Index Nested-Loop Join\"></a>Index Nested-Loop Join</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from t1 straight_join t2 on (t1.a=t2.a);<br></code></pre></td></tr></table></figure>\n<p>如果直接使用 join 语句，MySQL 优化器可能会选择表 t1 或 t2 作为驱动表，这样会影响我们分析 SQL 语句的执行过程。</p>\n<p>所以，为了便于分析执行过程中的性能问题，改用 <code>straight_join</code> 让 MySQL 使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去 join。在这个语句里，t1 是驱动表，t2 是被驱动表。</p>\n<p>执行流程：</p>\n<ol>\n<li>从表 t1 中读入一行数据 R；</li>\n<li>从数据行 R 中，取出 a 字段到表 t2 里去查找；</li>\n<li>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；</li>\n<li>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。</li>\n</ol>\n<p>这个过程是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“<strong>Index Nested-Loop Join</strong>”，简称 NLJ。</p>\n<p><img src=\"/article/Index Nested-Loop Join 算法的执行流程.jpg\"><span class=\"image-caption\">Index Nested-Loop Join 算法的执行流程</span></p>\n<p>在这个流程里：</p>\n<ol>\n<li>对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；</li>\n<li>而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；</li>\n<li>所以，整个执行流程，总扫描行数是 200。</li>\n</ol>\n</blockquote>\n<p><strong>使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好；</strong></p>\n<p><strong>如果使用 join 语句的话，需要让小表做驱动表（前提是“可以使用被驱动表的索引”）。</strong></p>\n<h3 id=\"Simple-Nested-Loop-Join\"><a href=\"#Simple-Nested-Loop-Join\" class=\"headerlink\" title=\"Simple Nested-Loop Join\"></a>Simple Nested-Loop Join</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from t1 straight_join t2 on (t1.a=t2.b);<br></code></pre></td></tr></table></figure>\n<p>由于表 t2 的字段 b 上没有索引，每次到 t2 去匹配的时候，就要做一次全表扫描。</p>\n<p>由于表 t2 的字段 b 上没有索引，因此再用图 2 的执行流程时，每次到 t2 去匹配的时候，就要做一次全表扫描。</p>\n<p>这样算来，这个 SQL 请求就要扫描表 t2 多达 100 次，总共扫描 100*1000=10 万行。</p>\n</blockquote>\n<h3 id=\"Block-Nested-Loop-Join\"><a href=\"#Block-Nested-Loop-Join\" class=\"headerlink\" title=\"Block Nested-Loop Join\"></a>Block Nested-Loop Join</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from t1 straight_join t2 on (t1.a=t2.b);<br></code></pre></td></tr></table></figure>\n<p>被驱动表上没有可用的索引，算法的流程是这样的：</p>\n<ol>\n<li>把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；</li>\n<li>扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</li>\n</ol>\n<p><img src=\"/article/Block Nested-Loop Join 算法的执行流程.jpg\"><span class=\"image-caption\">Block Nested-Loop Join 算法的执行流程</span></p>\n<p>在这个过程中，对表 t1 和 t2 都做了一次全表扫描，因此总的扫描行数是 1100。由于 join_buffer 是以无序数组的方式组织的，因此对表 t2 中的每一行，都要做 100 次判断，总共需要在内存中做的判断次数是：100*1000=10 万次</p>\n<p>如果使用 Simple Nested-Loop Join 算法进行查询，扫描行数也是 10 万行。因此，从<strong>时间复杂度上来说，这两个算法是一样</strong>的。但是，<strong>Block Nested-Loop Join 算法的这 10 万次判断是内存操作，速度上会快很多，性能也更好</strong>。</p>\n</blockquote>\n<p><strong>驱动表选择：</strong></p>\n<p>假设小表的行数是 N，大表的行数是 M，那么在这个算法里：</p>\n<ol>\n<li>两个表都做一次全表扫描，所以总的扫描行数是 M+N；</li>\n<li>内存中的判断次数是 M*N。</li>\n</ol>\n<p>可以看到，调换这两个算式中的 M 和 N 没差别，因此这时候<strong>选择大表还是小表做驱动表，执行耗时是一样的。</strong></p>\n<blockquote>\n<p><strong>问题：要是表 t1 是一个大表，join_buffer 放不下怎么办呢？</strong></p>\n<p>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t1 的所有数据话，策略很简单，就是<strong>分段放</strong>。</p>\n<p>执行过程就变成了：</p>\n<ol>\n<li>扫描表 t1，顺序读取数据行放入 join_buffer 中，中途join_buffer 满了，继续第 2 步；</li>\n<li>扫描表 t2，把 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回；</li>\n<li>清空 join_buffer；</li>\n<li>继续扫描表 t1，顺序读取最后的 12 行数据放入 join_buffer 中，继续执行第 2 步。</li>\n</ol>\n<p><img src=\"/article/Block Nested-Loop Join -- 两段.jpg\"><span class=\"image-caption\">Block Nested-Loop Join -- 两段</span></p>\n</blockquote>\n<p><strong>驱动表选择：</strong></p>\n<p>假设，驱动表的数据行数是 N，需要分 K 段才能完成算法流程，被驱动表的数据行数是 M。</p>\n<p>注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为λ*N，显然λ的取值范围是 (0,1)。</p>\n<p>所以，在这个算法的执行过程中：</p>\n<ol>\n<li>扫描行数是 N+λ<em>N</em>M；</li>\n<li>内存判断 N*M 次。</li>\n</ol>\n<p><strong>应该让小表当驱动表。</strong></p>\n<hr>\n<blockquote>\n<p><strong>Simple Nested Loop Join 的性能问题</strong></p>\n<p>虽然 BNL 算法和 Simple Nested Loop Join 算法都是要判断 M*N 次（M 和 N 分别是 join 的两个表的行数），但是 Simple Nested Loop Join 算法的每轮判断都要走全表扫描，因此性能上 BNL 算法执行起来会快很多。</p>\n<blockquote>\n<p>BNL 算法的执行逻辑是：</p>\n<ol>\n<li>首先，将驱动表的数据全部读入内存 join_buffer 中，这里 join_buffer 是无序数组；</li>\n<li>然后，顺序遍历被驱动表的所有行，每一行数据都跟 join_buffer 中的数据进行匹配，匹配成功则作为结果集的一部分返回。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>Simple Nested Loop Join 算法的执行逻辑是：</p>\n<p>顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。</p>\n</blockquote>\n<blockquote>\n<p>MySQL 中索引结构和 Buffer Pool 的相关知识点：</p>\n<ol>\n<li><p>在对被驱动表做全表扫描的时候，如果数据没有在 Buffer Pool 中，就需要等待这部分数据从磁盘读入；</p>\n<p>从磁盘读入数据到内存中，会影响正常业务的 Buffer Pool 命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到 Buffer Pool 的头部；</p>\n</li>\n<li><p>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而 join_buffer 中是数组，遍历的成本更低。</p>\n</li>\n</ol>\n</blockquote>\n<p><strong>所以说，BNL 算法的性能会更好</strong></p>\n</blockquote>\n<hr>\n<h3 id=\"能不能使用-join-语句？\"><a href=\"#能不能使用-join-语句？\" class=\"headerlink\" title=\"能不能使用 join 语句？\"></a>能不能使用 join 语句？</h3><ol>\n<li>如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li>\n<li>如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要用。</li>\n</ol>\n<blockquote>\n<p>所以你在判断要不要使用 join 语句时，就是看 explain 结果里面，Extra 字段里面有没有出现“Block Nested Loop”字样。</p>\n</blockquote>\n<h3 id=\"如果要使用-join，应该选择大表做驱动表还是选择小表做驱动表？\"><a href=\"#如果要使用-join，应该选择大表做驱动表还是选择小表做驱动表？\" class=\"headerlink\" title=\"如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？\"></a>如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？</h3><ol>\n<li>如果是 Index Nested-Loop Join 算法，应该选择小表做驱动表；</li>\n<li>如果是 Block Nested-Loop Join 算法：<ol>\n<li>在 join_buffer_size 足够大的时候，是一样的；</li>\n<li>在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表。</li>\n</ol>\n</li>\n</ol>\n<p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p>\n<h2 id=\"join语句怎么优化？\"><a href=\"#join语句怎么优化？\" class=\"headerlink\" title=\"join语句怎么优化？\"></a>join语句怎么优化？</h2><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table t1(id int primary key, a int, b int, index(a));<br>create table t2 like t1;<br>drop procedure idata;<br>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=1;<br>  while(i&lt;=1000)do<br>    insert into t1 values(i, 1001-i, i);<br>    set i=i+1;<br>  end while;<br>  <br>  set i=1;<br>  while(i&lt;=1000000)do<br>    insert into t2 values(i, i, i);<br>    set i=i+1;<br>  end while;<br><br>end;;<br>delimiter ;<br>call idata();<br></code></pre></td></tr></table></figure>\n<p>在表 t1 里，插入了 1000 行数据，每一行的 a=1001-id 的值。也就是说，表 t1 中字段 a 是逆序的。同时，在表 t2 中插入了 100 万行数据。</p>\n</blockquote>\n<h3 id=\"Multi-Range-Read-优化\"><a href=\"#Multi-Range-Read-优化\" class=\"headerlink\" title=\"Multi-Range Read 优化\"></a>Multi-Range Read 优化</h3><p><strong>Multi-Range Read 优化 (MRR)：这个优化的主要目的是尽量使用顺序读盘。</strong></p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from t1 where a&gt;=1 and a&lt;=100;<br></code></pre></td></tr></table></figure>\n<p>主键索引是一棵 B+ 树，在这棵树上，每次只能根据一个主键 id 查到一行数据。因此，回表肯定是一行行搜索主键索引的，基本流程如图所示</p>\n<img src=\"/article/10821/%E5%9F%BA%E6%9C%AC%E5%9B%9E%E8%A1%A8%E6%B5%81%E7%A8%8B.png\" class title=\"基本回表流程\">\n<p>如果随着 a 的值递增顺序查询的话，id 的值就变成随机的，那么就会出现随机访问，性能相对较差。(a虽然是倒叙存放在表中，但a上有B+tree索引，是顺序存储的，但是a索引的叶子节点存放的id的值是倒叙的，a索引的范围查询通过id回表查询，b+tree索引都是顺序存储的，那么通过a索引获取到的ID是倒序的，不是按照索引顺序查询就变成了随机查询。)</p>\n</blockquote>\n<p><strong>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p>\n<blockquote>\n<p>使用 MRR 优化，语句的执行流程变成了这样：</p>\n<ol>\n<li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</li>\n<li>将 read_rnd_buffer 中的 id 进行递增排序；</li>\n<li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li>\n</ol>\n<p>read_rnd_buffer 的大小是由 <code>read_rnd_buffer_size</code> 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</p>\n</blockquote>\n<p>如果你想要稳定地使用 MRR 优化的话，需要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code></p>\n<p><strong>MRR 能够提升性能的核心</strong>在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p>\n<h3 id=\"Batched-Key-Access\"><a href=\"#Batched-Key-Access\" class=\"headerlink\" title=\"Batched Key Access\"></a>Batched Key Access</h3><p>MySQL 在 5.6 版本后开始引入的 Batched Key Access(BKA) 算法。是对 NLJ 算法的优化。</p>\n<blockquote>\n<p>NLJ 算法执行的逻辑是：从驱动表 t1，一行行地取出 a 的值，再到被驱动表 t2 去做 join。也就是说，对于表 t2 来说，每次都是匹配一个值。这时，MRR 的优势就用不上了。</p>\n</blockquote>\n<blockquote>\n<p>把表 t1 的数据取出来一部分，先放到一个临时内存(join_buffer)，<strong>复用 join_buffer 到 BKA 算法中</strong></p>\n<p><img src=\"/article/Batched Key Access 流程.png\"><span class=\"image-caption\">Batched Key Access 流程</span></p>\n</blockquote>\n<p>如果要使用 BKA 优化算法的话，你需要在执行 SQL 语句之前，先设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">set optimizer_switch=&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;;<br></code></pre></td></tr></table></figure>\n<p>前两个参数的作用是要启用 MRR</p>\n<h3 id=\"BNL-算法的性能问题\"><a href=\"#BNL-算法的性能问题\" class=\"headerlink\" title=\"BNL 算法的性能问题\"></a>BNL 算法的性能问题</h3><p>大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</p>\n<p><strong>为了减少这种影响，你可以考虑增大 join_buffer_size 的值，减少对被驱动表的扫描次数</strong></p>\n<p>BNL 算法对系统的影响主要包括三个方面：</p>\n<ol>\n<li>可能会多次扫描被驱动表，占用磁盘 IO 资源；</li>\n<li>判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；</li>\n<li>可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。</li>\n</ol>\n<p><strong>优化</strong>的常见做法是，给被驱动表的 join 字段加上索引，<strong>把 BNL 算法转成 BKA 算法</strong>。</p>\n<p>让 join 语句能够用上被驱动表上的索引，来触发 BKA 算法，提升查询性能</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>BKA 优化是 MySQL 已经内置支持的，建议你默认使用；</li>\n<li>BNL 算法效率低，建议你都尽量转成 BKA 算法。优化的方向就是给被驱动表的关联字段加上索引；</li>\n<li>基于临时表的改进方案，对于能够提前过滤出小数据的 join 语句来说，效果还是很好的；</li>\n<li>MySQL 目前的版本还不支持 hash join，但你可以配合应用端自己模拟出来，理论上效果要好于临时表的方案。</li>\n</ol>\n<hr>\n<blockquote>\n<p><strong>问题：如果用 left join 的话，左边的表一定是驱动表吗？</strong></p>\n<p><strong>问题：如果两个表的 join 包含多个条件的等值匹配，是都要写到 on 里面呢，还是只把一个条件写到 on 里面，其他条件写到 where 部分？</strong></p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table a(f1 int, f2 int, index(f1))engine=innodb;<br>create table b(f1 int, f2 int)engine=innodb;<br>insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);<br>insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);<br></code></pre></td></tr></table></figure>\n<p>表 a 和 b 都有两个字段 f1 和 f2，不同的是表 a 的字段 f1 上有索引。然后，往两个表中都插入了 6 条记录，其中在表 a 和 b 中同时存在的数据有 4 行。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from a left join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q1*/<br>select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q2*/<br></code></pre></td></tr></table></figure>\n<p>第二个问题的两种写法</p>\n<p><img src=\"/article/两个 join 的查询结果.png\"><span class=\"image-caption\">两个 join 的查询结果</span></p>\n<ol>\n<li><p>语句 Q1 返回的数据集是 6 行，表 a 中即使没有满足匹配条件的记录，查询结果中也会返回一行，并将表 b 的各个字段值填成 NULL。</p>\n<blockquote>\n<p><img src=\"/article/Q1 的 explain 结果.jpg\"><span class=\"image-caption\">Q1 的 explain 结果</span></p>\n<ol>\n<li>驱动表是表 a，被驱动表是表 b；</li>\n<li>由于表 b 的 f1 字段上没有索引，所以使用的是 Block Nested Loop Join（简称 BNL） 算法。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>这条语句的执行流程:</p>\n<ol>\n<li>把表 a 的内容读入 join_buffer 中。因为是 select * ，所以字段 f1 和 f2 都被放入 join_buffer 了。</li>\n<li>顺序扫描表 b，对于每一行数据，判断 join 条件（也就是 (a.f1=b.f1) and (a.f1=1)）是否满足，满足条件的记录, 作为结果集的一行返回。如果语句中有 where 子句，需要先判断 where 部分满足条件后，再返回。</li>\n<li>表 b 扫描完成后，对于没有被匹配的表 a 的行（在这个例子中就是 (1,1)、(2,2) 这两行），把剩余字段补上 NULL，再放入结果集中。</li>\n</ol>\n<p><img src=\"/article/left join -BNL 算法.jpg\"><span class=\"image-caption\">left join -BNL 算法</span></p>\n</blockquote>\n</li>\n<li><p>语句 Q2 返回的是 4 行。从逻辑上可以这么理解，最后的两行，由于表 b 中没有匹配的字段，结果集里面 b.f2 的值是空，不满足 where 部分的条件判断，因此不能作为结果集的一部分。</p>\n<blockquote>\n<p><img src=\"/article/Q2 的 explain 结果.jpg\"><span class=\"image-caption\">Q2 的 explain 结果</span></p>\n<ol>\n<li>这条语句是以表 b 为驱动表的</li>\n<li>如果一条 join 语句的 Extra 字段什么都没写的话，就表示使用的是 Index Nested-Loop Join（简称 NLJ）算法。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>语句 Q2 的执行流程:</p>\n<ol>\n<li>顺序扫描表 b，每一行用 b.f1 到表 a 中去查</li>\n<li>匹配到记录后判断 a.f2=b.f2 是否满足，满足条件的话就作为结果集的一部分返回。</li>\n</ol>\n<p>语句 Q2 里面 where a.f2=b.f2 表示，查询结果里面不会包含 b.f2 是 NULL 的行，这样这个 left join 的语义就是“找到这两个表里面，f1、f2 对应相同的行。对于表 a 中存在，而表 b 中匹配不到的行，就放弃”。</p>\n</blockquote>\n<blockquote>\n<p>这条语句虽然用的是 left join，但是语义跟 join 是一致的</p>\n<p>因此，优化器就把这条语句的 left join 改写成了 join，然后因为表 a 的 f1 上有索引，就把表 b 作为驱动表，这样就可以用上 NLJ 算法。在执行 explain 之后，再执行 show warnings，就能看到这个改写的结果:</p>\n<p><img src=\"/article/Q2 的改写结果.jpg\"><span class=\"image-caption\">Q2 的改写结果</span></p>\n</blockquote>\n<p>这个例子说明，即使我们在 SQL 语句中写成 left join，执行过程还是有可能不是从左到右连接的。也就是说，<strong>使用 left join 时，左边的表不一定是驱动表。</strong></p>\n</li>\n</ol>\n</blockquote>\n<p><strong>如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面。</strong></p>\n<p><strong>join 将判断条件是否全部放在 on 部分没有区别</strong></p>\n</blockquote>\n<h2 id=\"为什么临时表可以重名？\"><a href=\"#为什么临时表可以重名？\" class=\"headerlink\" title=\"为什么临时表可以重名？\"></a>为什么临时表可以重名？</h2><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create temporary table temp_t like t1;<br>alter table temp_t add index(b);<br>insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;<br>select * from t1 join temp_t on (t1.b=temp_t.b);<br></code></pre></td></tr></table></figure>\n</blockquote>\n<ol>\n<li>内存表，指的是使用 Memory 引擎的表，建表语法是 <code>create table … engine=memory</code>。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</li>\n<li>临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎。</li>\n</ol>\n<h3 id=\"临时表的特性\"><a href=\"#临时表的特性\" class=\"headerlink\" title=\"临时表的特性\"></a>临时表的特性</h3><p>临时表在使用上有以下几个特点：</p>\n<ol>\n<li>建表语法是 <code>create temporary table …</code>。</li>\n<li>一个临时表只能被创建它的 session 访问，对其他线程不可见。由于临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。</li>\n<li>临时表可以与普通表同名。</li>\n<li>有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li>\n<li>show tables 命令不显示临时表。</li>\n</ol>\n<blockquote>\n<p>临时表就特别适合我们文章开头的 join 优化这种场景:</p>\n<ol>\n<li>不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。</li>\n<li>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。</li>\n</ol>\n</blockquote>\n<h3 id=\"临时表的应用\"><a href=\"#临时表的应用\" class=\"headerlink\" title=\"临时表的应用\"></a>临时表的应用</h3><p>由于不用担心线程之间的重名冲突，临时表经常会被用在<strong>复杂查询的优化过程</strong>中。其中，分库分表系统的跨库查询就是一个典型的使用场景。</p>\n<blockquote>\n<p>一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如。将一个大表 ht，按照字段 f，拆分成 1024 个分表，然后分布到 32 个数据库实例上。如下图所示：</p>\n<img src=\"/article/10821/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%AE%80%E5%9B%BE.jpg\" class title=\"分库分表简图\">\n<p>一般情况下，这种分库分表系统都有一个中间层 proxy。不过，也有一些方案会让客户端直接连接数据库，也就是没有 proxy 这一层。</p>\n<p>在这个架构中，分区 key 的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含 f 的等值条件，那么就要用 f 做分区键。这样，在 proxy 这一层解析完 SQL 语句以后，就能确定将这条语句路由到哪个分表做查询。</p>\n<p>比如下面这条语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select v from ht where f=N;<br></code></pre></td></tr></table></figure>\n<p>这时，我们就可以通过分表规则（比如，N%1024) 来确认需要的数据被放在了哪个分表上。这种语句只需要访问一个分表，是分库分表方案最欢迎的语句形式了。</p>\n<p>但是，如果这个表上还有另外一个索引 k，并且查询语句是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select v from ht where k &gt;= M order by t_modified desc limit 100;<br></code></pre></td></tr></table></figure>\n<p>这时候，由于查询条件里面没有用到分区字段 f，只能到所有的分区中去查找满足条件的所有行，然后统一做 order by 的操作。这种情况下，有两种比较常用的思路。</p>\n<p><strong>第一种思路是</strong>，在 proxy 层的进程代码中实现排序。</p>\n<p>这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显：</p>\n<ol>\n<li>需要的开发工作量比较大。我们举例的这条语句还算是比较简单的，如果涉及到复杂的操作，比如 group by，甚至 join 这样的操作，对中间层的开发能力要求比较高；</li>\n<li>对 proxy 端的压力比较大，尤其是很容易出现内存不够用和 CPU 瓶颈的问题。</li>\n</ol>\n<p><strong>另一种思路就是</strong>，把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。</p>\n<p>比如上面这条语句，执行流程可以类似这样：</p>\n<ol>\n<li><p>在汇总库上创建一个临时表 temp_ht，表里包含三个字段 v、k、t_modified；</p>\n</li>\n<li><p>在各个分库上执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select v,k,t_modified from ht_x where k &gt;= M order by t_modified desc limit 100;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>把分库执行的结果插入到 temp_ht 表中；</p>\n</li>\n<li><p>执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select v from temp_ht order by t_modified desc limit 100;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>得到结果。</p>\n</li>\n</ol>\n<img src=\"/article/10821/%E8%B7%A8%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg\" class title=\"跨库查询流程示意图\">\n<p>在实践中，我们往往会发现每个分库的计算量都不饱和，所以会直接把临时表 temp_ht 放到 32 个分库中的某一个上。</p>\n</blockquote>\n<h3 id=\"为什么临时表可以重名？-1\"><a href=\"#为什么临时表可以重名？-1\" class=\"headerlink\" title=\"为什么临时表可以重名？\"></a>为什么临时表可以重名？</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create temporary table temp_t(id int primary key)engine=innodb;<br></code></pre></td></tr></table></figure>\n<p>这个语句的时候，MySQL 要给这个 InnoDB 表创建一个 frm 文件保存表结构定义，还要有地方保存表数据。</p>\n<p>这个 frm 文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程 id}<em>{线程 id}</em> 序列号”。你可以使用 <code>select @@tmpdir</code> 命令，来显示实例的临时文件目录</p>\n</blockquote>\n<p>而关于表中数据的存放方式，在不同的 MySQL 版本中有着不同的处理方式：</p>\n<ol>\n<li>在 5.6 以及之前的版本里，MySQL 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件；</li>\n<li>而从 5.7 版本开始，MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建 ibd 文件了。</li>\n</ol>\n<blockquote>\n<p>从文件名的前缀规则，我们可以看到，其实创建一个叫作 t1 的 InnoDB 临时表，MySQL 在存储上认为我们创建的表名跟普通表 t1 是不同的，因此同一个库下面已经有普通表 t1 的情况下，还是可以再创建一个临时表 t1 的。</p>\n</blockquote>\n<p>MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个 table_def_key。</p>\n<ol>\n<li>一个普通表的 table_def_key 的值是由“库名 + 表名”得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了。</li>\n<li>而对于临时表，table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”。</li>\n</ol>\n<p>在实现上，每个线程都维护了自己的临时表链表。这样每次 session 内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在 session 结束的时候，对链表里的每个临时表，执行 <code>“DROP TEMPORARY TABLE + 表名”</code>操作。</p>\n<h3 id=\"临时表和主备复制\"><a href=\"#临时表和主备复制\" class=\"headerlink\" title=\"临时表和主备复制\"></a>临时表和主备复制</h3><p>binlog 中也记录了 <code>DROP TEMPORARY TABLE</code> 这条命令</p>\n<p><strong>既然写 binlog，就意味着备库需要。</strong></p>\n<p>如果当前的 <code>binlog_format=row</code>，那么跟临时表有关的语句，就不会记录到 binlog 里。也就是说，只在 <code>binlog_format=statment/mixed</code> 的时候，binlog 中才会记录临时表的操作。</p>\n<p>这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个 <code>DROP TEMPORARY TABLE</code> 传给备库执行。</p>\n<hr>\n<blockquote>\n<p><strong>问题：主库上不同的线程创建同名的临时表是没关系的，但是传到备库执行是怎么处理的呢？</strong></p>\n<p>MySQL 在记录 binlog 的时候，会把主库执行这个语句的线程 id 写到 binlog 中。这样，在备库的应用线程就能够知道执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key。</p>\n<p>由于 table_def_key 不同，所以这两个表在备库的应用线程里面是不会冲突的。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>问题：为什么不能用 rename 修改临时表的改名。</strong></p>\n<p>在实现上，执行 rename table 语句的时候，要求按照“库名 / 表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的 frm 文件是放在 tmpdir 目录下的，并且文件名的规则是“#sql{进程 id}<em>{线程 id}</em> 序列号.frm”，因此会报“找不到文件名”的错误。</p>\n</blockquote>\n<h2 id=\"什么时候会使用内部临时表？\"><a href=\"#什么时候会使用内部临时表？\" class=\"headerlink\" title=\"什么时候会使用内部临时表？\"></a>什么时候会使用内部临时表？</h2><h3 id=\"union-执行流程\"><a href=\"#union-执行流程\" class=\"headerlink\" title=\"union 执行流程\"></a>union 执行流程</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table t1(id int primary key, a int, b int, index(a));<br>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br><br>  set i=1;<br>  while(i&lt;=1000)do<br>    insert into t1 values(i, i, i);<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;<br>call idata();<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">(select 1000 as f) union (select id from t1 order by id desc limit 2);<br></code></pre></td></tr></table></figure>\n<p>这条语句用到了 union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。</p>\n<p>下图是这个语句的 explain 结果:</p>\n<p><img src=\"/article/union 语句 explain 结果.png\"><span class=\"image-caption\">union 语句 explain 结果</span></p>\n<ol>\n<li>第二行的 key=PRIMARY，说明第二个子句用到了索引 id。</li>\n<li>第三行的 Extra 字段，表示在对子查询的结果集做 union 的时候，使用了临时表 (Using temporary)。</li>\n</ol>\n<p>这个语句的执行流程是这样的：</p>\n<ol>\n<li>创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段。</li>\n<li>执行第一个子查询，得到 1000 这个值，并存入临时表中。</li>\n<li>执行第二个子查询：<ol>\n<li>拿到第一行 id=1000，试图插入临时表中。但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li>\n<li>取到第二行 id=999，插入临时表成功。</li>\n</ol>\n</li>\n<li>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是 1000 和 999。</li>\n</ol>\n<p><img src=\"/article/union 执行流程.jpg\"><span class=\"image-caption\">union 执行流程</span></p>\n<p>这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键 id 的唯一性约束，实现了 union 的语义。</p>\n<blockquote>\n<p>如果把上面这个语句中的 union 改成 union all 的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"group-by-执行流程\"><a href=\"#group-by-执行流程\" class=\"headerlink\" title=\"group by 执行流程\"></a>group by 执行流程</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select id%10 as m, count(*) as c from t1 group by m;<br></code></pre></td></tr></table></figure>\n<p>这个语句的逻辑是把表 t1 里的数据，按照 id%10 进行分组统计，并按照 m 的结果排序后输出。它的 explain 结果如下：</p>\n<p><img src=\"/article/group by 的 explain 结果.png\"><span class=\"image-caption\">group by 的 explain 结果</span></p>\n<ol>\n<li>Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；</li>\n<li>Using temporary，表示使用了临时表；</li>\n<li>Using filesort，表示需要排序。</li>\n</ol>\n<p>这个语句的执行流程是这样的：</p>\n<ol>\n<li>创建内存临时表，表里有两个字段 m 和 c，主键是 m；</li>\n<li>扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；<ol>\n<li>如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);</li>\n<li>如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；</li>\n</ol>\n</li>\n<li>遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。</li>\n</ol>\n<p><img src=\"/article/group by 执行流程.jpg\"><span class=\"image-caption\">group by 执行流程</span></p>\n<p>图中最后一步，对内存临时表的排序</p>\n<img src=\"/article/10821/%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.jpg\" class title=\"内存临时表排序流程\">\n</blockquote>\n<h3 id=\"group-by-优化方法-–-索引\"><a href=\"#group-by-优化方法-–-索引\" class=\"headerlink\" title=\"group by 优化方法 – 索引\"></a>group by 优化方法 – 索引</h3><p>group by 逻辑需要构造一个带唯一索引的表，执行代价是比较高的</p>\n<blockquote>\n<p>执行 group by 语句为什么需要临时表？</p>\n<p>group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p>\n</blockquote>\n<p>group by 优化方法 : 扫描过程中可以保证出现的数据是有序的</p>\n<p><strong>InnoDB 的索引，就可以满足这个输入有序的条件</strong></p>\n<blockquote>\n<p>在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">alter table t1 add column z int generated always as(id % 100), add index(z);<br></code></pre></td></tr></table></figure>\n<p>上面的 group by 语句就可以改成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select z, count(*) as c from t1 group by z;<br></code></pre></td></tr></table></figure>\n<p>优化后的 group by 语句的 explain 结果，如下图所示：</p>\n<p><img src=\"/article/group by 优化的 explain 结果.png\"><span class=\"image-caption\">group by 优化的 explain 结果</span></p>\n</blockquote>\n<h3 id=\"group-by-优化方法-–-直接排序\"><a href=\"#group-by-优化方法-–-直接排序\" class=\"headerlink\" title=\"group by 优化方法 – 直接排序\"></a>group by 优化方法 – 直接排序</h3><p>在 group by 语句中加入 SQL_BIG_RESULT 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p>\n<blockquote>\n<p>MySQL 的优化器一看，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;<br></code></pre></td></tr></table></figure>\n<p>执行流程就是这样的：</p>\n<ol>\n<li>初始化 sort_buffer，确定放入一个整型字段，记为 m；</li>\n<li>扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；</li>\n<li>扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；</li>\n<li>排序完成后，就得到了一个有序数组。</li>\n</ol>\n<p><img src=\"/article/使用 SQL_BIG_RESULT 的执行流程图.jpg\"><span class=\"image-caption\">使用 SQL_BIG_RESULT 的执行流程图</span></p>\n<p><img src=\"/article/使用 SQL_BIG_RESULT 的 explain 结果.png\"><span class=\"image-caption\">使用 SQL_BIG_RESULT 的 explain 结果</span></p>\n<p>从 Extra 字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。</p>\n</blockquote>\n<h3 id=\"group-by-使用的指导原则\"><a href=\"#group-by-使用的指导原则\" class=\"headerlink\" title=\"group by 使用的指导原则\"></a>group by 使用的指导原则</h3><ol>\n<li>如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；</li>\n<li>尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；</li>\n<li>如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</li>\n<li>如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。</li>\n</ol>\n<h3 id=\"MySQL-什么时候会使用内部临时表？\"><a href=\"#MySQL-什么时候会使用内部临时表？\" class=\"headerlink\" title=\"MySQL 什么时候会使用内部临时表？\"></a>MySQL 什么时候会使用内部临时表？</h3><ol>\n<li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li>\n<li>join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；</li>\n<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。</li>\n</ol>\n<hr>\n<blockquote>\n<p><strong>问题：如果只需要去重，不需要执行聚合函数，distinct 和 group by 哪种效率高一些呢？</strong></p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select a from t group by a order by null;<br>select distinct a from t;<br></code></pre></td></tr></table></figure>\n<p>表 t 的字段 a 上没有索引</p>\n</blockquote>\n<p><strong>不需要执行聚合函数时，distinct 和 group by 这两条语句的语义和执行流程是相同的，因此执行性能也相同。</strong></p>\n<blockquote>\n<p>这两条语句的执行流程是下面这样的:</p>\n<ol>\n<li>创建一个临时表，临时表有一个字段 a，并且在这个字段 a 上创建一个唯一索引；</li>\n<li>遍历表 t，依次取数据插入临时表中：<ol>\n<li>如果发现唯一键冲突，就跳过；</li>\n<li>否则插入成功；</li>\n</ol>\n</li>\n<li>遍历完成后，将临时表作为结果集返回给客户端。</li>\n</ol>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"都说InnoDB好，那还要不要使用Memory引擎？\"><a href=\"#都说InnoDB好，那还要不要使用Memory引擎？\" class=\"headerlink\" title=\"都说InnoDB好，那还要不要使用Memory引擎？\"></a>都说InnoDB好，那还要不要使用Memory引擎？</h2><h3 id=\"内存表的数据组织结构\"><a href=\"#内存表的数据组织结构\" class=\"headerlink\" title=\"内存表的数据组织结构\"></a>内存表的数据组织结构</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table t1(id int primary key, c int) engine=Memory;<br>create table t2(id int primary key, c int) engine=innodb;<br>insert into t1 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);<br>insert into t2 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);<br></code></pre></td></tr></table></figure>\n<p>表 t1 使用 Memory 引擎， 表 t2 使用 InnoDB 引擎。</p>\n<p>分别执行 select <em> from t1 和 select </em> from t2</p>\n<p><img src=\"/article/两个查询结果 -0 的位置.png\"><span class=\"image-caption\">两个查询结果 -0 的位置</span></p>\n<p>内存表 t1 的返回结果里面 0 在最后一行，而 InnoDB 表 t2 的返回结果里 0 在第一行。</p>\n</blockquote>\n<p><strong>InnoDB 引擎</strong>，它的主键索引 id 的组织方式：InnoDB 表的数据就放在<strong>主键索引树上</strong>，<strong>主键索引是 B+ 树</strong>。所以表 t2 的数据组织方式如下图所示：</p>\n<p><img src=\"/article/表 t2 的数据组织.jpg\"><span class=\"image-caption\">表 t2 的数据组织</span></p>\n<p><strong>主键索引上的值是有序存储的</strong></p>\n<blockquote>\n<p>在执行 select * 的时候，就会按照叶子节点从左到右扫描，所以得到的结果里，0 就出现在第一行。</p>\n</blockquote>\n<p><strong>Memory 引擎</strong>的数据和索引是分开的</p>\n<blockquote>\n<p><img src=\"/article/表 t1 的数据组织.jpg\"><span class=\"image-caption\">表 t1 的数据组织</span></p>\n</blockquote>\n<p>内存表的数据部分以数组的方式单独存放，而主键 id 索引里，存的是每个数据的位置。<strong>主键 id 是 hash 索引</strong>，可以看到索引上的 key 并不是有序的。</p>\n<blockquote>\n<p>在内存表 t1 中，当执行 select * 的时候，走的是全表扫描，也就是顺序扫描这个数组。因此，0 就是最后一个被读到，并放入结果集的数据。</p>\n</blockquote>\n<p><strong>InnoDB 和 Memory 引擎的数据组织方式是不同的：</strong></p>\n<ol>\n<li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。</li>\n<li>Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。</li>\n</ol>\n<p><strong>两个引擎的一些典型不同：</strong></p>\n<ol>\n<li>InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li>\n<li>当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li>\n<li>数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；</li>\n<li>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li>\n<li>InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li>\n</ol>\n<h3 id=\"hash-索引和-B-Tree-索引\"><a href=\"#hash-索引和-B-Tree-索引\" class=\"headerlink\" title=\"hash 索引和 B-Tree 索引\"></a>hash 索引和 B-Tree 索引</h3><p><strong>内存表也是支持 B-Tree 索引的。</strong></p>\n<blockquote>\n<p>在 id 列上创建一个 B-Tree 索引，SQL 语句可以这么写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">alter table t1 add index a_btree_index using btree (id);<br></code></pre></td></tr></table></figure>\n<p>表 t1 的数据组织形式就变成了这样：</p>\n<p><img src=\"/article/表 t1 的数据组织 -- 增加 B-Tree 索引.jpg\"><span class=\"image-caption\">表 t1 的数据组织 -- 增加 B-Tree 索引</span></p>\n<p><img src=\"/article/使用 B-Tree 和 hash 索引查询返回结果对比.png\"><span class=\"image-caption\">使用 B-Tree 和 hash 索引查询返回结果对比</span></p>\n</blockquote>\n<h3 id=\"为什么不建议生产环境上使用内存表\"><a href=\"#为什么不建议生产环境上使用内存表\" class=\"headerlink\" title=\"为什么不建议生产环境上使用内存表?\"></a>为什么不建议生产环境上使用内存表?</h3><ol>\n<li><p>锁粒度问题；</p>\n<p>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</p>\n</li>\n<li><p>数据持久化问题。</p>\n<p>数据库重启的时候，所有的内存表都会被清空。</p>\n<p>由于重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是双 M 架构，还可能导致主库的内存表数据被删掉。</p>\n</li>\n</ol>\n<p>内存临时表刚好可以无视内存表的两个不足，主要是下面的三个原因：</p>\n<ol>\n<li>临时表不会被其他线程访问，没有并发性的问题；</li>\n<li>临时表重启后也是需要删除的，清空数据这个问题不存在；</li>\n<li>备库的临时表也不会影响主库的用户线程。</li>\n</ol>\n","more":"<h2 id=\"如何判断一个数据库是不是出问题了？\"><a href=\"#如何判断一个数据库是不是出问题了？\" class=\"headerlink\" title=\"如何判断一个数据库是不是出问题了？\"></a>如何判断一个数据库是不是出问题了？</h2><h3 id=\"select-1-判断\"><a href=\"#select-1-判断\" class=\"headerlink\" title=\"select 1 判断\"></a>select 1 判断</h3><p>select 1 成功返回，只能说明这个库的进程还在，并不能说明主库没问题。</p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">set global innodb_thread_concurrency=3;<br><br>CREATE TABLE `t` (<br>  `id` int(11) NOT NULL,<br>  `c` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB;<br><br>insert into t values(1,1)<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article/查询 blocked.png\"><span class=\"image-caption\">查询 blocked</span></p>\n<p>设置 innodb_thread_concurrency 参数的目的是，控制 InnoDB 的并发线程上限。</p>\n</blockquote>\n<p>select 1 是能执行成功的，但是查询表 t 的语句会被堵住。</p>\n<p>如果用 select 1 来检测实例是否正常的话，是检测不出问题的。</p>\n<p>通常情况下，建议把 innodb_thread_concurrency 设置为 64~128 之间的值。</p>\n<blockquote>\n<p><strong>并发连接和并发查询</strong>，并不是同一个概念：</p>\n<p>在 <code>show processlist</code> 的结果里，看到的几千个连接，指的就是并发连接。而“当前正在执行”的语句，才是我们所说的并发查询。</p>\n<p>并发连接数达到几千个影响并不大，就是多占一些内存而已。我们应该关注的是并发查询，因为并发查询太高才是 CPU 杀手。</p>\n<p><strong>在线程进入锁等待以后，并发线程的计数会减一</strong></p>\n</blockquote>\n<p>在这个例子中，同时在执行的语句超过了设置的 innodb_thread_concurrency 的值，这时候系统其实已经不行了，但是通过 select 1 来检测系统，会认为系统还是正常的。</p>\n<p>因此，我们使用 select 1 的判断逻辑要修改一下。</p>\n<h3 id=\"查表判断\"><a href=\"#查表判断\" class=\"headerlink\" title=\"查表判断\"></a>查表判断</h3><p>为了能够检测 InnoDB 并发线程数过多导致的系统不可用情况，我们需要找一个访问 InnoDB 的场景。一般的做法是，在系统库（mysql 库）里创建一个表，比如命名为 health_check，里面只放一行数据，然后定期执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; select * from mysql.health_check; <br></code></pre></td></tr></table></figure>\n<p>使用这个方法，我们可以检测出由于并发线程过多导致的数据库不可用的情况。</p>\n<blockquote>\n<p>问题：更新事务要写 binlog，而一旦 binlog 所在磁盘的空间占用率达到 100%，那么所有的更新语句和事务提交的 commit 语句就都会被堵住。但是，系统这时候还是可以正常读数据的。</p>\n<p>因此，我们还是把这条监控语句再改进一下。把查询语句改成更新语句。</p>\n</blockquote>\n<h3 id=\"更新判断\"><a href=\"#更新判断\" class=\"headerlink\" title=\"更新判断\"></a>更新判断</h3><p>既然要更新，就要放个有意义的字段，常见做法是放一个 timestamp 字段，用来表示最后一次执行检测的时间。这条更新语句类似于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; update mysql.health_check set t_modified=now();<br></code></pre></td></tr></table></figure>\n<p>节点可用性的检测都应该包含主库和备库。如果用更新来检测主库的话，那么备库也要进行更新检测。</p>\n<p>但，备库的检测也是要写 binlog 的。由于我们一般会把数据库 A 和 B 的主备关系设计为双 M 结构，所以在备库 B 上执行的检测命令，也要发回给主库 A。</p>\n<p>但是，如果主库 A 和备库 B 都用相同的更新命令，就可能出现行冲突，也就是可能会导致主备同步停止。所以，现在看来 mysql.health_check 这个表就不能只有一行数据了。</p>\n<p><strong>为了让主备之间的更新不产生冲突，我们可以在 mysql.health_check 表上存入多行数据，并用 A、B 的 server_id 做主键。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql&gt; CREATE TABLE `health_check` (<br>  `id` int(11) NOT NULL,<br>  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB;<br><br>/* 检测命令 */<br>insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified=now();<br></code></pre></td></tr></table></figure>\n<p>由于 MySQL 规定了主库和备库的 server_id 必须不同（否则创建主备关系的时候就会报错），这样就可以保证主、备库各自的检测命令不会发生冲突。</p>\n<blockquote>\n<p>问题：更新判断是一个相对比较常用的方案了，不过依然存在一些“判定慢”的问题。</p>\n<p>涉及到的是服务器 IO 资源分配的问题</p>\n<p>首先，所有的检测逻辑都需要一个超时时间 N。执行一条 update 语句，超过 N 秒后还不返回，就认为系统不可用。</p>\n<p>IO 利用率 100% 表示系统的 IO 是在工作的，每个请求都有机会获得 IO 资源，执行自己的任务。而我们的检测使用的 update 命令，需要的资源很少，所以可能在拿到 IO 资源的时候就可以提交成功，并且在超时时间 N 秒未到达之前就返回给了检测系统。</p>\n<p>检测系统一看，update 命令没有超时，于是就得到了“系统正常”的结论。</p>\n<p>也就是说，这时候在业务系统上正常的 SQL 语句已经执行得很慢了，但是 DBA 上去一看，HA 系统还在正常工作，并且认为主库现在处于可用状态。</p>\n<p><strong>根本原因是我们上面说的所有方法，都是基于外部检测的。外部检测天然有一个问题，就是随机性。</strong></p>\n</blockquote>\n<h3 id=\"内部统计\"><a href=\"#内部统计\" class=\"headerlink\" title=\"内部统计\"></a>内部统计</h3><p>在 MySQL 内部发现数据库问题的方法</p>\n<p>MySQL 5.6 版本以后提供的 <code>performance_schema 库</code>，就在 <code>file_summary_by_event_name</code> 表里统计了每次 IO 请求的时间。</p>\n<blockquote>\n<p><code>event_name=&#39;wait/io/file/innodb/innodb_log_file’</code></p>\n<p><img src=\"/article/performance_schema.file_summary_by_event_name 的一行.png\"><span class=\"image-caption\">performance_schema.file_summary_by_event_name 的一行</span></p>\n<p>图中这一行表示统计的是 redo log 的写入时间，第一列 EVENT_NAME 表示统计的类型。</p>\n<p>接下来的三组数据，显示的是 redo log 操作的时间统计。</p>\n<p>第一组五列，是所有 IO 类型的统计。其中，COUNT_STAR 是所有 IO 的总次数，接下来四列是具体的统计项， 单位是皮秒；前缀 SUM、MIN、AVG、MAX，顾名思义指的就是总和、最小值、平均值和最大值。</p>\n<p>第二组六列，是读操作的统计。最后一列 SUM_NUMBER_OF_BYTES_READ 统计的是，总共从 redo log 里读了多少个字节。</p>\n<p>第三组六列，统计的是写操作。</p>\n<p>最后的第四组数据，是对其他类型数据的统计。在 redo log 里，你可以认为它们就是对 fsync 的统计。</p>\n<p>在 <code>performance_schema 库</code>的 <code>file_summary_by_event_name</code> 表里，binlog 对应的是 <code>event_name = &quot;wait/io/file/sql/binlog&quot;</code>这一行。各个字段的统计逻辑，与 redo log 的各个字段完全相同。</p>\n<p>每一次操作数据库，performance_schema 都需要额外地统计这些信息，所以我们打开这个统计功能是有性能损耗。如果打开所有的 performance_schema 项，性能大概会下降 10% 左右。</p>\n<p><strong>建议只打开自己需要的项进行统计</strong></p>\n<p>把这个信息用在实例状态诊断上：可以通过 MAX_TIMER 的值来判断数据库是否出问题了</p>\n</blockquote>\n<h2 id=\"误删数据后除了跑路，还能怎么办？\"><a href=\"#误删数据后除了跑路，还能怎么办？\" class=\"headerlink\" title=\"误删数据后除了跑路，还能怎么办？\"></a>误删数据后除了跑路，还能怎么办？</h2><p>对 MySQL 相关的误删数据，做下分类：</p>\n<ol>\n<li>使用 delete 语句误删数据行；</li>\n<li>使用 drop table 或者 truncate table 语句误删数据表；</li>\n<li>使用 drop database 语句误删数据库；</li>\n<li>使用 rm 命令误删整个 MySQL 实例。</li>\n</ol>\n<h3 id=\"误删行\"><a href=\"#误删行\" class=\"headerlink\" title=\"误删行\"></a>误删行</h3><p>如果是使用 delete 语句误删了数据行，可以用 Flashback 工具通过闪回把数据恢复回来。</p>\n<p>Flashback 恢复数据的原理，是修改 binlog 的内容，拿回原库重放。</p>\n<p><strong>需要确保 <code>binlog_format=row</code> 和 <code>binlog_row_image=FULL</code></strong></p>\n<p>具体恢复数据时，对单个事务做如下处理：</p>\n<ol>\n<li>对于 insert 语句，对应的 binlog event 类型是 <code>Write_rows event</code>，把它改成 <code>Delete_rows event</code> 即可；</li>\n<li>同理，对于 delete 语句，也是将 <code>Delete_rows event</code> 改为 <code>Write_rows event</code>；</li>\n<li>而如果是 Update_rows 的话，binlog 里面记录了数据行修改前和修改后的值，对调这两行的位置即可。</li>\n</ol>\n<p>如果误删数据涉及到了多个事务的话，需要将事务的顺序调过来再执行</p>\n<p><strong>不建议你直接在主库上执行这些操作</strong>:恢复数据比较安全的做法，是恢复出一个备份，或者找一个从库作为临时库，在这个临时库上执行这些操作，然后再将确认过的临时库的数据，恢复回主库。</p>\n<p><strong>更重要是要做到事前预防:</strong></p>\n<ol>\n<li><p>把 <code>sql_safe_updates</code> 参数设置为 <code>on</code>。这样一来，如果我们忘记在 delete 或者 update 语句中写 where 条件，或者 where 条件里面没有包含索引字段的话，这条语句的执行就会报错。</p>\n<blockquote>\n<p>如果你确定这个删除操作没问题的话，可以在 delete 语句中加上 where 条件，比如 where id&gt;=0。</p>\n<p>但是，delete 全表是很慢的，需要生成回滚日志、写 redo、写 binlog。所以，从性能角度考虑，你应该优先考虑使用 <code>truncate table</code> 或者 <code>drop table</code> 命令。</p>\n<p>使用 delete 命令删除的数据，你还可以用 Flashback 来恢复。而使用 <code>truncate /drop table</code> 和 <code>drop database</code> 命令删除的数据，就没办法通过 Flashback 来恢复了</p>\n<p>因为，即使我们配置了 <code>binlog_format=row</code>，执行这三个命令时，记录的 binlog 还是 statement 格式。binlog 里面就只有一个 truncate/drop 语句，这些信息是恢复不出数据的。</p>\n</blockquote>\n</li>\n<li><p>代码上线前，必须经过 SQL 审计。</p>\n</li>\n</ol>\n<h3 id=\"误删库-表\"><a href=\"#误删库-表\" class=\"headerlink\" title=\"误删库 / 表\"></a>误删库 / 表</h3><p>这种情况下，要想恢复数据，就需要使用全量备份，加增量日志的方式了。这个方案要求线上有定期的全量备份，并且实时备份 binlog。</p>\n<blockquote>\n<p>假如有人中午 12 点误删了一个库，恢复数据的流程如下：</p>\n<ol>\n<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天 0 点；</li>\n<li>用备份恢复出一个临时库；</li>\n<li>从日志备份里面，取出凌晨 0 点之后的日志；</li>\n<li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li>\n</ol>\n<p><img src=\"/article/数据恢复流程 -mysqlbinlog 方法.png\"><span class=\"image-caption\">数据恢复流程 -mysqlbinlog 方法</span></p>\n</blockquote>\n<ol>\n<li>为了加速数据恢复，如果这个临时库上有多个数据库，你可以在使用 mysqlbinlog 命令时，加上一个<code>–database</code> 参数，用来指定误删表所在的库。这样，就避免了在恢复数据时还要应用其他库日志的情况。</li>\n<li>在应用日志的时候，需要跳过 12 点误操作的那个语句的 binlog：<ol>\n<li>如果原实例没有使用 GTID 模式，只能在应用到包含 12 点的 binlog 文件的时候，先用<code>–stop-position</code> 参数执行到误操作之前的日志，然后再用<code>–start-position</code> 从误操作之后的日志继续执行；</li>\n<li>如果实例使用了 GTID 模式，就方便多了。假设误操作命令的 GTID 是 gtid1，那么只需要执行 <code>set gtid_next=gtid1;begin;commit;</code> 先把这个 GTID 加到临时实例的 GTID 集合，之后按顺序执行 binlog 的时候，就会自动跳过误操作的语句。</li>\n</ol>\n</li>\n</ol>\n<p><strong>使用 mysqlbinlog 方法恢复数据还是不够快</strong>，主要原因有两个：</p>\n<ol>\n<li>如果是误删表，最好就是只恢复出这张表，也就是只重放这张表的操作，但是 mysqlbinlog 工具并不能指定只解析一个表的日志；</li>\n<li>用 mysqlbinlog 解析出日志应用，应用日志的过程就只能是单线程。</li>\n</ol>\n<p><strong>一种加速的方法是</strong>，在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库，这样：</p>\n<ol>\n<li>在 <code>start slave</code> 之前，先通过执行﻿﻿<code>change replication filter replicate_do_table = (tbl_name)</code> 命令，就可以让临时库只同步误操作的表；</li>\n<li>这样做也可以用上并行复制技术，来加速整个数据恢复过程。</li>\n</ol>\n<p>不论是把 mysqlbinlog 工具解析出的 binlog 文件应用到临时库，还是把临时库接到备库上，这两个方案的共同点是：<strong>误删库或者表后，恢复数据的思路主要就是通过备份，再加上应用 binlog 的方式。</strong></p>\n<p>这两个方案都要求备份系统定期备份全量日志，而且需要确保 binlog 在被从本地删除之前已经做了备份。</p>\n<h4 id=\"延迟复制备库\"><a href=\"#延迟复制备库\" class=\"headerlink\" title=\"延迟复制备库\"></a>延迟复制备库</h4><blockquote>\n<p>虽然可以通过利用并行复制来加速恢复数据的过程，但是这个方案仍然存在“恢复时间不可控”的问题。</p>\n<p>如果一个库的备份特别大，或者误操作的时间距离上一个全量备份的时间较长，比如一周一备的实例，在备份之后的第 6 天发生误操作，那就需要恢复 6 天的日志，这个恢复时间可能是要按天来计算的。</p>\n</blockquote>\n<p><strong>缩短恢复数据需要的时间:</strong></p>\n<p>如果有非常核心的业务，不允许太长的恢复时间，我们可以考虑<strong>搭建延迟复制的备库</strong>。这个功能是 MySQL 5.6 版本引入的。</p>\n<p>延迟复制的备库是一种特殊的备库，通过 <code>CHANGE MASTER TO MASTER_DELAY = N</code> 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。</p>\n<h4 id=\"预防误删库-表的方法\"><a href=\"#预防误删库-表的方法\" class=\"headerlink\" title=\"预防误删库 / 表的方法\"></a>预防误删库 / 表的方法</h4><ol>\n<li>账号分离，避免写错命令<ol>\n<li>只给业务开发 DML 权限，而不给 truncate/drop 权限。而如果业务开发人员有 DDL 需求的话，也可以通过开发管理系统得到支持。</li>\n<li>即使是 DBA 团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</li>\n</ol>\n</li>\n<li>制定操作规范，是避免写错要删除的表名<ol>\n<li>在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。</li>\n<li>改表名的时候，要求给表名加固定的后缀（比如加 _to_be_deleted)，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"rm-删除数据\"><a href=\"#rm-删除数据\" class=\"headerlink\" title=\"rm 删除数据\"></a>rm 删除数据</h3><p>对于一个有高可用机制的 MySQL 集群来说，最不怕的就是 rm 删除数据了。只要不是恶意地把整个集群删除，而只是删掉了其中某一个节点的数据的话，HA 系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。</p>\n<h2 id=\"为什么还有kill不掉的语句？\"><a href=\"#为什么还有kill不掉的语句？\" class=\"headerlink\" title=\"为什么还有kill不掉的语句？\"></a>为什么还有kill不掉的语句？</h2><p>在 MySQL 中有两个 kill 命令:</p>\n<ol>\n<li>kill query + 线程 id，表示终止这个线程中正在执行的语句；</li>\n<li>kill connection + 线程 id，这里 connection 可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。</li>\n</ol>\n<blockquote>\n<p>问题：使用了 kill 命令，却没能断开这个连接。再执行 show processlist 命令，看到这条语句的 Command 列显示的是 Killed</p>\n</blockquote>\n<h3 id=\"收到-kill-以后，线程做什么？\"><a href=\"#收到-kill-以后，线程做什么？\" class=\"headerlink\" title=\"收到 kill 以后，线程做什么？\"></a>收到 kill 以后，线程做什么？</h3><p>kill 并不是马上停止的意思，而是告诉执行线程说，这条语句已经不需要继续执行了，可以开始“执行停止的逻辑了”。</p>\n<p>当用户执行 kill 时，MySQL 里处理 kill 命令的线程做了两件事：</p>\n<ol>\n<li>把运行状态改成 THD::KILL_QUERY(将变量 killed 赋值为 THD::KILL_QUERY)；</li>\n<li>给执行线程发一个信号。</li>\n</ol>\n<p>所以：</p>\n<ol>\n<li>一个语句执行过程中有多处“埋点”，在这些“埋点”的地方判断线程状态，如果发现线程状态是 THD::KILL_QUERY，才开始进入语句终止逻辑；</li>\n<li>如果处于等待状态，必须是一个可以被唤醒的等待，否则根本不会执行到“埋点”处；</li>\n<li>语句从开始进入终止逻辑，到终止逻辑完全完成，是有一个过程的。</li>\n</ol>\n<p>在执行 show processlist 的时候，有一个特别的逻辑：<strong>如果一个线程的状态是KILL_CONNECTION，就把Command列显示成Killed</strong>。即使是客户端退出了，这个线程的状态仍然是在等待中。只有等到满足进入 InnoDB 的条件后，才有可能判断到线程状态已经变成了 KILL_QUERY 或者 KILL_CONNECTION，再进入终止逻辑阶段。</p>\n<p><strong>kill 无效：</strong></p>\n<ol>\n<li>线程没有执行到判断线程状态的逻辑</li>\n<li>由于 IO 压力过大，读写 IO 的函数一直无法返回，导致不能及时判断线程的状态</li>\n<li>终止逻辑耗时较长<ol>\n<li>超大事务执行期间被 kill。这时候，回滚操作需要对事务执行期间生成的所有新数据版本做回收操作，耗时很长。</li>\n<li>大查询回滚。如果查询过程中生成了比较大的临时文件，加上此时文件系统压力大，删除临时文件可能需要等待 IO 资源，导致耗时较长。</li>\n<li>DDL 命令执行到最后阶段，如果被 kill，需要删除中间过程的临时文件，也可能受 IO 资源影响耗时较久。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"两个关于客户端的误解\"><a href=\"#两个关于客户端的误解\" class=\"headerlink\" title=\"两个关于客户端的误解\"></a>两个关于客户端的误解</h4><ol>\n<li><p>如果库里面的表特别多，连接就会很慢</p>\n<blockquote>\n<p>当使用默认参数连接的时候，MySQL 客户端会提供一个本地库名和表名补全的功能。为了实现这个功能，客户端在连接成功后，需要多做一些操作：</p>\n<ol>\n<li>执行 show databases；</li>\n<li>切到库，执行 show tables；</li>\n<li>把这两个命令的结果用于构建一个本地的哈希表。</li>\n</ol>\n</blockquote>\n<p>在这些操作中，最花时间的就是第三步在本地构建哈希表的操作。所以，当一个库中的表个数非常多的时候，这一步就会花比较长的时间。</p>\n<p><strong>我们感知到的连接过程慢，其实并不是连接慢，也不是服务端慢，而是客户端慢。</strong></p>\n<blockquote>\n<p>如果在连接命令中加上 <code>-A</code>，就可以关掉这个自动补全的功能，然后客户端就可以快速返回了。</p>\n</blockquote>\n</li>\n<li><p><code>–quick</code> 引起误会的参数</p>\n<p>加<code>–quick</code>(或者简写为 <code>-q</code>) 参数，也可以关掉这个自动补全的功能</p>\n<p>设置了这个参数可能会降低服务端的性能</p>\n<blockquote>\n<p>MySQL 客户端发送请求后，接收服务端返回结果的方式有两种：</p>\n<ol>\n<li>一种是本地缓存，也就是在本地开一片内存，先把结果存起来。如果你用 API 开发，对应的就是 mysql_store_result 方法。</li>\n<li>另一种是不缓存，读一个处理一个。如果你用 API 开发，对应的就是 mysql_use_result 方法。</li>\n</ol>\n<p>MySQL 客户端默认采用第一种方式，而如果加上–quick 参数，就会使用第二种不缓存的方式。</p>\n</blockquote>\n<p>采用不缓存的方式时，如果本地处理得慢，就会导致服务端发送结果被阻塞，因此会让服务端变慢。</p>\n<p>使用<code>–quick</code>参数可以达到以下三点效果：</p>\n<ol>\n<li>第一点，就是前面提到的，跳过表名自动补全功能。</li>\n<li>第二点，mysql_store_result 需要申请本地内存来缓存查询结果，如果查询结果太大，会耗费较多的本地内存，可能会影响客户端本地机器的性能；</li>\n<li>第三点，是不会把执行命令记录到本地的命令历史文件。</li>\n</ol>\n<p><code>–quick</code>参数的意思，是让客户端变得更快</p>\n</li>\n</ol>\n<h2 id=\"我查这么多数据，会不会把数据库内存打爆？\"><a href=\"#我查这么多数据，会不会把数据库内存打爆？\" class=\"headerlink\" title=\"我查这么多数据，会不会把数据库内存打爆？\"></a>我查这么多数据，会不会把数据库内存打爆？</h2><h3 id=\"全表扫描对-server-层的影响\"><a href=\"#全表扫描对-server-层的影响\" class=\"headerlink\" title=\"全表扫描对 server 层的影响\"></a>全表扫描对 server 层的影响</h3><blockquote>\n<p>假设，我们现在要对一个 200G 的 InnoDB 表 db1.t，执行一个全表扫描。当然，你要把扫描结果保存在客户端，会使用类似这样的命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">mysql -h<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"8.982ex\" height=\"2.343ex\" style=\"vertical-align: -0.505ex;\" viewbox=\"0 -791.3 3867.4 1008.6\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">host -P</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-68\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6F\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-73\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-74\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-50\" d=\"M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z\"/>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-68\" x=\"0\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-6F\" x=\"576\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-73\" x=\"1062\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-74\" x=\"1531\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMAIN-2212\" x=\"2115\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-50\" x=\"3115\" y=\"0\"/>\n</g>\n</svg>port -u<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"8.562ex\" height=\"2.343ex\" style=\"vertical-align: -0.671ex;\" viewbox=\"0 -719.6 3686.4 1008.6\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">user -p</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-75\" d=\"M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-73\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-65\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-72\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"/>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-70\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"/>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-75\" x=\"0\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-73\" x=\"572\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-65\" x=\"1042\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-72\" x=\"1508\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMAIN-2212\" x=\"2182\" y=\"0\"/>\n <use xlink:href=\"#E1-MJMATHI-70\" x=\"3182\" y=\"0\"/>\n</g>\n</svg>pwd -e &quot;select * from db1.t&quot; &gt; $target_file<br></code></pre></td></tr></table></figure>\n<p>InnoDB 的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表 t 的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到<strong>结果集</strong>里面，然后返回给客户端。</p>\n<p>实际上，服务端并不需要保存一个完整的结果集。取数据和发数据的流程是这样的：</p>\n<ol>\n<li>获取一行，写到 net_buffer 中。这块内存的大小是由参数 <code>net_buffer_length</code> 定义的，默认是 16k。</li>\n<li>重复获取行，直到 net_buffer 写满，调用网络接口发出去。</li>\n<li>如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer。</li>\n<li>如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待。直到网络栈重新可写，再继续发送。</li>\n</ol>\n<img src=\"/article/10821/%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.jpg\" class title=\"查询结果发送流程\">\n<ol>\n<li>一个查询在发送过程中，占用的 MySQL 内部的内存最大就是 net_buffer_length 这么大，并不会达到 200G；</li>\n<li>socket send buffer 也不可能达到 200G（默认定义 /proc/sys/net/core/wmem_default），如果 socket send buffer 被写满，就会暂停读数据的流程。</li>\n</ol>\n</blockquote>\n<p>MySQL 是<strong>“边读边发的”</strong>。这就意味着，如果客户端接收得慢，会导致 MySQL 服务端由于结果发不出去，这个事务的执行时间变长。</p>\n<p>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，建议使用 mysql_store_result 这个接口，直接把查询结果保存到本地内存。</p>\n<h3 id=\"全表扫描对-InnoDB-的影响\"><a href=\"#全表扫描对-InnoDB-的影响\" class=\"headerlink\" title=\"全表扫描对 InnoDB 的影响\"></a>全表扫描对 InnoDB 的影响</h3><p>内存的数据页是在 Buffer Pool (BP) 中管理的，在 WAL 里 Buffer Pool 起到了加速更新的作用。而实际上，Buffer Pool 还有一个更重要的作用，就是加速查询。</p>\n<p>Buffer Pool 对查询的加速效果，依赖于一个重要的指标，即：<strong>内存命中率</strong>。</p>\n<blockquote>\n<p>可以在 <code>show engine innodb status</code> 结果中，查看一个系统当前的 BP 命中率。一般情况下，一个稳定服务的线上系统，要保证响应时间符合要求的话，内存命中率要在 99% 以上。</p>\n</blockquote>\n<p>InnoDB Buffer Pool 的大小是由参数 <code>innodb_buffer_pool_size</code> 确定的，一般建议设置成可用物理内存的 60%~80%。</p>\n<p>InnoDB 内存管理用的是<strong>最近最少使用 (Least Recently Used, LRU) 算法</strong>，这个算法的核心就是淘汰最久未使用的数据。</p>\n<blockquote>\n<p><strong>基础的未改进的LRU算法</strong></p>\n<p><img src=\"/article/基本 LRU 算法.jpg\"><span class=\"image-caption\">基本 LRU 算法</span></p>\n<ol>\n<li>在状态 1 里，链表头部是 P1，表示 P1 是最近刚刚被访问过的数据页；假设内存里只能放下这么多数据页；</li>\n<li>这时候有一个读请求访问 P3，因此变成状态 2，P3 被移到最前面；</li>\n<li>状态 3 表示，这次访问的数据页是不存在于链表中的，所以需要在 Buffer Pool 中新申请一个数据页 Px，加到链表头部。但是由于内存已经满了，不能申请新的内存。于是，会清空链表末尾 Pm 这个数据页的内存，存入 Px 的内容，然后放到链表头部。</li>\n<li>从效果上看，就是最久没有被访问的数据页 Pm，被淘汰了。</li>\n</ol>\n<hr>\n<p><strong>问题：</strong>假设按照这个算法，我们要扫描一个 200G 的表，而这个表是一个历史数据表，平时没有业务访问它。那么，按照这个算法扫描的话，就会把当前的 Buffer Pool 里的数据全部淘汰掉，存入扫描过程中访问到的数据页的内容。也就是说 Buffer Pool 里面主要放的是这个历史数据表的数据。对于一个正在做业务服务的库，这可不妙。你会看到，Buffer Pool 的内存命中率急剧下降，磁盘压力增加，SQL 语句响应变慢。</p>\n</blockquote>\n<p><strong>InnoDB 对 LRU 算法做了改进</strong></p>\n<blockquote>\n<p><strong>改进的 LRU 算法</strong></p>\n<p><img src=\"/article/改进的 LRU 算法.png\"><span class=\"image-caption\">改进的 LRU 算法</span></p>\n<p>在 InnoDB 实现上，按照 5:3 的比例把整个 LRU 链表分成了 young 区域和 old 区域。图中 LRU_old 指向的就是 old 区域的第一个位置，是整个链表的 5/8 处。也就是说，靠近链表头部的 5/8 是 young 区域，靠近链表尾部的 3/8 是 old 区域。</p>\n<ol>\n<li>图中状态 1，要访问数据页 P3，由于 P3 在 young 区域，因此和优化前的 LRU 算法一样，将其移到链表头部，变成状态 2。</li>\n<li>之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页 Pm，但是新插入的数据页 Px，是放在 LRU_old 处。</li>\n<li>处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：<ol>\n<li>若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部；</li>\n<li>如果这个数据页在 LRU 链表中存在的时间短于 1 秒，位置保持不变。1 秒这个时间，是由参数 <code>innodb_old_blocks_time</code> 控制的。其默认值是 1000，单位毫秒。</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"到底可不可以使用join？\"><a href=\"#到底可不可以使用join？\" class=\"headerlink\" title=\"到底可不可以使用join？\"></a>到底可不可以使用join？</h2><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">CREATE TABLE `t2` (<br>  `id` int(11) NOT NULL,<br>  `a` int(11) DEFAULT NULL,<br>  `b` int(11) DEFAULT NULL,<br>  PRIMARY KEY (`id`),<br>  KEY `a` (`a`)<br>) ENGINE=InnoDB;<br><br>drop procedure idata;<br>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=1;<br>  while(i&lt;=1000)do<br>    insert into t2 values(i, i, i);<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;<br>call idata();<br><br>create table t1 like t2;<br>insert into t1 (select * from t2 where id&lt;=100)<br></code></pre></td></tr></table></figure>\n<p>这两个表都有一个主键索引 id 和一个索引 a，字段 b 上无索引。存储过程 idata() 往表 t2 里插入了 1000 行数据，在表 t1 里插入的是 100 行数据。</p>\n</blockquote>\n<h3 id=\"Index-Nested-Loop-Join\"><a href=\"#Index-Nested-Loop-Join\" class=\"headerlink\" title=\"Index Nested-Loop Join\"></a>Index Nested-Loop Join</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from t1 straight_join t2 on (t1.a=t2.a);<br></code></pre></td></tr></table></figure>\n<p>如果直接使用 join 语句，MySQL 优化器可能会选择表 t1 或 t2 作为驱动表，这样会影响我们分析 SQL 语句的执行过程。</p>\n<p>所以，为了便于分析执行过程中的性能问题，改用 <code>straight_join</code> 让 MySQL 使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去 join。在这个语句里，t1 是驱动表，t2 是被驱动表。</p>\n<p>执行流程：</p>\n<ol>\n<li>从表 t1 中读入一行数据 R；</li>\n<li>从数据行 R 中，取出 a 字段到表 t2 里去查找；</li>\n<li>取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分；</li>\n<li>重复执行步骤 1 到 3，直到表 t1 的末尾循环结束。</li>\n</ol>\n<p>这个过程是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“<strong>Index Nested-Loop Join</strong>”，简称 NLJ。</p>\n<p><img src=\"/article/Index Nested-Loop Join 算法的执行流程.jpg\"><span class=\"image-caption\">Index Nested-Loop Join 算法的执行流程</span></p>\n<p>在这个流程里：</p>\n<ol>\n<li>对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；</li>\n<li>而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；</li>\n<li>所以，整个执行流程，总扫描行数是 200。</li>\n</ol>\n</blockquote>\n<p><strong>使用 join 语句，性能比强行拆成多个单表执行 SQL 语句的性能要好；</strong></p>\n<p><strong>如果使用 join 语句的话，需要让小表做驱动表（前提是“可以使用被驱动表的索引”）。</strong></p>\n<h3 id=\"Simple-Nested-Loop-Join\"><a href=\"#Simple-Nested-Loop-Join\" class=\"headerlink\" title=\"Simple Nested-Loop Join\"></a>Simple Nested-Loop Join</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from t1 straight_join t2 on (t1.a=t2.b);<br></code></pre></td></tr></table></figure>\n<p>由于表 t2 的字段 b 上没有索引，每次到 t2 去匹配的时候，就要做一次全表扫描。</p>\n<p>由于表 t2 的字段 b 上没有索引，因此再用图 2 的执行流程时，每次到 t2 去匹配的时候，就要做一次全表扫描。</p>\n<p>这样算来，这个 SQL 请求就要扫描表 t2 多达 100 次，总共扫描 100*1000=10 万行。</p>\n</blockquote>\n<h3 id=\"Block-Nested-Loop-Join\"><a href=\"#Block-Nested-Loop-Join\" class=\"headerlink\" title=\"Block Nested-Loop Join\"></a>Block Nested-Loop Join</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from t1 straight_join t2 on (t1.a=t2.b);<br></code></pre></td></tr></table></figure>\n<p>被驱动表上没有可用的索引，算法的流程是这样的：</p>\n<ol>\n<li>把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；</li>\n<li>扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</li>\n</ol>\n<p><img src=\"/article/Block Nested-Loop Join 算法的执行流程.jpg\"><span class=\"image-caption\">Block Nested-Loop Join 算法的执行流程</span></p>\n<p>在这个过程中，对表 t1 和 t2 都做了一次全表扫描，因此总的扫描行数是 1100。由于 join_buffer 是以无序数组的方式组织的，因此对表 t2 中的每一行，都要做 100 次判断，总共需要在内存中做的判断次数是：100*1000=10 万次</p>\n<p>如果使用 Simple Nested-Loop Join 算法进行查询，扫描行数也是 10 万行。因此，从<strong>时间复杂度上来说，这两个算法是一样</strong>的。但是，<strong>Block Nested-Loop Join 算法的这 10 万次判断是内存操作，速度上会快很多，性能也更好</strong>。</p>\n</blockquote>\n<p><strong>驱动表选择：</strong></p>\n<p>假设小表的行数是 N，大表的行数是 M，那么在这个算法里：</p>\n<ol>\n<li>两个表都做一次全表扫描，所以总的扫描行数是 M+N；</li>\n<li>内存中的判断次数是 M*N。</li>\n</ol>\n<p>可以看到，调换这两个算式中的 M 和 N 没差别，因此这时候<strong>选择大表还是小表做驱动表，执行耗时是一样的。</strong></p>\n<blockquote>\n<p><strong>问题：要是表 t1 是一个大表，join_buffer 放不下怎么办呢？</strong></p>\n<p>join_buffer 的大小是由参数 join_buffer_size 设定的，默认值是 256k。如果放不下表 t1 的所有数据话，策略很简单，就是<strong>分段放</strong>。</p>\n<p>执行过程就变成了：</p>\n<ol>\n<li>扫描表 t1，顺序读取数据行放入 join_buffer 中，中途join_buffer 满了，继续第 2 步；</li>\n<li>扫描表 t2，把 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回；</li>\n<li>清空 join_buffer；</li>\n<li>继续扫描表 t1，顺序读取最后的 12 行数据放入 join_buffer 中，继续执行第 2 步。</li>\n</ol>\n<p><img src=\"/article/Block Nested-Loop Join -- 两段.jpg\"><span class=\"image-caption\">Block Nested-Loop Join -- 两段</span></p>\n</blockquote>\n<p><strong>驱动表选择：</strong></p>\n<p>假设，驱动表的数据行数是 N，需要分 K 段才能完成算法流程，被驱动表的数据行数是 M。</p>\n<p>注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为λ*N，显然λ的取值范围是 (0,1)。</p>\n<p>所以，在这个算法的执行过程中：</p>\n<ol>\n<li>扫描行数是 N+λ<em>N</em>M；</li>\n<li>内存判断 N*M 次。</li>\n</ol>\n<p><strong>应该让小表当驱动表。</strong></p>\n<hr>\n<blockquote>\n<p><strong>Simple Nested Loop Join 的性能问题</strong></p>\n<p>虽然 BNL 算法和 Simple Nested Loop Join 算法都是要判断 M*N 次（M 和 N 分别是 join 的两个表的行数），但是 Simple Nested Loop Join 算法的每轮判断都要走全表扫描，因此性能上 BNL 算法执行起来会快很多。</p>\n<blockquote>\n<p>BNL 算法的执行逻辑是：</p>\n<ol>\n<li>首先，将驱动表的数据全部读入内存 join_buffer 中，这里 join_buffer 是无序数组；</li>\n<li>然后，顺序遍历被驱动表的所有行，每一行数据都跟 join_buffer 中的数据进行匹配，匹配成功则作为结果集的一部分返回。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>Simple Nested Loop Join 算法的执行逻辑是：</p>\n<p>顺序取出驱动表中的每一行数据，到被驱动表去做全表扫描匹配，匹配成功则作为结果集的一部分返回。</p>\n</blockquote>\n<blockquote>\n<p>MySQL 中索引结构和 Buffer Pool 的相关知识点：</p>\n<ol>\n<li><p>在对被驱动表做全表扫描的时候，如果数据没有在 Buffer Pool 中，就需要等待这部分数据从磁盘读入；</p>\n<p>从磁盘读入数据到内存中，会影响正常业务的 Buffer Pool 命中率，而且这个算法天然会对被驱动表的数据做多次访问，更容易将这些数据页放到 Buffer Pool 的头部；</p>\n</li>\n<li><p>即使被驱动表数据都在内存中，每次查找“下一个记录的操作”，都是类似指针操作。而 join_buffer 中是数组，遍历的成本更低。</p>\n</li>\n</ol>\n</blockquote>\n<p><strong>所以说，BNL 算法的性能会更好</strong></p>\n</blockquote>\n<hr>\n<h3 id=\"能不能使用-join-语句？\"><a href=\"#能不能使用-join-语句？\" class=\"headerlink\" title=\"能不能使用 join 语句？\"></a>能不能使用 join 语句？</h3><ol>\n<li>如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的；</li>\n<li>如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种 join 尽量不要用。</li>\n</ol>\n<blockquote>\n<p>所以你在判断要不要使用 join 语句时，就是看 explain 结果里面，Extra 字段里面有没有出现“Block Nested Loop”字样。</p>\n</blockquote>\n<h3 id=\"如果要使用-join，应该选择大表做驱动表还是选择小表做驱动表？\"><a href=\"#如果要使用-join，应该选择大表做驱动表还是选择小表做驱动表？\" class=\"headerlink\" title=\"如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？\"></a>如果要使用 join，应该选择大表做驱动表还是选择小表做驱动表？</h3><ol>\n<li>如果是 Index Nested-Loop Join 算法，应该选择小表做驱动表；</li>\n<li>如果是 Block Nested-Loop Join 算法：<ol>\n<li>在 join_buffer_size 足够大的时候，是一样的；</li>\n<li>在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表。</li>\n</ol>\n</li>\n</ol>\n<p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p>\n<h2 id=\"join语句怎么优化？\"><a href=\"#join语句怎么优化？\" class=\"headerlink\" title=\"join语句怎么优化？\"></a>join语句怎么优化？</h2><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table t1(id int primary key, a int, b int, index(a));<br>create table t2 like t1;<br>drop procedure idata;<br>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br>  set i=1;<br>  while(i&lt;=1000)do<br>    insert into t1 values(i, 1001-i, i);<br>    set i=i+1;<br>  end while;<br>  <br>  set i=1;<br>  while(i&lt;=1000000)do<br>    insert into t2 values(i, i, i);<br>    set i=i+1;<br>  end while;<br><br>end;;<br>delimiter ;<br>call idata();<br></code></pre></td></tr></table></figure>\n<p>在表 t1 里，插入了 1000 行数据，每一行的 a=1001-id 的值。也就是说，表 t1 中字段 a 是逆序的。同时，在表 t2 中插入了 100 万行数据。</p>\n</blockquote>\n<h3 id=\"Multi-Range-Read-优化\"><a href=\"#Multi-Range-Read-优化\" class=\"headerlink\" title=\"Multi-Range Read 优化\"></a>Multi-Range Read 优化</h3><p><strong>Multi-Range Read 优化 (MRR)：这个优化的主要目的是尽量使用顺序读盘。</strong></p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from t1 where a&gt;=1 and a&lt;=100;<br></code></pre></td></tr></table></figure>\n<p>主键索引是一棵 B+ 树，在这棵树上，每次只能根据一个主键 id 查到一行数据。因此，回表肯定是一行行搜索主键索引的，基本流程如图所示</p>\n<img src=\"/article/10821/%E5%9F%BA%E6%9C%AC%E5%9B%9E%E8%A1%A8%E6%B5%81%E7%A8%8B.png\" class title=\"基本回表流程\">\n<p>如果随着 a 的值递增顺序查询的话，id 的值就变成随机的，那么就会出现随机访问，性能相对较差。(a虽然是倒叙存放在表中，但a上有B+tree索引，是顺序存储的，但是a索引的叶子节点存放的id的值是倒叙的，a索引的范围查询通过id回表查询，b+tree索引都是顺序存储的，那么通过a索引获取到的ID是倒序的，不是按照索引顺序查询就变成了随机查询。)</p>\n</blockquote>\n<p><strong>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p>\n<blockquote>\n<p>使用 MRR 优化，语句的执行流程变成了这样：</p>\n<ol>\n<li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</li>\n<li>将 read_rnd_buffer 中的 id 进行递增排序；</li>\n<li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li>\n</ol>\n<p>read_rnd_buffer 的大小是由 <code>read_rnd_buffer_size</code> 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</p>\n</blockquote>\n<p>如果你想要稳定地使用 MRR 优化的话，需要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code></p>\n<p><strong>MRR 能够提升性能的核心</strong>在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p>\n<h3 id=\"Batched-Key-Access\"><a href=\"#Batched-Key-Access\" class=\"headerlink\" title=\"Batched Key Access\"></a>Batched Key Access</h3><p>MySQL 在 5.6 版本后开始引入的 Batched Key Access(BKA) 算法。是对 NLJ 算法的优化。</p>\n<blockquote>\n<p>NLJ 算法执行的逻辑是：从驱动表 t1，一行行地取出 a 的值，再到被驱动表 t2 去做 join。也就是说，对于表 t2 来说，每次都是匹配一个值。这时，MRR 的优势就用不上了。</p>\n</blockquote>\n<blockquote>\n<p>把表 t1 的数据取出来一部分，先放到一个临时内存(join_buffer)，<strong>复用 join_buffer 到 BKA 算法中</strong></p>\n<p><img src=\"/article/Batched Key Access 流程.png\"><span class=\"image-caption\">Batched Key Access 流程</span></p>\n</blockquote>\n<p>如果要使用 BKA 优化算法的话，你需要在执行 SQL 语句之前，先设置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">set optimizer_switch=&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;;<br></code></pre></td></tr></table></figure>\n<p>前两个参数的作用是要启用 MRR</p>\n<h3 id=\"BNL-算法的性能问题\"><a href=\"#BNL-算法的性能问题\" class=\"headerlink\" title=\"BNL 算法的性能问题\"></a>BNL 算法的性能问题</h3><p>大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</p>\n<p><strong>为了减少这种影响，你可以考虑增大 join_buffer_size 的值，减少对被驱动表的扫描次数</strong></p>\n<p>BNL 算法对系统的影响主要包括三个方面：</p>\n<ol>\n<li>可能会多次扫描被驱动表，占用磁盘 IO 资源；</li>\n<li>判断 join 条件需要执行 M*N 次对比（M、N 分别是两张表的行数），如果是大表就会占用非常多的 CPU 资源；</li>\n<li>可能会导致 Buffer Pool 的热数据被淘汰，影响内存命中率。</li>\n</ol>\n<p><strong>优化</strong>的常见做法是，给被驱动表的 join 字段加上索引，<strong>把 BNL 算法转成 BKA 算法</strong>。</p>\n<p>让 join 语句能够用上被驱动表上的索引，来触发 BKA 算法，提升查询性能</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>BKA 优化是 MySQL 已经内置支持的，建议你默认使用；</li>\n<li>BNL 算法效率低，建议你都尽量转成 BKA 算法。优化的方向就是给被驱动表的关联字段加上索引；</li>\n<li>基于临时表的改进方案，对于能够提前过滤出小数据的 join 语句来说，效果还是很好的；</li>\n<li>MySQL 目前的版本还不支持 hash join，但你可以配合应用端自己模拟出来，理论上效果要好于临时表的方案。</li>\n</ol>\n<hr>\n<blockquote>\n<p><strong>问题：如果用 left join 的话，左边的表一定是驱动表吗？</strong></p>\n<p><strong>问题：如果两个表的 join 包含多个条件的等值匹配，是都要写到 on 里面呢，还是只把一个条件写到 on 里面，其他条件写到 where 部分？</strong></p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table a(f1 int, f2 int, index(f1))engine=innodb;<br>create table b(f1 int, f2 int)engine=innodb;<br>insert into a values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6);<br>insert into b values(3,3),(4,4),(5,5),(6,6),(7,7),(8,8);<br></code></pre></td></tr></table></figure>\n<p>表 a 和 b 都有两个字段 f1 和 f2，不同的是表 a 的字段 f1 上有索引。然后，往两个表中都插入了 6 条记录，其中在表 a 和 b 中同时存在的数据有 4 行。</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from a left join b on(a.f1=b.f1) and (a.f2=b.f2); /*Q1*/<br>select * from a left join b on(a.f1=b.f1) where (a.f2=b.f2);/*Q2*/<br></code></pre></td></tr></table></figure>\n<p>第二个问题的两种写法</p>\n<p><img src=\"/article/两个 join 的查询结果.png\"><span class=\"image-caption\">两个 join 的查询结果</span></p>\n<ol>\n<li><p>语句 Q1 返回的数据集是 6 行，表 a 中即使没有满足匹配条件的记录，查询结果中也会返回一行，并将表 b 的各个字段值填成 NULL。</p>\n<blockquote>\n<p><img src=\"/article/Q1 的 explain 结果.jpg\"><span class=\"image-caption\">Q1 的 explain 结果</span></p>\n<ol>\n<li>驱动表是表 a，被驱动表是表 b；</li>\n<li>由于表 b 的 f1 字段上没有索引，所以使用的是 Block Nested Loop Join（简称 BNL） 算法。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>这条语句的执行流程:</p>\n<ol>\n<li>把表 a 的内容读入 join_buffer 中。因为是 select * ，所以字段 f1 和 f2 都被放入 join_buffer 了。</li>\n<li>顺序扫描表 b，对于每一行数据，判断 join 条件（也就是 (a.f1=b.f1) and (a.f1=1)）是否满足，满足条件的记录, 作为结果集的一行返回。如果语句中有 where 子句，需要先判断 where 部分满足条件后，再返回。</li>\n<li>表 b 扫描完成后，对于没有被匹配的表 a 的行（在这个例子中就是 (1,1)、(2,2) 这两行），把剩余字段补上 NULL，再放入结果集中。</li>\n</ol>\n<p><img src=\"/article/left join -BNL 算法.jpg\"><span class=\"image-caption\">left join -BNL 算法</span></p>\n</blockquote>\n</li>\n<li><p>语句 Q2 返回的是 4 行。从逻辑上可以这么理解，最后的两行，由于表 b 中没有匹配的字段，结果集里面 b.f2 的值是空，不满足 where 部分的条件判断，因此不能作为结果集的一部分。</p>\n<blockquote>\n<p><img src=\"/article/Q2 的 explain 结果.jpg\"><span class=\"image-caption\">Q2 的 explain 结果</span></p>\n<ol>\n<li>这条语句是以表 b 为驱动表的</li>\n<li>如果一条 join 语句的 Extra 字段什么都没写的话，就表示使用的是 Index Nested-Loop Join（简称 NLJ）算法。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>语句 Q2 的执行流程:</p>\n<ol>\n<li>顺序扫描表 b，每一行用 b.f1 到表 a 中去查</li>\n<li>匹配到记录后判断 a.f2=b.f2 是否满足，满足条件的话就作为结果集的一部分返回。</li>\n</ol>\n<p>语句 Q2 里面 where a.f2=b.f2 表示，查询结果里面不会包含 b.f2 是 NULL 的行，这样这个 left join 的语义就是“找到这两个表里面，f1、f2 对应相同的行。对于表 a 中存在，而表 b 中匹配不到的行，就放弃”。</p>\n</blockquote>\n<blockquote>\n<p>这条语句虽然用的是 left join，但是语义跟 join 是一致的</p>\n<p>因此，优化器就把这条语句的 left join 改写成了 join，然后因为表 a 的 f1 上有索引，就把表 b 作为驱动表，这样就可以用上 NLJ 算法。在执行 explain 之后，再执行 show warnings，就能看到这个改写的结果:</p>\n<p><img src=\"/article/Q2 的改写结果.jpg\"><span class=\"image-caption\">Q2 的改写结果</span></p>\n</blockquote>\n<p>这个例子说明，即使我们在 SQL 语句中写成 left join，执行过程还是有可能不是从左到右连接的。也就是说，<strong>使用 left join 时，左边的表不一定是驱动表。</strong></p>\n</li>\n</ol>\n</blockquote>\n<p><strong>如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面。</strong></p>\n<p><strong>join 将判断条件是否全部放在 on 部分没有区别</strong></p>\n</blockquote>\n<h2 id=\"为什么临时表可以重名？\"><a href=\"#为什么临时表可以重名？\" class=\"headerlink\" title=\"为什么临时表可以重名？\"></a>为什么临时表可以重名？</h2><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create temporary table temp_t like t1;<br>alter table temp_t add index(b);<br>insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;<br>select * from t1 join temp_t on (t1.b=temp_t.b);<br></code></pre></td></tr></table></figure>\n</blockquote>\n<ol>\n<li>内存表，指的是使用 Memory 引擎的表，建表语法是 <code>create table … engine=memory</code>。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</li>\n<li>临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎。</li>\n</ol>\n<h3 id=\"临时表的特性\"><a href=\"#临时表的特性\" class=\"headerlink\" title=\"临时表的特性\"></a>临时表的特性</h3><p>临时表在使用上有以下几个特点：</p>\n<ol>\n<li>建表语法是 <code>create temporary table …</code>。</li>\n<li>一个临时表只能被创建它的 session 访问，对其他线程不可见。由于临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。</li>\n<li>临时表可以与普通表同名。</li>\n<li>有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li>\n<li>show tables 命令不显示临时表。</li>\n</ol>\n<blockquote>\n<p>临时表就特别适合我们文章开头的 join 优化这种场景:</p>\n<ol>\n<li>不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。</li>\n<li>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。</li>\n</ol>\n</blockquote>\n<h3 id=\"临时表的应用\"><a href=\"#临时表的应用\" class=\"headerlink\" title=\"临时表的应用\"></a>临时表的应用</h3><p>由于不用担心线程之间的重名冲突，临时表经常会被用在<strong>复杂查询的优化过程</strong>中。其中，分库分表系统的跨库查询就是一个典型的使用场景。</p>\n<blockquote>\n<p>一般分库分表的场景，就是要把一个逻辑上的大表分散到不同的数据库实例上。比如。将一个大表 ht，按照字段 f，拆分成 1024 个分表，然后分布到 32 个数据库实例上。如下图所示：</p>\n<img src=\"/article/10821/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%AE%80%E5%9B%BE.jpg\" class title=\"分库分表简图\">\n<p>一般情况下，这种分库分表系统都有一个中间层 proxy。不过，也有一些方案会让客户端直接连接数据库，也就是没有 proxy 这一层。</p>\n<p>在这个架构中，分区 key 的选择是以“减少跨库和跨表查询”为依据的。如果大部分的语句都会包含 f 的等值条件，那么就要用 f 做分区键。这样，在 proxy 这一层解析完 SQL 语句以后，就能确定将这条语句路由到哪个分表做查询。</p>\n<p>比如下面这条语句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select v from ht where f=N;<br></code></pre></td></tr></table></figure>\n<p>这时，我们就可以通过分表规则（比如，N%1024) 来确认需要的数据被放在了哪个分表上。这种语句只需要访问一个分表，是分库分表方案最欢迎的语句形式了。</p>\n<p>但是，如果这个表上还有另外一个索引 k，并且查询语句是这样的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select v from ht where k &gt;= M order by t_modified desc limit 100;<br></code></pre></td></tr></table></figure>\n<p>这时候，由于查询条件里面没有用到分区字段 f，只能到所有的分区中去查找满足条件的所有行，然后统一做 order by 的操作。这种情况下，有两种比较常用的思路。</p>\n<p><strong>第一种思路是</strong>，在 proxy 层的进程代码中实现排序。</p>\n<p>这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显：</p>\n<ol>\n<li>需要的开发工作量比较大。我们举例的这条语句还算是比较简单的，如果涉及到复杂的操作，比如 group by，甚至 join 这样的操作，对中间层的开发能力要求比较高；</li>\n<li>对 proxy 端的压力比较大，尤其是很容易出现内存不够用和 CPU 瓶颈的问题。</li>\n</ol>\n<p><strong>另一种思路就是</strong>，把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。</p>\n<p>比如上面这条语句，执行流程可以类似这样：</p>\n<ol>\n<li><p>在汇总库上创建一个临时表 temp_ht，表里包含三个字段 v、k、t_modified；</p>\n</li>\n<li><p>在各个分库上执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select v,k,t_modified from ht_x where k &gt;= M order by t_modified desc limit 100;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>把分库执行的结果插入到 temp_ht 表中；</p>\n</li>\n<li><p>执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select v from temp_ht order by t_modified desc limit 100;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>得到结果。</p>\n</li>\n</ol>\n<img src=\"/article/10821/%E8%B7%A8%E5%BA%93%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg\" class title=\"跨库查询流程示意图\">\n<p>在实践中，我们往往会发现每个分库的计算量都不饱和，所以会直接把临时表 temp_ht 放到 32 个分库中的某一个上。</p>\n</blockquote>\n<h3 id=\"为什么临时表可以重名？-1\"><a href=\"#为什么临时表可以重名？-1\" class=\"headerlink\" title=\"为什么临时表可以重名？\"></a>为什么临时表可以重名？</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create temporary table temp_t(id int primary key)engine=innodb;<br></code></pre></td></tr></table></figure>\n<p>这个语句的时候，MySQL 要给这个 InnoDB 表创建一个 frm 文件保存表结构定义，还要有地方保存表数据。</p>\n<p>这个 frm 文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程 id}<em>{线程 id}</em> 序列号”。你可以使用 <code>select @@tmpdir</code> 命令，来显示实例的临时文件目录</p>\n</blockquote>\n<p>而关于表中数据的存放方式，在不同的 MySQL 版本中有着不同的处理方式：</p>\n<ol>\n<li>在 5.6 以及之前的版本里，MySQL 会在临时文件目录下创建一个相同前缀、以.ibd 为后缀的文件，用来存放数据文件；</li>\n<li>而从 5.7 版本开始，MySQL 引入了一个临时文件表空间，专门用来存放临时文件的数据。因此，我们就不需要再创建 ibd 文件了。</li>\n</ol>\n<blockquote>\n<p>从文件名的前缀规则，我们可以看到，其实创建一个叫作 t1 的 InnoDB 临时表，MySQL 在存储上认为我们创建的表名跟普通表 t1 是不同的，因此同一个库下面已经有普通表 t1 的情况下，还是可以再创建一个临时表 t1 的。</p>\n</blockquote>\n<p>MySQL 维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个 table_def_key。</p>\n<ol>\n<li>一个普通表的 table_def_key 的值是由“库名 + 表名”得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现 table_def_key 已经存在了。</li>\n<li>而对于临时表，table_def_key 在“库名 + 表名”基础上，又加入了“server_id+thread_id”。</li>\n</ol>\n<p>在实现上，每个线程都维护了自己的临时表链表。这样每次 session 内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在 session 结束的时候，对链表里的每个临时表，执行 <code>“DROP TEMPORARY TABLE + 表名”</code>操作。</p>\n<h3 id=\"临时表和主备复制\"><a href=\"#临时表和主备复制\" class=\"headerlink\" title=\"临时表和主备复制\"></a>临时表和主备复制</h3><p>binlog 中也记录了 <code>DROP TEMPORARY TABLE</code> 这条命令</p>\n<p><strong>既然写 binlog，就意味着备库需要。</strong></p>\n<p>如果当前的 <code>binlog_format=row</code>，那么跟临时表有关的语句，就不会记录到 binlog 里。也就是说，只在 <code>binlog_format=statment/mixed</code> 的时候，binlog 中才会记录临时表的操作。</p>\n<p>这种情况下，创建临时表的语句会传到备库执行，因此备库的同步线程就会创建这个临时表。主库在线程退出的时候，会自动删除临时表，但是备库同步线程是持续在运行的。所以，这时候我们就需要在主库上再写一个 <code>DROP TEMPORARY TABLE</code> 传给备库执行。</p>\n<hr>\n<blockquote>\n<p><strong>问题：主库上不同的线程创建同名的临时表是没关系的，但是传到备库执行是怎么处理的呢？</strong></p>\n<p>MySQL 在记录 binlog 的时候，会把主库执行这个语句的线程 id 写到 binlog 中。这样，在备库的应用线程就能够知道执行每个语句的主库线程 id，并利用这个线程 id 来构造临时表的 table_def_key。</p>\n<p>由于 table_def_key 不同，所以这两个表在备库的应用线程里面是不会冲突的。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>问题：为什么不能用 rename 修改临时表的改名。</strong></p>\n<p>在实现上，执行 rename table 语句的时候，要求按照“库名 / 表名.frm”的规则去磁盘找文件，但是临时表在磁盘上的 frm 文件是放在 tmpdir 目录下的，并且文件名的规则是“#sql{进程 id}<em>{线程 id}</em> 序列号.frm”，因此会报“找不到文件名”的错误。</p>\n</blockquote>\n<h2 id=\"什么时候会使用内部临时表？\"><a href=\"#什么时候会使用内部临时表？\" class=\"headerlink\" title=\"什么时候会使用内部临时表？\"></a>什么时候会使用内部临时表？</h2><h3 id=\"union-执行流程\"><a href=\"#union-执行流程\" class=\"headerlink\" title=\"union 执行流程\"></a>union 执行流程</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table t1(id int primary key, a int, b int, index(a));<br>delimiter ;;<br>create procedure idata()<br>begin<br>  declare i int;<br><br>  set i=1;<br>  while(i&lt;=1000)do<br>    insert into t1 values(i, i, i);<br>    set i=i+1;<br>  end while;<br>end;;<br>delimiter ;<br>call idata();<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">(select 1000 as f) union (select id from t1 order by id desc limit 2);<br></code></pre></td></tr></table></figure>\n<p>这条语句用到了 union，它的语义是，取这两个子查询结果的并集。并集的意思就是这两个集合加起来，重复的行只保留一行。</p>\n<p>下图是这个语句的 explain 结果:</p>\n<p><img src=\"/article/union 语句 explain 结果.png\"><span class=\"image-caption\">union 语句 explain 结果</span></p>\n<ol>\n<li>第二行的 key=PRIMARY，说明第二个子句用到了索引 id。</li>\n<li>第三行的 Extra 字段，表示在对子查询的结果集做 union 的时候，使用了临时表 (Using temporary)。</li>\n</ol>\n<p>这个语句的执行流程是这样的：</p>\n<ol>\n<li>创建一个内存临时表，这个临时表只有一个整型字段 f，并且 f 是主键字段。</li>\n<li>执行第一个子查询，得到 1000 这个值，并存入临时表中。</li>\n<li>执行第二个子查询：<ol>\n<li>拿到第一行 id=1000，试图插入临时表中。但由于 1000 这个值已经存在于临时表了，违反了唯一性约束，所以插入失败，然后继续执行；</li>\n<li>取到第二行 id=999，插入临时表成功。</li>\n</ol>\n</li>\n<li>从临时表中按行取出数据，返回结果，并删除临时表，结果中包含两行数据分别是 1000 和 999。</li>\n</ol>\n<p><img src=\"/article/union 执行流程.jpg\"><span class=\"image-caption\">union 执行流程</span></p>\n<p>这里的内存临时表起到了暂存数据的作用，而且计算过程还用上了临时表主键 id 的唯一性约束，实现了 union 的语义。</p>\n<blockquote>\n<p>如果把上面这个语句中的 union 改成 union all 的话，就没有了“去重”的语义。这样执行的时候，就依次执行子查询，得到的结果直接作为结果集的一部分，发给客户端。因此也就不需要临时表了。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"group-by-执行流程\"><a href=\"#group-by-执行流程\" class=\"headerlink\" title=\"group by 执行流程\"></a>group by 执行流程</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select id%10 as m, count(*) as c from t1 group by m;<br></code></pre></td></tr></table></figure>\n<p>这个语句的逻辑是把表 t1 里的数据，按照 id%10 进行分组统计，并按照 m 的结果排序后输出。它的 explain 结果如下：</p>\n<p><img src=\"/article/group by 的 explain 结果.png\"><span class=\"image-caption\">group by 的 explain 结果</span></p>\n<ol>\n<li>Using index，表示这个语句使用了覆盖索引，选择了索引 a，不需要回表；</li>\n<li>Using temporary，表示使用了临时表；</li>\n<li>Using filesort，表示需要排序。</li>\n</ol>\n<p>这个语句的执行流程是这样的：</p>\n<ol>\n<li>创建内存临时表，表里有两个字段 m 和 c，主键是 m；</li>\n<li>扫描表 t1 的索引 a，依次取出叶子节点上的 id 值，计算 id%10 的结果，记为 x；<ol>\n<li>如果临时表中没有主键为 x 的行，就插入一个记录 (x,1);</li>\n<li>如果表中有主键为 x 的行，就将 x 这一行的 c 值加 1；</li>\n</ol>\n</li>\n<li>遍历完成后，再根据字段 m 做排序，得到结果集返回给客户端。</li>\n</ol>\n<p><img src=\"/article/group by 执行流程.jpg\"><span class=\"image-caption\">group by 执行流程</span></p>\n<p>图中最后一步，对内存临时表的排序</p>\n<img src=\"/article/10821/%E5%86%85%E5%AD%98%E4%B8%B4%E6%97%B6%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.jpg\" class title=\"内存临时表排序流程\">\n</blockquote>\n<h3 id=\"group-by-优化方法-–-索引\"><a href=\"#group-by-优化方法-–-索引\" class=\"headerlink\" title=\"group by 优化方法 – 索引\"></a>group by 优化方法 – 索引</h3><p>group by 逻辑需要构造一个带唯一索引的表，执行代价是比较高的</p>\n<blockquote>\n<p>执行 group by 语句为什么需要临时表？</p>\n<p>group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p>\n</blockquote>\n<p>group by 优化方法 : 扫描过程中可以保证出现的数据是有序的</p>\n<p><strong>InnoDB 的索引，就可以满足这个输入有序的条件</strong></p>\n<blockquote>\n<p>在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">alter table t1 add column z int generated always as(id % 100), add index(z);<br></code></pre></td></tr></table></figure>\n<p>上面的 group by 语句就可以改成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select z, count(*) as c from t1 group by z;<br></code></pre></td></tr></table></figure>\n<p>优化后的 group by 语句的 explain 结果，如下图所示：</p>\n<p><img src=\"/article/group by 优化的 explain 结果.png\"><span class=\"image-caption\">group by 优化的 explain 结果</span></p>\n</blockquote>\n<h3 id=\"group-by-优化方法-–-直接排序\"><a href=\"#group-by-优化方法-–-直接排序\" class=\"headerlink\" title=\"group by 优化方法 – 直接排序\"></a>group by 优化方法 – 直接排序</h3><p>在 group by 语句中加入 SQL_BIG_RESULT 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p>\n<blockquote>\n<p>MySQL 的优化器一看，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m;<br></code></pre></td></tr></table></figure>\n<p>执行流程就是这样的：</p>\n<ol>\n<li>初始化 sort_buffer，确定放入一个整型字段，记为 m；</li>\n<li>扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；</li>\n<li>扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；</li>\n<li>排序完成后，就得到了一个有序数组。</li>\n</ol>\n<p><img src=\"/article/使用 SQL_BIG_RESULT 的执行流程图.jpg\"><span class=\"image-caption\">使用 SQL_BIG_RESULT 的执行流程图</span></p>\n<p><img src=\"/article/使用 SQL_BIG_RESULT 的 explain 结果.png\"><span class=\"image-caption\">使用 SQL_BIG_RESULT 的 explain 结果</span></p>\n<p>从 Extra 字段可以看到，这个语句的执行没有再使用临时表，而是直接用了排序算法。</p>\n</blockquote>\n<h3 id=\"group-by-使用的指导原则\"><a href=\"#group-by-使用的指导原则\" class=\"headerlink\" title=\"group by 使用的指导原则\"></a>group by 使用的指导原则</h3><ol>\n<li>如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；</li>\n<li>尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；</li>\n<li>如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</li>\n<li>如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。</li>\n</ol>\n<h3 id=\"MySQL-什么时候会使用内部临时表？\"><a href=\"#MySQL-什么时候会使用内部临时表？\" class=\"headerlink\" title=\"MySQL 什么时候会使用内部临时表？\"></a>MySQL 什么时候会使用内部临时表？</h3><ol>\n<li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li>\n<li>join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；</li>\n<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。</li>\n</ol>\n<hr>\n<blockquote>\n<p><strong>问题：如果只需要去重，不需要执行聚合函数，distinct 和 group by 哪种效率高一些呢？</strong></p>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select a from t group by a order by null;<br>select distinct a from t;<br></code></pre></td></tr></table></figure>\n<p>表 t 的字段 a 上没有索引</p>\n</blockquote>\n<p><strong>不需要执行聚合函数时，distinct 和 group by 这两条语句的语义和执行流程是相同的，因此执行性能也相同。</strong></p>\n<blockquote>\n<p>这两条语句的执行流程是下面这样的:</p>\n<ol>\n<li>创建一个临时表，临时表有一个字段 a，并且在这个字段 a 上创建一个唯一索引；</li>\n<li>遍历表 t，依次取数据插入临时表中：<ol>\n<li>如果发现唯一键冲突，就跳过；</li>\n<li>否则插入成功；</li>\n</ol>\n</li>\n<li>遍历完成后，将临时表作为结果集返回给客户端。</li>\n</ol>\n</blockquote>\n</blockquote>\n<hr>\n<h2 id=\"都说InnoDB好，那还要不要使用Memory引擎？\"><a href=\"#都说InnoDB好，那还要不要使用Memory引擎？\" class=\"headerlink\" title=\"都说InnoDB好，那还要不要使用Memory引擎？\"></a>都说InnoDB好，那还要不要使用Memory引擎？</h2><h3 id=\"内存表的数据组织结构\"><a href=\"#内存表的数据组织结构\" class=\"headerlink\" title=\"内存表的数据组织结构\"></a>内存表的数据组织结构</h3><blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table t1(id int primary key, c int) engine=Memory;<br>create table t2(id int primary key, c int) engine=innodb;<br>insert into t1 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);<br>insert into t2 values(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(0,0);<br></code></pre></td></tr></table></figure>\n<p>表 t1 使用 Memory 引擎， 表 t2 使用 InnoDB 引擎。</p>\n<p>分别执行 select <em> from t1 和 select </em> from t2</p>\n<p><img src=\"/article/两个查询结果 -0 的位置.png\"><span class=\"image-caption\">两个查询结果 -0 的位置</span></p>\n<p>内存表 t1 的返回结果里面 0 在最后一行，而 InnoDB 表 t2 的返回结果里 0 在第一行。</p>\n</blockquote>\n<p><strong>InnoDB 引擎</strong>，它的主键索引 id 的组织方式：InnoDB 表的数据就放在<strong>主键索引树上</strong>，<strong>主键索引是 B+ 树</strong>。所以表 t2 的数据组织方式如下图所示：</p>\n<p><img src=\"/article/表 t2 的数据组织.jpg\"><span class=\"image-caption\">表 t2 的数据组织</span></p>\n<p><strong>主键索引上的值是有序存储的</strong></p>\n<blockquote>\n<p>在执行 select * 的时候，就会按照叶子节点从左到右扫描，所以得到的结果里，0 就出现在第一行。</p>\n</blockquote>\n<p><strong>Memory 引擎</strong>的数据和索引是分开的</p>\n<blockquote>\n<p><img src=\"/article/表 t1 的数据组织.jpg\"><span class=\"image-caption\">表 t1 的数据组织</span></p>\n</blockquote>\n<p>内存表的数据部分以数组的方式单独存放，而主键 id 索引里，存的是每个数据的位置。<strong>主键 id 是 hash 索引</strong>，可以看到索引上的 key 并不是有序的。</p>\n<blockquote>\n<p>在内存表 t1 中，当执行 select * 的时候，走的是全表扫描，也就是顺序扫描这个数组。因此，0 就是最后一个被读到，并放入结果集的数据。</p>\n</blockquote>\n<p><strong>InnoDB 和 Memory 引擎的数据组织方式是不同的：</strong></p>\n<ol>\n<li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。</li>\n<li>Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。</li>\n</ol>\n<p><strong>两个引擎的一些典型不同：</strong></p>\n<ol>\n<li>InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li>\n<li>当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li>\n<li>数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；</li>\n<li>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li>\n<li>InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li>\n</ol>\n<h3 id=\"hash-索引和-B-Tree-索引\"><a href=\"#hash-索引和-B-Tree-索引\" class=\"headerlink\" title=\"hash 索引和 B-Tree 索引\"></a>hash 索引和 B-Tree 索引</h3><p><strong>内存表也是支持 B-Tree 索引的。</strong></p>\n<blockquote>\n<p>在 id 列上创建一个 B-Tree 索引，SQL 语句可以这么写：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">alter table t1 add index a_btree_index using btree (id);<br></code></pre></td></tr></table></figure>\n<p>表 t1 的数据组织形式就变成了这样：</p>\n<p><img src=\"/article/表 t1 的数据组织 -- 增加 B-Tree 索引.jpg\"><span class=\"image-caption\">表 t1 的数据组织 -- 增加 B-Tree 索引</span></p>\n<p><img src=\"/article/使用 B-Tree 和 hash 索引查询返回结果对比.png\"><span class=\"image-caption\">使用 B-Tree 和 hash 索引查询返回结果对比</span></p>\n</blockquote>\n<h3 id=\"为什么不建议生产环境上使用内存表\"><a href=\"#为什么不建议生产环境上使用内存表\" class=\"headerlink\" title=\"为什么不建议生产环境上使用内存表?\"></a>为什么不建议生产环境上使用内存表?</h3><ol>\n<li><p>锁粒度问题；</p>\n<p>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</p>\n</li>\n<li><p>数据持久化问题。</p>\n<p>数据库重启的时候，所有的内存表都会被清空。</p>\n<p>由于重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是双 M 架构，还可能导致主库的内存表数据被删掉。</p>\n</li>\n</ol>\n<p>内存临时表刚好可以无视内存表的两个不足，主要是下面的三个原因：</p>\n<ol>\n<li>临时表不会被其他线程访问，没有并发性的问题；</li>\n<li>临时表重启后也是需要删除的，清空数据这个问题不存在；</li>\n<li>备库的临时表也不会影响主库的用户线程。</li>\n</ol>\n","categories":[{"name":"Mysql","path":"api/categories/Mysql.json"},{"name":"面试","path":"api/categories/面试.json"}],"tags":[{"name":"实习,Mysql","path":"api/tags/实习,Mysql.json"}]}