{"title":"栈","slug":"栈","date":"2022-05-06T07:27:26.000Z","updated":"2022-05-24T11:41:34.366Z","comments":true,"path":"api/articles/栈.json","realPath":null,"excerpt":null,"covers":["/article/37273/%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88.jpg","/article/37273/%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E6%A0%88.jpg","/article/37273/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.jpg"],"cover":"/images/theme/coverphoto/栈.jpg","content":"<h2 id=\"栈：如何实现浏览器的前进和后退功能？\"><a href=\"#栈：如何实现浏览器的前进和后退功能？\" class=\"headerlink\" title=\"栈：如何实现浏览器的前进和后退功能？\"></a>栈：如何实现浏览器的前进和后退功能？</h2><blockquote>\n<p>当你依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果你后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。</p>\n</blockquote>\n<p><strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong></p>\n<p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</strong></p>\n<h3 id=\"如何实现一个“栈”？\"><a href=\"#如何实现一个“栈”？\" class=\"headerlink\" title=\"如何实现一个“栈”？\"></a>如何实现一个“栈”？</h3><p>栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。</p>\n<p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 基于数组实现的顺序栈</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ArrayStack</span> </span>&#123;<br>  <span class=\"hljs-keyword\">private</span> String[] items;  <span class=\"hljs-comment\">// 数组</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> count;       <span class=\"hljs-comment\">// 栈中元素个数</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> n;           <span class=\"hljs-comment\">//栈的大小</span><br><br>  <span class=\"hljs-comment\">// 初始化数组，申请一个大小为n的数组空间</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ArrayStack</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.items = <span class=\"hljs-keyword\">new</span> String[n];<br>    <span class=\"hljs-keyword\">this</span>.n = n;<br>    <span class=\"hljs-keyword\">this</span>.count = <span class=\"hljs-number\">0</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 入栈操作</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(String item)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 数组空间不够了，直接返回false，入栈失败。</span><br>    <span class=\"hljs-keyword\">if</span> (count == n) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    <span class=\"hljs-comment\">// 将item放到下标为count的位置，并且count加一</span><br>    items[count] = item;<br>    ++count;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 出栈操作</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 栈为空，则直接返回null</span><br>    <span class=\"hljs-keyword\">if</span> (count == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    <span class=\"hljs-comment\">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span><br>    String tmp = items[count-<span class=\"hljs-number\">1</span>];<br>    --count;<br>    <span class=\"hljs-keyword\">return</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>空间复杂度是 O(1)</p>\n<p>时间复杂度是 O(1)</p>\n<h3 id=\"支持动态扩容的顺序栈\"><a href=\"#支持动态扩容的顺序栈\" class=\"headerlink\" title=\"支持动态扩容的顺序栈\"></a>支持动态扩容的顺序栈</h3><blockquote>\n<p>如何来实现一个支持动态扩容的数组的？</p>\n<p>当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p>\n</blockquote>\n<p>要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</p>\n<img src=\"/article/37273/%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88.jpg\" class title=\"支持动态扩容的顺序栈\">\n<p>对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。</p>\n<p>但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。<strong>对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。</strong></p>\n<p>入栈操作的均摊时间复杂度为 O(1)</p>\n<blockquote>\n<p>假设和定义：</p>\n<ul>\n<li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li>\n<li>为了简化分析，假设只有入栈操作没有出栈操作；</li>\n<li>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)。</li>\n</ul>\n<p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。</p>\n<img src=\"/article/37273/%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E6%A0%88.jpg\" class title=\"动态扩容栈\">\n<p>这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，<strong>入栈操作的均摊时间复杂度就为 O(1)</strong>。</p>\n</blockquote>\n<h3 id=\"栈在函数调用中的应用\"><a href=\"#栈在函数调用中的应用\" class=\"headerlink\" title=\"栈在函数调用中的应用\"></a>栈在函数调用中的应用</h3><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>   <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>; <br>   <span class=\"hljs-keyword\">int</span> ret = <span class=\"hljs-number\">0</span>;<br>   <span class=\"hljs-keyword\">int</span> res = <span class=\"hljs-number\">0</span>;<br>   ret = add(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);<br>   res = a + ret;<br>   printf(<span class=\"hljs-string\">&quot;%d&quot;</span>, res);<br>   reuturn <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>&#123;<br>   <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>;<br>   sum = x + y;<br>   <span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相加，最后打印 res 的值</p>\n<p> 函数调用栈.jpg)</p>\n</blockquote>\n<h3 id=\"栈在表达式求值中的应用\"><a href=\"#栈在表达式求值中的应用\" class=\"headerlink\" title=\"栈在表达式求值中的应用\"></a>栈在表达式求值中的应用</h3><blockquote>\n<p>3+5*8-6</p>\n</blockquote>\n<p>编译器就是通过两个栈来实现的。</p>\n<ol>\n<li>其中一个保存操作数的栈，</li>\n<li>另一个是保存运算符的栈。</li>\n</ol>\n<p>我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>\n<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>\n<blockquote>\n<img src=\"/article/37273/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.jpg\" class title=\"表达式的计算过程\">\n</blockquote>\n<h3 id=\"栈在括号匹配中的应用\"><a href=\"#栈在括号匹配中的应用\" class=\"headerlink\" title=\"栈在括号匹配中的应用\"></a>栈在括号匹配中的应用</h3><blockquote>\n<p>假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。</p>\n</blockquote>\n<p>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>\n<p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>\n<h3 id=\"如何实现浏览器的前进、后退功能？\"><a href=\"#如何实现浏览器的前进、后退功能？\" class=\"headerlink\" title=\"如何实现浏览器的前进、后退功能？\"></a>如何实现浏览器的前进、后退功能？</h3><p>使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>\n","more":"<h2 id=\"栈：如何实现浏览器的前进和后退功能？\"><a href=\"#栈：如何实现浏览器的前进和后退功能？\" class=\"headerlink\" title=\"栈：如何实现浏览器的前进和后退功能？\"></a>栈：如何实现浏览器的前进和后退功能？</h2><blockquote>\n<p>当你依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果你后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。</p>\n</blockquote>\n<p><strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong></p>\n<p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</strong></p>\n<h3 id=\"如何实现一个“栈”？\"><a href=\"#如何实现一个“栈”？\" class=\"headerlink\" title=\"如何实现一个“栈”？\"></a>如何实现一个“栈”？</h3><p>栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。</p>\n<p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 基于数组实现的顺序栈</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ArrayStack</span> </span>&#123;<br>  <span class=\"hljs-keyword\">private</span> String[] items;  <span class=\"hljs-comment\">// 数组</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> count;       <span class=\"hljs-comment\">// 栈中元素个数</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> n;           <span class=\"hljs-comment\">//栈的大小</span><br><br>  <span class=\"hljs-comment\">// 初始化数组，申请一个大小为n的数组空间</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ArrayStack</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.items = <span class=\"hljs-keyword\">new</span> String[n];<br>    <span class=\"hljs-keyword\">this</span>.n = n;<br>    <span class=\"hljs-keyword\">this</span>.count = <span class=\"hljs-number\">0</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 入栈操作</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(String item)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 数组空间不够了，直接返回false，入栈失败。</span><br>    <span class=\"hljs-keyword\">if</span> (count == n) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    <span class=\"hljs-comment\">// 将item放到下标为count的位置，并且count加一</span><br>    items[count] = item;<br>    ++count;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 出栈操作</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 栈为空，则直接返回null</span><br>    <span class=\"hljs-keyword\">if</span> (count == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    <span class=\"hljs-comment\">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span><br>    String tmp = items[count-<span class=\"hljs-number\">1</span>];<br>    --count;<br>    <span class=\"hljs-keyword\">return</span> tmp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>空间复杂度是 O(1)</p>\n<p>时间复杂度是 O(1)</p>\n<h3 id=\"支持动态扩容的顺序栈\"><a href=\"#支持动态扩容的顺序栈\" class=\"headerlink\" title=\"支持动态扩容的顺序栈\"></a>支持动态扩容的顺序栈</h3><blockquote>\n<p>如何来实现一个支持动态扩容的数组的？</p>\n<p>当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p>\n</blockquote>\n<p>要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</p>\n<img src=\"/article/37273/%E6%94%AF%E6%8C%81%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%A0%88.jpg\" class title=\"支持动态扩容的顺序栈\">\n<p>对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。</p>\n<p>但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。<strong>对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。</strong></p>\n<p>入栈操作的均摊时间复杂度为 O(1)</p>\n<blockquote>\n<p>假设和定义：</p>\n<ul>\n<li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li>\n<li>为了简化分析，假设只有入栈操作没有出栈操作；</li>\n<li>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)。</li>\n</ul>\n<p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。</p>\n<img src=\"/article/37273/%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E6%A0%88.jpg\" class title=\"动态扩容栈\">\n<p>这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，<strong>入栈操作的均摊时间复杂度就为 O(1)</strong>。</p>\n</blockquote>\n<h3 id=\"栈在函数调用中的应用\"><a href=\"#栈在函数调用中的应用\" class=\"headerlink\" title=\"栈在函数调用中的应用\"></a>栈在函数调用中的应用</h3><p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>   <span class=\"hljs-keyword\">int</span> a = <span class=\"hljs-number\">1</span>; <br>   <span class=\"hljs-keyword\">int</span> ret = <span class=\"hljs-number\">0</span>;<br>   <span class=\"hljs-keyword\">int</span> res = <span class=\"hljs-number\">0</span>;<br>   ret = add(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);<br>   res = a + ret;<br>   printf(<span class=\"hljs-string\">&quot;%d&quot;</span>, res);<br>   reuturn <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x, <span class=\"hljs-keyword\">int</span> y)</span> </span>&#123;<br>   <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>;<br>   sum = x + y;<br>   <span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相加，最后打印 res 的值</p>\n<p> 函数调用栈.jpg)</p>\n</blockquote>\n<h3 id=\"栈在表达式求值中的应用\"><a href=\"#栈在表达式求值中的应用\" class=\"headerlink\" title=\"栈在表达式求值中的应用\"></a>栈在表达式求值中的应用</h3><blockquote>\n<p>3+5*8-6</p>\n</blockquote>\n<p>编译器就是通过两个栈来实现的。</p>\n<ol>\n<li>其中一个保存操作数的栈，</li>\n<li>另一个是保存运算符的栈。</li>\n</ol>\n<p>我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>\n<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>\n<blockquote>\n<img src=\"/article/37273/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.jpg\" class title=\"表达式的计算过程\">\n</blockquote>\n<h3 id=\"栈在括号匹配中的应用\"><a href=\"#栈在括号匹配中的应用\" class=\"headerlink\" title=\"栈在括号匹配中的应用\"></a>栈在括号匹配中的应用</h3><blockquote>\n<p>假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。</p>\n</blockquote>\n<p>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p>\n<p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>\n<h3 id=\"如何实现浏览器的前进、后退功能？\"><a href=\"#如何实现浏览器的前进、后退功能？\" class=\"headerlink\" title=\"如何实现浏览器的前进、后退功能？\"></a>如何实现浏览器的前进、后退功能？</h3><p>使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>\n","categories":[{"name":"数据结构与算法","path":"api/categories/数据结构与算法.json"},{"name":"栈","path":"api/categories/栈.json"}],"tags":[{"name":"数据结构与算法,栈","path":"api/tags/数据结构与算法,栈.json"}]}