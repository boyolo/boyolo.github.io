{"title":"字符串匹配","slug":"字符串匹配","date":"2022-05-26T13:11:52.000Z","updated":"2022-07-11T13:10:18.140Z","comments":true,"path":"api/articles/字符串匹配.json","realPath":null,"excerpt":null,"covers":["/article/41181/%E4%B8%BB%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC.jpg","/article/41181/%E6%8F%90%E9%AB%98%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%AD%90%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC%E7%9A%84%E6%95%88%E7%8E%87.jpg","/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E5%AE%9E%E4%BE%8B.jpg","/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F1.jpg","/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F2.jpg","/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D.jpg","/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F3.jpg","/article/41181/%E6%9F%A5%E6%89%BE%E5%9D%8F%E5%AD%97%E7%AC%A6%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg","/article/41181/%E6%9F%A5%E6%89%BE%E5%9D%8F%E5%AD%97%E7%AC%A6%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%B9%B6%E7%A7%BB%E5%8A%A8.jpg","/article/41181/%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84%E5%90%8E%E7%BC%80%E5%AD%90%E4%B8%B2.jpg","/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D1.jpg","/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D1.jpg","/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D3.jpg","/article/41181/%E5%A5%BD%E5%89%8D%E7%BC%80%E4%B8%8E%E5%9D%8F%E5%AD%97%E7%AC%A6.jpg","/article/41181/%E5%AD%97%E4%B8%B2%E5%AF%B9%E6%AF%94.jpg","/article/41181/%E5%AD%97%E4%B8%B2%E5%8C%B9%E9%85%8D.jpg","/article/41181/%E6%9C%80%E9%95%BF%E5%8F%AF%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2.jpg","/article/41181/Trie%E6%A0%91%E5%AE%9E%E4%BE%8B.jpg","/article/41181/%E5%80%9F%E5%8A%A9%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0Trie%E6%A0%91.jpg","/article/41181/%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg","/article/41181/%E5%AF%BB%E6%89%BE%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg","/article/41181/%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg"],"cover":"/images/theme/coverphoto/字符串匹配.jpg","content":"<h2 id=\"字符串匹配\"><a href=\"#字符串匹配\" class=\"headerlink\" title=\"字符串匹配\"></a>字符串匹配</h2><p>在字符串 A 中查找字符串 B，那字符串 A 就是<strong>主串</strong>，字符串 B 就是<strong>模式串</strong>。</p>\n<h3 id=\"BF-算法\"><a href=\"#BF-算法\" class=\"headerlink\" title=\"BF 算法\"></a>BF 算法</h3><p>BF 算法中的 BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。</p>\n<p><strong>在主串中，检查起始位置分别是 0、1、2….n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。</strong></p>\n<p><img src=\"/article/BF 算法实例.jpg\"><span class=\"image-caption\">BF 算法实例</span></p>\n<p>最坏情况时间复杂度是 O(n*m)</p>\n<h3 id=\"RK-算法\"><a href=\"#RK-算法\" class=\"headerlink\" title=\"RK 算法\"></a>RK 算法</h3><p>RK 算法的全称叫 Rabin-Karp 算法，是 BF 算法的升级版</p>\n<h4 id=\"RK-算法的思路\"><a href=\"#RK-算法的思路\" class=\"headerlink\" title=\"RK 算法的思路\"></a>RK 算法的思路</h4><p>通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p>\n<img src=\"/article/41181/%E4%B8%BB%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC.jpg\" class title=\"主串哈希值\">\n<h4 id=\"提高哈希算法计算子串哈希值的效率\"><a href=\"#提高哈希算法计算子串哈希值的效率\" class=\"headerlink\" title=\"提高哈希算法计算子串哈希值的效率\"></a><strong>提高哈希算法计算子串哈希值的效率</strong></h4><p>假设要匹配的字符串的字符集中只包含 K 个字符，可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p>\n<p>相邻两个子串 s[i-1]和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，<strong>可以使用 s[i-1]的哈希值很快的计算出 s[i]的哈希值。</strong></p>\n<img src=\"/article/41181/%E6%8F%90%E9%AB%98%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%AD%90%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC%E7%9A%84%E6%95%88%E7%8E%87.jpg\" class title=\"提高哈希算法计算子串哈希值的效率\">\n<p>26<sup>(m-1)</sup> 这部分的计算，我们可以通过查表的方法来提高效率。事先计算好 26<sup>0</sup>、26<sup>1</sup>、26<sup>2</sup>、26<sup>3</sup>……26<sup>(m-1)</sup> ，并且<strong>存储在一个长度为 m 的数组中</strong>，公式中的“次方”就对应数组的下标，需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。</p>\n<blockquote>\n<p><strong>问题：模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？</strong></p>\n<p>为了能将哈希值落在整型数据范围内，可以允许哈希冲突</p>\n</blockquote>\n<h4 id=\"RK-算法的时间复杂度\"><a href=\"#RK-算法的时间复杂度\" class=\"headerlink\" title=\"RK 算法的时间复杂度\"></a><strong>RK 算法的时间复杂度</strong></h4><p>整个 RK 算法包含两部分</p>\n<ol>\n<li><p>计算子串哈希值和模式串哈希值</p>\n<p>通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 <strong>O(n)</strong></p>\n</li>\n<li><p>子串哈希值之间的比较</p>\n<p>时间复杂度是 <strong>O(1)</strong>，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 <strong>O(n)</strong></p>\n</li>\n</ol>\n<p>RK 算法整体的时间复杂度就是 <strong>O(n)</strong></p>\n<p>最坏情况时间复杂度<strong>O(n*m)</strong></p>\n<h3 id=\"BF、RK算法实现\"><a href=\"#BF、RK算法实现\" class=\"headerlink\" title=\"BF、RK算法实现\"></a>BF、RK算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bF</span><span class=\"hljs-params\">(String a,String b)</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">int</span> m=a.length(),n=b.length(),k;<br>\t\t<span class=\"hljs-keyword\">char</span>[] a1=a.toCharArray();<br>\t\t<span class=\"hljs-keyword\">char</span>[] b1=b.toCharArray();<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=m-n;i++) &#123;<br>\t\t\tk=<span class=\"hljs-number\">0</span>;<br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(a1[i+j]==b1[j]) &#123;<br>\t\t\t\t\tk++;<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(k==n) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> i;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>\t&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">rK</span><span class=\"hljs-params\">(String a,String b)</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">int</span> m=a.length(),n=b.length(),s,j;<br>\t\t<span class=\"hljs-keyword\">int</span>[] hash=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[m-n+<span class=\"hljs-number\">1</span>];<br>\t\t<span class=\"hljs-keyword\">int</span>[] table=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">26</span>];<br>\t\t<span class=\"hljs-keyword\">char</span>[] a1=a.toCharArray();<br>\t\t<span class=\"hljs-keyword\">char</span>[] b1=b.toCharArray();<br>\t\ts=<span class=\"hljs-number\">1</span>;<br>\t\t<span class=\"hljs-comment\">//将26的次方存储在一个表里，取的时候直接用,虽然溢出，但没啥问题</span><br>\t\t<span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">26</span>;j++) &#123;<br>\t\t\ttable[j]=s;<br>\t\t\ts*=<span class=\"hljs-number\">26</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=m-n;i++) &#123;<br>\t\t\ts=<span class=\"hljs-number\">0</span>;<br>\t\t\t<span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;n;j++) &#123;<br>\t\t\t\ts+=(a1[i+j]-<span class=\"hljs-string\">&#x27;a&#x27;</span>)*table[n-<span class=\"hljs-number\">1</span>-j];<br>\t\t\t&#125;<br>\t\t\thash[i]=s;<br>\t\t&#125;<br>\t\ts=<span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;n;j++) &#123;<br>\t\t\ts+=(b1[j]-<span class=\"hljs-string\">&#x27;a&#x27;</span>)*table[n-<span class=\"hljs-number\">1</span>-j];<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;m-n+<span class=\"hljs-number\">1</span>;j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(hash[j]==s) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> j;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"BM（Boyer-Moore）算法\"><a href=\"#BM（Boyer-Moore）算法\" class=\"headerlink\" title=\"BM（Boyer-Moore）算法\"></a>BM（Boyer-Moore）算法</h3><h4 id=\"BM-算法的核心思想\"><a href=\"#BM-算法的核心思想\" class=\"headerlink\" title=\"BM 算法的核心思想\"></a>BM 算法的核心思想</h4><p>BM 算法包含两部分，分别是<strong>坏字符规则（bad character rule）</strong>和<strong>好后缀规则（good suffix shift）</strong>。</p>\n<ol>\n<li><p>坏字符规则</p>\n<p><img src=\"/article/BM 算法的匹配顺序实例.jpg\"><span class=\"image-caption\">BM 算法的匹配顺序实例</span></p>\n<p>BM 算法的匹配顺序是<strong>按照模式串下标从大到小的顺序</strong></p>\n<p>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候，把这个没有匹配的字符叫作<strong>坏字符（主串中的字符）</strong>。</p>\n<blockquote>\n<ol>\n<li><p>坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p>\n<p><img src=\"/article/BM 算法的匹配顺序1.jpg\"><span class=\"image-caption\">BM 算法的匹配顺序1</span></p>\n</li>\n<li><p>模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，<strong>不能将模式串往后滑动三位</strong>。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。</p>\n<p><img src=\"/article/BM 算法的匹配顺序2.jpg\"><span class=\"image-caption\">BM 算法的匹配顺序2</span></p>\n</li>\n</ol>\n</blockquote>\n<p>当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。</p>\n<p><img src=\"/article/BM 算法坏字符规律.jpg\"><span class=\"image-caption\">BM 算法坏字符规律</span></p>\n<p><strong>如果坏字符在模式串里多处出现，在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</strong></p>\n<p><strong>最好情况时间复杂度：</strong>O(n/m)</p>\n<p><strong>问题：</strong>根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。</p>\n</li>\n<li><p>好后缀规则</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E5%AE%9E%E4%BE%8B.jpg\" class title=\"好后缀规则实例\">\n<p><strong>把已经匹配的 bc 叫作好后缀</strong>，记作{u}</p>\n<blockquote>\n<ol>\n<li><p>拿 {u} 在模式串中查找，如果找到了另一个跟 {u} 相匹配的子串 {u*} ，就将模式串滑动到子串{u*}与主串中{u}对齐的位置。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F1.jpg\" class title=\"好后缀规则顺序1\">\n</li>\n<li><p>如果好后缀在模式串中不存在可匹配的子串，在一步一步往后滑动模式串的过程中，只要主串中的 {u} 与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中 {u} 的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F2.jpg\" class title=\"好后缀规则顺序2\">\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D.jpg\" class title=\"好后缀规则前缀后缀部分匹配\">\n<p>所以，针对这种情况，不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察<strong>好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的</strong>。</p>\n<p><strong>从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是 {v} ，然后将模式串滑动到如图所示的位置。</strong></p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F3.jpg\" class title=\"好后缀规则顺序3\">\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<p><strong>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数</strong></p>\n<h4 id=\"BM-算法代码实现\"><a href=\"#BM-算法代码实现\" class=\"headerlink\" title=\"BM 算法代码实现\"></a>BM 算法代码实现</h4><blockquote>\n<p><strong>如何查找坏字符在模式串中出现的位置?</strong></p>\n<p>可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。</p>\n<p>假设字符串的字符集不是很大，每个字符长度是 1 字节，用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。</p>\n<img src=\"/article/41181/%E6%9F%A5%E6%89%BE%E5%9D%8F%E5%AD%97%E7%AC%A6%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg\" class title=\"查找坏字符在模式串中出现的位置\">\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> SIZE = <span class=\"hljs-number\">256</span>; <span class=\"hljs-comment\">// 全局变量或成员变量</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">generateBC</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] b, <span class=\"hljs-keyword\">int</span> m, <span class=\"hljs-keyword\">int</span>[] bc)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; SIZE; ++i) &#123;<br>    bc[i] = -<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 初始化bc</span><br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; ++i) &#123;<br>    <span class=\"hljs-keyword\">int</span> ascii = (<span class=\"hljs-keyword\">int</span>)b[i]; <span class=\"hljs-comment\">// 计算b[i]的ASCII值</span><br>    bc[ascii] = i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>变量 b 是模式串，m 是模式串的长度，bc 表示散列表</p>\n</blockquote>\n<blockquote>\n<p><strong>不考虑好后缀规则，仅用坏字符规则，并且不考虑 si-xi 计算得到的移动位数可能会出现负数的情况</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bm</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] a, <span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">char</span>[] b, <span class=\"hljs-keyword\">int</span> m)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span>[] bc = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[SIZE]; <span class=\"hljs-comment\">// 记录模式串中每个字符最后出现的位置</span><br>  generateBC(b, m, bc); <span class=\"hljs-comment\">// 构建坏字符哈希表</span><br>  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// i表示主串与模式串对齐的第一个字符</span><br>  <span class=\"hljs-keyword\">while</span> (i &lt;= n - m) &#123;<br>    <span class=\"hljs-keyword\">int</span> j;<br>    <span class=\"hljs-keyword\">for</span> (j = m - <span class=\"hljs-number\">1</span>; j &gt;= <span class=\"hljs-number\">0</span>; --j) &#123; <span class=\"hljs-comment\">// 模式串从后往前匹配</span><br>      <span class=\"hljs-keyword\">if</span> (a[i+j] != b[j]) <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// 坏字符对应模式串中的下标是j</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (j &lt; <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> i; <span class=\"hljs-comment\">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br>    &#125;<br>    <span class=\"hljs-comment\">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span><br>    i = i + (j - bc[(<span class=\"hljs-keyword\">int</span>)a[i+j]]); <br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/41181/%E6%9F%A5%E6%89%BE%E5%9D%8F%E5%AD%97%E7%AC%A6%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%B9%B6%E7%A7%BB%E5%8A%A8.jpg\" class title=\"查找坏字符在模式串中出现的位置并移动\">\n</blockquote>\n<blockquote>\n<p><strong>好后缀规则</strong></p>\n<ol>\n<li>在模式串中，查找跟好后缀匹配的另一个子串；</li>\n<li>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</li>\n</ol>\n<p><strong>在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置</strong></p>\n<ol>\n<li><p>表示模式串中不同的后缀子串</p>\n<p>后缀子串的最后一个字符的位置是固定的，下标为 m-1，只需要记录长度就可以了。通过长度，可以确定一个唯一的后缀子串。</p>\n<img src=\"/article/41181/%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84%E5%90%8E%E7%BC%80%E5%AD%90%E4%B8%B2.jpg\" class title=\"表示模式串中不同的后缀子串\">\n</li>\n<li><p><strong>引入关键变量 suffix 数组</strong></p>\n<p>suffix 数组的下标 k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀{u}相匹配的子串{u*}的起始下标值</p>\n<p><img src=\"/article/suffix 数组.jpg\"><span class=\"image-caption\">suffix 数组</span></p>\n</li>\n<li><p><strong>引入 boolean 类型的 prefix 数组</strong></p>\n<p>记录模式串的后缀子串是否能匹配模式串的前缀子串</p>\n<p><img src=\"/article/prefix 数组.jpg\"><span class=\"image-caption\">prefix 数组</span></p>\n</li>\n</ol>\n<p>拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 k，那我们就记录 suffix[k]=j（j 表示公共后缀子串的起始下标）。如果 j 等于 0，也就是说，公共后缀子串也是模式串的前缀子串，我们就记录 prefix[k]=true。</p>\n<p><img src=\"/article/suffix 数组、prefix 数组计算.jpg\"><span class=\"image-caption\">suffix 数组、prefix 数组计算</span></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">generateGS</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] b, <span class=\"hljs-keyword\">int</span> m, <span class=\"hljs-keyword\">int</span>[] suffix, <span class=\"hljs-keyword\">boolean</span>[] prefix)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; ++i) &#123; <span class=\"hljs-comment\">// 初始化</span><br>    suffix[i] = -<span class=\"hljs-number\">1</span>;<br>    prefix[i] = <span class=\"hljs-keyword\">false</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m - <span class=\"hljs-number\">1</span>; ++i) &#123; <span class=\"hljs-comment\">// b[0, i]</span><br>    <span class=\"hljs-keyword\">int</span> j = i;<br>    <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 公共后缀子串长度</span><br>    <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; b[j] == b[m-<span class=\"hljs-number\">1</span>-k]) &#123; <span class=\"hljs-comment\">// 与b[0, m-1]求公共后缀子串</span><br>      --j;<br>      ++k;<br>      suffix[k] = j+<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//j+1表示公共后缀子串在b[0, i]中的起始下标</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (j == -<span class=\"hljs-number\">1</span>) prefix[k] = <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">//如果公共后缀子串也是模式串的前缀子串</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</strong></p>\n<ol>\n<li><p>假设好后缀的长度是 k。先拿好后缀，在 suffix 数组中查找其匹配的子串。如果 suffix[k]不等于 -1（-1 表示不存在匹配的子串），那我们就将模式串往后移动 j-suffix[k]+1 位（j 表示坏字符对应的模式串中的字符下标）。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D1.jpg\" class title=\"好后缀匹配1\">\n</li>\n<li><p>如果 suffix[k]等于 -1，表示模式串中不存在另一个跟好后缀匹配的子串片段</p>\n<p>好后缀的后缀子串 b[r, m-1]（其中，r 取值从 j+2 到 m-1）的长度 k=m-r，如果 prefix[k]等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样我们可以把模式串后移 r 位。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D1.jpg\" class title=\"好后缀匹配1\">\n</li>\n<li><p>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，就将整个模式串后移 m 位。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D3.jpg\" class title=\"好后缀匹配3\">\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// a,b表示主串和模式串；n，m表示主串和模式串的长度。</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bm</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] a, <span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">char</span>[] b, <span class=\"hljs-keyword\">int</span> m)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span>[] bc = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[SIZE]; <span class=\"hljs-comment\">// 记录模式串中每个字符最后出现的位置</span><br>  generateBC(b, m, bc); <span class=\"hljs-comment\">// 构建坏字符哈希表</span><br>  <span class=\"hljs-keyword\">int</span>[] suffix = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[m];<br>  <span class=\"hljs-keyword\">boolean</span>[] prefix = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">boolean</span>[m];<br>  generateGS(b, m, suffix, prefix);<br>  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// j表示主串与模式串匹配的第一个字符</span><br>  <span class=\"hljs-keyword\">while</span> (i &lt;= n - m) &#123;<br>    <span class=\"hljs-keyword\">int</span> j;<br>    <span class=\"hljs-keyword\">for</span> (j = m - <span class=\"hljs-number\">1</span>; j &gt;= <span class=\"hljs-number\">0</span>; --j) &#123; <span class=\"hljs-comment\">// 模式串从后往前匹配</span><br>      <span class=\"hljs-keyword\">if</span> (a[i+j] != b[j]) <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// 坏字符对应模式串中的下标是j</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (j &lt; <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> i; <span class=\"hljs-comment\">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> x = j - bc[(<span class=\"hljs-keyword\">int</span>)a[i+j]];<br>    <span class=\"hljs-keyword\">int</span> y = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">if</span> (j &lt; m-<span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-comment\">// 如果有好后缀的话</span><br>      y = moveByGS(j, m, suffix, prefix);<br>    &#125;<br>    i = i + Math.max(x, y);<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">moveByGS</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> j, <span class=\"hljs-keyword\">int</span> m, <span class=\"hljs-keyword\">int</span>[] suffix, <span class=\"hljs-keyword\">boolean</span>[] prefix)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span> k = m - <span class=\"hljs-number\">1</span> - j; <span class=\"hljs-comment\">// 好后缀长度</span><br>  <span class=\"hljs-keyword\">if</span> (suffix[k] != -<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> j - suffix[k] +<span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> r = j+<span class=\"hljs-number\">2</span>; r &lt;= m-<span class=\"hljs-number\">1</span>; ++r) &#123;<br>    <span class=\"hljs-keyword\">if</span> (prefix[m-r] == <span class=\"hljs-keyword\">true</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> r;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"></a>KMP 算法</h2><h3 id=\"KMP-算法基本原理\"><a href=\"#KMP-算法基本原理\" class=\"headerlink\" title=\"KMP 算法基本原理\"></a>KMP 算法基本原理</h3><p>在模式串和主串匹配的过程中，把不能匹配的那个字符叫作坏字符，把已经匹配的那段字符串叫作好前缀。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%89%8D%E7%BC%80%E4%B8%8E%E5%9D%8F%E5%AD%97%E7%AC%A6.jpg\" class title=\"好前缀与坏字符\">\n<p>当遇到坏字符的时候，把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。</p>\n<img src=\"/article/41181/%E5%AD%97%E4%B8%B2%E5%AF%B9%E6%AF%94.jpg\" class title=\"字串对比\">\n<p>只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。</p>\n<img src=\"/article/41181/%E5%AD%97%E4%B8%B2%E5%8C%B9%E9%85%8D.jpg\" class title=\"字串匹配\">\n<p>好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫作<strong>最长可匹配前缀子串</strong>。</p>\n<img src=\"/article/41181/%E6%9C%80%E9%95%BF%E5%8F%AF%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2.jpg\" class title=\"最长可匹配子串\">\n<h3 id=\"next-数组\"><a href=\"#next-数组\" class=\"headerlink\" title=\"next 数组\"></a>next 数组</h3><p>KMP 算法可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。把这个数组定义为 <strong>next 数组</strong>，也叫失效函数（failure function）。</p>\n<p>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。</p>\n<p>匹配发生冲突时，查看坏字符前一位的next数组下标</p>\n<table>\n<thead>\n<tr>\n<th>模式串</th>\n<th>a</th>\n<th>a</th>\n<th>b</th>\n<th>a</th>\n<th>a</th>\n<th>f</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>前缀表（next数组）</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p><strong>next 数组算法实现</strong></p>\n<ol>\n<li>初始化</li>\n<li>前后缀不相同情况</li>\n<li>前后缀相同情况</li>\n<li>next数组</li>\n</ol>\n<p>i 表示 后缀末尾位置</p>\n<p>j 表示 前缀末尾位置、i之前包括i的字串的的最长相等前后缀的长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getNext</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] next, <span class=\"hljs-keyword\">char</span>[] s)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;<br>  next[] = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; s.size ; i++)&#123;<br>    <span class=\"hljs-keyword\">while</span>(j &gt; <span class=\"hljs-number\">0</span> &amp;&amp; s[i] != s[j])&#123;<br>      j = next[ j - <span class=\"hljs-number\">1</span> ];<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(s[i] == s[j])&#123;<br>      j++;<br>      next[i] = j;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"KMP-算法复杂度分析\"><a href=\"#KMP-算法复杂度分析\" class=\"headerlink\" title=\"KMP 算法复杂度分析\"></a>KMP 算法复杂度分析</h3><p>KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以<strong>空间复杂度是 O(m)</strong>，m 表示模式串的长度。</p>\n<p>KMP 算法的时间复杂度就是 O(m+n)</p>\n<h3 id=\"KMP算法算法实现\"><a href=\"#KMP算法算法实现\" class=\"headerlink\" title=\"KMP算法算法实现\"></a>KMP算法算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br></code></pre></td></tr></table></figure>\n<h2 id=\"Trie树\"><a href=\"#Trie树\" class=\"headerlink\" title=\"Trie树\"></a>Trie树</h2><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种<strong>专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</strong></p>\n<blockquote>\n<p>有 6 个字符串，它们分别是：how，hi，her，hello，so，see。希望在里面多次查找某个字符串是否存在。</p>\n<p>对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。</p>\n</blockquote>\n<p><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</strong></p>\n<blockquote>\n<img src=\"/article/41181/Trie%E6%A0%91%E5%AE%9E%E4%BE%8B.jpg\" class title=\"Trie树实例\">\n</blockquote>\n<p>根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p>\n<blockquote>\n<p>Trie 树构造的分解过程</p>\n<p><img src=\"/article/Trie 树构造的分解过程1.jpg\"><span class=\"image-caption\">img</span></p>\n<p><img src=\"/article/Trie 树构造的分解过程2.jpg\"><span class=\"image-caption\">Trie 树构造的分解过程</span></p>\n</blockquote>\n<h3 id=\"如何实现一棵-Trie-树？\"><a href=\"#如何实现一棵-Trie-树？\" class=\"headerlink\" title=\"如何实现一棵 Trie 树？\"></a>如何实现一棵 Trie 树？</h3><p>Trie 树主要有两个操作</p>\n<ol>\n<li>一个是将字符串集合构造成 Trie 树。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。</li>\n<li>另一个是在 Trie 树中查询一个字符串。</li>\n</ol>\n<p>借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrieNode</span> </span>&#123;<br>  <span class=\"hljs-keyword\">char</span> data;<br>  TrieNode children[<span class=\"hljs-number\">26</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/41181/%E5%80%9F%E5%8A%A9%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0Trie%E6%A0%91.jpg\" class title=\"借助散列表实现Trie树\">\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Trie</span> </span>&#123;<br>  <span class=\"hljs-keyword\">private</span> TrieNode root = <span class=\"hljs-keyword\">new</span> TrieNode(<span class=\"hljs-string\">&#x27;/&#x27;</span>); <span class=\"hljs-comment\">// 存储无意义字符</span><br><br>  <span class=\"hljs-comment\">// 往Trie树中插入一个字符串</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] text)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; text.length; ++i) &#123;<br>      <span class=\"hljs-keyword\">int</span> index = text[i] - <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>      <span class=\"hljs-keyword\">if</span> (p.children[index] == <span class=\"hljs-keyword\">null</span>) &#123;<br>        TrieNode newNode = <span class=\"hljs-keyword\">new</span> TrieNode(text[i]);<br>        p.children[index] = newNode;<br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    p.isEndingChar = <span class=\"hljs-keyword\">true</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 在Trie树中查找一个字符串</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] pattern)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; pattern.length; ++i) &#123;<br>      <span class=\"hljs-keyword\">int</span> index = pattern[i] - <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>      <span class=\"hljs-keyword\">if</span> (p.children[index] == <span class=\"hljs-keyword\">null</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>; <span class=\"hljs-comment\">// 不存在pattern</span><br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (p.isEndingChar == <span class=\"hljs-keyword\">false</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>; <span class=\"hljs-comment\">// 不能完全匹配，只是前缀</span><br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">// 找到pattern</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrieNode</span> </span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">char</span> data;<br>    <span class=\"hljs-keyword\">public</span> TrieNode[] children = <span class=\"hljs-keyword\">new</span> TrieNode[<span class=\"hljs-number\">26</span>];<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> isEndingChar = <span class=\"hljs-keyword\">false</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">TrieNode</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span> data)</span> </span>&#123;<br>      <span class=\"hljs-keyword\">this</span>.data = data;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><ol>\n<li><p>时间复杂度</p>\n<p>构建 Trie 树的过程，需要扫描所有的字符串，<strong>时间复杂度是 O(n)</strong>（n 表示所有字符串的长度和）</p>\n<p>每次查询时，如果要查询的字符串长度是 k，只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的<strong>时间复杂度是 O(k)</strong>，k 表示要查找的字符串的长度。</p>\n</li>\n<li><p>空间复杂度</p>\n<p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组元素要存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>\n<p><strong>在某些情况下，Trie 树不一定会节省存储空间。在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存。</strong></p>\n</li>\n</ol>\n<h3 id=\"Trie-树与散列表、红黑树\"><a href=\"#Trie-树与散列表、红黑树\" class=\"headerlink\" title=\"Trie 树与散列表、红黑树\"></a>Trie 树与散列表、红黑树</h3><p>Trie 树对要处理的字符串有极其严苛的要求</p>\n<ol>\n<li>第一，字符串中包含的字符集不能太大。即便可以优化，但也要付出牺牲查询、插入效率的代价。</li>\n<li>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</li>\n<li>第三，如果要用 Trie 树解决问题，那就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</li>\n<li>第四，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</li>\n</ol>\n<p>针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树</p>\n<h2 id=\"AC-自动机-Trie-树优化\"><a href=\"#AC-自动机-Trie-树优化\" class=\"headerlink\" title=\"AC 自动机(Trie 树优化)\"></a>AC 自动机(Trie 树优化)</h2><p><strong>基于单模式串和 Trie 树实现的敏感词过滤</strong></p>\n<p>多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。</p>\n<p>只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。</p>\n<p><strong>Trie 树就是一种多模式串匹配算法</strong></p>\n<p>可以对敏感词字典进行预处理，构建成 Trie 树结构。这个预处理的操作只需要做一次，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，只需要动态更新一下 Trie 树就可以了。</p>\n<p>当用户输入一个文本内容后，把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p>\n<h3 id=\"经典的多模式串匹配算法：AC-自动机\"><a href=\"#经典的多模式串匹配算法：AC-自动机\" class=\"headerlink\" title=\"经典的多模式串匹配算法：AC 自动机\"></a>经典的多模式串匹配算法：AC 自动机</h3><p>AC 自动机算法，全称是 Aho-Corasick 算法。</p>\n<p>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AcNode</span> </span>&#123;<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">char</span> data; <br>  <span class=\"hljs-keyword\">public</span> AcNode[] children = <span class=\"hljs-keyword\">new</span> AcNode[<span class=\"hljs-number\">26</span>]; <span class=\"hljs-comment\">// 字符集只包含a~z这26个字符</span><br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> isEndingChar = <span class=\"hljs-keyword\">false</span>; <span class=\"hljs-comment\">// 结尾字符为true</span><br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> length = -<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 当isEndingChar=true时，记录模式串长度</span><br>  <span class=\"hljs-keyword\">public</span> AcNode fail; <span class=\"hljs-comment\">// 失败指针</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AcNode</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span> data)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.data = data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>AC 自动机的构建，包含两个操作：</p>\n<ol>\n<li>将多个模式串构建成 Trie 树；</li>\n<li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。</li>\n</ol>\n<h3 id=\"构建失败指针\"><a href=\"#构建失败指针\" class=\"headerlink\" title=\"构建失败指针\"></a><strong>构建失败指针</strong></h3><p>Trie 树中的每一个节点都有一个失败指针</p>\n<blockquote>\n<p>有 4 个模式串，分别是 c，bc，bcd，abcd；主串是 abcd。</p>\n</blockquote>\n<img src=\"/article/41181/%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg\" class title=\"构建失败指针\">\n<p>假设沿 Trie 树走到 p 节点，也就是下图中的紫色节点，那 p 的失败指针就是从 root 走到紫色节点形成的字符串 abc，跟所有模式串前缀匹配的最长可匹配后缀子串，就是箭头指的 bc 模式串。</p>\n<blockquote>\n<p>字符串 abc 的后缀子串有两个 bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，那我们就把这个后缀子串叫作可匹配后缀子串。</p>\n</blockquote>\n<p>从可匹配后缀子串中，找出最长的一个。将 p 节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是图中紫色箭头指向的节点。</p>\n<p><strong>如果把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。</strong></p>\n<p><strong>失败指针的构建过程，是一个按层遍历树的过程</strong></p>\n<p>首先 root 的失败指针为 NULL，也就是指向自己。</p>\n<p>假设节点 p 的失败指针指向节点 q，看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc。</p>\n<img src=\"/article/41181/%E5%AF%BB%E6%89%BE%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg\" class title=\"寻找子节点的失败指针\">\n<p>如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 q=q-&gt;fail（fail 表示失败指针），继续上面的查找，直到 q 是 root 为止，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//构建失败指针</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buildFailurePointer</span><span class=\"hljs-params\">()</span> </span>&#123;<br>  Queue&lt;AcNode&gt; queue = <span class=\"hljs-keyword\">new</span> LinkedList&lt;&gt;();<br>  root.fail = <span class=\"hljs-keyword\">null</span>;<br>  queue.add(root);<br>  <span class=\"hljs-keyword\">while</span> (!queue.isEmpty()) &#123;<br>    AcNode p = queue.remove();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">26</span>; ++i) &#123;<br>      AcNode pc = p.children[i];<br>      <span class=\"hljs-keyword\">if</span> (pc == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">continue</span>;<br>      <span class=\"hljs-keyword\">if</span> (p == root) &#123;<br>        pc.fail = root;<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        AcNode q = p.fail;<br>        <span class=\"hljs-keyword\">while</span> (q != <span class=\"hljs-keyword\">null</span>) &#123;<br>          AcNode qc = q.children[pc.data - <span class=\"hljs-string\">&#x27;a&#x27;</span>];<br>          <span class=\"hljs-keyword\">if</span> (qc != <span class=\"hljs-keyword\">null</span>) &#123;<br>            pc.fail = qc;<br>            <span class=\"hljs-keyword\">break</span>;<br>          &#125;<br>          q = q.fail;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (q == <span class=\"hljs-keyword\">null</span>) &#123;<br>          pc.fail = root;<br>        &#125;<br>      &#125;<br>      queue.add(pc);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/41181/%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg\" class title=\"失败指针\">\n<h3 id=\"在-AC-自动机上匹配主串\"><a href=\"#在-AC-自动机上匹配主串\" class=\"headerlink\" title=\"在 AC 自动机上匹配主串\"></a>在 AC 自动机上匹配主串</h3><p>在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是 b，主串是 a。</p>\n<ol>\n<li>如果 p 指向的节点有一个等于 a[i]的子节点 x，我们就更新 p 指向 x，这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。处理完之后，我们将 i 加一，继续这两个过程；</li>\n<li>如果 p 指向的节点没有等于 a[i]的子节点，那失败指针就派上用场了，我们让 <code>p=p-&gt;fail</code>，然后继续这 2 个过程。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">match</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] text)</span> </span>&#123; <span class=\"hljs-comment\">// text是主串</span><br>  <span class=\"hljs-keyword\">int</span> n = text.length;<br>  AcNode p = root;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>    <span class=\"hljs-keyword\">int</span> idx = text[i] - <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>    <span class=\"hljs-keyword\">while</span> (p.children[idx] == <span class=\"hljs-keyword\">null</span> &amp;&amp; p != root) &#123;<br>      p = p.fail; <span class=\"hljs-comment\">// 失败指针发挥作用的地方</span><br>    &#125;<br>    p = p.children[idx];<br>    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span>) p = root; <span class=\"hljs-comment\">// 如果没有匹配的，从root开始重新匹配</span><br>    AcNode tmp = p;<br>    <span class=\"hljs-keyword\">while</span> (tmp != root) &#123; <span class=\"hljs-comment\">// 打印出可以匹配的模式串</span><br>      <span class=\"hljs-keyword\">if</span> (tmp.isEndingChar == <span class=\"hljs-keyword\">true</span>) &#123;<br>        <span class=\"hljs-keyword\">int</span> pos = i-tmp.length+<span class=\"hljs-number\">1</span>;<br>        System.out.println(<span class=\"hljs-string\">&quot;匹配起始下标&quot;</span> + pos + <span class=\"hljs-string\">&quot;; 长度&quot;</span> + tmp.length);<br>      &#125;<br>      tmp = tmp.fail;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Trie 树构建的<strong>时间复杂度是 O(m*len)</strong>，其中 len 表示敏感词的平均长度，m 表示敏感词的个数。</p>\n<p>整个失败指针的构建过程<strong>时间复杂度是 O(k*len)</strong>， k 是 Trie 树中总的节点个数，每个节点构建失败指针的时候，最耗时的环节是 while 循环中的 q=q-&gt;fail，每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len，所以每个节点构建失败指针的时间复杂度是 O(len)。</p>\n<p>用 AC 自动机做匹配的时间复杂度，for 循环依次遍历主串中的每个字符，for 循环内部最耗时的部分也是 while 循环，而这一部分的时间复杂度也是 O(len)，所以总的匹配的时间复杂度就是 O(n*len)。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，<strong>可能近似于 O(n)</strong>，所以 AC 自动机做敏感词过滤，性能非常高。</p>\n","more":"<h2 id=\"字符串匹配\"><a href=\"#字符串匹配\" class=\"headerlink\" title=\"字符串匹配\"></a>字符串匹配</h2><p>在字符串 A 中查找字符串 B，那字符串 A 就是<strong>主串</strong>，字符串 B 就是<strong>模式串</strong>。</p>\n<h3 id=\"BF-算法\"><a href=\"#BF-算法\" class=\"headerlink\" title=\"BF 算法\"></a>BF 算法</h3><p>BF 算法中的 BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。</p>\n<p><strong>在主串中，检查起始位置分别是 0、1、2….n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。</strong></p>\n<p><img src=\"/article/BF 算法实例.jpg\"><span class=\"image-caption\">BF 算法实例</span></p>\n<p>最坏情况时间复杂度是 O(n*m)</p>\n<h3 id=\"RK-算法\"><a href=\"#RK-算法\" class=\"headerlink\" title=\"RK 算法\"></a>RK 算法</h3><p>RK 算法的全称叫 Rabin-Karp 算法，是 BF 算法的升级版</p>\n<h4 id=\"RK-算法的思路\"><a href=\"#RK-算法的思路\" class=\"headerlink\" title=\"RK 算法的思路\"></a>RK 算法的思路</h4><p>通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p>\n<img src=\"/article/41181/%E4%B8%BB%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC.jpg\" class title=\"主串哈希值\">\n<h4 id=\"提高哈希算法计算子串哈希值的效率\"><a href=\"#提高哈希算法计算子串哈希值的效率\" class=\"headerlink\" title=\"提高哈希算法计算子串哈希值的效率\"></a><strong>提高哈希算法计算子串哈希值的效率</strong></h4><p>假设要匹配的字符串的字符集中只包含 K 个字符，可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p>\n<p>相邻两个子串 s[i-1]和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，<strong>可以使用 s[i-1]的哈希值很快的计算出 s[i]的哈希值。</strong></p>\n<img src=\"/article/41181/%E6%8F%90%E9%AB%98%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%AD%90%E4%B8%B2%E5%93%88%E5%B8%8C%E5%80%BC%E7%9A%84%E6%95%88%E7%8E%87.jpg\" class title=\"提高哈希算法计算子串哈希值的效率\">\n<p>26<sup>(m-1)</sup> 这部分的计算，我们可以通过查表的方法来提高效率。事先计算好 26<sup>0</sup>、26<sup>1</sup>、26<sup>2</sup>、26<sup>3</sup>……26<sup>(m-1)</sup> ，并且<strong>存储在一个长度为 m 的数组中</strong>，公式中的“次方”就对应数组的下标，需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。</p>\n<blockquote>\n<p><strong>问题：模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？</strong></p>\n<p>为了能将哈希值落在整型数据范围内，可以允许哈希冲突</p>\n</blockquote>\n<h4 id=\"RK-算法的时间复杂度\"><a href=\"#RK-算法的时间复杂度\" class=\"headerlink\" title=\"RK 算法的时间复杂度\"></a><strong>RK 算法的时间复杂度</strong></h4><p>整个 RK 算法包含两部分</p>\n<ol>\n<li><p>计算子串哈希值和模式串哈希值</p>\n<p>通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 <strong>O(n)</strong></p>\n</li>\n<li><p>子串哈希值之间的比较</p>\n<p>时间复杂度是 <strong>O(1)</strong>，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 <strong>O(n)</strong></p>\n</li>\n</ol>\n<p>RK 算法整体的时间复杂度就是 <strong>O(n)</strong></p>\n<p>最坏情况时间复杂度<strong>O(n*m)</strong></p>\n<h3 id=\"BF、RK算法实现\"><a href=\"#BF、RK算法实现\" class=\"headerlink\" title=\"BF、RK算法实现\"></a>BF、RK算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bF</span><span class=\"hljs-params\">(String a,String b)</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">int</span> m=a.length(),n=b.length(),k;<br>\t\t<span class=\"hljs-keyword\">char</span>[] a1=a.toCharArray();<br>\t\t<span class=\"hljs-keyword\">char</span>[] b1=b.toCharArray();<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=m-n;i++) &#123;<br>\t\t\tk=<span class=\"hljs-number\">0</span>;<br>\t\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(a1[i+j]==b1[j]) &#123;<br>\t\t\t\t\tk++;<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(k==n) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> i;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>\t&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">rK</span><span class=\"hljs-params\">(String a,String b)</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">int</span> m=a.length(),n=b.length(),s,j;<br>\t\t<span class=\"hljs-keyword\">int</span>[] hash=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[m-n+<span class=\"hljs-number\">1</span>];<br>\t\t<span class=\"hljs-keyword\">int</span>[] table=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">26</span>];<br>\t\t<span class=\"hljs-keyword\">char</span>[] a1=a.toCharArray();<br>\t\t<span class=\"hljs-keyword\">char</span>[] b1=b.toCharArray();<br>\t\ts=<span class=\"hljs-number\">1</span>;<br>\t\t<span class=\"hljs-comment\">//将26的次方存储在一个表里，取的时候直接用,虽然溢出，但没啥问题</span><br>\t\t<span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;<span class=\"hljs-number\">26</span>;j++) &#123;<br>\t\t\ttable[j]=s;<br>\t\t\ts*=<span class=\"hljs-number\">26</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=m-n;i++) &#123;<br>\t\t\ts=<span class=\"hljs-number\">0</span>;<br>\t\t\t<span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;n;j++) &#123;<br>\t\t\t\ts+=(a1[i+j]-<span class=\"hljs-string\">&#x27;a&#x27;</span>)*table[n-<span class=\"hljs-number\">1</span>-j];<br>\t\t\t&#125;<br>\t\t\thash[i]=s;<br>\t\t&#125;<br>\t\ts=<span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;n;j++) &#123;<br>\t\t\ts+=(b1[j]-<span class=\"hljs-string\">&#x27;a&#x27;</span>)*table[n-<span class=\"hljs-number\">1</span>-j];<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">for</span>(j=<span class=\"hljs-number\">0</span>;j&lt;m-n+<span class=\"hljs-number\">1</span>;j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(hash[j]==s) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> j;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"BM（Boyer-Moore）算法\"><a href=\"#BM（Boyer-Moore）算法\" class=\"headerlink\" title=\"BM（Boyer-Moore）算法\"></a>BM（Boyer-Moore）算法</h3><h4 id=\"BM-算法的核心思想\"><a href=\"#BM-算法的核心思想\" class=\"headerlink\" title=\"BM 算法的核心思想\"></a>BM 算法的核心思想</h4><p>BM 算法包含两部分，分别是<strong>坏字符规则（bad character rule）</strong>和<strong>好后缀规则（good suffix shift）</strong>。</p>\n<ol>\n<li><p>坏字符规则</p>\n<p><img src=\"/article/BM 算法的匹配顺序实例.jpg\"><span class=\"image-caption\">BM 算法的匹配顺序实例</span></p>\n<p>BM 算法的匹配顺序是<strong>按照模式串下标从大到小的顺序</strong></p>\n<p>从模式串的末尾往前倒着匹配，当发现某个字符没法匹配的时候，把这个没有匹配的字符叫作<strong>坏字符（主串中的字符）</strong>。</p>\n<blockquote>\n<ol>\n<li><p>坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p>\n<p><img src=\"/article/BM 算法的匹配顺序1.jpg\"><span class=\"image-caption\">BM 算法的匹配顺序1</span></p>\n</li>\n<li><p>模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，<strong>不能将模式串往后滑动三位</strong>。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。</p>\n<p><img src=\"/article/BM 算法的匹配顺序2.jpg\"><span class=\"image-caption\">BM 算法的匹配顺序2</span></p>\n</li>\n</ol>\n</blockquote>\n<p>当发生不匹配的时候，把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。</p>\n<p><img src=\"/article/BM 算法坏字符规律.jpg\"><span class=\"image-caption\">BM 算法坏字符规律</span></p>\n<p><strong>如果坏字符在模式串里多处出现，在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</strong></p>\n<p><strong>最好情况时间复杂度：</strong>O(n/m)</p>\n<p><strong>问题：</strong>根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。</p>\n</li>\n<li><p>好后缀规则</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E5%AE%9E%E4%BE%8B.jpg\" class title=\"好后缀规则实例\">\n<p><strong>把已经匹配的 bc 叫作好后缀</strong>，记作{u}</p>\n<blockquote>\n<ol>\n<li><p>拿 {u} 在模式串中查找，如果找到了另一个跟 {u} 相匹配的子串 {u*} ，就将模式串滑动到子串{u*}与主串中{u}对齐的位置。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F1.jpg\" class title=\"好后缀规则顺序1\">\n</li>\n<li><p>如果好后缀在模式串中不存在可匹配的子串，在一步一步往后滑动模式串的过程中，只要主串中的 {u} 与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中 {u} 的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F2.jpg\" class title=\"好后缀规则顺序2\">\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D.jpg\" class title=\"好后缀规则前缀后缀部分匹配\">\n<p>所以，针对这种情况，不仅要看好后缀在模式串中，是否有另一个匹配的子串，还要考察<strong>好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的</strong>。</p>\n<p><strong>从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是 {v} ，然后将模式串滑动到如图所示的位置。</strong></p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E8%A7%84%E5%88%99%E9%A1%BA%E5%BA%8F3.jpg\" class title=\"好后缀规则顺序3\">\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<p><strong>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数</strong></p>\n<h4 id=\"BM-算法代码实现\"><a href=\"#BM-算法代码实现\" class=\"headerlink\" title=\"BM 算法代码实现\"></a>BM 算法代码实现</h4><blockquote>\n<p><strong>如何查找坏字符在模式串中出现的位置?</strong></p>\n<p>可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。</p>\n<p>假设字符串的字符集不是很大，每个字符长度是 1 字节，用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。</p>\n<img src=\"/article/41181/%E6%9F%A5%E6%89%BE%E5%9D%8F%E5%AD%97%E7%AC%A6%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg\" class title=\"查找坏字符在模式串中出现的位置\">\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> SIZE = <span class=\"hljs-number\">256</span>; <span class=\"hljs-comment\">// 全局变量或成员变量</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">generateBC</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] b, <span class=\"hljs-keyword\">int</span> m, <span class=\"hljs-keyword\">int</span>[] bc)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; SIZE; ++i) &#123;<br>    bc[i] = -<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 初始化bc</span><br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; ++i) &#123;<br>    <span class=\"hljs-keyword\">int</span> ascii = (<span class=\"hljs-keyword\">int</span>)b[i]; <span class=\"hljs-comment\">// 计算b[i]的ASCII值</span><br>    bc[ascii] = i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>变量 b 是模式串，m 是模式串的长度，bc 表示散列表</p>\n</blockquote>\n<blockquote>\n<p><strong>不考虑好后缀规则，仅用坏字符规则，并且不考虑 si-xi 计算得到的移动位数可能会出现负数的情况</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bm</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] a, <span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">char</span>[] b, <span class=\"hljs-keyword\">int</span> m)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span>[] bc = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[SIZE]; <span class=\"hljs-comment\">// 记录模式串中每个字符最后出现的位置</span><br>  generateBC(b, m, bc); <span class=\"hljs-comment\">// 构建坏字符哈希表</span><br>  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// i表示主串与模式串对齐的第一个字符</span><br>  <span class=\"hljs-keyword\">while</span> (i &lt;= n - m) &#123;<br>    <span class=\"hljs-keyword\">int</span> j;<br>    <span class=\"hljs-keyword\">for</span> (j = m - <span class=\"hljs-number\">1</span>; j &gt;= <span class=\"hljs-number\">0</span>; --j) &#123; <span class=\"hljs-comment\">// 模式串从后往前匹配</span><br>      <span class=\"hljs-keyword\">if</span> (a[i+j] != b[j]) <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// 坏字符对应模式串中的下标是j</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (j &lt; <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> i; <span class=\"hljs-comment\">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br>    &#125;<br>    <span class=\"hljs-comment\">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span><br>    i = i + (j - bc[(<span class=\"hljs-keyword\">int</span>)a[i+j]]); <br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/41181/%E6%9F%A5%E6%89%BE%E5%9D%8F%E5%AD%97%E7%AC%A6%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%B9%B6%E7%A7%BB%E5%8A%A8.jpg\" class title=\"查找坏字符在模式串中出现的位置并移动\">\n</blockquote>\n<blockquote>\n<p><strong>好后缀规则</strong></p>\n<ol>\n<li>在模式串中，查找跟好后缀匹配的另一个子串；</li>\n<li>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</li>\n</ol>\n<p><strong>在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置</strong></p>\n<ol>\n<li><p>表示模式串中不同的后缀子串</p>\n<p>后缀子串的最后一个字符的位置是固定的，下标为 m-1，只需要记录长度就可以了。通过长度，可以确定一个唯一的后缀子串。</p>\n<img src=\"/article/41181/%E8%A1%A8%E7%A4%BA%E6%A8%A1%E5%BC%8F%E4%B8%B2%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84%E5%90%8E%E7%BC%80%E5%AD%90%E4%B8%B2.jpg\" class title=\"表示模式串中不同的后缀子串\">\n</li>\n<li><p><strong>引入关键变量 suffix 数组</strong></p>\n<p>suffix 数组的下标 k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀{u}相匹配的子串{u*}的起始下标值</p>\n<p><img src=\"/article/suffix 数组.jpg\"><span class=\"image-caption\">suffix 数组</span></p>\n</li>\n<li><p><strong>引入 boolean 类型的 prefix 数组</strong></p>\n<p>记录模式串的后缀子串是否能匹配模式串的前缀子串</p>\n<p><img src=\"/article/prefix 数组.jpg\"><span class=\"image-caption\">prefix 数组</span></p>\n</li>\n</ol>\n<p>拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 k，那我们就记录 suffix[k]=j（j 表示公共后缀子串的起始下标）。如果 j 等于 0，也就是说，公共后缀子串也是模式串的前缀子串，我们就记录 prefix[k]=true。</p>\n<p><img src=\"/article/suffix 数组、prefix 数组计算.jpg\"><span class=\"image-caption\">suffix 数组、prefix 数组计算</span></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">generateGS</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] b, <span class=\"hljs-keyword\">int</span> m, <span class=\"hljs-keyword\">int</span>[] suffix, <span class=\"hljs-keyword\">boolean</span>[] prefix)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m; ++i) &#123; <span class=\"hljs-comment\">// 初始化</span><br>    suffix[i] = -<span class=\"hljs-number\">1</span>;<br>    prefix[i] = <span class=\"hljs-keyword\">false</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; m - <span class=\"hljs-number\">1</span>; ++i) &#123; <span class=\"hljs-comment\">// b[0, i]</span><br>    <span class=\"hljs-keyword\">int</span> j = i;<br>    <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 公共后缀子串长度</span><br>    <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; b[j] == b[m-<span class=\"hljs-number\">1</span>-k]) &#123; <span class=\"hljs-comment\">// 与b[0, m-1]求公共后缀子串</span><br>      --j;<br>      ++k;<br>      suffix[k] = j+<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//j+1表示公共后缀子串在b[0, i]中的起始下标</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (j == -<span class=\"hljs-number\">1</span>) prefix[k] = <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">//如果公共后缀子串也是模式串的前缀子串</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</strong></p>\n<ol>\n<li><p>假设好后缀的长度是 k。先拿好后缀，在 suffix 数组中查找其匹配的子串。如果 suffix[k]不等于 -1（-1 表示不存在匹配的子串），那我们就将模式串往后移动 j-suffix[k]+1 位（j 表示坏字符对应的模式串中的字符下标）。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D1.jpg\" class title=\"好后缀匹配1\">\n</li>\n<li><p>如果 suffix[k]等于 -1，表示模式串中不存在另一个跟好后缀匹配的子串片段</p>\n<p>好后缀的后缀子串 b[r, m-1]（其中，r 取值从 j+2 到 m-1）的长度 k=m-r，如果 prefix[k]等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样我们可以把模式串后移 r 位。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D1.jpg\" class title=\"好后缀匹配1\">\n</li>\n<li><p>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，就将整个模式串后移 m 位。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D3.jpg\" class title=\"好后缀匹配3\">\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// a,b表示主串和模式串；n，m表示主串和模式串的长度。</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">bm</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] a, <span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">char</span>[] b, <span class=\"hljs-keyword\">int</span> m)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span>[] bc = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[SIZE]; <span class=\"hljs-comment\">// 记录模式串中每个字符最后出现的位置</span><br>  generateBC(b, m, bc); <span class=\"hljs-comment\">// 构建坏字符哈希表</span><br>  <span class=\"hljs-keyword\">int</span>[] suffix = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[m];<br>  <span class=\"hljs-keyword\">boolean</span>[] prefix = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">boolean</span>[m];<br>  generateGS(b, m, suffix, prefix);<br>  <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// j表示主串与模式串匹配的第一个字符</span><br>  <span class=\"hljs-keyword\">while</span> (i &lt;= n - m) &#123;<br>    <span class=\"hljs-keyword\">int</span> j;<br>    <span class=\"hljs-keyword\">for</span> (j = m - <span class=\"hljs-number\">1</span>; j &gt;= <span class=\"hljs-number\">0</span>; --j) &#123; <span class=\"hljs-comment\">// 模式串从后往前匹配</span><br>      <span class=\"hljs-keyword\">if</span> (a[i+j] != b[j]) <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// 坏字符对应模式串中的下标是j</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (j &lt; <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> i; <span class=\"hljs-comment\">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> x = j - bc[(<span class=\"hljs-keyword\">int</span>)a[i+j]];<br>    <span class=\"hljs-keyword\">int</span> y = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">if</span> (j &lt; m-<span class=\"hljs-number\">1</span>) &#123; <span class=\"hljs-comment\">// 如果有好后缀的话</span><br>      y = moveByGS(j, m, suffix, prefix);<br>    &#125;<br>    i = i + Math.max(x, y);<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">moveByGS</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> j, <span class=\"hljs-keyword\">int</span> m, <span class=\"hljs-keyword\">int</span>[] suffix, <span class=\"hljs-keyword\">boolean</span>[] prefix)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span> k = m - <span class=\"hljs-number\">1</span> - j; <span class=\"hljs-comment\">// 好后缀长度</span><br>  <span class=\"hljs-keyword\">if</span> (suffix[k] != -<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> j - suffix[k] +<span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> r = j+<span class=\"hljs-number\">2</span>; r &lt;= m-<span class=\"hljs-number\">1</span>; ++r) &#123;<br>    <span class=\"hljs-keyword\">if</span> (prefix[m-r] == <span class=\"hljs-keyword\">true</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> r;<br>    &#125;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> m;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"></a>KMP 算法</h2><h3 id=\"KMP-算法基本原理\"><a href=\"#KMP-算法基本原理\" class=\"headerlink\" title=\"KMP 算法基本原理\"></a>KMP 算法基本原理</h3><p>在模式串和主串匹配的过程中，把不能匹配的那个字符叫作坏字符，把已经匹配的那段字符串叫作好前缀。</p>\n<img src=\"/article/41181/%E5%A5%BD%E5%89%8D%E7%BC%80%E4%B8%8E%E5%9D%8F%E5%AD%97%E7%AC%A6.jpg\" class title=\"好前缀与坏字符\">\n<p>当遇到坏字符的时候，把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。</p>\n<img src=\"/article/41181/%E5%AD%97%E4%B8%B2%E5%AF%B9%E6%AF%94.jpg\" class title=\"字串对比\">\n<p>只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。</p>\n<img src=\"/article/41181/%E5%AD%97%E4%B8%B2%E5%8C%B9%E9%85%8D.jpg\" class title=\"字串匹配\">\n<p>好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫作<strong>最长可匹配前缀子串</strong>。</p>\n<img src=\"/article/41181/%E6%9C%80%E9%95%BF%E5%8F%AF%E5%8C%B9%E9%85%8D%E5%AD%90%E4%B8%B2.jpg\" class title=\"最长可匹配子串\">\n<h3 id=\"next-数组\"><a href=\"#next-数组\" class=\"headerlink\" title=\"next 数组\"></a>next 数组</h3><p>KMP 算法可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。把这个数组定义为 <strong>next 数组</strong>，也叫失效函数（failure function）。</p>\n<p>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。</p>\n<p>匹配发生冲突时，查看坏字符前一位的next数组下标</p>\n<table>\n<thead>\n<tr>\n<th>模式串</th>\n<th>a</th>\n<th>a</th>\n<th>b</th>\n<th>a</th>\n<th>a</th>\n<th>f</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>前缀表（next数组）</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>2</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p><strong>next 数组算法实现</strong></p>\n<ol>\n<li>初始化</li>\n<li>前后缀不相同情况</li>\n<li>前后缀相同情况</li>\n<li>next数组</li>\n</ol>\n<p>i 表示 后缀末尾位置</p>\n<p>j 表示 前缀末尾位置、i之前包括i的字串的的最长相等前后缀的长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getNext</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] next, <span class=\"hljs-keyword\">char</span>[] s)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;<br>  next[] = <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; s.size ; i++)&#123;<br>    <span class=\"hljs-keyword\">while</span>(j &gt; <span class=\"hljs-number\">0</span> &amp;&amp; s[i] != s[j])&#123;<br>      j = next[ j - <span class=\"hljs-number\">1</span> ];<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(s[i] == s[j])&#123;<br>      j++;<br>      next[i] = j;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"KMP-算法复杂度分析\"><a href=\"#KMP-算法复杂度分析\" class=\"headerlink\" title=\"KMP 算法复杂度分析\"></a>KMP 算法复杂度分析</h3><p>KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以<strong>空间复杂度是 O(m)</strong>，m 表示模式串的长度。</p>\n<p>KMP 算法的时间复杂度就是 O(m+n)</p>\n<h3 id=\"KMP算法算法实现\"><a href=\"#KMP算法算法实现\" class=\"headerlink\" title=\"KMP算法算法实现\"></a>KMP算法算法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br></code></pre></td></tr></table></figure>\n<h2 id=\"Trie树\"><a href=\"#Trie树\" class=\"headerlink\" title=\"Trie树\"></a>Trie树</h2><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种<strong>专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</strong></p>\n<blockquote>\n<p>有 6 个字符串，它们分别是：how，hi，her，hello，so，see。希望在里面多次查找某个字符串是否存在。</p>\n<p>对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。</p>\n</blockquote>\n<p><strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</strong></p>\n<blockquote>\n<img src=\"/article/41181/Trie%E6%A0%91%E5%AE%9E%E4%BE%8B.jpg\" class title=\"Trie树实例\">\n</blockquote>\n<p>根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p>\n<blockquote>\n<p>Trie 树构造的分解过程</p>\n<p><img src=\"/article/Trie 树构造的分解过程1.jpg\"><span class=\"image-caption\">img</span></p>\n<p><img src=\"/article/Trie 树构造的分解过程2.jpg\"><span class=\"image-caption\">Trie 树构造的分解过程</span></p>\n</blockquote>\n<h3 id=\"如何实现一棵-Trie-树？\"><a href=\"#如何实现一棵-Trie-树？\" class=\"headerlink\" title=\"如何实现一棵 Trie 树？\"></a>如何实现一棵 Trie 树？</h3><p>Trie 树主要有两个操作</p>\n<ol>\n<li>一个是将字符串集合构造成 Trie 树。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。</li>\n<li>另一个是在 Trie 树中查询一个字符串。</li>\n</ol>\n<p>借助散列表的思想，通过一个下标与字符一一映射的数组，来存储子节点的指针</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrieNode</span> </span>&#123;<br>  <span class=\"hljs-keyword\">char</span> data;<br>  TrieNode children[<span class=\"hljs-number\">26</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/41181/%E5%80%9F%E5%8A%A9%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0Trie%E6%A0%91.jpg\" class title=\"借助散列表实现Trie树\">\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Trie</span> </span>&#123;<br>  <span class=\"hljs-keyword\">private</span> TrieNode root = <span class=\"hljs-keyword\">new</span> TrieNode(<span class=\"hljs-string\">&#x27;/&#x27;</span>); <span class=\"hljs-comment\">// 存储无意义字符</span><br><br>  <span class=\"hljs-comment\">// 往Trie树中插入一个字符串</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] text)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; text.length; ++i) &#123;<br>      <span class=\"hljs-keyword\">int</span> index = text[i] - <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>      <span class=\"hljs-keyword\">if</span> (p.children[index] == <span class=\"hljs-keyword\">null</span>) &#123;<br>        TrieNode newNode = <span class=\"hljs-keyword\">new</span> TrieNode(text[i]);<br>        p.children[index] = newNode;<br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    p.isEndingChar = <span class=\"hljs-keyword\">true</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// 在Trie树中查找一个字符串</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] pattern)</span> </span>&#123;<br>    TrieNode p = root;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; pattern.length; ++i) &#123;<br>      <span class=\"hljs-keyword\">int</span> index = pattern[i] - <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>      <span class=\"hljs-keyword\">if</span> (p.children[index] == <span class=\"hljs-keyword\">null</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>; <span class=\"hljs-comment\">// 不存在pattern</span><br>      &#125;<br>      p = p.children[index];<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (p.isEndingChar == <span class=\"hljs-keyword\">false</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>; <span class=\"hljs-comment\">// 不能完全匹配，只是前缀</span><br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">// 找到pattern</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrieNode</span> </span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">char</span> data;<br>    <span class=\"hljs-keyword\">public</span> TrieNode[] children = <span class=\"hljs-keyword\">new</span> TrieNode[<span class=\"hljs-number\">26</span>];<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> isEndingChar = <span class=\"hljs-keyword\">false</span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">TrieNode</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span> data)</span> </span>&#123;<br>      <span class=\"hljs-keyword\">this</span>.data = data;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析\"><a href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"></a>复杂度分析</h3><ol>\n<li><p>时间复杂度</p>\n<p>构建 Trie 树的过程，需要扫描所有的字符串，<strong>时间复杂度是 O(n)</strong>（n 表示所有字符串的长度和）</p>\n<p>每次查询时，如果要查询的字符串长度是 k，只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的<strong>时间复杂度是 O(k)</strong>，k 表示要查找的字符串的长度。</p>\n</li>\n<li><p>空间复杂度</p>\n<p>用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组元素要存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p>\n<p><strong>在某些情况下，Trie 树不一定会节省存储空间。在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存。</strong></p>\n</li>\n</ol>\n<h3 id=\"Trie-树与散列表、红黑树\"><a href=\"#Trie-树与散列表、红黑树\" class=\"headerlink\" title=\"Trie 树与散列表、红黑树\"></a>Trie 树与散列表、红黑树</h3><p>Trie 树对要处理的字符串有极其严苛的要求</p>\n<ol>\n<li>第一，字符串中包含的字符集不能太大。即便可以优化，但也要付出牺牲查询、插入效率的代价。</li>\n<li>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</li>\n<li>第三，如果要用 Trie 树解决问题，那就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</li>\n<li>第四，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</li>\n</ol>\n<p>针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树</p>\n<h2 id=\"AC-自动机-Trie-树优化\"><a href=\"#AC-自动机-Trie-树优化\" class=\"headerlink\" title=\"AC 自动机(Trie 树优化)\"></a>AC 自动机(Trie 树优化)</h2><p><strong>基于单模式串和 Trie 树实现的敏感词过滤</strong></p>\n<p>多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。</p>\n<p>只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。</p>\n<p><strong>Trie 树就是一种多模式串匹配算法</strong></p>\n<p>可以对敏感词字典进行预处理，构建成 Trie 树结构。这个预处理的操作只需要做一次，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，只需要动态更新一下 Trie 树就可以了。</p>\n<p>当用户输入一个文本内容后，把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p>\n<h3 id=\"经典的多模式串匹配算法：AC-自动机\"><a href=\"#经典的多模式串匹配算法：AC-自动机\" class=\"headerlink\" title=\"经典的多模式串匹配算法：AC 自动机\"></a>经典的多模式串匹配算法：AC 自动机</h3><p>AC 自动机算法，全称是 Aho-Corasick 算法。</p>\n<p>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AcNode</span> </span>&#123;<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">char</span> data; <br>  <span class=\"hljs-keyword\">public</span> AcNode[] children = <span class=\"hljs-keyword\">new</span> AcNode[<span class=\"hljs-number\">26</span>]; <span class=\"hljs-comment\">// 字符集只包含a~z这26个字符</span><br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> isEndingChar = <span class=\"hljs-keyword\">false</span>; <span class=\"hljs-comment\">// 结尾字符为true</span><br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> length = -<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 当isEndingChar=true时，记录模式串长度</span><br>  <span class=\"hljs-keyword\">public</span> AcNode fail; <span class=\"hljs-comment\">// 失败指针</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AcNode</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span> data)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.data = data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>AC 自动机的构建，包含两个操作：</p>\n<ol>\n<li>将多个模式串构建成 Trie 树；</li>\n<li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。</li>\n</ol>\n<h3 id=\"构建失败指针\"><a href=\"#构建失败指针\" class=\"headerlink\" title=\"构建失败指针\"></a><strong>构建失败指针</strong></h3><p>Trie 树中的每一个节点都有一个失败指针</p>\n<blockquote>\n<p>有 4 个模式串，分别是 c，bc，bcd，abcd；主串是 abcd。</p>\n</blockquote>\n<img src=\"/article/41181/%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg\" class title=\"构建失败指针\">\n<p>假设沿 Trie 树走到 p 节点，也就是下图中的紫色节点，那 p 的失败指针就是从 root 走到紫色节点形成的字符串 abc，跟所有模式串前缀匹配的最长可匹配后缀子串，就是箭头指的 bc 模式串。</p>\n<blockquote>\n<p>字符串 abc 的后缀子串有两个 bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，那我们就把这个后缀子串叫作可匹配后缀子串。</p>\n</blockquote>\n<p>从可匹配后缀子串中，找出最长的一个。将 p 节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是图中紫色箭头指向的节点。</p>\n<p><strong>如果把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。</strong></p>\n<p><strong>失败指针的构建过程，是一个按层遍历树的过程</strong></p>\n<p>首先 root 的失败指针为 NULL，也就是指向自己。</p>\n<p>假设节点 p 的失败指针指向节点 q，看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc。</p>\n<img src=\"/article/41181/%E5%AF%BB%E6%89%BE%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg\" class title=\"寻找子节点的失败指针\">\n<p>如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 q=q-&gt;fail（fail 表示失败指针），继续上面的查找，直到 q 是 root 为止，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//构建失败指针</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buildFailurePointer</span><span class=\"hljs-params\">()</span> </span>&#123;<br>  Queue&lt;AcNode&gt; queue = <span class=\"hljs-keyword\">new</span> LinkedList&lt;&gt;();<br>  root.fail = <span class=\"hljs-keyword\">null</span>;<br>  queue.add(root);<br>  <span class=\"hljs-keyword\">while</span> (!queue.isEmpty()) &#123;<br>    AcNode p = queue.remove();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">26</span>; ++i) &#123;<br>      AcNode pc = p.children[i];<br>      <span class=\"hljs-keyword\">if</span> (pc == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">continue</span>;<br>      <span class=\"hljs-keyword\">if</span> (p == root) &#123;<br>        pc.fail = root;<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        AcNode q = p.fail;<br>        <span class=\"hljs-keyword\">while</span> (q != <span class=\"hljs-keyword\">null</span>) &#123;<br>          AcNode qc = q.children[pc.data - <span class=\"hljs-string\">&#x27;a&#x27;</span>];<br>          <span class=\"hljs-keyword\">if</span> (qc != <span class=\"hljs-keyword\">null</span>) &#123;<br>            pc.fail = qc;<br>            <span class=\"hljs-keyword\">break</span>;<br>          &#125;<br>          q = q.fail;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (q == <span class=\"hljs-keyword\">null</span>) &#123;<br>          pc.fail = root;<br>        &#125;<br>      &#125;<br>      queue.add(pc);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article/41181/%E5%A4%B1%E8%B4%A5%E6%8C%87%E9%92%88.jpg\" class title=\"失败指针\">\n<h3 id=\"在-AC-自动机上匹配主串\"><a href=\"#在-AC-自动机上匹配主串\" class=\"headerlink\" title=\"在 AC 自动机上匹配主串\"></a>在 AC 自动机上匹配主串</h3><p>在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是 b，主串是 a。</p>\n<ol>\n<li>如果 p 指向的节点有一个等于 a[i]的子节点 x，我们就更新 p 指向 x，这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。处理完之后，我们将 i 加一，继续这两个过程；</li>\n<li>如果 p 指向的节点没有等于 a[i]的子节点，那失败指针就派上用场了，我们让 <code>p=p-&gt;fail</code>，然后继续这 2 个过程。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">match</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] text)</span> </span>&#123; <span class=\"hljs-comment\">// text是主串</span><br>  <span class=\"hljs-keyword\">int</span> n = text.length;<br>  AcNode p = root;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>    <span class=\"hljs-keyword\">int</span> idx = text[i] - <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>    <span class=\"hljs-keyword\">while</span> (p.children[idx] == <span class=\"hljs-keyword\">null</span> &amp;&amp; p != root) &#123;<br>      p = p.fail; <span class=\"hljs-comment\">// 失败指针发挥作用的地方</span><br>    &#125;<br>    p = p.children[idx];<br>    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span>) p = root; <span class=\"hljs-comment\">// 如果没有匹配的，从root开始重新匹配</span><br>    AcNode tmp = p;<br>    <span class=\"hljs-keyword\">while</span> (tmp != root) &#123; <span class=\"hljs-comment\">// 打印出可以匹配的模式串</span><br>      <span class=\"hljs-keyword\">if</span> (tmp.isEndingChar == <span class=\"hljs-keyword\">true</span>) &#123;<br>        <span class=\"hljs-keyword\">int</span> pos = i-tmp.length+<span class=\"hljs-number\">1</span>;<br>        System.out.println(<span class=\"hljs-string\">&quot;匹配起始下标&quot;</span> + pos + <span class=\"hljs-string\">&quot;; 长度&quot;</span> + tmp.length);<br>      &#125;<br>      tmp = tmp.fail;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>Trie 树构建的<strong>时间复杂度是 O(m*len)</strong>，其中 len 表示敏感词的平均长度，m 表示敏感词的个数。</p>\n<p>整个失败指针的构建过程<strong>时间复杂度是 O(k*len)</strong>， k 是 Trie 树中总的节点个数，每个节点构建失败指针的时候，最耗时的环节是 while 循环中的 q=q-&gt;fail，每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len，所以每个节点构建失败指针的时间复杂度是 O(len)。</p>\n<p>用 AC 自动机做匹配的时间复杂度，for 循环依次遍历主串中的每个字符，for 循环内部最耗时的部分也是 while 循环，而这一部分的时间复杂度也是 O(len)，所以总的匹配的时间复杂度就是 O(n*len)。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，<strong>可能近似于 O(n)</strong>，所以 AC 自动机做敏感词过滤，性能非常高。</p>\n","categories":[{"name":"数据结构与算法","path":"api/categories/数据结构与算法.json"},{"name":"字符串匹配","path":"api/categories/字符串匹配.json"}],"tags":[{"name":"数据结构与算法,字符串匹配","path":"api/tags/数据结构与算法,字符串匹配.json"}]}