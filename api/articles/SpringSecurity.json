{"title":"SpringSecurity","slug":"SpringSecurity","date":"2022-04-04T01:18:58.000Z","updated":"2022-09-06T11:05:31.618Z","comments":true,"path":"api/articles/SpringSecurity.json","realPath":null,"excerpt":null,"covers":["/article/52913/SpringSecurity%E5%85%A5%E9%97%A8.png","/article/52913/%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%B5%81%E7%A8%8B.png","/article/52913/%E6%B5%81%E7%A8%8B%E5%9B%BE-9039561.png","/article/52913/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.png","/article/52913/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-9040230.png","/article/52913/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81.png","/article/52913/%E5%BE%AE%E4%BF%A1%E8%AE%A4%E8%AF%81%E4%B8%BE%E4%BE%8B.png","/article/52913/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png","/article/52913/SpringSecurityOAuth2.png","/article/52913/SpringSecurityOAuth2%E6%9E%B6%E6%9E%84.png"],"cover":"/article/52913/SpringSecurity%E5%85%A5%E9%97%A8.png","content":"<p>学习源于<a href=\"https://www.bilibili.com/video/BV1mm4y1X7Hc?p=8&amp;spm_id_from=pageDriver\">三更草堂</a></p>\n<h2 id=\"SpringSecurity\"><a href=\"#SpringSecurity\" class=\"headerlink\" title=\"SpringSecurity\"></a>SpringSecurity</h2><p>Spring Security是一个<strong>功能强大且高度可定制的身份验证和访问控制框架</strong>。这是保护基于Spring的应用程序的事实上的标准。</p>\n<p>SpringSecurity 提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC、DI、AOP功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p>\n<p>Spring Security是一个专注于为Java应用程序提供身份验证和授权的框架。像所有Spring项目一样，Spring Security的真正力量在于它有多容易被扩展以满足自定义要求。</p>\n<p><strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p>\n<p><strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p><code>pom.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.projectlombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>lombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">optional</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">optional</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>基础项目</strong></p>\n<p><code>SecurityApplication.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.boyolo;<br><span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;<br><span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SecurityApplication</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(SecurityApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>HelloController.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.boyolo.controller;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>&#123;<br>  <span class=\"hljs-meta\">@RequestMapping(&quot;/hello&quot;)</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">helloController</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>测试</strong></p>\n<p>访问 <code>http://localhost:8080/hello</code></p>\n<p>跳转页面</p>\n<img src=\"/article/52913/SpringSecurity%E5%85%A5%E9%97%A8.png\" class title=\"image-20220404100727005\">\n<p>默认用户名：user</p>\n<p>默认密码：后台运行复制</p>\n<h2 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h2><img src=\"/article/52913/%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%B5%81%E7%A8%8B.png\" class title=\"登录校验流程\">\n<h3 id=\"SpringSecurity完整流程\"><a href=\"#SpringSecurity完整流程\" class=\"headerlink\" title=\"SpringSecurity完整流程\"></a>SpringSecurity完整流程</h3><p>SpringSecurity其实就是一个过滤器链，内部包含了各种功能的过滤器。</p>\n<p><strong>基础流程图</strong></p>\n<img src=\"/article/52913/%E6%B5%81%E7%A8%8B%E5%9B%BE-9039561.png\" class title=\"流程图\">\n<p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。</p>\n<p><strong>ExceptionTranslationFilter：</strong> 处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>\n<p><strong>FilterSecurityInterceptor：</strong> 负责权限校验的过滤器。</p>\n<p>SpringSecurity过滤器链中有哪些过滤器及它们的顺序：</p>\n<img src=\"/article/52913/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.png\" class title=\"SpringSecurity过滤器链\">\n<h3 id=\"认证流程详解\"><a href=\"#认证流程详解\" class=\"headerlink\" title=\"认证流程详解\"></a>认证流程详解</h3><img src=\"/article/52913/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-9040230.png\" class title=\"认证流程详解\">\n<p><strong>Authentication接口</strong>: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>\n<p><strong>AuthenticationManager接口</strong>：定义了认证Authentication的方法，在 Spring Security 中，用来处理身份认证的类是 AuthenticationManager，我们也称之为认证管理器。</p>\n<p><strong>UserDetailsService接口</strong>：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>\n<p><strong>UserDetails接口（继承了 Serializable 序列化）</strong>：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>\n<ol>\n<li><p>自定义登录验证</p>\n<img src=\"/article/52913/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81.png\" class title=\"自定义登录验证\">\n<ol>\n<li><p>自定义登录接口</p>\n<p>调用ProviderManager的方法进行认证 如果认证通过生成jwt</p>\n<p>使用userId作为Key，用户信息作为Value，把用户信息存入redis中</p>\n</li>\n<li><p>自定义UserDetailsService</p>\n<p>在这个实现类中去查询数据库</p>\n</li>\n</ol>\n</li>\n<li><p>校验</p>\n<p>定义Jwt认证过滤器，获取token，解析token获取其中的userid，从redis中获取用户信息，存入SecurityContextHolder</p>\n</li>\n</ol>\n<h2 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a>授权</h2><h3 id=\"授权基本流程\"><a href=\"#授权基本流程\" class=\"headerlink\" title=\"授权基本流程\"></a>授权基本流程</h3><p>在 SpringSecurity 中，会使用默认的 FilterSecurityInterceptor 来进行权限校验。在 FilterSecurityInterceptor 中会从 SecurityContextHolder 获取其中的 Authentication ，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>\n<p>所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</p>\n<p>然后设置我们的资源所需要的权限即可。</p>\n<h3 id=\"授权实现\"><a href=\"#授权实现\" class=\"headerlink\" title=\"授权实现\"></a>授权实现</h3><p><strong>限制访问资源所需权限</strong></p>\n<p>可以使用注解去指定访问对应的资源所需的权限</p>\n<ol>\n<li><p>需要先开启相关配置 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableGlobalMethodSecurity(prePostEnabled = true)</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>在方法中使用注解配置权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@PreAuthorize(&quot;hasAuthority(&#x27;权限&#x27;)&quot;)</span><br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>封装权限信息</strong></p>\n<h2 id=\"自定义失败处理\"><a href=\"#自定义失败处理\" class=\"headerlink\" title=\"自定义失败处理\"></a>自定义失败处理</h2><p>希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。</p>\n<p>在 SpringSecurity 中，如果我们在认证或者授权的过程中出现了异常会被 ExceptionTranslationFilter 捕获到。在 ExceptionTranslationFilter 中会去判断是认证失败还是授权失败出现的异常。</p>\n<p>如果是认证过程中出现的异常会被封装成 AuthenticationException 然后调用 <strong>AuthenticationEntryPoint</strong>  对象的方法去进行异常处理。</p>\n<p>如果是授权过程中出现的异常会被封装成 AccessDeniedException 然后调用 <strong>AccessDeniedHandler</strong> 对象的方法去进行异常处理。</p>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><p>浏览器出于安全的考虑，使用 XMLHttpRequest 对象发起 HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。</p>\n<ol>\n<li><p>先对SpringBoot配置，运行跨域请求</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Configuration</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CorsConfig</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebMvcConfigurer</span> </span>&#123;<br>  <span class=\"hljs-meta\">@Override</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addCorsMappings</span><span class=\"hljs-params\">(CorsRegistry registry)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 设置允许跨域的路径</span><br>    registry.addMapping(<span class=\"hljs-string\">&quot;/**&quot;</span>)<br>      <span class=\"hljs-comment\">// 设置允许跨域请求的域名</span><br>      .allowedOriginPatterns(<span class=\"hljs-string\">&quot;*&quot;</span>)<br>      <span class=\"hljs-comment\">// 是否允许cookie</span><br>      .allowCredentials(<span class=\"hljs-keyword\">true</span>)<br>      <span class=\"hljs-comment\">// 设置允许的请求方式</span><br>      .allowedMethods(<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;POST&quot;</span>, <span class=\"hljs-string\">&quot;DELETE&quot;</span>, <span class=\"hljs-string\">&quot;PUT&quot;</span>)<br>      <span class=\"hljs-comment\">// 设置允许的header属性</span><br>      .allowedHeaders(<span class=\"hljs-string\">&quot;*&quot;</span>)<br>      <span class=\"hljs-comment\">// 跨域允许时间</span><br>      .maxAge(<span class=\"hljs-number\">3600</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>开启 SpringSecurity 的跨域访问</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">(HttpSecurity http)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;<br>  <span class=\"hljs-comment\">//允许跨域</span><br>  http.cors();<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3><p>CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。</p>\n<p>SpringSecurit 去防止 CSRF 攻击的方式就是通过 csrf_token 。后端会生成一个 csrf_token ，前端发起请求的时候需要携带这个 csrf_token ,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。</p>\n<p>CSRF 攻击依靠的是 cookie 中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是 token ，而 token 并不是存储中 cookie 中，并且需要前端代码去把token 设置到请求头中才可以，所以CSRF攻击也就不用担心了。</p>\n<hr>\n<h2 id=\"项目过程\"><a href=\"#项目过程\" class=\"headerlink\" title=\"项目过程\"></a><strong>项目过程</strong></h2><p><strong>前端输入用户密码传入后端，后端判断用户名密码是否正确，如果正确，会生成一个JWT令牌，返回给前端，如果不正确重新输入用户名密码。</strong></p>\n<p><strong>前端拿到JWT令牌之后，会放在请求头中，之后每一次请求都会携带JWT令牌，后端 JWT令牌拦截器，每次有请求进入后端，先判断JWT令牌 是否存在以及令牌是否正确合法有效，如果不存在或者JWT令牌不合法有效，拦截请求，如果JWT令牌合法有效，允许请求访问。</strong></p>\n<blockquote>\n<p><strong>引入依赖</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">&lt;!--security 依赖--&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--JWT 依赖--&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;<br>  &lt;artifactId&gt;jjwt&lt;/artifactId&gt;<br>  &lt;version&gt;<span class=\"hljs-number\">0.9</span><span class=\"hljs-number\">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>\n<p><strong>JWT配置</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">jwt:</span><br>  <span class=\"hljs-comment\"># JWT存储的请求头</span><br>  <span class=\"hljs-attr\">tokenHeader:</span> <span class=\"hljs-string\">Authorization</span><br>  <span class=\"hljs-comment\"># JWT 加解密使用的密钥</span><br>  <span class=\"hljs-attr\">secret:</span> <span class=\"hljs-string\">yeb-secret</span><br>  <span class=\"hljs-comment\"># JWT的超期限时间（60*60*24）</span><br>  <span class=\"hljs-attr\">expiration:</span> <span class=\"hljs-number\">604800</span><br>  <span class=\"hljs-comment\"># JWT 负载中拿到开头</span><br>  <span class=\"hljs-attr\">tokenHead:</span> <span class=\"hljs-string\">Bearer</span><br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><strong>编写JwtToken工具类</strong></p>\n<ol>\n<li><p>根据用户信息生成Token</p>\n<ol>\n<li>generateToken(UserDetails userDetails)</li>\n<li>generateToken(Map&lt;String,Object&gt; claims)</li>\n<li>generateExpirationDate()</li>\n</ol>\n</li>\n<li><p>从Token中获取信息</p>\n<ol>\n<li><p>从Token中获取登录用户名</p>\n<p>public String getUserNameFromToken(String token)</p>\n</li>\n<li><p>从Token中获取荷载</p>\n<p>private Claims getClaimsFromToken(String token)</p>\n</li>\n</ol>\n</li>\n<li><p>判断Token是否有效</p>\n<ol>\n<li><p>判断 Token中的用户名和 用户信息中的用户名是否一致 并且 是否失效</p>\n<p>public boolean validateToken(String token , UserDetails userDetails)</p>\n</li>\n<li><p>判断 Token 是否失效</p>\n<p>private boolean isTokenExpired(String token)</p>\n</li>\n<li><p>获取 Token 失效时间</p>\n<p>private Date getExpiredDateFromToken(String token)</p>\n</li>\n</ol>\n</li>\n<li><p>判断 Token 是否可以被刷新</p>\n<p>public boolean canRefreshToken(String token)</p>\n</li>\n<li><p>刷新 Token</p>\n<p>public String refreshToken(String token)</p>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol>\n<li><p><strong>前端输入用户密码传入后端，后端判断用户名密码是否正确，如果正确，会生成一个JWT令牌，返回给前端，如果不正确重新输入用户名密码。</strong></p>\n<ol>\n<li><p>使用 Admin 实现 UserDetails , 重写其中的方法</p>\n</li>\n<li><p>使用 AdminServiceImpl 实现类 ， 获取前端传入的 用户名、密码、图形验证码；</p>\n<ol>\n<li><p>获取请求中的的图形验证码进行校验；</p>\n</li>\n<li><p>通过 userDetailsService 接口中 loadUserByUsername(username) 根据传入的用户名生成用户信息 userDetails</p>\n<p>校验 userDetails </p>\n<p>校验 前端传入密码是否与数据库中存储的密码进行校验</p>\n</li>\n<li><p>SpringSecurity全局对象中 更新 用户登录信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//全局更新</span><br><span class=\"hljs-comment\">//更新security登录用户对象</span><br>UsernamePasswordAuthenticationToken authenticationToken = <span class=\"hljs-keyword\">new</span> UsernamePasswordAuthenticationToken(userDetails, <span class=\"hljs-keyword\">null</span>, userDetails.getAuthorities());<br>SecurityContextHolder.getContext().setAuthentication(authenticationToken);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>生成 Token ，将 Token 以及 请求头放入 map 传入前端</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>登录成功</p>\n</li>\n<li><p><strong>JWT登录授权过滤器</strong></p>\n<p>存在token并且token格式正确，使其登录，同时判断token是否有效，有效重新 SpringSecurity全局对象中 更新 用户登录信息</p>\n</li>\n<li><p>自定义未授权和登录结果返回</p>\n<ol>\n<li>未登录或token失效处理器</li>\n<li>授权失败处理器</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<hr>\n<h3 id=\"UserDetailsService接口\"><a href=\"#UserDetailsService接口\" class=\"headerlink\" title=\"UserDetailsService接口\"></a>UserDetailsService接口</h3><blockquote>\n<p><strong>UserDetailsService接口</strong> 加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\">UserDetails <span class=\"hljs-title\">loadUserByUsername</span><span class=\"hljs-params\">(String username)</span> throw UsernameNotFoundException</span>;<br></code></pre></td></tr></table></figure>\n<hr>\n<p><strong>UserDetails</strong>接口：提供核心用户信息。通过 UserDetailsService 根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>\n<hr>\n<p>UserDetails接口的实现类 <strong>User</strong> 其中有两个核心构造方法,其中第一个User()调用第二个 User()方法</p>\n<ul>\n<li>User()方法中的 username 是从 loadUserByUsername(String username) 中前端传入的username，然后 User()方法中的 password 是从数据库中 根据 username 查找对应的 用户，返回其密码（用来和前端传入的密码进行比较）。</li>\n</ul>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">User</span><span class=\"hljs-params\">(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>(username, password, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">true</span>, authorities);<br>\t&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">User</span><span class=\"hljs-params\">(String username, String password, <span class=\"hljs-keyword\">boolean</span> enabled, <span class=\"hljs-keyword\">boolean</span> accountNonExpired,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t\t<span class=\"hljs-keyword\">boolean</span> credentialsNonExpired, <span class=\"hljs-keyword\">boolean</span> accountNonLocked,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t\tCollection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;<br>\t\tAssert.isTrue(username != <span class=\"hljs-keyword\">null</span> &amp;&amp; !<span class=\"hljs-string\">&quot;&quot;</span>.equals(username) &amp;&amp; password != <span class=\"hljs-keyword\">null</span>,<br>\t\t\t\t<span class=\"hljs-string\">&quot;Cannot pass null or empty values to constructor&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">this</span>.username = username;<br>\t\t<span class=\"hljs-keyword\">this</span>.password = password;<br>\t\t<span class=\"hljs-keyword\">this</span>.enabled = enabled;<br>\t\t<span class=\"hljs-keyword\">this</span>.accountNonExpired = accountNonExpired;<br>\t\t<span class=\"hljs-keyword\">this</span>.credentialsNonExpired = credentialsNonExpired;<br>\t\t<span class=\"hljs-keyword\">this</span>.accountNonLocked = accountNonLocked;<br>\t\t<span class=\"hljs-keyword\">this</span>.authorities = Collections.unmodifiableSet(sortAuthorities(authorities));<br>\t&#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><strong>PasswordEncoder 接口</strong> Spring已经实例化，需要自定义重新实现 PasswordEncoder 实例。</p>\n<p>该接口共有两个主要方法</p>\n<ol>\n<li><p>对 密码进行加密 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\">String <span class=\"hljs-title\">encode</span><span class=\"hljs-params\">(CharSequence rawPassword)</span></span>;<br></code></pre></td></tr></table></figure>\n<p>通过对 <strong>原始密码 rawPassword</strong> 进行加密，返回一个加密后的 字符串</p>\n</li>\n<li><p>匹配 原始密码 与 加密后的密码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">matches</span><span class=\"hljs-params\">(CharSequence rawPassword, String encodedPassword)</span></span>;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<p>官方推荐使用<strong>PasswordEncoder 接口</strong>的实现类 <strong>BCryptPasswordEncoder</strong> 基于 <strong>Hash算法</strong> 实现单向加密 </p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>UsernamePasswordAuthenticationFilter类</strong> 负责处理在登陆页面填写了用户名密码后的登陆请求</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>Authentication接口</strong>: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>FormLoginConfigurer类</strong> 可以自定义登陆成功登陆失败跳转</p>\n<p><strong>ForwardAuthenticationSuccessHandler</strong> 实现了 <strong>AuthenticationSuccessHandler 接口</strong> 定义了成功跳转链接</p>\n<p><strong>ForwardAuthenticationFailureHandler</strong> 实现了 <strong>AuthenticationFailureHandler 接口</strong> 定义了失败跳转链接</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>WebSecurityConfigurerAdapter</strong> 是个适配器，是构建<strong>SecurityFilterChain</strong>的关键， 在配置的时候,需要我们自己写个配置类去继承他,然后编写自己所特殊需要的配置</p>\n<p>重写的 <strong>configure(HttpSecurity http)</strong> 的方法就是用来配置 <strong>HttpSecurity</strong> 的</p>\n<blockquote>\n<p>http.</p>\n<p>anyRequest() 表示所有请求</p>\n<p>antMatches() 表示匹配请求</p>\n<p>regexMatches() 表示通过正则进行匹配</p>\n<p>mvcMatches() 表示匹配 ServletPath 为特有方法</p>\n<hr>\n<p>permitAll() 表示不需要被认证</p>\n<p>authenticated() 表示需要被认证</p>\n<p>hasAuthority() 表示需要某种权限</p>\n<p>hasAnyAuthority() 表示需要多个权限其中之一</p>\n<p>hasRole() 表示需要某种角色（初始化角色时 前缀 ROLE_ 匹配值不需要前缀）</p>\n<p>hasAnyRole() 表示需要多个角色中的其中之一</p>\n<p>hasIpAddress() 表示特定的 IP地址 才可以通过</p>\n<hr>\n<p>http.csrf() 跨站请求伪造攻击</p>\n<hr>\n<p>http.</p>\n<p>exceptionHandling() 表示异常处理</p>\n<p>accessDeniedHandler() 表示授权失败处理器</p>\n<p>authenticationEntryPoint() 表示认证失败处理器</p>\n</blockquote>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>AccessDeniedHandler接口</strong> 该类用来统一处理 <strong>AccessDeniedException</strong> 异常，为授权过程中出现异常</p>\n<p>自定义授权过程异常处理，实现<strong>AccessDeniedHandler接口</strong>，并重写handle() 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handle</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span></span><br><span class=\"hljs-function\">\t\t\t<span class=\"hljs-keyword\">throws</span> IOException, ServletException</span>;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><strong>基于注解的访问控制</strong></p>\n<p>需要通过 <strong>@EnableGlobalMethodSecurity</strong> 进行开启后使用</p>\n<p><strong>@Secured</strong>（方法或类） 专门用于判断是否具有角色 ，参数以 <strong>ROLE_</strong> 开头</p>\n<p><strong>@PreAuthorize/@PostAuthorize</strong>（方法或类） 在访问方法或类再执行之前/之后判断权限 </p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>Token Auth</strong></p>\n<p>基于Token的身份验证方法，在服务端不需要存储用户的登录记录</p>\n<ol>\n<li>客户端使用用户名跟密码请求登陆</li>\n<li>服务端收到请求，验证用户名和密码</li>\n<li>验证成功，服务器端签发一个 Token，将这个Token发送给客户端</li>\n<li>客户端收到Token将其存储</li>\n<li>客户端每次向服务器请求资源的时候携带该 Token</li>\n<li>服务器端收到请求，验证请求中携带的Token，验证成功，返回请求数据</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><strong>JWT</strong> JSON WEB Token ,定义了一种简介的、自包含的协议格式，用于在通信双方传递JSON对象，传递的信息经过数字签名可以被验证和信任。</p>\n<ol>\n<li>基于JSON，方便解析；</li>\n<li>可以在令牌中自定义丰富内容，易扩展；</li>\n<li>通过非对称加密算法及数字签名技术，防止篡改，安全性高；</li>\n<li>资源服务使用JWT可不依赖认证服务即可完成授权。</li>\n</ol>\n<p>JWT令牌较长，占存储空间比较大</p>\n</blockquote>\n<h3 id=\"JWT组成\"><a href=\"#JWT组成\" class=\"headerlink\" title=\"JWT组成\"></a><strong>JWT组成</strong></h3><blockquote>\n<ol>\n<li><p>头部 Header 描述JWT最基本信息</p>\n<p>对头部的 JSON 字符串 进行 BASE64编码解码</p>\n</li>\n<li><p>负载 payload 存放有效信息（不要放敏感信息）</p>\n<ol>\n<li>标准中注册的声明</li>\n<li>公共的声明</li>\n<li>私有的声明</li>\n</ol>\n</li>\n<li><p>签证、签名 signature</p>\n<ol>\n<li>header（BASE64编码之后的头部信息）</li>\n<li>payload （BASE64编码之后的载荷信息）</li>\n<li>secret （盐 ，必须保密，保存在服务器端）</li>\n</ol>\n</li>\n</ol>\n<p>JWT签发在服务器端，secret相当于私钥 </p>\n</blockquote>\n<blockquote>\n<p><strong>JJWT</strong>：提供端到端的JWT创建和验证的Java库</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>OAUTH2 认证</strong></p>\n<p>优点</p>\n<ol>\n<li>更安全，客户端不接触用户密码</li>\n<li>短寿命和封装的Token</li>\n<li>广泛传播、持续采用</li>\n<li>资源服务器和授权服务器解耦</li>\n<li>集中式授权，简化客户端</li>\n<li>客户可以具有不同的信任级别</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>协议框架太宽泛，造成各种实现的兼容性和互操作性差</li>\n<li>不是一个认证协议，本身不能告诉你任何用户信息</li>\n</ol>\n<img src=\"/article/52913/%E5%BE%AE%E4%BF%A1%E8%AE%A4%E8%AF%81%E4%B8%BE%E4%BE%8B.png\" class title=\"微信认证举例\">\n<img src=\"/article/52913/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png\" class title=\"认证流程\">\n</blockquote>\n<blockquote>\n<p>客户凭证(client Credentials) 客户端的clientId和密码用于认证客户</p>\n<p>令牌(tokens) 授权服务器在接受到客户请求后，颁发的访问令牌</p>\n<blockquote>\n<p>授权码 仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌</p>\n<p>访问令牌 用于代表一个用户或服务直接去访问受保护的资源</p>\n<p>刷新令牌 用于去授权服务器获取一个刷新访问令牌</p>\n<p>beareaToken 不管谁拿到Token都可以访问资源</p>\n<p>proof of Possession Token 可以校验client是否对Token有明确的拥有权</p>\n</blockquote>\n<p>作用域(scopes) 客户请求访问令牌时，由资源拥有者外指定的细分权限</p>\n</blockquote>\n<blockquote>\n<img src=\"/article/52913/SpringSecurityOAuth2.png\" class title=\"SpringSecurityOAuth2\">\n</blockquote>\n<blockquote>\n<img src=\"/article/52913/SpringSecurityOAuth2%E6%9E%B6%E6%9E%84.png\" class title=\"SpringSecurityOAuth2架构\">\n<ol>\n<li>用户访问，此时没有Token，Oauth2RestTemplate报错，报错信息会被Oauth2ClientContextFilter捕获，并重定向到认证服务器；</li>\n<li>认证服务器通过 Authorization Endpoint进行授权，并通过  AuthorizationServerTokenServices 生成授权码并返回给客户；</li>\n<li>客户端拿到授权码去认证服务器通过 Token Endpoint 调用 AuthorizationServerTokenServices 生成Token 并返回给客户端</li>\n<li>客户端拿到Token 去资源服务器访问资源，一般会通过 Oauth2AuthenticationManager 调用 ResourceServerTokenServices 进行校验，校验通过可获取资源</li>\n</ol>\n</blockquote>\n","more":"<p>学习源于<a href=\"https://www.bilibili.com/video/BV1mm4y1X7Hc?p=8&amp;spm_id_from=pageDriver\">三更草堂</a></p>\n<h2 id=\"SpringSecurity\"><a href=\"#SpringSecurity\" class=\"headerlink\" title=\"SpringSecurity\"></a>SpringSecurity</h2><p>Spring Security是一个<strong>功能强大且高度可定制的身份验证和访问控制框架</strong>。这是保护基于Spring的应用程序的事实上的标准。</p>\n<p>SpringSecurity 提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC、DI、AOP功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p>\n<p>Spring Security是一个专注于为Java应用程序提供身份验证和授权的框架。像所有Spring项目一样，Spring Security的真正力量在于它有多容易被扩展以满足自定义要求。</p>\n<p><strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p>\n<p><strong>授权：经过认证后判断当前用户是否有权限进行某个操作</strong></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p><code>pom.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.6<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.projectlombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>lombok<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">optional</span>&gt;</span>true<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">optional</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-security<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>基础项目</strong></p>\n<p><code>SecurityApplication.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.boyolo;<br><span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;<br><span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class=\"hljs-meta\">@SpringBootApplication</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SecurityApplication</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(SecurityApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>HelloController.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.boyolo.controller;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class=\"hljs-meta\">@RestController</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>&#123;<br>  <span class=\"hljs-meta\">@RequestMapping(&quot;/hello&quot;)</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">helloController</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;hello&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>测试</strong></p>\n<p>访问 <code>http://localhost:8080/hello</code></p>\n<p>跳转页面</p>\n<img src=\"/article/52913/SpringSecurity%E5%85%A5%E9%97%A8.png\" class title=\"image-20220404100727005\">\n<p>默认用户名：user</p>\n<p>默认密码：后台运行复制</p>\n<h2 id=\"认证\"><a href=\"#认证\" class=\"headerlink\" title=\"认证\"></a>认证</h2><img src=\"/article/52913/%E7%99%BB%E5%BD%95%E6%A0%A1%E9%AA%8C%E6%B5%81%E7%A8%8B.png\" class title=\"登录校验流程\">\n<h3 id=\"SpringSecurity完整流程\"><a href=\"#SpringSecurity完整流程\" class=\"headerlink\" title=\"SpringSecurity完整流程\"></a>SpringSecurity完整流程</h3><p>SpringSecurity其实就是一个过滤器链，内部包含了各种功能的过滤器。</p>\n<p><strong>基础流程图</strong></p>\n<img src=\"/article/52913/%E6%B5%81%E7%A8%8B%E5%9B%BE-9039561.png\" class title=\"流程图\">\n<p><strong>UsernamePasswordAuthenticationFilter</strong>:负责处理我们在登陆页面填写了用户名密码后的登陆请求。</p>\n<p><strong>ExceptionTranslationFilter：</strong> 处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p>\n<p><strong>FilterSecurityInterceptor：</strong> 负责权限校验的过滤器。</p>\n<p>SpringSecurity过滤器链中有哪些过滤器及它们的顺序：</p>\n<img src=\"/article/52913/SpringSecurity%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.png\" class title=\"SpringSecurity过滤器链\">\n<h3 id=\"认证流程详解\"><a href=\"#认证流程详解\" class=\"headerlink\" title=\"认证流程详解\"></a>认证流程详解</h3><img src=\"/article/52913/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-9040230.png\" class title=\"认证流程详解\">\n<p><strong>Authentication接口</strong>: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>\n<p><strong>AuthenticationManager接口</strong>：定义了认证Authentication的方法，在 Spring Security 中，用来处理身份认证的类是 AuthenticationManager，我们也称之为认证管理器。</p>\n<p><strong>UserDetailsService接口</strong>：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>\n<p><strong>UserDetails接口（继承了 Serializable 序列化）</strong>：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>\n<ol>\n<li><p>自定义登录验证</p>\n<img src=\"/article/52913/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81.png\" class title=\"自定义登录验证\">\n<ol>\n<li><p>自定义登录接口</p>\n<p>调用ProviderManager的方法进行认证 如果认证通过生成jwt</p>\n<p>使用userId作为Key，用户信息作为Value，把用户信息存入redis中</p>\n</li>\n<li><p>自定义UserDetailsService</p>\n<p>在这个实现类中去查询数据库</p>\n</li>\n</ol>\n</li>\n<li><p>校验</p>\n<p>定义Jwt认证过滤器，获取token，解析token获取其中的userid，从redis中获取用户信息，存入SecurityContextHolder</p>\n</li>\n</ol>\n<h2 id=\"授权\"><a href=\"#授权\" class=\"headerlink\" title=\"授权\"></a>授权</h2><h3 id=\"授权基本流程\"><a href=\"#授权基本流程\" class=\"headerlink\" title=\"授权基本流程\"></a>授权基本流程</h3><p>在 SpringSecurity 中，会使用默认的 FilterSecurityInterceptor 来进行权限校验。在 FilterSecurityInterceptor 中会从 SecurityContextHolder 获取其中的 Authentication ，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。</p>\n<p>所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。</p>\n<p>然后设置我们的资源所需要的权限即可。</p>\n<h3 id=\"授权实现\"><a href=\"#授权实现\" class=\"headerlink\" title=\"授权实现\"></a>授权实现</h3><p><strong>限制访问资源所需权限</strong></p>\n<p>可以使用注解去指定访问对应的资源所需的权限</p>\n<ol>\n<li><p>需要先开启相关配置 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@EnableGlobalMethodSecurity(prePostEnabled = true)</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>在方法中使用注解配置权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@PreAuthorize(&quot;hasAuthority(&#x27;权限&#x27;)&quot;)</span><br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>封装权限信息</strong></p>\n<h2 id=\"自定义失败处理\"><a href=\"#自定义失败处理\" class=\"headerlink\" title=\"自定义失败处理\"></a>自定义失败处理</h2><p>希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。</p>\n<p>在 SpringSecurity 中，如果我们在认证或者授权的过程中出现了异常会被 ExceptionTranslationFilter 捕获到。在 ExceptionTranslationFilter 中会去判断是认证失败还是授权失败出现的异常。</p>\n<p>如果是认证过程中出现的异常会被封装成 AuthenticationException 然后调用 <strong>AuthenticationEntryPoint</strong>  对象的方法去进行异常处理。</p>\n<p>如果是授权过程中出现的异常会被封装成 AccessDeniedException 然后调用 <strong>AccessDeniedHandler</strong> 对象的方法去进行异常处理。</p>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><p>浏览器出于安全的考虑，使用 XMLHttpRequest 对象发起 HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。</p>\n<ol>\n<li><p>先对SpringBoot配置，运行跨域请求</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Configuration</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CorsConfig</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">WebMvcConfigurer</span> </span>&#123;<br>  <span class=\"hljs-meta\">@Override</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addCorsMappings</span><span class=\"hljs-params\">(CorsRegistry registry)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 设置允许跨域的路径</span><br>    registry.addMapping(<span class=\"hljs-string\">&quot;/**&quot;</span>)<br>      <span class=\"hljs-comment\">// 设置允许跨域请求的域名</span><br>      .allowedOriginPatterns(<span class=\"hljs-string\">&quot;*&quot;</span>)<br>      <span class=\"hljs-comment\">// 是否允许cookie</span><br>      .allowCredentials(<span class=\"hljs-keyword\">true</span>)<br>      <span class=\"hljs-comment\">// 设置允许的请求方式</span><br>      .allowedMethods(<span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-string\">&quot;POST&quot;</span>, <span class=\"hljs-string\">&quot;DELETE&quot;</span>, <span class=\"hljs-string\">&quot;PUT&quot;</span>)<br>      <span class=\"hljs-comment\">// 设置允许的header属性</span><br>      .allowedHeaders(<span class=\"hljs-string\">&quot;*&quot;</span>)<br>      <span class=\"hljs-comment\">// 跨域允许时间</span><br>      .maxAge(<span class=\"hljs-number\">3600</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>开启 SpringSecurity 的跨域访问</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">(HttpSecurity http)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;<br>  <span class=\"hljs-comment\">//允许跨域</span><br>  http.cors();<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3><p>CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。</p>\n<p>SpringSecurit 去防止 CSRF 攻击的方式就是通过 csrf_token 。后端会生成一个 csrf_token ，前端发起请求的时候需要携带这个 csrf_token ,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。</p>\n<p>CSRF 攻击依靠的是 cookie 中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是 token ，而 token 并不是存储中 cookie 中，并且需要前端代码去把token 设置到请求头中才可以，所以CSRF攻击也就不用担心了。</p>\n<hr>\n<h2 id=\"项目过程\"><a href=\"#项目过程\" class=\"headerlink\" title=\"项目过程\"></a><strong>项目过程</strong></h2><p><strong>前端输入用户密码传入后端，后端判断用户名密码是否正确，如果正确，会生成一个JWT令牌，返回给前端，如果不正确重新输入用户名密码。</strong></p>\n<p><strong>前端拿到JWT令牌之后，会放在请求头中，之后每一次请求都会携带JWT令牌，后端 JWT令牌拦截器，每次有请求进入后端，先判断JWT令牌 是否存在以及令牌是否正确合法有效，如果不存在或者JWT令牌不合法有效，拦截请求，如果JWT令牌合法有效，允许请求访问。</strong></p>\n<blockquote>\n<p><strong>引入依赖</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">&lt;!--security 依赖--&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br>&lt;!--JWT 依赖--&gt;<br>&lt;dependency&gt;<br>  &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;<br>  &lt;artifactId&gt;jjwt&lt;/artifactId&gt;<br>  &lt;version&gt;<span class=\"hljs-number\">0.9</span><span class=\"hljs-number\">.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>\n<p><strong>JWT配置</strong></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">jwt:</span><br>  <span class=\"hljs-comment\"># JWT存储的请求头</span><br>  <span class=\"hljs-attr\">tokenHeader:</span> <span class=\"hljs-string\">Authorization</span><br>  <span class=\"hljs-comment\"># JWT 加解密使用的密钥</span><br>  <span class=\"hljs-attr\">secret:</span> <span class=\"hljs-string\">yeb-secret</span><br>  <span class=\"hljs-comment\"># JWT的超期限时间（60*60*24）</span><br>  <span class=\"hljs-attr\">expiration:</span> <span class=\"hljs-number\">604800</span><br>  <span class=\"hljs-comment\"># JWT 负载中拿到开头</span><br>  <span class=\"hljs-attr\">tokenHead:</span> <span class=\"hljs-string\">Bearer</span><br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><strong>编写JwtToken工具类</strong></p>\n<ol>\n<li><p>根据用户信息生成Token</p>\n<ol>\n<li>generateToken(UserDetails userDetails)</li>\n<li>generateToken(Map&lt;String,Object&gt; claims)</li>\n<li>generateExpirationDate()</li>\n</ol>\n</li>\n<li><p>从Token中获取信息</p>\n<ol>\n<li><p>从Token中获取登录用户名</p>\n<p>public String getUserNameFromToken(String token)</p>\n</li>\n<li><p>从Token中获取荷载</p>\n<p>private Claims getClaimsFromToken(String token)</p>\n</li>\n</ol>\n</li>\n<li><p>判断Token是否有效</p>\n<ol>\n<li><p>判断 Token中的用户名和 用户信息中的用户名是否一致 并且 是否失效</p>\n<p>public boolean validateToken(String token , UserDetails userDetails)</p>\n</li>\n<li><p>判断 Token 是否失效</p>\n<p>private boolean isTokenExpired(String token)</p>\n</li>\n<li><p>获取 Token 失效时间</p>\n<p>private Date getExpiredDateFromToken(String token)</p>\n</li>\n</ol>\n</li>\n<li><p>判断 Token 是否可以被刷新</p>\n<p>public boolean canRefreshToken(String token)</p>\n</li>\n<li><p>刷新 Token</p>\n<p>public String refreshToken(String token)</p>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol>\n<li><p><strong>前端输入用户密码传入后端，后端判断用户名密码是否正确，如果正确，会生成一个JWT令牌，返回给前端，如果不正确重新输入用户名密码。</strong></p>\n<ol>\n<li><p>使用 Admin 实现 UserDetails , 重写其中的方法</p>\n</li>\n<li><p>使用 AdminServiceImpl 实现类 ， 获取前端传入的 用户名、密码、图形验证码；</p>\n<ol>\n<li><p>获取请求中的的图形验证码进行校验；</p>\n</li>\n<li><p>通过 userDetailsService 接口中 loadUserByUsername(username) 根据传入的用户名生成用户信息 userDetails</p>\n<p>校验 userDetails </p>\n<p>校验 前端传入密码是否与数据库中存储的密码进行校验</p>\n</li>\n<li><p>SpringSecurity全局对象中 更新 用户登录信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//全局更新</span><br><span class=\"hljs-comment\">//更新security登录用户对象</span><br>UsernamePasswordAuthenticationToken authenticationToken = <span class=\"hljs-keyword\">new</span> UsernamePasswordAuthenticationToken(userDetails, <span class=\"hljs-keyword\">null</span>, userDetails.getAuthorities());<br>SecurityContextHolder.getContext().setAuthentication(authenticationToken);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>生成 Token ，将 Token 以及 请求头放入 map 传入前端</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>登录成功</p>\n</li>\n<li><p><strong>JWT登录授权过滤器</strong></p>\n<p>存在token并且token格式正确，使其登录，同时判断token是否有效，有效重新 SpringSecurity全局对象中 更新 用户登录信息</p>\n</li>\n<li><p>自定义未授权和登录结果返回</p>\n<ol>\n<li>未登录或token失效处理器</li>\n<li>授权失败处理器</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<hr>\n<h3 id=\"UserDetailsService接口\"><a href=\"#UserDetailsService接口\" class=\"headerlink\" title=\"UserDetailsService接口\"></a>UserDetailsService接口</h3><blockquote>\n<p><strong>UserDetailsService接口</strong> 加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\">UserDetails <span class=\"hljs-title\">loadUserByUsername</span><span class=\"hljs-params\">(String username)</span> throw UsernameNotFoundException</span>;<br></code></pre></td></tr></table></figure>\n<hr>\n<p><strong>UserDetails</strong>接口：提供核心用户信息。通过 UserDetailsService 根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。</p>\n<hr>\n<p>UserDetails接口的实现类 <strong>User</strong> 其中有两个核心构造方法,其中第一个User()调用第二个 User()方法</p>\n<ul>\n<li>User()方法中的 username 是从 loadUserByUsername(String username) 中前端传入的username，然后 User()方法中的 password 是从数据库中 根据 username 查找对应的 用户，返回其密码（用来和前端传入的密码进行比较）。</li>\n</ul>\n<blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">User</span><span class=\"hljs-params\">(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>(username, password, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">true</span>, <span class=\"hljs-keyword\">true</span>, authorities);<br>\t&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">User</span><span class=\"hljs-params\">(String username, String password, <span class=\"hljs-keyword\">boolean</span> enabled, <span class=\"hljs-keyword\">boolean</span> accountNonExpired,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t\t<span class=\"hljs-keyword\">boolean</span> credentialsNonExpired, <span class=\"hljs-keyword\">boolean</span> accountNonLocked,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t\tCollection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;<br>\t\tAssert.isTrue(username != <span class=\"hljs-keyword\">null</span> &amp;&amp; !<span class=\"hljs-string\">&quot;&quot;</span>.equals(username) &amp;&amp; password != <span class=\"hljs-keyword\">null</span>,<br>\t\t\t\t<span class=\"hljs-string\">&quot;Cannot pass null or empty values to constructor&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">this</span>.username = username;<br>\t\t<span class=\"hljs-keyword\">this</span>.password = password;<br>\t\t<span class=\"hljs-keyword\">this</span>.enabled = enabled;<br>\t\t<span class=\"hljs-keyword\">this</span>.accountNonExpired = accountNonExpired;<br>\t\t<span class=\"hljs-keyword\">this</span>.credentialsNonExpired = credentialsNonExpired;<br>\t\t<span class=\"hljs-keyword\">this</span>.accountNonLocked = accountNonLocked;<br>\t\t<span class=\"hljs-keyword\">this</span>.authorities = Collections.unmodifiableSet(sortAuthorities(authorities));<br>\t&#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n</blockquote>\n<blockquote>\n<p><strong>PasswordEncoder 接口</strong> Spring已经实例化，需要自定义重新实现 PasswordEncoder 实例。</p>\n<p>该接口共有两个主要方法</p>\n<ol>\n<li><p>对 密码进行加密 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\">String <span class=\"hljs-title\">encode</span><span class=\"hljs-params\">(CharSequence rawPassword)</span></span>;<br></code></pre></td></tr></table></figure>\n<p>通过对 <strong>原始密码 rawPassword</strong> 进行加密，返回一个加密后的 字符串</p>\n</li>\n<li><p>匹配 原始密码 与 加密后的密码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">matches</span><span class=\"hljs-params\">(CharSequence rawPassword, String encodedPassword)</span></span>;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<p>官方推荐使用<strong>PasswordEncoder 接口</strong>的实现类 <strong>BCryptPasswordEncoder</strong> 基于 <strong>Hash算法</strong> 实现单向加密 </p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>UsernamePasswordAuthenticationFilter类</strong> 负责处理在登陆页面填写了用户名密码后的登陆请求</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>Authentication接口</strong>: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>FormLoginConfigurer类</strong> 可以自定义登陆成功登陆失败跳转</p>\n<p><strong>ForwardAuthenticationSuccessHandler</strong> 实现了 <strong>AuthenticationSuccessHandler 接口</strong> 定义了成功跳转链接</p>\n<p><strong>ForwardAuthenticationFailureHandler</strong> 实现了 <strong>AuthenticationFailureHandler 接口</strong> 定义了失败跳转链接</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>WebSecurityConfigurerAdapter</strong> 是个适配器，是构建<strong>SecurityFilterChain</strong>的关键， 在配置的时候,需要我们自己写个配置类去继承他,然后编写自己所特殊需要的配置</p>\n<p>重写的 <strong>configure(HttpSecurity http)</strong> 的方法就是用来配置 <strong>HttpSecurity</strong> 的</p>\n<blockquote>\n<p>http.</p>\n<p>anyRequest() 表示所有请求</p>\n<p>antMatches() 表示匹配请求</p>\n<p>regexMatches() 表示通过正则进行匹配</p>\n<p>mvcMatches() 表示匹配 ServletPath 为特有方法</p>\n<hr>\n<p>permitAll() 表示不需要被认证</p>\n<p>authenticated() 表示需要被认证</p>\n<p>hasAuthority() 表示需要某种权限</p>\n<p>hasAnyAuthority() 表示需要多个权限其中之一</p>\n<p>hasRole() 表示需要某种角色（初始化角色时 前缀 ROLE_ 匹配值不需要前缀）</p>\n<p>hasAnyRole() 表示需要多个角色中的其中之一</p>\n<p>hasIpAddress() 表示特定的 IP地址 才可以通过</p>\n<hr>\n<p>http.csrf() 跨站请求伪造攻击</p>\n<hr>\n<p>http.</p>\n<p>exceptionHandling() 表示异常处理</p>\n<p>accessDeniedHandler() 表示授权失败处理器</p>\n<p>authenticationEntryPoint() 表示认证失败处理器</p>\n</blockquote>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>AccessDeniedHandler接口</strong> 该类用来统一处理 <strong>AccessDeniedException</strong> 异常，为授权过程中出现异常</p>\n<p>自定义授权过程异常处理，实现<strong>AccessDeniedHandler接口</strong>，并重写handle() 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handle</span><span class=\"hljs-params\">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span></span><br><span class=\"hljs-function\">\t\t\t<span class=\"hljs-keyword\">throws</span> IOException, ServletException</span>;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p><strong>基于注解的访问控制</strong></p>\n<p>需要通过 <strong>@EnableGlobalMethodSecurity</strong> 进行开启后使用</p>\n<p><strong>@Secured</strong>（方法或类） 专门用于判断是否具有角色 ，参数以 <strong>ROLE_</strong> 开头</p>\n<p><strong>@PreAuthorize/@PostAuthorize</strong>（方法或类） 在访问方法或类再执行之前/之后判断权限 </p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>Token Auth</strong></p>\n<p>基于Token的身份验证方法，在服务端不需要存储用户的登录记录</p>\n<ol>\n<li>客户端使用用户名跟密码请求登陆</li>\n<li>服务端收到请求，验证用户名和密码</li>\n<li>验证成功，服务器端签发一个 Token，将这个Token发送给客户端</li>\n<li>客户端收到Token将其存储</li>\n<li>客户端每次向服务器请求资源的时候携带该 Token</li>\n<li>服务器端收到请求，验证请求中携带的Token，验证成功，返回请求数据</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><strong>JWT</strong> JSON WEB Token ,定义了一种简介的、自包含的协议格式，用于在通信双方传递JSON对象，传递的信息经过数字签名可以被验证和信任。</p>\n<ol>\n<li>基于JSON，方便解析；</li>\n<li>可以在令牌中自定义丰富内容，易扩展；</li>\n<li>通过非对称加密算法及数字签名技术，防止篡改，安全性高；</li>\n<li>资源服务使用JWT可不依赖认证服务即可完成授权。</li>\n</ol>\n<p>JWT令牌较长，占存储空间比较大</p>\n</blockquote>\n<h3 id=\"JWT组成\"><a href=\"#JWT组成\" class=\"headerlink\" title=\"JWT组成\"></a><strong>JWT组成</strong></h3><blockquote>\n<ol>\n<li><p>头部 Header 描述JWT最基本信息</p>\n<p>对头部的 JSON 字符串 进行 BASE64编码解码</p>\n</li>\n<li><p>负载 payload 存放有效信息（不要放敏感信息）</p>\n<ol>\n<li>标准中注册的声明</li>\n<li>公共的声明</li>\n<li>私有的声明</li>\n</ol>\n</li>\n<li><p>签证、签名 signature</p>\n<ol>\n<li>header（BASE64编码之后的头部信息）</li>\n<li>payload （BASE64编码之后的载荷信息）</li>\n<li>secret （盐 ，必须保密，保存在服务器端）</li>\n</ol>\n</li>\n</ol>\n<p>JWT签发在服务器端，secret相当于私钥 </p>\n</blockquote>\n<blockquote>\n<p><strong>JJWT</strong>：提供端到端的JWT创建和验证的Java库</p>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>OAUTH2 认证</strong></p>\n<p>优点</p>\n<ol>\n<li>更安全，客户端不接触用户密码</li>\n<li>短寿命和封装的Token</li>\n<li>广泛传播、持续采用</li>\n<li>资源服务器和授权服务器解耦</li>\n<li>集中式授权，简化客户端</li>\n<li>客户可以具有不同的信任级别</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>协议框架太宽泛，造成各种实现的兼容性和互操作性差</li>\n<li>不是一个认证协议，本身不能告诉你任何用户信息</li>\n</ol>\n<img src=\"/article/52913/%E5%BE%AE%E4%BF%A1%E8%AE%A4%E8%AF%81%E4%B8%BE%E4%BE%8B.png\" class title=\"微信认证举例\">\n<img src=\"/article/52913/%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png\" class title=\"认证流程\">\n</blockquote>\n<blockquote>\n<p>客户凭证(client Credentials) 客户端的clientId和密码用于认证客户</p>\n<p>令牌(tokens) 授权服务器在接受到客户请求后，颁发的访问令牌</p>\n<blockquote>\n<p>授权码 仅用于授权码授权类型，用于交换获取访问令牌和刷新令牌</p>\n<p>访问令牌 用于代表一个用户或服务直接去访问受保护的资源</p>\n<p>刷新令牌 用于去授权服务器获取一个刷新访问令牌</p>\n<p>beareaToken 不管谁拿到Token都可以访问资源</p>\n<p>proof of Possession Token 可以校验client是否对Token有明确的拥有权</p>\n</blockquote>\n<p>作用域(scopes) 客户请求访问令牌时，由资源拥有者外指定的细分权限</p>\n</blockquote>\n<blockquote>\n<img src=\"/article/52913/SpringSecurityOAuth2.png\" class title=\"SpringSecurityOAuth2\">\n</blockquote>\n<blockquote>\n<img src=\"/article/52913/SpringSecurityOAuth2%E6%9E%B6%E6%9E%84.png\" class title=\"SpringSecurityOAuth2架构\">\n<ol>\n<li>用户访问，此时没有Token，Oauth2RestTemplate报错，报错信息会被Oauth2ClientContextFilter捕获，并重定向到认证服务器；</li>\n<li>认证服务器通过 Authorization Endpoint进行授权，并通过  AuthorizationServerTokenServices 生成授权码并返回给客户；</li>\n<li>客户端拿到授权码去认证服务器通过 Token Endpoint 调用 AuthorizationServerTokenServices 生成Token 并返回给客户端</li>\n<li>客户端拿到Token 去资源服务器访问资源，一般会通过 Oauth2AuthenticationManager 调用 ResourceServerTokenServices 进行校验，校验通过可获取资源</li>\n</ol>\n</blockquote>\n","categories":[{"name":"Java","path":"api/categories/Java.json"},{"name":"SpringSecurity","path":"api/categories/SpringSecurity.json"},{"name":"SpringSecurity","path":"api/categories/SpringSecurity.json"}],"tags":[{"name":"实习,SpringSecurity","path":"api/tags/实习,SpringSecurity.json"}]}