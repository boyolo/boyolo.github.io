{"title":"回溯算法","slug":"回溯算法","date":"2022-05-30T02:48:34.000Z","updated":"2022-07-11T13:10:18.134Z","comments":true,"path":"api/articles/回溯算法.json","realPath":null,"excerpt":null,"covers":["/article/60033/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.jpg"],"cover":"/images/theme/coverphoto/回溯算法.jpg","content":"<h2 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h2><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>\n<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>\n<h3 id=\"应用实例\"><a href=\"#应用实例\" class=\"headerlink\" title=\"应用实例\"></a>应用实例</h3><h4 id=\"八皇后问题\"><a href=\"#八皇后问题\" class=\"headerlink\" title=\"八皇后问题\"></a>八皇后问题</h4><blockquote>\n<p>有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。</p>\n<p>第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p>\n<img src=\"/article/60033/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.jpg\" class title=\"八皇后问题\">\n</blockquote>\n<p>把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">int</span>[] result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">8</span>];<span class=\"hljs-comment\">//全局或成员变量,下标表示行,值表示queen存储在哪一列</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">cal8queens</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> row)</span> </span>&#123; <span class=\"hljs-comment\">// 调用方式：cal8queens(0);</span><br>  <span class=\"hljs-keyword\">if</span> (row == <span class=\"hljs-number\">8</span>) &#123; <span class=\"hljs-comment\">// 8个棋子都放置好了，打印结果</span><br>    printQueens(result);<br>    <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span><br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> column = <span class=\"hljs-number\">0</span>; column &lt; <span class=\"hljs-number\">8</span>; ++column) &#123; <span class=\"hljs-comment\">// 每一行都有8中放法</span><br>    <span class=\"hljs-keyword\">if</span> (isOk(row, column)) &#123; <span class=\"hljs-comment\">// 有些放法不满足要求</span><br>      result[row] = column; <span class=\"hljs-comment\">// 第row行的棋子放到了column列</span><br>      cal8queens(row+<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 考察下一行</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isOk</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> row, <span class=\"hljs-keyword\">int</span> column)</span> </span>&#123;<span class=\"hljs-comment\">//判断row行column列放置是否合适</span><br>  <span class=\"hljs-keyword\">int</span> leftup = column - <span class=\"hljs-number\">1</span>, rightup = column + <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = row-<span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i) &#123; <span class=\"hljs-comment\">// 逐行往上考察每一行</span><br>    <span class=\"hljs-keyword\">if</span> (result[i] == column) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>; <span class=\"hljs-comment\">// 第i行的column列有棋子吗？</span><br>    <span class=\"hljs-keyword\">if</span> (leftup &gt;= <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// 考察左上对角线：第i行leftup列有棋子吗？</span><br>      <span class=\"hljs-keyword\">if</span> (result[i] == leftup) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (rightup &lt; <span class=\"hljs-number\">8</span>) &#123; <span class=\"hljs-comment\">// 考察右上对角线：第i行rightup列有棋子吗？</span><br>      <span class=\"hljs-keyword\">if</span> (result[i] == rightup) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    &#125;<br>    --leftup; ++rightup;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">printQueens</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] result)</span> </span>&#123; <span class=\"hljs-comment\">// 打印出一个二维矩阵</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> row = <span class=\"hljs-number\">0</span>; row &lt; <span class=\"hljs-number\">8</span>; ++row) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> column = <span class=\"hljs-number\">0</span>; column &lt; <span class=\"hljs-number\">8</span>; ++column) &#123;<br>      <span class=\"hljs-keyword\">if</span> (result[row] == column) System.out.print(<span class=\"hljs-string\">&quot;Q &quot;</span>);<br>      <span class=\"hljs-keyword\">else</span> System.out.print(<span class=\"hljs-string\">&quot;* &quot;</span>);<br>    &#125;<br>    System.out.println();<br>  &#125;<br>  System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"0-1-背包\"><a href=\"#0-1-背包\" class=\"headerlink\" title=\"0-1 背包\"></a>0-1 背包</h4><blockquote>\n<p>有一个背包，背包总的承载重量是 Wkg。现在有 n 个物品，每个物品的重量不等，并且不可分割。现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>\n</blockquote>\n<p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2^n 种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。</p>\n<p>可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> maxW = Integer.MIN_VALUE; <span class=\"hljs-comment\">//存储背包中物品总重量的最大值</span><br><span class=\"hljs-comment\">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span><br><span class=\"hljs-comment\">// w背包重量；items表示每个物品的重量；n表示物品个数</span><br><span class=\"hljs-comment\">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span><br><span class=\"hljs-comment\">// f(0, 0, a, 10, 100)</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> cw, <span class=\"hljs-keyword\">int</span>[] items, <span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">int</span> w)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (cw == w || i == n) &#123; <span class=\"hljs-comment\">// cw==w表示装满了;i==n表示已经考察完所有的物品</span><br>    <span class=\"hljs-keyword\">if</span> (cw &gt; maxW) maxW = cw;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  f(i+<span class=\"hljs-number\">1</span>, cw, items, n, w);<span class=\"hljs-comment\">//当前物品不装进背包</span><br>  <span class=\"hljs-keyword\">if</span> (cw + items[i] &lt;= w) &#123;<span class=\"hljs-comment\">// 已经超过可以背包承受的重量的时候，就不要再装了</span><br>    f(i+<span class=\"hljs-number\">1</span>,cw + items[i], items, n, w);<span class=\"hljs-comment\">// 当前物品装进背包</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h4><blockquote>\n<p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。</p>\n<p>假设正则表达式中只包含“*”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。</p>\n<p>如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p>\n</blockquote>\n<p>依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</p>\n<p>如果遇到特殊字符的时候，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Pattern</span> </span>&#123;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> matched = <span class=\"hljs-keyword\">false</span>;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">char</span>[] pattern; <span class=\"hljs-comment\">// 正则表达式</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> plen; <span class=\"hljs-comment\">// 正则表达式长度</span><br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Pattern</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] pattern, <span class=\"hljs-keyword\">int</span> plen)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.pattern = pattern;<br>    <span class=\"hljs-keyword\">this</span>.plen = plen;<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">match</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] text, <span class=\"hljs-keyword\">int</span> tlen)</span> </span>&#123; <span class=\"hljs-comment\">// 文本串及长度</span><br>    matched = <span class=\"hljs-keyword\">false</span>;<br>    rmatch(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, text, tlen);<br>    <span class=\"hljs-keyword\">return</span> matched;<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">rmatch</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> ti, <span class=\"hljs-keyword\">int</span> pj, <span class=\"hljs-keyword\">char</span>[] text, <span class=\"hljs-keyword\">int</span> tlen)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (matched) <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">// 如果已经匹配了，就不要继续递归了</span><br>    <span class=\"hljs-keyword\">if</span> (pj == plen) &#123; <span class=\"hljs-comment\">// 正则表达式到结尾了</span><br>      <span class=\"hljs-keyword\">if</span> (ti == tlen) matched = <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">// 文本串也到结尾了</span><br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (pattern[pj] == <span class=\"hljs-string\">&#x27;*&#x27;</span>) &#123; <span class=\"hljs-comment\">// *匹配任意个字符</span><br>      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt;= tlen-ti; ++k) &#123;<br>        rmatch(ti+k, pj+<span class=\"hljs-number\">1</span>, text, tlen);<br>      &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pattern[pj] == <span class=\"hljs-string\">&#x27;?&#x27;</span>) &#123; <span class=\"hljs-comment\">// ?匹配0个或者1个字符</span><br>      rmatch(ti, pj+<span class=\"hljs-number\">1</span>, text, tlen);<br>      rmatch(ti+<span class=\"hljs-number\">1</span>, pj+<span class=\"hljs-number\">1</span>, text, tlen);<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class=\"hljs-comment\">// 纯字符匹配才行</span><br>      rmatch(ti+<span class=\"hljs-number\">1</span>, pj+<span class=\"hljs-number\">1</span>, text, tlen);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","more":"<h2 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h2><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>\n<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>\n<h3 id=\"应用实例\"><a href=\"#应用实例\" class=\"headerlink\" title=\"应用实例\"></a>应用实例</h3><h4 id=\"八皇后问题\"><a href=\"#八皇后问题\" class=\"headerlink\" title=\"八皇后问题\"></a>八皇后问题</h4><blockquote>\n<p>有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。</p>\n<p>第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p>\n<img src=\"/article/60033/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.jpg\" class title=\"八皇后问题\">\n</blockquote>\n<p>把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">int</span>[] result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">8</span>];<span class=\"hljs-comment\">//全局或成员变量,下标表示行,值表示queen存储在哪一列</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">cal8queens</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> row)</span> </span>&#123; <span class=\"hljs-comment\">// 调用方式：cal8queens(0);</span><br>  <span class=\"hljs-keyword\">if</span> (row == <span class=\"hljs-number\">8</span>) &#123; <span class=\"hljs-comment\">// 8个棋子都放置好了，打印结果</span><br>    printQueens(result);<br>    <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span><br>  &#125;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> column = <span class=\"hljs-number\">0</span>; column &lt; <span class=\"hljs-number\">8</span>; ++column) &#123; <span class=\"hljs-comment\">// 每一行都有8中放法</span><br>    <span class=\"hljs-keyword\">if</span> (isOk(row, column)) &#123; <span class=\"hljs-comment\">// 有些放法不满足要求</span><br>      result[row] = column; <span class=\"hljs-comment\">// 第row行的棋子放到了column列</span><br>      cal8queens(row+<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 考察下一行</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isOk</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> row, <span class=\"hljs-keyword\">int</span> column)</span> </span>&#123;<span class=\"hljs-comment\">//判断row行column列放置是否合适</span><br>  <span class=\"hljs-keyword\">int</span> leftup = column - <span class=\"hljs-number\">1</span>, rightup = column + <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = row-<span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i) &#123; <span class=\"hljs-comment\">// 逐行往上考察每一行</span><br>    <span class=\"hljs-keyword\">if</span> (result[i] == column) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>; <span class=\"hljs-comment\">// 第i行的column列有棋子吗？</span><br>    <span class=\"hljs-keyword\">if</span> (leftup &gt;= <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// 考察左上对角线：第i行leftup列有棋子吗？</span><br>      <span class=\"hljs-keyword\">if</span> (result[i] == leftup) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (rightup &lt; <span class=\"hljs-number\">8</span>) &#123; <span class=\"hljs-comment\">// 考察右上对角线：第i行rightup列有棋子吗？</span><br>      <span class=\"hljs-keyword\">if</span> (result[i] == rightup) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>    &#125;<br>    --leftup; ++rightup;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">printQueens</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] result)</span> </span>&#123; <span class=\"hljs-comment\">// 打印出一个二维矩阵</span><br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> row = <span class=\"hljs-number\">0</span>; row &lt; <span class=\"hljs-number\">8</span>; ++row) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> column = <span class=\"hljs-number\">0</span>; column &lt; <span class=\"hljs-number\">8</span>; ++column) &#123;<br>      <span class=\"hljs-keyword\">if</span> (result[row] == column) System.out.print(<span class=\"hljs-string\">&quot;Q &quot;</span>);<br>      <span class=\"hljs-keyword\">else</span> System.out.print(<span class=\"hljs-string\">&quot;* &quot;</span>);<br>    &#125;<br>    System.out.println();<br>  &#125;<br>  System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"0-1-背包\"><a href=\"#0-1-背包\" class=\"headerlink\" title=\"0-1 背包\"></a>0-1 背包</h4><blockquote>\n<p>有一个背包，背包总的承载重量是 Wkg。现在有 n 个物品，每个物品的重量不等，并且不可分割。现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>\n</blockquote>\n<p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2^n 种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。</p>\n<p>可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> maxW = Integer.MIN_VALUE; <span class=\"hljs-comment\">//存储背包中物品总重量的最大值</span><br><span class=\"hljs-comment\">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span><br><span class=\"hljs-comment\">// w背包重量；items表示每个物品的重量；n表示物品个数</span><br><span class=\"hljs-comment\">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span><br><span class=\"hljs-comment\">// f(0, 0, a, 10, 100)</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i, <span class=\"hljs-keyword\">int</span> cw, <span class=\"hljs-keyword\">int</span>[] items, <span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">int</span> w)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (cw == w || i == n) &#123; <span class=\"hljs-comment\">// cw==w表示装满了;i==n表示已经考察完所有的物品</span><br>    <span class=\"hljs-keyword\">if</span> (cw &gt; maxW) maxW = cw;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  f(i+<span class=\"hljs-number\">1</span>, cw, items, n, w);<span class=\"hljs-comment\">//当前物品不装进背包</span><br>  <span class=\"hljs-keyword\">if</span> (cw + items[i] &lt;= w) &#123;<span class=\"hljs-comment\">// 已经超过可以背包承受的重量的时候，就不要再装了</span><br>    f(i+<span class=\"hljs-number\">1</span>,cw + items[i], items, n, w);<span class=\"hljs-comment\">// 当前物品装进背包</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h4><blockquote>\n<p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。</p>\n<p>假设正则表达式中只包含“*”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。</p>\n<p>如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p>\n</blockquote>\n<p>依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</p>\n<p>如果遇到特殊字符的时候，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Pattern</span> </span>&#123;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> matched = <span class=\"hljs-keyword\">false</span>;<br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">char</span>[] pattern; <span class=\"hljs-comment\">// 正则表达式</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> plen; <span class=\"hljs-comment\">// 正则表达式长度</span><br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Pattern</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] pattern, <span class=\"hljs-keyword\">int</span> plen)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.pattern = pattern;<br>    <span class=\"hljs-keyword\">this</span>.plen = plen;<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">match</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span>[] text, <span class=\"hljs-keyword\">int</span> tlen)</span> </span>&#123; <span class=\"hljs-comment\">// 文本串及长度</span><br>    matched = <span class=\"hljs-keyword\">false</span>;<br>    rmatch(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, text, tlen);<br>    <span class=\"hljs-keyword\">return</span> matched;<br>  &#125;<br><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">rmatch</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> ti, <span class=\"hljs-keyword\">int</span> pj, <span class=\"hljs-keyword\">char</span>[] text, <span class=\"hljs-keyword\">int</span> tlen)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (matched) <span class=\"hljs-keyword\">return</span>; <span class=\"hljs-comment\">// 如果已经匹配了，就不要继续递归了</span><br>    <span class=\"hljs-keyword\">if</span> (pj == plen) &#123; <span class=\"hljs-comment\">// 正则表达式到结尾了</span><br>      <span class=\"hljs-keyword\">if</span> (ti == tlen) matched = <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">// 文本串也到结尾了</span><br>      <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (pattern[pj] == <span class=\"hljs-string\">&#x27;*&#x27;</span>) &#123; <span class=\"hljs-comment\">// *匹配任意个字符</span><br>      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt;= tlen-ti; ++k) &#123;<br>        rmatch(ti+k, pj+<span class=\"hljs-number\">1</span>, text, tlen);<br>      &#125;<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pattern[pj] == <span class=\"hljs-string\">&#x27;?&#x27;</span>) &#123; <span class=\"hljs-comment\">// ?匹配0个或者1个字符</span><br>      rmatch(ti, pj+<span class=\"hljs-number\">1</span>, text, tlen);<br>      rmatch(ti+<span class=\"hljs-number\">1</span>, pj+<span class=\"hljs-number\">1</span>, text, tlen);<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class=\"hljs-comment\">// 纯字符匹配才行</span><br>      rmatch(ti+<span class=\"hljs-number\">1</span>, pj+<span class=\"hljs-number\">1</span>, text, tlen);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","categories":[{"name":"数据结构与算法","path":"api/categories/数据结构与算法.json"},{"name":"回溯算法","path":"api/categories/回溯算法.json"}],"tags":[{"name":"数据结构与算法,回溯算法","path":"api/tags/数据结构与算法,回溯算法.json"}]}