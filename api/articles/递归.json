{"title":"递归","slug":"递归","date":"2022-05-08T03:04:06.000Z","updated":"2022-05-24T11:41:34.368Z","comments":true,"path":"api/articles/递归.json","realPath":null,"excerpt":null,"covers":null,"cover":"/images/theme/coverphoto/递归.jpg","content":"<h2 id=\"如何理解“递归”？\"><a href=\"#如何理解“递归”？\" class=\"headerlink\" title=\"如何理解“递归”？\"></a>如何理解“递归”？</h2><h3 id=\"递归需要满足的三个条件\"><a href=\"#递归需要满足的三个条件\" class=\"headerlink\" title=\"递归需要满足的三个条件\"></a>递归需要满足的三个条件</h3><ol>\n<li><p>一个问题的解可以分解为几个子问题的解</p>\n<p>子问题就是数据规模更小的问题</p>\n</li>\n<li><p>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</p>\n</li>\n<li><p>存在递归终止条件</p>\n<p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p>\n</li>\n</ol>\n<h3 id=\"如何编写递归代码？\"><a href=\"#如何编写递归代码？\" class=\"headerlink\" title=\"如何编写递归代码？\"></a>如何编写递归代码？</h3><p>写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong></p>\n<p><strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</strong></p>\n<h3 id=\"递归代码要警惕堆栈溢出\"><a href=\"#递归代码要警惕堆栈溢出\" class=\"headerlink\" title=\"递归代码要警惕堆栈溢出\"></a>递归代码要警惕堆栈溢出</h3><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>\n<blockquote>\n<p><strong>问题：如何避免出现堆栈溢出呢？</strong></p>\n<p>可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。</p>\n<p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。</p>\n</blockquote>\n<h3 id=\"递归代码要警惕重复计算\"><a href=\"#递归代码要警惕重复计算\" class=\"headerlink\" title=\"递归代码要警惕重复计算\"></a>递归代码要警惕重复计算</h3><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p>\n<ol>\n<li>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。</li>\n<li>在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据。</li>\n</ol>\n","more":"<h2 id=\"如何理解“递归”？\"><a href=\"#如何理解“递归”？\" class=\"headerlink\" title=\"如何理解“递归”？\"></a>如何理解“递归”？</h2><h3 id=\"递归需要满足的三个条件\"><a href=\"#递归需要满足的三个条件\" class=\"headerlink\" title=\"递归需要满足的三个条件\"></a>递归需要满足的三个条件</h3><ol>\n<li><p>一个问题的解可以分解为几个子问题的解</p>\n<p>子问题就是数据规模更小的问题</p>\n</li>\n<li><p>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</p>\n</li>\n<li><p>存在递归终止条件</p>\n<p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p>\n</li>\n</ol>\n<h3 id=\"如何编写递归代码？\"><a href=\"#如何编写递归代码？\" class=\"headerlink\" title=\"如何编写递归代码？\"></a>如何编写递归代码？</h3><p>写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong></p>\n<p><strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</strong></p>\n<h3 id=\"递归代码要警惕堆栈溢出\"><a href=\"#递归代码要警惕堆栈溢出\" class=\"headerlink\" title=\"递归代码要警惕堆栈溢出\"></a>递归代码要警惕堆栈溢出</h3><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>\n<blockquote>\n<p><strong>问题：如何避免出现堆栈溢出呢？</strong></p>\n<p>可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。</p>\n<p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。</p>\n</blockquote>\n<h3 id=\"递归代码要警惕重复计算\"><a href=\"#递归代码要警惕重复计算\" class=\"headerlink\" title=\"递归代码要警惕重复计算\"></a>递归代码要警惕重复计算</h3><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算。</p>\n<ol>\n<li>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。</li>\n<li>在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据。</li>\n</ol>\n","categories":[{"name":"数据结构与算法","path":"api/categories/数据结构与算法.json"},{"name":"递归","path":"api/categories/递归.json"}],"tags":[{"name":"数据结构与算法,递归","path":"api/tags/数据结构与算法,递归.json"}]}